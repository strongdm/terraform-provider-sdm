// Copyright 2020 StrongDM Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// This file was generated by protogen. DO NOT EDIT.

package sdm

import (
	"encoding/json"
	"fmt"
	proto "github.com/strongdm/strongdm-sdk-go/internal/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/timestamppb"
	"strings"
	"time"
)

func quoteFilterArgs(filter string, args ...interface{}) (string, error) {
	parts := strings.Split(filter, "?")
	if len(parts) != len(args)+1 {
		return "", &BadRequestError{Message: "incorrect number of replacements"}
	}
	var b strings.Builder
	for i, v := range parts {
		b.WriteString(v)
		if i < len(args) {
			s := fmt.Sprint(args[i])
			j, err := json.Marshal(s)
			if err != nil {
				return "", &BadRequestError{Message: "unable to marshal string to JSON"}
			}
			b.Write(j)
		}
	}
	return b.String(), nil
}

func convertTimestampToPorcelain(t *timestamppb.Timestamp) time.Time {
	if t == nil {
		return time.Unix(0, 0).UTC()
	}
	return time.Unix(t.Seconds, int64(t.Nanos)).UTC()
}

func convertTimestampToPlumbing(t time.Time) *timestamppb.Timestamp {
	if t.IsZero() {
		return nil
	}
	return &timestamppb.Timestamp{
		Seconds: t.Unix(),
		Nanos:   int32(t.Nanosecond()),
	}
}

func convertTagsToPorcelain(tags *proto.Tags) Tags {
	result := Tags{}
	for _, tag := range tags.GetPairs() {
		result[tag.Name] = tag.Value
	}
	return result
}

func convertTagsToPlumbing(tags Tags) *proto.Tags {
	var result []*proto.Tags_Pair
	for name, value := range tags {
		result = append(result, &proto.Tags_Pair{Name: name, Value: value})
	}
	return &proto.Tags{Pairs: result}
}
func convertCreateResponseMetadataToPorcelain(plumbing *proto.CreateResponseMetadata) *CreateResponseMetadata {
	if plumbing == nil {
		return nil
	}
	porcelain := &CreateResponseMetadata{}
	return porcelain
}

func convertCreateResponseMetadataToPlumbing(porcelain *CreateResponseMetadata) *proto.CreateResponseMetadata {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.CreateResponseMetadata{}
	return plumbing
}
func convertRepeatedCreateResponseMetadataToPlumbing(
	porcelains []*CreateResponseMetadata,
) []*proto.CreateResponseMetadata {
	var items []*proto.CreateResponseMetadata
	for _, porcelain := range porcelains {
		items = append(items, convertCreateResponseMetadataToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedCreateResponseMetadataToPorcelain(plumbings []*proto.CreateResponseMetadata) []*CreateResponseMetadata {
	var items []*CreateResponseMetadata
	for _, plumbing := range plumbings {
		items = append(items, convertCreateResponseMetadataToPorcelain(plumbing))
	}
	return items
}
func convertGetResponseMetadataToPorcelain(plumbing *proto.GetResponseMetadata) *GetResponseMetadata {
	if plumbing == nil {
		return nil
	}
	porcelain := &GetResponseMetadata{}
	return porcelain
}

func convertGetResponseMetadataToPlumbing(porcelain *GetResponseMetadata) *proto.GetResponseMetadata {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.GetResponseMetadata{}
	return plumbing
}
func convertRepeatedGetResponseMetadataToPlumbing(
	porcelains []*GetResponseMetadata,
) []*proto.GetResponseMetadata {
	var items []*proto.GetResponseMetadata
	for _, porcelain := range porcelains {
		items = append(items, convertGetResponseMetadataToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedGetResponseMetadataToPorcelain(plumbings []*proto.GetResponseMetadata) []*GetResponseMetadata {
	var items []*GetResponseMetadata
	for _, plumbing := range plumbings {
		items = append(items, convertGetResponseMetadataToPorcelain(plumbing))
	}
	return items
}
func convertUpdateResponseMetadataToPorcelain(plumbing *proto.UpdateResponseMetadata) *UpdateResponseMetadata {
	if plumbing == nil {
		return nil
	}
	porcelain := &UpdateResponseMetadata{}
	return porcelain
}

func convertUpdateResponseMetadataToPlumbing(porcelain *UpdateResponseMetadata) *proto.UpdateResponseMetadata {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.UpdateResponseMetadata{}
	return plumbing
}
func convertRepeatedUpdateResponseMetadataToPlumbing(
	porcelains []*UpdateResponseMetadata,
) []*proto.UpdateResponseMetadata {
	var items []*proto.UpdateResponseMetadata
	for _, porcelain := range porcelains {
		items = append(items, convertUpdateResponseMetadataToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedUpdateResponseMetadataToPorcelain(plumbings []*proto.UpdateResponseMetadata) []*UpdateResponseMetadata {
	var items []*UpdateResponseMetadata
	for _, plumbing := range plumbings {
		items = append(items, convertUpdateResponseMetadataToPorcelain(plumbing))
	}
	return items
}
func convertDeleteResponseMetadataToPorcelain(plumbing *proto.DeleteResponseMetadata) *DeleteResponseMetadata {
	if plumbing == nil {
		return nil
	}
	porcelain := &DeleteResponseMetadata{}
	return porcelain
}

func convertDeleteResponseMetadataToPlumbing(porcelain *DeleteResponseMetadata) *proto.DeleteResponseMetadata {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.DeleteResponseMetadata{}
	return plumbing
}
func convertRepeatedDeleteResponseMetadataToPlumbing(
	porcelains []*DeleteResponseMetadata,
) []*proto.DeleteResponseMetadata {
	var items []*proto.DeleteResponseMetadata
	for _, porcelain := range porcelains {
		items = append(items, convertDeleteResponseMetadataToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedDeleteResponseMetadataToPorcelain(plumbings []*proto.DeleteResponseMetadata) []*DeleteResponseMetadata {
	var items []*DeleteResponseMetadata
	for _, plumbing := range plumbings {
		items = append(items, convertDeleteResponseMetadataToPorcelain(plumbing))
	}
	return items
}
func convertRateLimitMetadataToPorcelain(plumbing *proto.RateLimitMetadata) *RateLimitMetadata {
	if plumbing == nil {
		return nil
	}
	porcelain := &RateLimitMetadata{}
	porcelain.Limit = (plumbing.Limit)
	porcelain.Remaining = (plumbing.Remaining)
	porcelain.ResetAt = convertTimestampToPorcelain(plumbing.ResetAt)
	porcelain.Bucket = (plumbing.Bucket)
	return porcelain
}

func convertRateLimitMetadataToPlumbing(porcelain *RateLimitMetadata) *proto.RateLimitMetadata {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RateLimitMetadata{}
	plumbing.Limit = (porcelain.Limit)
	plumbing.Remaining = (porcelain.Remaining)
	plumbing.ResetAt = convertTimestampToPlumbing(porcelain.ResetAt)
	plumbing.Bucket = (porcelain.Bucket)
	return plumbing
}
func convertRepeatedRateLimitMetadataToPlumbing(
	porcelains []*RateLimitMetadata,
) []*proto.RateLimitMetadata {
	var items []*proto.RateLimitMetadata
	for _, porcelain := range porcelains {
		items = append(items, convertRateLimitMetadataToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRateLimitMetadataToPorcelain(plumbings []*proto.RateLimitMetadata) []*RateLimitMetadata {
	var items []*RateLimitMetadata
	for _, plumbing := range plumbings {
		items = append(items, convertRateLimitMetadataToPorcelain(plumbing))
	}
	return items
}
func convertTagToPorcelain(plumbing *proto.Tag) *Tag {
	if plumbing == nil {
		return nil
	}
	porcelain := &Tag{}
	porcelain.Name = (plumbing.Name)
	porcelain.Value = (plumbing.Value)
	return porcelain
}

func convertTagToPlumbing(porcelain *Tag) *proto.Tag {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Tag{}
	plumbing.Name = (porcelain.Name)
	plumbing.Value = (porcelain.Value)
	return plumbing
}
func convertRepeatedTagToPlumbing(
	porcelains []*Tag,
) []*proto.Tag {
	var items []*proto.Tag
	for _, porcelain := range porcelains {
		items = append(items, convertTagToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedTagToPorcelain(plumbings []*proto.Tag) []*Tag {
	var items []*Tag
	for _, plumbing := range plumbings {
		items = append(items, convertTagToPorcelain(plumbing))
	}
	return items
}
func convertAccountAttachmentCreateResponseToPorcelain(plumbing *proto.AccountAttachmentCreateResponse) *AccountAttachmentCreateResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &AccountAttachmentCreateResponse{}
	porcelain.Meta = convertCreateResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.AccountAttachment = convertAccountAttachmentToPorcelain(plumbing.AccountAttachment)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertAccountAttachmentCreateResponseToPlumbing(porcelain *AccountAttachmentCreateResponse) *proto.AccountAttachmentCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountAttachmentCreateResponse{}
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.AccountAttachment = convertAccountAttachmentToPlumbing(porcelain.AccountAttachment)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountAttachmentCreateResponseToPlumbing(
	porcelains []*AccountAttachmentCreateResponse,
) []*proto.AccountAttachmentCreateResponse {
	var items []*proto.AccountAttachmentCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountAttachmentCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountAttachmentCreateResponseToPorcelain(plumbings []*proto.AccountAttachmentCreateResponse) []*AccountAttachmentCreateResponse {
	var items []*AccountAttachmentCreateResponse
	for _, plumbing := range plumbings {
		items = append(items, convertAccountAttachmentCreateResponseToPorcelain(plumbing))
	}
	return items
}
func convertAccountAttachmentGetResponseToPorcelain(plumbing *proto.AccountAttachmentGetResponse) *AccountAttachmentGetResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &AccountAttachmentGetResponse{}
	porcelain.Meta = convertGetResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.AccountAttachment = convertAccountAttachmentToPorcelain(plumbing.AccountAttachment)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertAccountAttachmentGetResponseToPlumbing(porcelain *AccountAttachmentGetResponse) *proto.AccountAttachmentGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountAttachmentGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.AccountAttachment = convertAccountAttachmentToPlumbing(porcelain.AccountAttachment)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountAttachmentGetResponseToPlumbing(
	porcelains []*AccountAttachmentGetResponse,
) []*proto.AccountAttachmentGetResponse {
	var items []*proto.AccountAttachmentGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountAttachmentGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountAttachmentGetResponseToPorcelain(plumbings []*proto.AccountAttachmentGetResponse) []*AccountAttachmentGetResponse {
	var items []*AccountAttachmentGetResponse
	for _, plumbing := range plumbings {
		items = append(items, convertAccountAttachmentGetResponseToPorcelain(plumbing))
	}
	return items
}
func convertAccountAttachmentDeleteResponseToPorcelain(plumbing *proto.AccountAttachmentDeleteResponse) *AccountAttachmentDeleteResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &AccountAttachmentDeleteResponse{}
	porcelain.Meta = convertDeleteResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertAccountAttachmentDeleteResponseToPlumbing(porcelain *AccountAttachmentDeleteResponse) *proto.AccountAttachmentDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountAttachmentDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountAttachmentDeleteResponseToPlumbing(
	porcelains []*AccountAttachmentDeleteResponse,
) []*proto.AccountAttachmentDeleteResponse {
	var items []*proto.AccountAttachmentDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountAttachmentDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountAttachmentDeleteResponseToPorcelain(plumbings []*proto.AccountAttachmentDeleteResponse) []*AccountAttachmentDeleteResponse {
	var items []*AccountAttachmentDeleteResponse
	for _, plumbing := range plumbings {
		items = append(items, convertAccountAttachmentDeleteResponseToPorcelain(plumbing))
	}
	return items
}
func convertAccountAttachmentToPorcelain(plumbing *proto.AccountAttachment) *AccountAttachment {
	if plumbing == nil {
		return nil
	}
	porcelain := &AccountAttachment{}
	porcelain.ID = (plumbing.Id)
	porcelain.AccountID = (plumbing.AccountId)
	porcelain.RoleID = (plumbing.RoleId)
	return porcelain
}

func convertAccountAttachmentToPlumbing(porcelain *AccountAttachment) *proto.AccountAttachment {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountAttachment{}
	plumbing.Id = (porcelain.ID)
	plumbing.AccountId = (porcelain.AccountID)
	plumbing.RoleId = (porcelain.RoleID)
	return plumbing
}
func convertRepeatedAccountAttachmentToPlumbing(
	porcelains []*AccountAttachment,
) []*proto.AccountAttachment {
	var items []*proto.AccountAttachment
	for _, porcelain := range porcelains {
		items = append(items, convertAccountAttachmentToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountAttachmentToPorcelain(plumbings []*proto.AccountAttachment) []*AccountAttachment {
	var items []*AccountAttachment
	for _, plumbing := range plumbings {
		items = append(items, convertAccountAttachmentToPorcelain(plumbing))
	}
	return items
}
func convertAccountGrantCreateResponseToPorcelain(plumbing *proto.AccountGrantCreateResponse) *AccountGrantCreateResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &AccountGrantCreateResponse{}
	porcelain.Meta = convertCreateResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.AccountGrant = convertAccountGrantToPorcelain(plumbing.AccountGrant)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertAccountGrantCreateResponseToPlumbing(porcelain *AccountGrantCreateResponse) *proto.AccountGrantCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountGrantCreateResponse{}
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.AccountGrant = convertAccountGrantToPlumbing(porcelain.AccountGrant)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountGrantCreateResponseToPlumbing(
	porcelains []*AccountGrantCreateResponse,
) []*proto.AccountGrantCreateResponse {
	var items []*proto.AccountGrantCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountGrantCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountGrantCreateResponseToPorcelain(plumbings []*proto.AccountGrantCreateResponse) []*AccountGrantCreateResponse {
	var items []*AccountGrantCreateResponse
	for _, plumbing := range plumbings {
		items = append(items, convertAccountGrantCreateResponseToPorcelain(plumbing))
	}
	return items
}
func convertAccountGrantGetResponseToPorcelain(plumbing *proto.AccountGrantGetResponse) *AccountGrantGetResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &AccountGrantGetResponse{}
	porcelain.Meta = convertGetResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.AccountGrant = convertAccountGrantToPorcelain(plumbing.AccountGrant)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertAccountGrantGetResponseToPlumbing(porcelain *AccountGrantGetResponse) *proto.AccountGrantGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountGrantGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.AccountGrant = convertAccountGrantToPlumbing(porcelain.AccountGrant)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountGrantGetResponseToPlumbing(
	porcelains []*AccountGrantGetResponse,
) []*proto.AccountGrantGetResponse {
	var items []*proto.AccountGrantGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountGrantGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountGrantGetResponseToPorcelain(plumbings []*proto.AccountGrantGetResponse) []*AccountGrantGetResponse {
	var items []*AccountGrantGetResponse
	for _, plumbing := range plumbings {
		items = append(items, convertAccountGrantGetResponseToPorcelain(plumbing))
	}
	return items
}
func convertAccountGrantDeleteResponseToPorcelain(plumbing *proto.AccountGrantDeleteResponse) *AccountGrantDeleteResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &AccountGrantDeleteResponse{}
	porcelain.Meta = convertDeleteResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertAccountGrantDeleteResponseToPlumbing(porcelain *AccountGrantDeleteResponse) *proto.AccountGrantDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountGrantDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountGrantDeleteResponseToPlumbing(
	porcelains []*AccountGrantDeleteResponse,
) []*proto.AccountGrantDeleteResponse {
	var items []*proto.AccountGrantDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountGrantDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountGrantDeleteResponseToPorcelain(plumbings []*proto.AccountGrantDeleteResponse) []*AccountGrantDeleteResponse {
	var items []*AccountGrantDeleteResponse
	for _, plumbing := range plumbings {
		items = append(items, convertAccountGrantDeleteResponseToPorcelain(plumbing))
	}
	return items
}
func convertAccountGrantToPorcelain(plumbing *proto.AccountGrant) *AccountGrant {
	if plumbing == nil {
		return nil
	}
	porcelain := &AccountGrant{}
	porcelain.ID = (plumbing.Id)
	porcelain.ResourceID = (plumbing.ResourceId)
	porcelain.AccountID = (plumbing.AccountId)
	porcelain.StartFrom = convertTimestampToPorcelain(plumbing.StartFrom)
	porcelain.ValidUntil = convertTimestampToPorcelain(plumbing.ValidUntil)
	return porcelain
}

func convertAccountGrantToPlumbing(porcelain *AccountGrant) *proto.AccountGrant {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountGrant{}
	plumbing.Id = (porcelain.ID)
	plumbing.ResourceId = (porcelain.ResourceID)
	plumbing.AccountId = (porcelain.AccountID)
	plumbing.StartFrom = convertTimestampToPlumbing(porcelain.StartFrom)
	plumbing.ValidUntil = convertTimestampToPlumbing(porcelain.ValidUntil)
	return plumbing
}
func convertRepeatedAccountGrantToPlumbing(
	porcelains []*AccountGrant,
) []*proto.AccountGrant {
	var items []*proto.AccountGrant
	for _, porcelain := range porcelains {
		items = append(items, convertAccountGrantToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountGrantToPorcelain(plumbings []*proto.AccountGrant) []*AccountGrant {
	var items []*AccountGrant
	for _, plumbing := range plumbings {
		items = append(items, convertAccountGrantToPorcelain(plumbing))
	}
	return items
}
func convertAccountCreateResponseToPorcelain(plumbing *proto.AccountCreateResponse) *AccountCreateResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &AccountCreateResponse{}
	porcelain.Meta = convertCreateResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.Account = convertAccountToPorcelain(plumbing.Account)
	porcelain.Token = (plumbing.Token)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertAccountCreateResponseToPlumbing(porcelain *AccountCreateResponse) *proto.AccountCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountCreateResponse{}
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.Account = convertAccountToPlumbing(porcelain.Account)
	plumbing.Token = (porcelain.Token)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountCreateResponseToPlumbing(
	porcelains []*AccountCreateResponse,
) []*proto.AccountCreateResponse {
	var items []*proto.AccountCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountCreateResponseToPorcelain(plumbings []*proto.AccountCreateResponse) []*AccountCreateResponse {
	var items []*AccountCreateResponse
	for _, plumbing := range plumbings {
		items = append(items, convertAccountCreateResponseToPorcelain(plumbing))
	}
	return items
}
func convertAccountGetResponseToPorcelain(plumbing *proto.AccountGetResponse) *AccountGetResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &AccountGetResponse{}
	porcelain.Meta = convertGetResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.Account = convertAccountToPorcelain(plumbing.Account)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertAccountGetResponseToPlumbing(porcelain *AccountGetResponse) *proto.AccountGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.Account = convertAccountToPlumbing(porcelain.Account)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountGetResponseToPlumbing(
	porcelains []*AccountGetResponse,
) []*proto.AccountGetResponse {
	var items []*proto.AccountGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountGetResponseToPorcelain(plumbings []*proto.AccountGetResponse) []*AccountGetResponse {
	var items []*AccountGetResponse
	for _, plumbing := range plumbings {
		items = append(items, convertAccountGetResponseToPorcelain(plumbing))
	}
	return items
}
func convertAccountUpdateResponseToPorcelain(plumbing *proto.AccountUpdateResponse) *AccountUpdateResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &AccountUpdateResponse{}
	porcelain.Meta = convertUpdateResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.Account = convertAccountToPorcelain(plumbing.Account)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertAccountUpdateResponseToPlumbing(porcelain *AccountUpdateResponse) *proto.AccountUpdateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountUpdateResponse{}
	plumbing.Meta = convertUpdateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.Account = convertAccountToPlumbing(porcelain.Account)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountUpdateResponseToPlumbing(
	porcelains []*AccountUpdateResponse,
) []*proto.AccountUpdateResponse {
	var items []*proto.AccountUpdateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountUpdateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountUpdateResponseToPorcelain(plumbings []*proto.AccountUpdateResponse) []*AccountUpdateResponse {
	var items []*AccountUpdateResponse
	for _, plumbing := range plumbings {
		items = append(items, convertAccountUpdateResponseToPorcelain(plumbing))
	}
	return items
}
func convertAccountDeleteResponseToPorcelain(plumbing *proto.AccountDeleteResponse) *AccountDeleteResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &AccountDeleteResponse{}
	porcelain.Meta = convertDeleteResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertAccountDeleteResponseToPlumbing(porcelain *AccountDeleteResponse) *proto.AccountDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountDeleteResponseToPlumbing(
	porcelains []*AccountDeleteResponse,
) []*proto.AccountDeleteResponse {
	var items []*proto.AccountDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountDeleteResponseToPorcelain(plumbings []*proto.AccountDeleteResponse) []*AccountDeleteResponse {
	var items []*AccountDeleteResponse
	for _, plumbing := range plumbings {
		items = append(items, convertAccountDeleteResponseToPorcelain(plumbing))
	}
	return items
}
func convertAccountToPlumbing(porcelain Account) *proto.Account {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Account{}

	switch v := porcelain.(type) {
	case *User:
		plumbing.Account = &proto.Account_User{User: convertUserToPlumbing(v)}
	case *Service:
		plumbing.Account = &proto.Account_Service{Service: convertServiceToPlumbing(v)}
	}
	return plumbing
}

func convertAccountToPorcelain(plumbing *proto.Account) Account {
	if plumbing.GetUser() != nil {
		return convertUserToPorcelain(plumbing.GetUser())
	}
	if plumbing.GetService() != nil {
		return convertServiceToPorcelain(plumbing.GetService())
	}
	return nil
}
func convertRepeatedAccountToPlumbing(
	porcelains []Account,
) []*proto.Account {
	var items []*proto.Account
	for _, porcelain := range porcelains {
		items = append(items, convertAccountToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountToPorcelain(plumbings []*proto.Account) []Account {
	var items []Account
	for _, plumbing := range plumbings {
		items = append(items, convertAccountToPorcelain(plumbing))
	}
	return items
}
func convertUserToPorcelain(plumbing *proto.User) *User {
	if plumbing == nil {
		return nil
	}
	porcelain := &User{}
	porcelain.ID = (plumbing.Id)
	porcelain.Email = (plumbing.Email)
	porcelain.FirstName = (plumbing.FirstName)
	porcelain.LastName = (plumbing.LastName)
	porcelain.Suspended = (plumbing.Suspended)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	return porcelain
}

func convertUserToPlumbing(porcelain *User) *proto.User {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.User{}
	plumbing.Id = (porcelain.ID)
	plumbing.Email = (porcelain.Email)
	plumbing.FirstName = (porcelain.FirstName)
	plumbing.LastName = (porcelain.LastName)
	plumbing.Suspended = (porcelain.Suspended)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedUserToPlumbing(
	porcelains []*User,
) []*proto.User {
	var items []*proto.User
	for _, porcelain := range porcelains {
		items = append(items, convertUserToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedUserToPorcelain(plumbings []*proto.User) []*User {
	var items []*User
	for _, plumbing := range plumbings {
		items = append(items, convertUserToPorcelain(plumbing))
	}
	return items
}
func convertServiceToPorcelain(plumbing *proto.Service) *Service {
	if plumbing == nil {
		return nil
	}
	porcelain := &Service{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Suspended = (plumbing.Suspended)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	return porcelain
}

func convertServiceToPlumbing(porcelain *Service) *proto.Service {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Service{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Suspended = (porcelain.Suspended)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedServiceToPlumbing(
	porcelains []*Service,
) []*proto.Service {
	var items []*proto.Service
	for _, porcelain := range porcelains {
		items = append(items, convertServiceToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedServiceToPorcelain(plumbings []*proto.Service) []*Service {
	var items []*Service
	for _, plumbing := range plumbings {
		items = append(items, convertServiceToPorcelain(plumbing))
	}
	return items
}
func convertControlPanelGetSSHCAPublicKeyResponseToPorcelain(plumbing *proto.ControlPanelGetSSHCAPublicKeyResponse) *ControlPanelGetSSHCAPublicKeyResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &ControlPanelGetSSHCAPublicKeyResponse{}
	porcelain.Meta = convertGetResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.PublicKey = (plumbing.PublicKey)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertControlPanelGetSSHCAPublicKeyResponseToPlumbing(porcelain *ControlPanelGetSSHCAPublicKeyResponse) *proto.ControlPanelGetSSHCAPublicKeyResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ControlPanelGetSSHCAPublicKeyResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.PublicKey = (porcelain.PublicKey)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedControlPanelGetSSHCAPublicKeyResponseToPlumbing(
	porcelains []*ControlPanelGetSSHCAPublicKeyResponse,
) []*proto.ControlPanelGetSSHCAPublicKeyResponse {
	var items []*proto.ControlPanelGetSSHCAPublicKeyResponse
	for _, porcelain := range porcelains {
		items = append(items, convertControlPanelGetSSHCAPublicKeyResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedControlPanelGetSSHCAPublicKeyResponseToPorcelain(plumbings []*proto.ControlPanelGetSSHCAPublicKeyResponse) []*ControlPanelGetSSHCAPublicKeyResponse {
	var items []*ControlPanelGetSSHCAPublicKeyResponse
	for _, plumbing := range plumbings {
		items = append(items, convertControlPanelGetSSHCAPublicKeyResponseToPorcelain(plumbing))
	}
	return items
}
func convertControlPanelVerifyJWTResponseToPorcelain(plumbing *proto.ControlPanelVerifyJWTResponse) *ControlPanelVerifyJWTResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &ControlPanelVerifyJWTResponse{}
	porcelain.Meta = convertGetResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.ValID = (plumbing.Valid)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertControlPanelVerifyJWTResponseToPlumbing(porcelain *ControlPanelVerifyJWTResponse) *proto.ControlPanelVerifyJWTResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ControlPanelVerifyJWTResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.Valid = (porcelain.ValID)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedControlPanelVerifyJWTResponseToPlumbing(
	porcelains []*ControlPanelVerifyJWTResponse,
) []*proto.ControlPanelVerifyJWTResponse {
	var items []*proto.ControlPanelVerifyJWTResponse
	for _, porcelain := range porcelains {
		items = append(items, convertControlPanelVerifyJWTResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedControlPanelVerifyJWTResponseToPorcelain(plumbings []*proto.ControlPanelVerifyJWTResponse) []*ControlPanelVerifyJWTResponse {
	var items []*ControlPanelVerifyJWTResponse
	for _, plumbing := range plumbings {
		items = append(items, convertControlPanelVerifyJWTResponseToPorcelain(plumbing))
	}
	return items
}
func convertResourceToPlumbing(porcelain Resource) *proto.Resource {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Resource{}

	switch v := porcelain.(type) {
	case *Athena:
		plumbing.Resource = &proto.Resource_Athena{Athena: convertAthenaToPlumbing(v)}
	case *AWS:
		plumbing.Resource = &proto.Resource_Aws{Aws: convertAWSToPlumbing(v)}
	case *BigQuery:
		plumbing.Resource = &proto.Resource_BigQuery{BigQuery: convertBigQueryToPlumbing(v)}
	case *Cassandra:
		plumbing.Resource = &proto.Resource_Cassandra{Cassandra: convertCassandraToPlumbing(v)}
	case *DB2I:
		plumbing.Resource = &proto.Resource_Db_2I{Db_2I: convertDB2IToPlumbing(v)}
	case *DB2LUW:
		plumbing.Resource = &proto.Resource_Db_2Luw{Db_2Luw: convertDB2LUWToPlumbing(v)}
	case *Druid:
		plumbing.Resource = &proto.Resource_Druid{Druid: convertDruidToPlumbing(v)}
	case *DynamoDB:
		plumbing.Resource = &proto.Resource_DynamoDb{DynamoDb: convertDynamoDBToPlumbing(v)}
	case *AmazonES:
		plumbing.Resource = &proto.Resource_AmazonEs{AmazonEs: convertAmazonESToPlumbing(v)}
	case *Elastic:
		plumbing.Resource = &proto.Resource_Elastic{Elastic: convertElasticToPlumbing(v)}
	case *HTTPBasicAuth:
		plumbing.Resource = &proto.Resource_HttpBasicAuth{HttpBasicAuth: convertHTTPBasicAuthToPlumbing(v)}
	case *HTTPNoAuth:
		plumbing.Resource = &proto.Resource_HttpNoAuth{HttpNoAuth: convertHTTPNoAuthToPlumbing(v)}
	case *HTTPAuth:
		plumbing.Resource = &proto.Resource_HttpAuth{HttpAuth: convertHTTPAuthToPlumbing(v)}
	case *Kubernetes:
		plumbing.Resource = &proto.Resource_Kubernetes{Kubernetes: convertKubernetesToPlumbing(v)}
	case *KubernetesBasicAuth:
		plumbing.Resource = &proto.Resource_KubernetesBasicAuth{KubernetesBasicAuth: convertKubernetesBasicAuthToPlumbing(v)}
	case *KubernetesServiceAccount:
		plumbing.Resource = &proto.Resource_KubernetesServiceAccount{KubernetesServiceAccount: convertKubernetesServiceAccountToPlumbing(v)}
	case *AmazonEKS:
		plumbing.Resource = &proto.Resource_AmazonEks{AmazonEks: convertAmazonEKSToPlumbing(v)}
	case *GoogleGKE:
		plumbing.Resource = &proto.Resource_GoogleGke{GoogleGke: convertGoogleGKEToPlumbing(v)}
	case *AKS:
		plumbing.Resource = &proto.Resource_Aks{Aks: convertAKSToPlumbing(v)}
	case *AKSBasicAuth:
		plumbing.Resource = &proto.Resource_AksBasicAuth{AksBasicAuth: convertAKSBasicAuthToPlumbing(v)}
	case *AKSServiceAccount:
		plumbing.Resource = &proto.Resource_AksServiceAccount{AksServiceAccount: convertAKSServiceAccountToPlumbing(v)}
	case *Memcached:
		plumbing.Resource = &proto.Resource_Memcached{Memcached: convertMemcachedToPlumbing(v)}
	case *MongoLegacyHost:
		plumbing.Resource = &proto.Resource_MongoLegacyHost{MongoLegacyHost: convertMongoLegacyHostToPlumbing(v)}
	case *MongoLegacyReplicaset:
		plumbing.Resource = &proto.Resource_MongoLegacyReplicaset{MongoLegacyReplicaset: convertMongoLegacyReplicasetToPlumbing(v)}
	case *MongoHost:
		plumbing.Resource = &proto.Resource_MongoHost{MongoHost: convertMongoHostToPlumbing(v)}
	case *MongoReplicaSet:
		plumbing.Resource = &proto.Resource_MongoReplicaSet{MongoReplicaSet: convertMongoReplicaSetToPlumbing(v)}
	case *Mysql:
		plumbing.Resource = &proto.Resource_Mysql{Mysql: convertMysqlToPlumbing(v)}
	case *AuroraMysql:
		plumbing.Resource = &proto.Resource_AuroraMysql{AuroraMysql: convertAuroraMysqlToPlumbing(v)}
	case *Clustrix:
		plumbing.Resource = &proto.Resource_Clustrix{Clustrix: convertClustrixToPlumbing(v)}
	case *Maria:
		plumbing.Resource = &proto.Resource_Maria{Maria: convertMariaToPlumbing(v)}
	case *Memsql:
		plumbing.Resource = &proto.Resource_Memsql{Memsql: convertMemsqlToPlumbing(v)}
	case *Oracle:
		plumbing.Resource = &proto.Resource_Oracle{Oracle: convertOracleToPlumbing(v)}
	case *Postgres:
		plumbing.Resource = &proto.Resource_Postgres{Postgres: convertPostgresToPlumbing(v)}
	case *AuroraPostgres:
		plumbing.Resource = &proto.Resource_AuroraPostgres{AuroraPostgres: convertAuroraPostgresToPlumbing(v)}
	case *Greenplum:
		plumbing.Resource = &proto.Resource_Greenplum{Greenplum: convertGreenplumToPlumbing(v)}
	case *Cockroach:
		plumbing.Resource = &proto.Resource_Cockroach{Cockroach: convertCockroachToPlumbing(v)}
	case *Redshift:
		plumbing.Resource = &proto.Resource_Redshift{Redshift: convertRedshiftToPlumbing(v)}
	case *Citus:
		plumbing.Resource = &proto.Resource_Citus{Citus: convertCitusToPlumbing(v)}
	case *Presto:
		plumbing.Resource = &proto.Resource_Presto{Presto: convertPrestoToPlumbing(v)}
	case *RDP:
		plumbing.Resource = &proto.Resource_Rdp{Rdp: convertRDPToPlumbing(v)}
	case *Redis:
		plumbing.Resource = &proto.Resource_Redis{Redis: convertRedisToPlumbing(v)}
	case *ElasticacheRedis:
		plumbing.Resource = &proto.Resource_ElasticacheRedis{ElasticacheRedis: convertElasticacheRedisToPlumbing(v)}
	case *Snowflake:
		plumbing.Resource = &proto.Resource_Snowflake{Snowflake: convertSnowflakeToPlumbing(v)}
	case *SQLServer:
		plumbing.Resource = &proto.Resource_SqlServer{SqlServer: convertSQLServerToPlumbing(v)}
	case *SSH:
		plumbing.Resource = &proto.Resource_Ssh{Ssh: convertSSHToPlumbing(v)}
	case *SSHCert:
		plumbing.Resource = &proto.Resource_SshCert{SshCert: convertSSHCertToPlumbing(v)}
	case *SSHCustomerKey:
		plumbing.Resource = &proto.Resource_SshCustomerKey{SshCustomerKey: convertSSHCustomerKeyToPlumbing(v)}
	case *Sybase:
		plumbing.Resource = &proto.Resource_Sybase{Sybase: convertSybaseToPlumbing(v)}
	case *SybaseIQ:
		plumbing.Resource = &proto.Resource_SybaseIq{SybaseIq: convertSybaseIQToPlumbing(v)}
	case *Teradata:
		plumbing.Resource = &proto.Resource_Teradata{Teradata: convertTeradataToPlumbing(v)}
	}
	return plumbing
}

func convertResourceToPorcelain(plumbing *proto.Resource) Resource {
	if plumbing.GetAthena() != nil {
		return convertAthenaToPorcelain(plumbing.GetAthena())
	}
	if plumbing.GetAws() != nil {
		return convertAWSToPorcelain(plumbing.GetAws())
	}
	if plumbing.GetBigQuery() != nil {
		return convertBigQueryToPorcelain(plumbing.GetBigQuery())
	}
	if plumbing.GetCassandra() != nil {
		return convertCassandraToPorcelain(plumbing.GetCassandra())
	}
	if plumbing.GetDb_2I() != nil {
		return convertDB2IToPorcelain(plumbing.GetDb_2I())
	}
	if plumbing.GetDb_2Luw() != nil {
		return convertDB2LUWToPorcelain(plumbing.GetDb_2Luw())
	}
	if plumbing.GetDruid() != nil {
		return convertDruidToPorcelain(plumbing.GetDruid())
	}
	if plumbing.GetDynamoDb() != nil {
		return convertDynamoDBToPorcelain(plumbing.GetDynamoDb())
	}
	if plumbing.GetAmazonEs() != nil {
		return convertAmazonESToPorcelain(plumbing.GetAmazonEs())
	}
	if plumbing.GetElastic() != nil {
		return convertElasticToPorcelain(plumbing.GetElastic())
	}
	if plumbing.GetHttpBasicAuth() != nil {
		return convertHTTPBasicAuthToPorcelain(plumbing.GetHttpBasicAuth())
	}
	if plumbing.GetHttpNoAuth() != nil {
		return convertHTTPNoAuthToPorcelain(plumbing.GetHttpNoAuth())
	}
	if plumbing.GetHttpAuth() != nil {
		return convertHTTPAuthToPorcelain(plumbing.GetHttpAuth())
	}
	if plumbing.GetKubernetes() != nil {
		return convertKubernetesToPorcelain(plumbing.GetKubernetes())
	}
	if plumbing.GetKubernetesBasicAuth() != nil {
		return convertKubernetesBasicAuthToPorcelain(plumbing.GetKubernetesBasicAuth())
	}
	if plumbing.GetKubernetesServiceAccount() != nil {
		return convertKubernetesServiceAccountToPorcelain(plumbing.GetKubernetesServiceAccount())
	}
	if plumbing.GetAmazonEks() != nil {
		return convertAmazonEKSToPorcelain(plumbing.GetAmazonEks())
	}
	if plumbing.GetGoogleGke() != nil {
		return convertGoogleGKEToPorcelain(plumbing.GetGoogleGke())
	}
	if plumbing.GetAks() != nil {
		return convertAKSToPorcelain(plumbing.GetAks())
	}
	if plumbing.GetAksBasicAuth() != nil {
		return convertAKSBasicAuthToPorcelain(plumbing.GetAksBasicAuth())
	}
	if plumbing.GetAksServiceAccount() != nil {
		return convertAKSServiceAccountToPorcelain(plumbing.GetAksServiceAccount())
	}
	if plumbing.GetMemcached() != nil {
		return convertMemcachedToPorcelain(plumbing.GetMemcached())
	}
	if plumbing.GetMongoLegacyHost() != nil {
		return convertMongoLegacyHostToPorcelain(plumbing.GetMongoLegacyHost())
	}
	if plumbing.GetMongoLegacyReplicaset() != nil {
		return convertMongoLegacyReplicasetToPorcelain(plumbing.GetMongoLegacyReplicaset())
	}
	if plumbing.GetMongoHost() != nil {
		return convertMongoHostToPorcelain(plumbing.GetMongoHost())
	}
	if plumbing.GetMongoReplicaSet() != nil {
		return convertMongoReplicaSetToPorcelain(plumbing.GetMongoReplicaSet())
	}
	if plumbing.GetMysql() != nil {
		return convertMysqlToPorcelain(plumbing.GetMysql())
	}
	if plumbing.GetAuroraMysql() != nil {
		return convertAuroraMysqlToPorcelain(plumbing.GetAuroraMysql())
	}
	if plumbing.GetClustrix() != nil {
		return convertClustrixToPorcelain(plumbing.GetClustrix())
	}
	if plumbing.GetMaria() != nil {
		return convertMariaToPorcelain(plumbing.GetMaria())
	}
	if plumbing.GetMemsql() != nil {
		return convertMemsqlToPorcelain(plumbing.GetMemsql())
	}
	if plumbing.GetOracle() != nil {
		return convertOracleToPorcelain(plumbing.GetOracle())
	}
	if plumbing.GetPostgres() != nil {
		return convertPostgresToPorcelain(plumbing.GetPostgres())
	}
	if plumbing.GetAuroraPostgres() != nil {
		return convertAuroraPostgresToPorcelain(plumbing.GetAuroraPostgres())
	}
	if plumbing.GetGreenplum() != nil {
		return convertGreenplumToPorcelain(plumbing.GetGreenplum())
	}
	if plumbing.GetCockroach() != nil {
		return convertCockroachToPorcelain(plumbing.GetCockroach())
	}
	if plumbing.GetRedshift() != nil {
		return convertRedshiftToPorcelain(plumbing.GetRedshift())
	}
	if plumbing.GetCitus() != nil {
		return convertCitusToPorcelain(plumbing.GetCitus())
	}
	if plumbing.GetPresto() != nil {
		return convertPrestoToPorcelain(plumbing.GetPresto())
	}
	if plumbing.GetRdp() != nil {
		return convertRDPToPorcelain(plumbing.GetRdp())
	}
	if plumbing.GetRedis() != nil {
		return convertRedisToPorcelain(plumbing.GetRedis())
	}
	if plumbing.GetElasticacheRedis() != nil {
		return convertElasticacheRedisToPorcelain(plumbing.GetElasticacheRedis())
	}
	if plumbing.GetSnowflake() != nil {
		return convertSnowflakeToPorcelain(plumbing.GetSnowflake())
	}
	if plumbing.GetSqlServer() != nil {
		return convertSQLServerToPorcelain(plumbing.GetSqlServer())
	}
	if plumbing.GetSsh() != nil {
		return convertSSHToPorcelain(plumbing.GetSsh())
	}
	if plumbing.GetSshCert() != nil {
		return convertSSHCertToPorcelain(plumbing.GetSshCert())
	}
	if plumbing.GetSshCustomerKey() != nil {
		return convertSSHCustomerKeyToPorcelain(plumbing.GetSshCustomerKey())
	}
	if plumbing.GetSybase() != nil {
		return convertSybaseToPorcelain(plumbing.GetSybase())
	}
	if plumbing.GetSybaseIq() != nil {
		return convertSybaseIQToPorcelain(plumbing.GetSybaseIq())
	}
	if plumbing.GetTeradata() != nil {
		return convertTeradataToPorcelain(plumbing.GetTeradata())
	}
	return nil
}
func convertRepeatedResourceToPlumbing(
	porcelains []Resource,
) []*proto.Resource {
	var items []*proto.Resource
	for _, porcelain := range porcelains {
		items = append(items, convertResourceToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedResourceToPorcelain(plumbings []*proto.Resource) []Resource {
	var items []Resource
	for _, plumbing := range plumbings {
		items = append(items, convertResourceToPorcelain(plumbing))
	}
	return items
}
func convertAthenaToPorcelain(plumbing *proto.Athena) *Athena {
	if plumbing == nil {
		return nil
	}
	porcelain := &Athena{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.AccessKey = (plumbing.AccessKey)
	porcelain.SecretAccessKey = (plumbing.SecretAccessKey)
	porcelain.Output = (plumbing.Output)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Region = (plumbing.Region)
	porcelain.RoleArn = (plumbing.RoleArn)
	porcelain.RoleExternalID = (plumbing.RoleExternalId)
	return porcelain
}

func convertAthenaToPlumbing(porcelain *Athena) *proto.Athena {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Athena{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.AccessKey = (porcelain.AccessKey)
	plumbing.SecretAccessKey = (porcelain.SecretAccessKey)
	plumbing.Output = (porcelain.Output)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Region = (porcelain.Region)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	return plumbing
}
func convertRepeatedAthenaToPlumbing(
	porcelains []*Athena,
) []*proto.Athena {
	var items []*proto.Athena
	for _, porcelain := range porcelains {
		items = append(items, convertAthenaToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAthenaToPorcelain(plumbings []*proto.Athena) []*Athena {
	var items []*Athena
	for _, plumbing := range plumbings {
		items = append(items, convertAthenaToPorcelain(plumbing))
	}
	return items
}
func convertAWSToPorcelain(plumbing *proto.AWS) *AWS {
	if plumbing == nil {
		return nil
	}
	porcelain := &AWS{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.AccessKey = (plumbing.AccessKey)
	porcelain.SecretAccessKey = (plumbing.SecretAccessKey)
	porcelain.HealthcheckRegion = (plumbing.HealthcheckRegion)
	porcelain.RoleArn = (plumbing.RoleArn)
	porcelain.RoleExternalID = (plumbing.RoleExternalId)
	return porcelain
}

func convertAWSToPlumbing(porcelain *AWS) *proto.AWS {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AWS{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.AccessKey = (porcelain.AccessKey)
	plumbing.SecretAccessKey = (porcelain.SecretAccessKey)
	plumbing.HealthcheckRegion = (porcelain.HealthcheckRegion)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	return plumbing
}
func convertRepeatedAWSToPlumbing(
	porcelains []*AWS,
) []*proto.AWS {
	var items []*proto.AWS
	for _, porcelain := range porcelains {
		items = append(items, convertAWSToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAWSToPorcelain(plumbings []*proto.AWS) []*AWS {
	var items []*AWS
	for _, plumbing := range plumbings {
		items = append(items, convertAWSToPorcelain(plumbing))
	}
	return items
}
func convertBigQueryToPorcelain(plumbing *proto.BigQuery) *BigQuery {
	if plumbing == nil {
		return nil
	}
	porcelain := &BigQuery{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.PrivateKey = (plumbing.PrivateKey)
	porcelain.Project = (plumbing.Project)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Endpoint = (plumbing.Endpoint)
	porcelain.Username = (plumbing.Username)
	return porcelain
}

func convertBigQueryToPlumbing(porcelain *BigQuery) *proto.BigQuery {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.BigQuery{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.PrivateKey = (porcelain.PrivateKey)
	plumbing.Project = (porcelain.Project)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedBigQueryToPlumbing(
	porcelains []*BigQuery,
) []*proto.BigQuery {
	var items []*proto.BigQuery
	for _, porcelain := range porcelains {
		items = append(items, convertBigQueryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedBigQueryToPorcelain(plumbings []*proto.BigQuery) []*BigQuery {
	var items []*BigQuery
	for _, plumbing := range plumbings {
		items = append(items, convertBigQueryToPorcelain(plumbing))
	}
	return items
}
func convertCassandraToPorcelain(plumbing *proto.Cassandra) *Cassandra {
	if plumbing == nil {
		return nil
	}
	porcelain := &Cassandra{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Port = (plumbing.Port)
	porcelain.TlsRequired = (plumbing.TlsRequired)
	return porcelain
}

func convertCassandraToPlumbing(porcelain *Cassandra) *proto.Cassandra {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Cassandra{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Port = (porcelain.Port)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	return plumbing
}
func convertRepeatedCassandraToPlumbing(
	porcelains []*Cassandra,
) []*proto.Cassandra {
	var items []*proto.Cassandra
	for _, porcelain := range porcelains {
		items = append(items, convertCassandraToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedCassandraToPorcelain(plumbings []*proto.Cassandra) []*Cassandra {
	var items []*Cassandra
	for _, plumbing := range plumbings {
		items = append(items, convertCassandraToPorcelain(plumbing))
	}
	return items
}
func convertDB2IToPorcelain(plumbing *proto.DB2I) *DB2I {
	if plumbing == nil {
		return nil
	}
	porcelain := &DB2I{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Port = (plumbing.Port)
	porcelain.TlsRequired = (plumbing.TlsRequired)
	return porcelain
}

func convertDB2IToPlumbing(porcelain *DB2I) *proto.DB2I {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.DB2I{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Port = (porcelain.Port)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	return plumbing
}
func convertRepeatedDB2IToPlumbing(
	porcelains []*DB2I,
) []*proto.DB2I {
	var items []*proto.DB2I
	for _, porcelain := range porcelains {
		items = append(items, convertDB2IToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedDB2IToPorcelain(plumbings []*proto.DB2I) []*DB2I {
	var items []*DB2I
	for _, plumbing := range plumbings {
		items = append(items, convertDB2IToPorcelain(plumbing))
	}
	return items
}
func convertDB2LUWToPorcelain(plumbing *proto.DB2LUW) *DB2LUW {
	if plumbing == nil {
		return nil
	}
	porcelain := &DB2LUW{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.Database = (plumbing.Database)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Port = (plumbing.Port)
	return porcelain
}

func convertDB2LUWToPlumbing(porcelain *DB2LUW) *proto.DB2LUW {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.DB2LUW{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.Database = (porcelain.Database)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Port = (porcelain.Port)
	return plumbing
}
func convertRepeatedDB2LUWToPlumbing(
	porcelains []*DB2LUW,
) []*proto.DB2LUW {
	var items []*proto.DB2LUW
	for _, porcelain := range porcelains {
		items = append(items, convertDB2LUWToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedDB2LUWToPorcelain(plumbings []*proto.DB2LUW) []*DB2LUW {
	var items []*DB2LUW
	for _, plumbing := range plumbings {
		items = append(items, convertDB2LUWToPorcelain(plumbing))
	}
	return items
}
func convertDruidToPorcelain(plumbing *proto.Druid) *Druid {
	if plumbing == nil {
		return nil
	}
	porcelain := &Druid{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.Port = (plumbing.Port)
	return porcelain
}

func convertDruidToPlumbing(porcelain *Druid) *proto.Druid {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Druid{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	return plumbing
}
func convertRepeatedDruidToPlumbing(
	porcelains []*Druid,
) []*proto.Druid {
	var items []*proto.Druid
	for _, porcelain := range porcelains {
		items = append(items, convertDruidToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedDruidToPorcelain(plumbings []*proto.Druid) []*Druid {
	var items []*Druid
	for _, plumbing := range plumbings {
		items = append(items, convertDruidToPorcelain(plumbing))
	}
	return items
}
func convertDynamoDBToPorcelain(plumbing *proto.DynamoDB) *DynamoDB {
	if plumbing == nil {
		return nil
	}
	porcelain := &DynamoDB{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.AccessKey = (plumbing.AccessKey)
	porcelain.SecretAccessKey = (plumbing.SecretAccessKey)
	porcelain.Region = (plumbing.Region)
	porcelain.Endpoint = (plumbing.Endpoint)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.RoleArn = (plumbing.RoleArn)
	porcelain.RoleExternalID = (plumbing.RoleExternalId)
	return porcelain
}

func convertDynamoDBToPlumbing(porcelain *DynamoDB) *proto.DynamoDB {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.DynamoDB{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.AccessKey = (porcelain.AccessKey)
	plumbing.SecretAccessKey = (porcelain.SecretAccessKey)
	plumbing.Region = (porcelain.Region)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	return plumbing
}
func convertRepeatedDynamoDBToPlumbing(
	porcelains []*DynamoDB,
) []*proto.DynamoDB {
	var items []*proto.DynamoDB
	for _, porcelain := range porcelains {
		items = append(items, convertDynamoDBToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedDynamoDBToPorcelain(plumbings []*proto.DynamoDB) []*DynamoDB {
	var items []*DynamoDB
	for _, plumbing := range plumbings {
		items = append(items, convertDynamoDBToPorcelain(plumbing))
	}
	return items
}
func convertAmazonESToPorcelain(plumbing *proto.AmazonES) *AmazonES {
	if plumbing == nil {
		return nil
	}
	porcelain := &AmazonES{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Region = (plumbing.Region)
	porcelain.SecretAccessKey = (plumbing.SecretAccessKey)
	porcelain.Endpoint = (plumbing.Endpoint)
	porcelain.AccessKey = (plumbing.AccessKey)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.RoleArn = (plumbing.RoleArn)
	porcelain.RoleExternalID = (plumbing.RoleExternalId)
	return porcelain
}

func convertAmazonESToPlumbing(porcelain *AmazonES) *proto.AmazonES {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AmazonES{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Region = (porcelain.Region)
	plumbing.SecretAccessKey = (porcelain.SecretAccessKey)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.AccessKey = (porcelain.AccessKey)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	return plumbing
}
func convertRepeatedAmazonESToPlumbing(
	porcelains []*AmazonES,
) []*proto.AmazonES {
	var items []*proto.AmazonES
	for _, porcelain := range porcelains {
		items = append(items, convertAmazonESToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAmazonESToPorcelain(plumbings []*proto.AmazonES) []*AmazonES {
	var items []*AmazonES
	for _, plumbing := range plumbings {
		items = append(items, convertAmazonESToPorcelain(plumbing))
	}
	return items
}
func convertElasticToPorcelain(plumbing *proto.Elastic) *Elastic {
	if plumbing == nil {
		return nil
	}
	porcelain := &Elastic{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Port = (plumbing.Port)
	porcelain.TlsRequired = (plumbing.TlsRequired)
	return porcelain
}

func convertElasticToPlumbing(porcelain *Elastic) *proto.Elastic {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Elastic{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Port = (porcelain.Port)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	return plumbing
}
func convertRepeatedElasticToPlumbing(
	porcelains []*Elastic,
) []*proto.Elastic {
	var items []*proto.Elastic
	for _, porcelain := range porcelains {
		items = append(items, convertElasticToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedElasticToPorcelain(plumbings []*proto.Elastic) []*Elastic {
	var items []*Elastic
	for _, plumbing := range plumbings {
		items = append(items, convertElasticToPorcelain(plumbing))
	}
	return items
}
func convertHTTPBasicAuthToPorcelain(plumbing *proto.HTTPBasicAuth) *HTTPBasicAuth {
	if plumbing == nil {
		return nil
	}
	porcelain := &HTTPBasicAuth{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Url = (plumbing.Url)
	porcelain.HealthcheckPath = (plumbing.HealthcheckPath)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.HeadersBlacklist = (plumbing.HeadersBlacklist)
	porcelain.DefaultPath = (plumbing.DefaultPath)
	porcelain.Subdomain = (plumbing.Subdomain)
	return porcelain
}

func convertHTTPBasicAuthToPlumbing(porcelain *HTTPBasicAuth) *proto.HTTPBasicAuth {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.HTTPBasicAuth{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Url = (porcelain.Url)
	plumbing.HealthcheckPath = (porcelain.HealthcheckPath)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.HeadersBlacklist = (porcelain.HeadersBlacklist)
	plumbing.DefaultPath = (porcelain.DefaultPath)
	plumbing.Subdomain = (porcelain.Subdomain)
	return plumbing
}
func convertRepeatedHTTPBasicAuthToPlumbing(
	porcelains []*HTTPBasicAuth,
) []*proto.HTTPBasicAuth {
	var items []*proto.HTTPBasicAuth
	for _, porcelain := range porcelains {
		items = append(items, convertHTTPBasicAuthToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedHTTPBasicAuthToPorcelain(plumbings []*proto.HTTPBasicAuth) []*HTTPBasicAuth {
	var items []*HTTPBasicAuth
	for _, plumbing := range plumbings {
		items = append(items, convertHTTPBasicAuthToPorcelain(plumbing))
	}
	return items
}
func convertHTTPNoAuthToPorcelain(plumbing *proto.HTTPNoAuth) *HTTPNoAuth {
	if plumbing == nil {
		return nil
	}
	porcelain := &HTTPNoAuth{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Url = (plumbing.Url)
	porcelain.HealthcheckPath = (plumbing.HealthcheckPath)
	porcelain.HeadersBlacklist = (plumbing.HeadersBlacklist)
	porcelain.DefaultPath = (plumbing.DefaultPath)
	porcelain.Subdomain = (plumbing.Subdomain)
	return porcelain
}

func convertHTTPNoAuthToPlumbing(porcelain *HTTPNoAuth) *proto.HTTPNoAuth {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.HTTPNoAuth{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Url = (porcelain.Url)
	plumbing.HealthcheckPath = (porcelain.HealthcheckPath)
	plumbing.HeadersBlacklist = (porcelain.HeadersBlacklist)
	plumbing.DefaultPath = (porcelain.DefaultPath)
	plumbing.Subdomain = (porcelain.Subdomain)
	return plumbing
}
func convertRepeatedHTTPNoAuthToPlumbing(
	porcelains []*HTTPNoAuth,
) []*proto.HTTPNoAuth {
	var items []*proto.HTTPNoAuth
	for _, porcelain := range porcelains {
		items = append(items, convertHTTPNoAuthToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedHTTPNoAuthToPorcelain(plumbings []*proto.HTTPNoAuth) []*HTTPNoAuth {
	var items []*HTTPNoAuth
	for _, plumbing := range plumbings {
		items = append(items, convertHTTPNoAuthToPorcelain(plumbing))
	}
	return items
}
func convertHTTPAuthToPorcelain(plumbing *proto.HTTPAuth) *HTTPAuth {
	if plumbing == nil {
		return nil
	}
	porcelain := &HTTPAuth{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Url = (plumbing.Url)
	porcelain.HealthcheckPath = (plumbing.HealthcheckPath)
	porcelain.AuthHeader = (plumbing.AuthHeader)
	porcelain.HeadersBlacklist = (plumbing.HeadersBlacklist)
	porcelain.DefaultPath = (plumbing.DefaultPath)
	porcelain.Subdomain = (plumbing.Subdomain)
	return porcelain
}

func convertHTTPAuthToPlumbing(porcelain *HTTPAuth) *proto.HTTPAuth {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.HTTPAuth{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Url = (porcelain.Url)
	plumbing.HealthcheckPath = (porcelain.HealthcheckPath)
	plumbing.AuthHeader = (porcelain.AuthHeader)
	plumbing.HeadersBlacklist = (porcelain.HeadersBlacklist)
	plumbing.DefaultPath = (porcelain.DefaultPath)
	plumbing.Subdomain = (porcelain.Subdomain)
	return plumbing
}
func convertRepeatedHTTPAuthToPlumbing(
	porcelains []*HTTPAuth,
) []*proto.HTTPAuth {
	var items []*proto.HTTPAuth
	for _, porcelain := range porcelains {
		items = append(items, convertHTTPAuthToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedHTTPAuthToPorcelain(plumbings []*proto.HTTPAuth) []*HTTPAuth {
	var items []*HTTPAuth
	for _, plumbing := range plumbings {
		items = append(items, convertHTTPAuthToPorcelain(plumbing))
	}
	return items
}
func convertKubernetesToPorcelain(plumbing *proto.Kubernetes) *Kubernetes {
	if plumbing == nil {
		return nil
	}
	porcelain := &Kubernetes{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Port = (plumbing.Port)
	porcelain.CertificateAuthority = (plumbing.CertificateAuthority)
	porcelain.ClientCertificate = (plumbing.ClientCertificate)
	porcelain.ClientKey = (plumbing.ClientKey)
	porcelain.HealthcheckNamespace = (plumbing.HealthcheckNamespace)
	return porcelain
}

func convertKubernetesToPlumbing(porcelain *Kubernetes) *proto.Kubernetes {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Kubernetes{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Port = (porcelain.Port)
	plumbing.CertificateAuthority = (porcelain.CertificateAuthority)
	plumbing.ClientCertificate = (porcelain.ClientCertificate)
	plumbing.ClientKey = (porcelain.ClientKey)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	return plumbing
}
func convertRepeatedKubernetesToPlumbing(
	porcelains []*Kubernetes,
) []*proto.Kubernetes {
	var items []*proto.Kubernetes
	for _, porcelain := range porcelains {
		items = append(items, convertKubernetesToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedKubernetesToPorcelain(plumbings []*proto.Kubernetes) []*Kubernetes {
	var items []*Kubernetes
	for _, plumbing := range plumbings {
		items = append(items, convertKubernetesToPorcelain(plumbing))
	}
	return items
}
func convertKubernetesBasicAuthToPorcelain(plumbing *proto.KubernetesBasicAuth) *KubernetesBasicAuth {
	if plumbing == nil {
		return nil
	}
	porcelain := &KubernetesBasicAuth{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Port = (plumbing.Port)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.HealthcheckNamespace = (plumbing.HealthcheckNamespace)
	return porcelain
}

func convertKubernetesBasicAuthToPlumbing(porcelain *KubernetesBasicAuth) *proto.KubernetesBasicAuth {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.KubernetesBasicAuth{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Port = (porcelain.Port)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	return plumbing
}
func convertRepeatedKubernetesBasicAuthToPlumbing(
	porcelains []*KubernetesBasicAuth,
) []*proto.KubernetesBasicAuth {
	var items []*proto.KubernetesBasicAuth
	for _, porcelain := range porcelains {
		items = append(items, convertKubernetesBasicAuthToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedKubernetesBasicAuthToPorcelain(plumbings []*proto.KubernetesBasicAuth) []*KubernetesBasicAuth {
	var items []*KubernetesBasicAuth
	for _, plumbing := range plumbings {
		items = append(items, convertKubernetesBasicAuthToPorcelain(plumbing))
	}
	return items
}
func convertKubernetesServiceAccountToPorcelain(plumbing *proto.KubernetesServiceAccount) *KubernetesServiceAccount {
	if plumbing == nil {
		return nil
	}
	porcelain := &KubernetesServiceAccount{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Port = (plumbing.Port)
	porcelain.Token = (plumbing.Token)
	porcelain.HealthcheckNamespace = (plumbing.HealthcheckNamespace)
	return porcelain
}

func convertKubernetesServiceAccountToPlumbing(porcelain *KubernetesServiceAccount) *proto.KubernetesServiceAccount {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.KubernetesServiceAccount{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Port = (porcelain.Port)
	plumbing.Token = (porcelain.Token)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	return plumbing
}
func convertRepeatedKubernetesServiceAccountToPlumbing(
	porcelains []*KubernetesServiceAccount,
) []*proto.KubernetesServiceAccount {
	var items []*proto.KubernetesServiceAccount
	for _, porcelain := range porcelains {
		items = append(items, convertKubernetesServiceAccountToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedKubernetesServiceAccountToPorcelain(plumbings []*proto.KubernetesServiceAccount) []*KubernetesServiceAccount {
	var items []*KubernetesServiceAccount
	for _, plumbing := range plumbings {
		items = append(items, convertKubernetesServiceAccountToPorcelain(plumbing))
	}
	return items
}
func convertAmazonEKSToPorcelain(plumbing *proto.AmazonEKS) *AmazonEKS {
	if plumbing == nil {
		return nil
	}
	porcelain := &AmazonEKS{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Endpoint = (plumbing.Endpoint)
	porcelain.AccessKey = (plumbing.AccessKey)
	porcelain.SecretAccessKey = (plumbing.SecretAccessKey)
	porcelain.CertificateAuthority = (plumbing.CertificateAuthority)
	porcelain.Region = (plumbing.Region)
	porcelain.ClusterName = (plumbing.ClusterName)
	porcelain.RoleArn = (plumbing.RoleArn)
	porcelain.RoleExternalID = (plumbing.RoleExternalId)
	porcelain.HealthcheckNamespace = (plumbing.HealthcheckNamespace)
	return porcelain
}

func convertAmazonEKSToPlumbing(porcelain *AmazonEKS) *proto.AmazonEKS {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AmazonEKS{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.AccessKey = (porcelain.AccessKey)
	plumbing.SecretAccessKey = (porcelain.SecretAccessKey)
	plumbing.CertificateAuthority = (porcelain.CertificateAuthority)
	plumbing.Region = (porcelain.Region)
	plumbing.ClusterName = (porcelain.ClusterName)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	return plumbing
}
func convertRepeatedAmazonEKSToPlumbing(
	porcelains []*AmazonEKS,
) []*proto.AmazonEKS {
	var items []*proto.AmazonEKS
	for _, porcelain := range porcelains {
		items = append(items, convertAmazonEKSToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAmazonEKSToPorcelain(plumbings []*proto.AmazonEKS) []*AmazonEKS {
	var items []*AmazonEKS
	for _, plumbing := range plumbings {
		items = append(items, convertAmazonEKSToPorcelain(plumbing))
	}
	return items
}
func convertGoogleGKEToPorcelain(plumbing *proto.GoogleGKE) *GoogleGKE {
	if plumbing == nil {
		return nil
	}
	porcelain := &GoogleGKE{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Endpoint = (plumbing.Endpoint)
	porcelain.CertificateAuthority = (plumbing.CertificateAuthority)
	porcelain.ServiceAccountKey = (plumbing.ServiceAccountKey)
	porcelain.HealthcheckNamespace = (plumbing.HealthcheckNamespace)
	return porcelain
}

func convertGoogleGKEToPlumbing(porcelain *GoogleGKE) *proto.GoogleGKE {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.GoogleGKE{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.CertificateAuthority = (porcelain.CertificateAuthority)
	plumbing.ServiceAccountKey = (porcelain.ServiceAccountKey)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	return plumbing
}
func convertRepeatedGoogleGKEToPlumbing(
	porcelains []*GoogleGKE,
) []*proto.GoogleGKE {
	var items []*proto.GoogleGKE
	for _, porcelain := range porcelains {
		items = append(items, convertGoogleGKEToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedGoogleGKEToPorcelain(plumbings []*proto.GoogleGKE) []*GoogleGKE {
	var items []*GoogleGKE
	for _, plumbing := range plumbings {
		items = append(items, convertGoogleGKEToPorcelain(plumbing))
	}
	return items
}
func convertAKSToPorcelain(plumbing *proto.AKS) *AKS {
	if plumbing == nil {
		return nil
	}
	porcelain := &AKS{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Port = (plumbing.Port)
	porcelain.CertificateAuthority = (plumbing.CertificateAuthority)
	porcelain.ClientCertificate = (plumbing.ClientCertificate)
	porcelain.ClientKey = (plumbing.ClientKey)
	porcelain.HealthcheckNamespace = (plumbing.HealthcheckNamespace)
	return porcelain
}

func convertAKSToPlumbing(porcelain *AKS) *proto.AKS {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AKS{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Port = (porcelain.Port)
	plumbing.CertificateAuthority = (porcelain.CertificateAuthority)
	plumbing.ClientCertificate = (porcelain.ClientCertificate)
	plumbing.ClientKey = (porcelain.ClientKey)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	return plumbing
}
func convertRepeatedAKSToPlumbing(
	porcelains []*AKS,
) []*proto.AKS {
	var items []*proto.AKS
	for _, porcelain := range porcelains {
		items = append(items, convertAKSToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAKSToPorcelain(plumbings []*proto.AKS) []*AKS {
	var items []*AKS
	for _, plumbing := range plumbings {
		items = append(items, convertAKSToPorcelain(plumbing))
	}
	return items
}
func convertAKSBasicAuthToPorcelain(plumbing *proto.AKSBasicAuth) *AKSBasicAuth {
	if plumbing == nil {
		return nil
	}
	porcelain := &AKSBasicAuth{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Port = (plumbing.Port)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.HealthcheckNamespace = (plumbing.HealthcheckNamespace)
	return porcelain
}

func convertAKSBasicAuthToPlumbing(porcelain *AKSBasicAuth) *proto.AKSBasicAuth {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AKSBasicAuth{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Port = (porcelain.Port)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	return plumbing
}
func convertRepeatedAKSBasicAuthToPlumbing(
	porcelains []*AKSBasicAuth,
) []*proto.AKSBasicAuth {
	var items []*proto.AKSBasicAuth
	for _, porcelain := range porcelains {
		items = append(items, convertAKSBasicAuthToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAKSBasicAuthToPorcelain(plumbings []*proto.AKSBasicAuth) []*AKSBasicAuth {
	var items []*AKSBasicAuth
	for _, plumbing := range plumbings {
		items = append(items, convertAKSBasicAuthToPorcelain(plumbing))
	}
	return items
}
func convertAKSServiceAccountToPorcelain(plumbing *proto.AKSServiceAccount) *AKSServiceAccount {
	if plumbing == nil {
		return nil
	}
	porcelain := &AKSServiceAccount{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Port = (plumbing.Port)
	porcelain.Token = (plumbing.Token)
	porcelain.HealthcheckNamespace = (plumbing.HealthcheckNamespace)
	return porcelain
}

func convertAKSServiceAccountToPlumbing(porcelain *AKSServiceAccount) *proto.AKSServiceAccount {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AKSServiceAccount{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Port = (porcelain.Port)
	plumbing.Token = (porcelain.Token)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	return plumbing
}
func convertRepeatedAKSServiceAccountToPlumbing(
	porcelains []*AKSServiceAccount,
) []*proto.AKSServiceAccount {
	var items []*proto.AKSServiceAccount
	for _, porcelain := range porcelains {
		items = append(items, convertAKSServiceAccountToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAKSServiceAccountToPorcelain(plumbings []*proto.AKSServiceAccount) []*AKSServiceAccount {
	var items []*AKSServiceAccount
	for _, plumbing := range plumbings {
		items = append(items, convertAKSServiceAccountToPorcelain(plumbing))
	}
	return items
}
func convertMemcachedToPorcelain(plumbing *proto.Memcached) *Memcached {
	if plumbing == nil {
		return nil
	}
	porcelain := &Memcached{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Port = (plumbing.Port)
	return porcelain
}

func convertMemcachedToPlumbing(porcelain *Memcached) *proto.Memcached {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Memcached{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Port = (porcelain.Port)
	return plumbing
}
func convertRepeatedMemcachedToPlumbing(
	porcelains []*Memcached,
) []*proto.Memcached {
	var items []*proto.Memcached
	for _, porcelain := range porcelains {
		items = append(items, convertMemcachedToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMemcachedToPorcelain(plumbings []*proto.Memcached) []*Memcached {
	var items []*Memcached
	for _, plumbing := range plumbings {
		items = append(items, convertMemcachedToPorcelain(plumbing))
	}
	return items
}
func convertMongoLegacyHostToPorcelain(plumbing *proto.MongoLegacyHost) *MongoLegacyHost {
	if plumbing == nil {
		return nil
	}
	porcelain := &MongoLegacyHost{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.AuthDatabase = (plumbing.AuthDatabase)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.Port = (plumbing.Port)
	porcelain.ReplicaSet = (plumbing.ReplicaSet)
	porcelain.TlsRequired = (plumbing.TlsRequired)
	return porcelain
}

func convertMongoLegacyHostToPlumbing(porcelain *MongoLegacyHost) *proto.MongoLegacyHost {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.MongoLegacyHost{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.AuthDatabase = (porcelain.AuthDatabase)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.ReplicaSet = (porcelain.ReplicaSet)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	return plumbing
}
func convertRepeatedMongoLegacyHostToPlumbing(
	porcelains []*MongoLegacyHost,
) []*proto.MongoLegacyHost {
	var items []*proto.MongoLegacyHost
	for _, porcelain := range porcelains {
		items = append(items, convertMongoLegacyHostToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMongoLegacyHostToPorcelain(plumbings []*proto.MongoLegacyHost) []*MongoLegacyHost {
	var items []*MongoLegacyHost
	for _, plumbing := range plumbings {
		items = append(items, convertMongoLegacyHostToPorcelain(plumbing))
	}
	return items
}
func convertMongoLegacyReplicasetToPorcelain(plumbing *proto.MongoLegacyReplicaset) *MongoLegacyReplicaset {
	if plumbing == nil {
		return nil
	}
	porcelain := &MongoLegacyReplicaset{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.AuthDatabase = (plumbing.AuthDatabase)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.Port = (plumbing.Port)
	porcelain.ReplicaSet = (plumbing.ReplicaSet)
	porcelain.ConnectToReplica = (plumbing.ConnectToReplica)
	porcelain.TlsRequired = (plumbing.TlsRequired)
	return porcelain
}

func convertMongoLegacyReplicasetToPlumbing(porcelain *MongoLegacyReplicaset) *proto.MongoLegacyReplicaset {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.MongoLegacyReplicaset{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.AuthDatabase = (porcelain.AuthDatabase)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.ReplicaSet = (porcelain.ReplicaSet)
	plumbing.ConnectToReplica = (porcelain.ConnectToReplica)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	return plumbing
}
func convertRepeatedMongoLegacyReplicasetToPlumbing(
	porcelains []*MongoLegacyReplicaset,
) []*proto.MongoLegacyReplicaset {
	var items []*proto.MongoLegacyReplicaset
	for _, porcelain := range porcelains {
		items = append(items, convertMongoLegacyReplicasetToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMongoLegacyReplicasetToPorcelain(plumbings []*proto.MongoLegacyReplicaset) []*MongoLegacyReplicaset {
	var items []*MongoLegacyReplicaset
	for _, plumbing := range plumbings {
		items = append(items, convertMongoLegacyReplicasetToPorcelain(plumbing))
	}
	return items
}
func convertMongoHostToPorcelain(plumbing *proto.MongoHost) *MongoHost {
	if plumbing == nil {
		return nil
	}
	porcelain := &MongoHost{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.AuthDatabase = (plumbing.AuthDatabase)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.Port = (plumbing.Port)
	porcelain.TlsRequired = (plumbing.TlsRequired)
	return porcelain
}

func convertMongoHostToPlumbing(porcelain *MongoHost) *proto.MongoHost {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.MongoHost{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.AuthDatabase = (porcelain.AuthDatabase)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	return plumbing
}
func convertRepeatedMongoHostToPlumbing(
	porcelains []*MongoHost,
) []*proto.MongoHost {
	var items []*proto.MongoHost
	for _, porcelain := range porcelains {
		items = append(items, convertMongoHostToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMongoHostToPorcelain(plumbings []*proto.MongoHost) []*MongoHost {
	var items []*MongoHost
	for _, plumbing := range plumbings {
		items = append(items, convertMongoHostToPorcelain(plumbing))
	}
	return items
}
func convertMongoReplicaSetToPorcelain(plumbing *proto.MongoReplicaSet) *MongoReplicaSet {
	if plumbing == nil {
		return nil
	}
	porcelain := &MongoReplicaSet{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.AuthDatabase = (plumbing.AuthDatabase)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.Port = (plumbing.Port)
	porcelain.ReplicaSet = (plumbing.ReplicaSet)
	porcelain.ConnectToReplica = (plumbing.ConnectToReplica)
	porcelain.TlsRequired = (plumbing.TlsRequired)
	return porcelain
}

func convertMongoReplicaSetToPlumbing(porcelain *MongoReplicaSet) *proto.MongoReplicaSet {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.MongoReplicaSet{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.AuthDatabase = (porcelain.AuthDatabase)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.ReplicaSet = (porcelain.ReplicaSet)
	plumbing.ConnectToReplica = (porcelain.ConnectToReplica)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	return plumbing
}
func convertRepeatedMongoReplicaSetToPlumbing(
	porcelains []*MongoReplicaSet,
) []*proto.MongoReplicaSet {
	var items []*proto.MongoReplicaSet
	for _, porcelain := range porcelains {
		items = append(items, convertMongoReplicaSetToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMongoReplicaSetToPorcelain(plumbings []*proto.MongoReplicaSet) []*MongoReplicaSet {
	var items []*MongoReplicaSet
	for _, plumbing := range plumbings {
		items = append(items, convertMongoReplicaSetToPorcelain(plumbing))
	}
	return items
}
func convertMysqlToPorcelain(plumbing *proto.Mysql) *Mysql {
	if plumbing == nil {
		return nil
	}
	porcelain := &Mysql{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.Database = (plumbing.Database)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Port = (plumbing.Port)
	return porcelain
}

func convertMysqlToPlumbing(porcelain *Mysql) *proto.Mysql {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Mysql{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.Database = (porcelain.Database)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Port = (porcelain.Port)
	return plumbing
}
func convertRepeatedMysqlToPlumbing(
	porcelains []*Mysql,
) []*proto.Mysql {
	var items []*proto.Mysql
	for _, porcelain := range porcelains {
		items = append(items, convertMysqlToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMysqlToPorcelain(plumbings []*proto.Mysql) []*Mysql {
	var items []*Mysql
	for _, plumbing := range plumbings {
		items = append(items, convertMysqlToPorcelain(plumbing))
	}
	return items
}
func convertAuroraMysqlToPorcelain(plumbing *proto.AuroraMysql) *AuroraMysql {
	if plumbing == nil {
		return nil
	}
	porcelain := &AuroraMysql{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.Database = (plumbing.Database)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Port = (plumbing.Port)
	return porcelain
}

func convertAuroraMysqlToPlumbing(porcelain *AuroraMysql) *proto.AuroraMysql {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AuroraMysql{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.Database = (porcelain.Database)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Port = (porcelain.Port)
	return plumbing
}
func convertRepeatedAuroraMysqlToPlumbing(
	porcelains []*AuroraMysql,
) []*proto.AuroraMysql {
	var items []*proto.AuroraMysql
	for _, porcelain := range porcelains {
		items = append(items, convertAuroraMysqlToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAuroraMysqlToPorcelain(plumbings []*proto.AuroraMysql) []*AuroraMysql {
	var items []*AuroraMysql
	for _, plumbing := range plumbings {
		items = append(items, convertAuroraMysqlToPorcelain(plumbing))
	}
	return items
}
func convertClustrixToPorcelain(plumbing *proto.Clustrix) *Clustrix {
	if plumbing == nil {
		return nil
	}
	porcelain := &Clustrix{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.Database = (plumbing.Database)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Port = (plumbing.Port)
	return porcelain
}

func convertClustrixToPlumbing(porcelain *Clustrix) *proto.Clustrix {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Clustrix{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.Database = (porcelain.Database)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Port = (porcelain.Port)
	return plumbing
}
func convertRepeatedClustrixToPlumbing(
	porcelains []*Clustrix,
) []*proto.Clustrix {
	var items []*proto.Clustrix
	for _, porcelain := range porcelains {
		items = append(items, convertClustrixToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedClustrixToPorcelain(plumbings []*proto.Clustrix) []*Clustrix {
	var items []*Clustrix
	for _, plumbing := range plumbings {
		items = append(items, convertClustrixToPorcelain(plumbing))
	}
	return items
}
func convertMariaToPorcelain(plumbing *proto.Maria) *Maria {
	if plumbing == nil {
		return nil
	}
	porcelain := &Maria{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.Database = (plumbing.Database)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Port = (plumbing.Port)
	return porcelain
}

func convertMariaToPlumbing(porcelain *Maria) *proto.Maria {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Maria{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.Database = (porcelain.Database)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Port = (porcelain.Port)
	return plumbing
}
func convertRepeatedMariaToPlumbing(
	porcelains []*Maria,
) []*proto.Maria {
	var items []*proto.Maria
	for _, porcelain := range porcelains {
		items = append(items, convertMariaToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMariaToPorcelain(plumbings []*proto.Maria) []*Maria {
	var items []*Maria
	for _, plumbing := range plumbings {
		items = append(items, convertMariaToPorcelain(plumbing))
	}
	return items
}
func convertMemsqlToPorcelain(plumbing *proto.Memsql) *Memsql {
	if plumbing == nil {
		return nil
	}
	porcelain := &Memsql{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.Database = (plumbing.Database)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Port = (plumbing.Port)
	return porcelain
}

func convertMemsqlToPlumbing(porcelain *Memsql) *proto.Memsql {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Memsql{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.Database = (porcelain.Database)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Port = (porcelain.Port)
	return plumbing
}
func convertRepeatedMemsqlToPlumbing(
	porcelains []*Memsql,
) []*proto.Memsql {
	var items []*proto.Memsql
	for _, porcelain := range porcelains {
		items = append(items, convertMemsqlToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMemsqlToPorcelain(plumbings []*proto.Memsql) []*Memsql {
	var items []*Memsql
	for _, plumbing := range plumbings {
		items = append(items, convertMemsqlToPorcelain(plumbing))
	}
	return items
}
func convertOracleToPorcelain(plumbing *proto.Oracle) *Oracle {
	if plumbing == nil {
		return nil
	}
	porcelain := &Oracle{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.Database = (plumbing.Database)
	porcelain.Port = (plumbing.Port)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.TlsRequired = (plumbing.TlsRequired)
	return porcelain
}

func convertOracleToPlumbing(porcelain *Oracle) *proto.Oracle {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Oracle{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.Database = (porcelain.Database)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	return plumbing
}
func convertRepeatedOracleToPlumbing(
	porcelains []*Oracle,
) []*proto.Oracle {
	var items []*proto.Oracle
	for _, porcelain := range porcelains {
		items = append(items, convertOracleToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedOracleToPorcelain(plumbings []*proto.Oracle) []*Oracle {
	var items []*Oracle
	for _, plumbing := range plumbings {
		items = append(items, convertOracleToPorcelain(plumbing))
	}
	return items
}
func convertPostgresToPorcelain(plumbing *proto.Postgres) *Postgres {
	if plumbing == nil {
		return nil
	}
	porcelain := &Postgres{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.Database = (plumbing.Database)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Port = (plumbing.Port)
	porcelain.OverrideDatabase = (plumbing.OverrideDatabase)
	return porcelain
}

func convertPostgresToPlumbing(porcelain *Postgres) *proto.Postgres {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Postgres{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.Database = (porcelain.Database)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Port = (porcelain.Port)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	return plumbing
}
func convertRepeatedPostgresToPlumbing(
	porcelains []*Postgres,
) []*proto.Postgres {
	var items []*proto.Postgres
	for _, porcelain := range porcelains {
		items = append(items, convertPostgresToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPostgresToPorcelain(plumbings []*proto.Postgres) []*Postgres {
	var items []*Postgres
	for _, plumbing := range plumbings {
		items = append(items, convertPostgresToPorcelain(plumbing))
	}
	return items
}
func convertAuroraPostgresToPorcelain(plumbing *proto.AuroraPostgres) *AuroraPostgres {
	if plumbing == nil {
		return nil
	}
	porcelain := &AuroraPostgres{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.Database = (plumbing.Database)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Port = (plumbing.Port)
	porcelain.OverrideDatabase = (plumbing.OverrideDatabase)
	return porcelain
}

func convertAuroraPostgresToPlumbing(porcelain *AuroraPostgres) *proto.AuroraPostgres {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AuroraPostgres{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.Database = (porcelain.Database)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Port = (porcelain.Port)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	return plumbing
}
func convertRepeatedAuroraPostgresToPlumbing(
	porcelains []*AuroraPostgres,
) []*proto.AuroraPostgres {
	var items []*proto.AuroraPostgres
	for _, porcelain := range porcelains {
		items = append(items, convertAuroraPostgresToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAuroraPostgresToPorcelain(plumbings []*proto.AuroraPostgres) []*AuroraPostgres {
	var items []*AuroraPostgres
	for _, plumbing := range plumbings {
		items = append(items, convertAuroraPostgresToPorcelain(plumbing))
	}
	return items
}
func convertGreenplumToPorcelain(plumbing *proto.Greenplum) *Greenplum {
	if plumbing == nil {
		return nil
	}
	porcelain := &Greenplum{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.Database = (plumbing.Database)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Port = (plumbing.Port)
	porcelain.OverrideDatabase = (plumbing.OverrideDatabase)
	return porcelain
}

func convertGreenplumToPlumbing(porcelain *Greenplum) *proto.Greenplum {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Greenplum{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.Database = (porcelain.Database)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Port = (porcelain.Port)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	return plumbing
}
func convertRepeatedGreenplumToPlumbing(
	porcelains []*Greenplum,
) []*proto.Greenplum {
	var items []*proto.Greenplum
	for _, porcelain := range porcelains {
		items = append(items, convertGreenplumToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedGreenplumToPorcelain(plumbings []*proto.Greenplum) []*Greenplum {
	var items []*Greenplum
	for _, plumbing := range plumbings {
		items = append(items, convertGreenplumToPorcelain(plumbing))
	}
	return items
}
func convertCockroachToPorcelain(plumbing *proto.Cockroach) *Cockroach {
	if plumbing == nil {
		return nil
	}
	porcelain := &Cockroach{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.Database = (plumbing.Database)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Port = (plumbing.Port)
	porcelain.OverrideDatabase = (plumbing.OverrideDatabase)
	return porcelain
}

func convertCockroachToPlumbing(porcelain *Cockroach) *proto.Cockroach {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Cockroach{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.Database = (porcelain.Database)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Port = (porcelain.Port)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	return plumbing
}
func convertRepeatedCockroachToPlumbing(
	porcelains []*Cockroach,
) []*proto.Cockroach {
	var items []*proto.Cockroach
	for _, porcelain := range porcelains {
		items = append(items, convertCockroachToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedCockroachToPorcelain(plumbings []*proto.Cockroach) []*Cockroach {
	var items []*Cockroach
	for _, plumbing := range plumbings {
		items = append(items, convertCockroachToPorcelain(plumbing))
	}
	return items
}
func convertRedshiftToPorcelain(plumbing *proto.Redshift) *Redshift {
	if plumbing == nil {
		return nil
	}
	porcelain := &Redshift{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.Database = (plumbing.Database)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Port = (plumbing.Port)
	porcelain.OverrideDatabase = (plumbing.OverrideDatabase)
	return porcelain
}

func convertRedshiftToPlumbing(porcelain *Redshift) *proto.Redshift {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Redshift{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.Database = (porcelain.Database)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Port = (porcelain.Port)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	return plumbing
}
func convertRepeatedRedshiftToPlumbing(
	porcelains []*Redshift,
) []*proto.Redshift {
	var items []*proto.Redshift
	for _, porcelain := range porcelains {
		items = append(items, convertRedshiftToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRedshiftToPorcelain(plumbings []*proto.Redshift) []*Redshift {
	var items []*Redshift
	for _, plumbing := range plumbings {
		items = append(items, convertRedshiftToPorcelain(plumbing))
	}
	return items
}
func convertCitusToPorcelain(plumbing *proto.Citus) *Citus {
	if plumbing == nil {
		return nil
	}
	porcelain := &Citus{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.Database = (plumbing.Database)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Port = (plumbing.Port)
	porcelain.OverrideDatabase = (plumbing.OverrideDatabase)
	return porcelain
}

func convertCitusToPlumbing(porcelain *Citus) *proto.Citus {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Citus{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.Database = (porcelain.Database)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Port = (porcelain.Port)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	return plumbing
}
func convertRepeatedCitusToPlumbing(
	porcelains []*Citus,
) []*proto.Citus {
	var items []*proto.Citus
	for _, porcelain := range porcelains {
		items = append(items, convertCitusToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedCitusToPorcelain(plumbings []*proto.Citus) []*Citus {
	var items []*Citus
	for _, plumbing := range plumbings {
		items = append(items, convertCitusToPorcelain(plumbing))
	}
	return items
}
func convertPrestoToPorcelain(plumbing *proto.Presto) *Presto {
	if plumbing == nil {
		return nil
	}
	porcelain := &Presto{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Password = (plumbing.Password)
	porcelain.Database = (plumbing.Database)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Port = (plumbing.Port)
	porcelain.Username = (plumbing.Username)
	porcelain.TlsRequired = (plumbing.TlsRequired)
	return porcelain
}

func convertPrestoToPlumbing(porcelain *Presto) *proto.Presto {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Presto{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Password = (porcelain.Password)
	plumbing.Database = (porcelain.Database)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Port = (porcelain.Port)
	plumbing.Username = (porcelain.Username)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	return plumbing
}
func convertRepeatedPrestoToPlumbing(
	porcelains []*Presto,
) []*proto.Presto {
	var items []*proto.Presto
	for _, porcelain := range porcelains {
		items = append(items, convertPrestoToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPrestoToPorcelain(plumbings []*proto.Presto) []*Presto {
	var items []*Presto
	for _, plumbing := range plumbings {
		items = append(items, convertPrestoToPorcelain(plumbing))
	}
	return items
}
func convertRDPToPorcelain(plumbing *proto.RDP) *RDP {
	if plumbing == nil {
		return nil
	}
	porcelain := &RDP{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Port = (plumbing.Port)
	return porcelain
}

func convertRDPToPlumbing(porcelain *RDP) *proto.RDP {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RDP{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Port = (porcelain.Port)
	return plumbing
}
func convertRepeatedRDPToPlumbing(
	porcelains []*RDP,
) []*proto.RDP {
	var items []*proto.RDP
	for _, porcelain := range porcelains {
		items = append(items, convertRDPToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRDPToPorcelain(plumbings []*proto.RDP) []*RDP {
	var items []*RDP
	for _, plumbing := range plumbings {
		items = append(items, convertRDPToPorcelain(plumbing))
	}
	return items
}
func convertRedisToPorcelain(plumbing *proto.Redis) *Redis {
	if plumbing == nil {
		return nil
	}
	porcelain := &Redis{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Password = (plumbing.Password)
	porcelain.Port = (plumbing.Port)
	return porcelain
}

func convertRedisToPlumbing(porcelain *Redis) *proto.Redis {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Redis{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	return plumbing
}
func convertRepeatedRedisToPlumbing(
	porcelains []*Redis,
) []*proto.Redis {
	var items []*proto.Redis
	for _, porcelain := range porcelains {
		items = append(items, convertRedisToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRedisToPorcelain(plumbings []*proto.Redis) []*Redis {
	var items []*Redis
	for _, plumbing := range plumbings {
		items = append(items, convertRedisToPorcelain(plumbing))
	}
	return items
}
func convertElasticacheRedisToPorcelain(plumbing *proto.ElasticacheRedis) *ElasticacheRedis {
	if plumbing == nil {
		return nil
	}
	porcelain := &ElasticacheRedis{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Password = (plumbing.Password)
	porcelain.Port = (plumbing.Port)
	porcelain.TlsRequired = (plumbing.TlsRequired)
	return porcelain
}

func convertElasticacheRedisToPlumbing(porcelain *ElasticacheRedis) *proto.ElasticacheRedis {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ElasticacheRedis{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	return plumbing
}
func convertRepeatedElasticacheRedisToPlumbing(
	porcelains []*ElasticacheRedis,
) []*proto.ElasticacheRedis {
	var items []*proto.ElasticacheRedis
	for _, porcelain := range porcelains {
		items = append(items, convertElasticacheRedisToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedElasticacheRedisToPorcelain(plumbings []*proto.ElasticacheRedis) []*ElasticacheRedis {
	var items []*ElasticacheRedis
	for _, plumbing := range plumbings {
		items = append(items, convertElasticacheRedisToPorcelain(plumbing))
	}
	return items
}
func convertSnowflakeToPorcelain(plumbing *proto.Snowflake) *Snowflake {
	if plumbing == nil {
		return nil
	}
	porcelain := &Snowflake{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.Database = (plumbing.Database)
	porcelain.Schema = (plumbing.Schema)
	porcelain.PortOverride = (plumbing.PortOverride)
	return porcelain
}

func convertSnowflakeToPlumbing(porcelain *Snowflake) *proto.Snowflake {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Snowflake{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.Database = (porcelain.Database)
	plumbing.Schema = (porcelain.Schema)
	plumbing.PortOverride = (porcelain.PortOverride)
	return plumbing
}
func convertRepeatedSnowflakeToPlumbing(
	porcelains []*Snowflake,
) []*proto.Snowflake {
	var items []*proto.Snowflake
	for _, porcelain := range porcelains {
		items = append(items, convertSnowflakeToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSnowflakeToPorcelain(plumbings []*proto.Snowflake) []*Snowflake {
	var items []*Snowflake
	for _, plumbing := range plumbings {
		items = append(items, convertSnowflakeToPorcelain(plumbing))
	}
	return items
}
func convertSQLServerToPorcelain(plumbing *proto.SQLServer) *SQLServer {
	if plumbing == nil {
		return nil
	}
	porcelain := &SQLServer{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.Database = (plumbing.Database)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Schema = (plumbing.Schema)
	porcelain.Port = (plumbing.Port)
	porcelain.OverrideDatabase = (plumbing.OverrideDatabase)
	return porcelain
}

func convertSQLServerToPlumbing(porcelain *SQLServer) *proto.SQLServer {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SQLServer{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.Database = (porcelain.Database)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Schema = (porcelain.Schema)
	plumbing.Port = (porcelain.Port)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	return plumbing
}
func convertRepeatedSQLServerToPlumbing(
	porcelains []*SQLServer,
) []*proto.SQLServer {
	var items []*proto.SQLServer
	for _, porcelain := range porcelains {
		items = append(items, convertSQLServerToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSQLServerToPorcelain(plumbings []*proto.SQLServer) []*SQLServer {
	var items []*SQLServer
	for _, plumbing := range plumbings {
		items = append(items, convertSQLServerToPorcelain(plumbing))
	}
	return items
}
func convertSSHToPorcelain(plumbing *proto.SSH) *SSH {
	if plumbing == nil {
		return nil
	}
	porcelain := &SSH{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Username = (plumbing.Username)
	porcelain.Port = (plumbing.Port)
	porcelain.PublicKey = (plumbing.PublicKey)
	porcelain.PortForwarding = (plumbing.PortForwarding)
	porcelain.AllowDeprecatedKeyExchanges = (plumbing.AllowDeprecatedKeyExchanges)
	return porcelain
}

func convertSSHToPlumbing(porcelain *SSH) *proto.SSH {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SSH{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Username = (porcelain.Username)
	plumbing.Port = (porcelain.Port)
	plumbing.PublicKey = (porcelain.PublicKey)
	plumbing.PortForwarding = (porcelain.PortForwarding)
	plumbing.AllowDeprecatedKeyExchanges = (porcelain.AllowDeprecatedKeyExchanges)
	return plumbing
}
func convertRepeatedSSHToPlumbing(
	porcelains []*SSH,
) []*proto.SSH {
	var items []*proto.SSH
	for _, porcelain := range porcelains {
		items = append(items, convertSSHToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSSHToPorcelain(plumbings []*proto.SSH) []*SSH {
	var items []*SSH
	for _, plumbing := range plumbings {
		items = append(items, convertSSHToPorcelain(plumbing))
	}
	return items
}
func convertSSHCertToPorcelain(plumbing *proto.SSHCert) *SSHCert {
	if plumbing == nil {
		return nil
	}
	porcelain := &SSHCert{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Username = (plumbing.Username)
	porcelain.Port = (plumbing.Port)
	porcelain.PortForwarding = (plumbing.PortForwarding)
	porcelain.AllowDeprecatedKeyExchanges = (plumbing.AllowDeprecatedKeyExchanges)
	return porcelain
}

func convertSSHCertToPlumbing(porcelain *SSHCert) *proto.SSHCert {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SSHCert{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Username = (porcelain.Username)
	plumbing.Port = (porcelain.Port)
	plumbing.PortForwarding = (porcelain.PortForwarding)
	plumbing.AllowDeprecatedKeyExchanges = (porcelain.AllowDeprecatedKeyExchanges)
	return plumbing
}
func convertRepeatedSSHCertToPlumbing(
	porcelains []*SSHCert,
) []*proto.SSHCert {
	var items []*proto.SSHCert
	for _, porcelain := range porcelains {
		items = append(items, convertSSHCertToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSSHCertToPorcelain(plumbings []*proto.SSHCert) []*SSHCert {
	var items []*SSHCert
	for _, plumbing := range plumbings {
		items = append(items, convertSSHCertToPorcelain(plumbing))
	}
	return items
}
func convertSSHCustomerKeyToPorcelain(plumbing *proto.SSHCustomerKey) *SSHCustomerKey {
	if plumbing == nil {
		return nil
	}
	porcelain := &SSHCustomerKey{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Username = (plumbing.Username)
	porcelain.Port = (plumbing.Port)
	porcelain.PrivateKey = (plumbing.PrivateKey)
	porcelain.PortForwarding = (plumbing.PortForwarding)
	porcelain.AllowDeprecatedKeyExchanges = (plumbing.AllowDeprecatedKeyExchanges)
	return porcelain
}

func convertSSHCustomerKeyToPlumbing(porcelain *SSHCustomerKey) *proto.SSHCustomerKey {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SSHCustomerKey{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Username = (porcelain.Username)
	plumbing.Port = (porcelain.Port)
	plumbing.PrivateKey = (porcelain.PrivateKey)
	plumbing.PortForwarding = (porcelain.PortForwarding)
	plumbing.AllowDeprecatedKeyExchanges = (porcelain.AllowDeprecatedKeyExchanges)
	return plumbing
}
func convertRepeatedSSHCustomerKeyToPlumbing(
	porcelains []*SSHCustomerKey,
) []*proto.SSHCustomerKey {
	var items []*proto.SSHCustomerKey
	for _, porcelain := range porcelains {
		items = append(items, convertSSHCustomerKeyToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSSHCustomerKeyToPorcelain(plumbings []*proto.SSHCustomerKey) []*SSHCustomerKey {
	var items []*SSHCustomerKey
	for _, plumbing := range plumbings {
		items = append(items, convertSSHCustomerKeyToPorcelain(plumbing))
	}
	return items
}
func convertSybaseToPorcelain(plumbing *proto.Sybase) *Sybase {
	if plumbing == nil {
		return nil
	}
	porcelain := &Sybase{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Username = (plumbing.Username)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Port = (plumbing.Port)
	porcelain.Password = (plumbing.Password)
	return porcelain
}

func convertSybaseToPlumbing(porcelain *Sybase) *proto.Sybase {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Sybase{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Username = (porcelain.Username)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Port = (porcelain.Port)
	plumbing.Password = (porcelain.Password)
	return plumbing
}
func convertRepeatedSybaseToPlumbing(
	porcelains []*Sybase,
) []*proto.Sybase {
	var items []*proto.Sybase
	for _, porcelain := range porcelains {
		items = append(items, convertSybaseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSybaseToPorcelain(plumbings []*proto.Sybase) []*Sybase {
	var items []*Sybase
	for _, plumbing := range plumbings {
		items = append(items, convertSybaseToPorcelain(plumbing))
	}
	return items
}
func convertSybaseIQToPorcelain(plumbing *proto.SybaseIQ) *SybaseIQ {
	if plumbing == nil {
		return nil
	}
	porcelain := &SybaseIQ{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Username = (plumbing.Username)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Port = (plumbing.Port)
	porcelain.Password = (plumbing.Password)
	return porcelain
}

func convertSybaseIQToPlumbing(porcelain *SybaseIQ) *proto.SybaseIQ {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SybaseIQ{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Username = (porcelain.Username)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Port = (porcelain.Port)
	plumbing.Password = (porcelain.Password)
	return plumbing
}
func convertRepeatedSybaseIQToPlumbing(
	porcelains []*SybaseIQ,
) []*proto.SybaseIQ {
	var items []*proto.SybaseIQ
	for _, porcelain := range porcelains {
		items = append(items, convertSybaseIQToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSybaseIQToPorcelain(plumbings []*proto.SybaseIQ) []*SybaseIQ {
	var items []*SybaseIQ
	for _, plumbing := range plumbings {
		items = append(items, convertSybaseIQToPorcelain(plumbing))
	}
	return items
}
func convertTeradataToPorcelain(plumbing *proto.Teradata) *Teradata {
	if plumbing == nil {
		return nil
	}
	porcelain := &Teradata{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Healthy = (plumbing.Healthy)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	porcelain.SecretStoreID = (plumbing.SecretStoreId)
	porcelain.Hostname = (plumbing.Hostname)
	porcelain.Username = (plumbing.Username)
	porcelain.Password = (plumbing.Password)
	porcelain.PortOverride = (plumbing.PortOverride)
	porcelain.Port = (plumbing.Port)
	return porcelain
}

func convertTeradataToPlumbing(porcelain *Teradata) *proto.Teradata {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Teradata{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Username = (porcelain.Username)
	plumbing.Password = (porcelain.Password)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Port = (porcelain.Port)
	return plumbing
}
func convertRepeatedTeradataToPlumbing(
	porcelains []*Teradata,
) []*proto.Teradata {
	var items []*proto.Teradata
	for _, porcelain := range porcelains {
		items = append(items, convertTeradataToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedTeradataToPorcelain(plumbings []*proto.Teradata) []*Teradata {
	var items []*Teradata
	for _, plumbing := range plumbings {
		items = append(items, convertTeradataToPorcelain(plumbing))
	}
	return items
}
func convertNodeCreateResponseToPorcelain(plumbing *proto.NodeCreateResponse) *NodeCreateResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &NodeCreateResponse{}
	porcelain.Meta = convertCreateResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.Node = convertNodeToPorcelain(plumbing.Node)
	porcelain.Token = (plumbing.Token)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertNodeCreateResponseToPlumbing(porcelain *NodeCreateResponse) *proto.NodeCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.NodeCreateResponse{}
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.Node = convertNodeToPlumbing(porcelain.Node)
	plumbing.Token = (porcelain.Token)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedNodeCreateResponseToPlumbing(
	porcelains []*NodeCreateResponse,
) []*proto.NodeCreateResponse {
	var items []*proto.NodeCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertNodeCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedNodeCreateResponseToPorcelain(plumbings []*proto.NodeCreateResponse) []*NodeCreateResponse {
	var items []*NodeCreateResponse
	for _, plumbing := range plumbings {
		items = append(items, convertNodeCreateResponseToPorcelain(plumbing))
	}
	return items
}
func convertNodeGetResponseToPorcelain(plumbing *proto.NodeGetResponse) *NodeGetResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &NodeGetResponse{}
	porcelain.Meta = convertGetResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.Node = convertNodeToPorcelain(plumbing.Node)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertNodeGetResponseToPlumbing(porcelain *NodeGetResponse) *proto.NodeGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.NodeGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.Node = convertNodeToPlumbing(porcelain.Node)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedNodeGetResponseToPlumbing(
	porcelains []*NodeGetResponse,
) []*proto.NodeGetResponse {
	var items []*proto.NodeGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertNodeGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedNodeGetResponseToPorcelain(plumbings []*proto.NodeGetResponse) []*NodeGetResponse {
	var items []*NodeGetResponse
	for _, plumbing := range plumbings {
		items = append(items, convertNodeGetResponseToPorcelain(plumbing))
	}
	return items
}
func convertNodeUpdateResponseToPorcelain(plumbing *proto.NodeUpdateResponse) *NodeUpdateResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &NodeUpdateResponse{}
	porcelain.Meta = convertUpdateResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.Node = convertNodeToPorcelain(plumbing.Node)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertNodeUpdateResponseToPlumbing(porcelain *NodeUpdateResponse) *proto.NodeUpdateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.NodeUpdateResponse{}
	plumbing.Meta = convertUpdateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.Node = convertNodeToPlumbing(porcelain.Node)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedNodeUpdateResponseToPlumbing(
	porcelains []*NodeUpdateResponse,
) []*proto.NodeUpdateResponse {
	var items []*proto.NodeUpdateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertNodeUpdateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedNodeUpdateResponseToPorcelain(plumbings []*proto.NodeUpdateResponse) []*NodeUpdateResponse {
	var items []*NodeUpdateResponse
	for _, plumbing := range plumbings {
		items = append(items, convertNodeUpdateResponseToPorcelain(plumbing))
	}
	return items
}
func convertNodeDeleteResponseToPorcelain(plumbing *proto.NodeDeleteResponse) *NodeDeleteResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &NodeDeleteResponse{}
	porcelain.Meta = convertDeleteResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertNodeDeleteResponseToPlumbing(porcelain *NodeDeleteResponse) *proto.NodeDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.NodeDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedNodeDeleteResponseToPlumbing(
	porcelains []*NodeDeleteResponse,
) []*proto.NodeDeleteResponse {
	var items []*proto.NodeDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertNodeDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedNodeDeleteResponseToPorcelain(plumbings []*proto.NodeDeleteResponse) []*NodeDeleteResponse {
	var items []*NodeDeleteResponse
	for _, plumbing := range plumbings {
		items = append(items, convertNodeDeleteResponseToPorcelain(plumbing))
	}
	return items
}
func convertNodeToPlumbing(porcelain Node) *proto.Node {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Node{}

	switch v := porcelain.(type) {
	case *Relay:
		plumbing.Node = &proto.Node_Relay{Relay: convertRelayToPlumbing(v)}
	case *Gateway:
		plumbing.Node = &proto.Node_Gateway{Gateway: convertGatewayToPlumbing(v)}
	}
	return plumbing
}

func convertNodeToPorcelain(plumbing *proto.Node) Node {
	if plumbing.GetRelay() != nil {
		return convertRelayToPorcelain(plumbing.GetRelay())
	}
	if plumbing.GetGateway() != nil {
		return convertGatewayToPorcelain(plumbing.GetGateway())
	}
	return nil
}
func convertRepeatedNodeToPlumbing(
	porcelains []Node,
) []*proto.Node {
	var items []*proto.Node
	for _, porcelain := range porcelains {
		items = append(items, convertNodeToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedNodeToPorcelain(plumbings []*proto.Node) []Node {
	var items []Node
	for _, plumbing := range plumbings {
		items = append(items, convertNodeToPorcelain(plumbing))
	}
	return items
}
func convertRelayToPorcelain(plumbing *proto.Relay) *Relay {
	if plumbing == nil {
		return nil
	}
	porcelain := &Relay{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.State = (plumbing.State)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	return porcelain
}

func convertRelayToPlumbing(porcelain *Relay) *proto.Relay {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Relay{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.State = (porcelain.State)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedRelayToPlumbing(
	porcelains []*Relay,
) []*proto.Relay {
	var items []*proto.Relay
	for _, porcelain := range porcelains {
		items = append(items, convertRelayToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRelayToPorcelain(plumbings []*proto.Relay) []*Relay {
	var items []*Relay
	for _, plumbing := range plumbings {
		items = append(items, convertRelayToPorcelain(plumbing))
	}
	return items
}
func convertGatewayToPorcelain(plumbing *proto.Gateway) *Gateway {
	if plumbing == nil {
		return nil
	}
	porcelain := &Gateway{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.State = (plumbing.State)
	porcelain.ListenAddress = (plumbing.ListenAddress)
	porcelain.BindAddress = (plumbing.BindAddress)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	return porcelain
}

func convertGatewayToPlumbing(porcelain *Gateway) *proto.Gateway {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Gateway{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.State = (porcelain.State)
	plumbing.ListenAddress = (porcelain.ListenAddress)
	plumbing.BindAddress = (porcelain.BindAddress)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedGatewayToPlumbing(
	porcelains []*Gateway,
) []*proto.Gateway {
	var items []*proto.Gateway
	for _, porcelain := range porcelains {
		items = append(items, convertGatewayToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedGatewayToPorcelain(plumbings []*proto.Gateway) []*Gateway {
	var items []*Gateway
	for _, plumbing := range plumbings {
		items = append(items, convertGatewayToPorcelain(plumbing))
	}
	return items
}
func convertResourceCreateResponseToPorcelain(plumbing *proto.ResourceCreateResponse) *ResourceCreateResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &ResourceCreateResponse{}
	porcelain.Meta = convertCreateResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.Resource = convertResourceToPorcelain(plumbing.Resource)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertResourceCreateResponseToPlumbing(porcelain *ResourceCreateResponse) *proto.ResourceCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ResourceCreateResponse{}
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.Resource = convertResourceToPlumbing(porcelain.Resource)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedResourceCreateResponseToPlumbing(
	porcelains []*ResourceCreateResponse,
) []*proto.ResourceCreateResponse {
	var items []*proto.ResourceCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertResourceCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedResourceCreateResponseToPorcelain(plumbings []*proto.ResourceCreateResponse) []*ResourceCreateResponse {
	var items []*ResourceCreateResponse
	for _, plumbing := range plumbings {
		items = append(items, convertResourceCreateResponseToPorcelain(plumbing))
	}
	return items
}
func convertResourceGetResponseToPorcelain(plumbing *proto.ResourceGetResponse) *ResourceGetResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &ResourceGetResponse{}
	porcelain.Meta = convertGetResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.Resource = convertResourceToPorcelain(plumbing.Resource)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertResourceGetResponseToPlumbing(porcelain *ResourceGetResponse) *proto.ResourceGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ResourceGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.Resource = convertResourceToPlumbing(porcelain.Resource)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedResourceGetResponseToPlumbing(
	porcelains []*ResourceGetResponse,
) []*proto.ResourceGetResponse {
	var items []*proto.ResourceGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertResourceGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedResourceGetResponseToPorcelain(plumbings []*proto.ResourceGetResponse) []*ResourceGetResponse {
	var items []*ResourceGetResponse
	for _, plumbing := range plumbings {
		items = append(items, convertResourceGetResponseToPorcelain(plumbing))
	}
	return items
}
func convertResourceUpdateResponseToPorcelain(plumbing *proto.ResourceUpdateResponse) *ResourceUpdateResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &ResourceUpdateResponse{}
	porcelain.Meta = convertUpdateResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.Resource = convertResourceToPorcelain(plumbing.Resource)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertResourceUpdateResponseToPlumbing(porcelain *ResourceUpdateResponse) *proto.ResourceUpdateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ResourceUpdateResponse{}
	plumbing.Meta = convertUpdateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.Resource = convertResourceToPlumbing(porcelain.Resource)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedResourceUpdateResponseToPlumbing(
	porcelains []*ResourceUpdateResponse,
) []*proto.ResourceUpdateResponse {
	var items []*proto.ResourceUpdateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertResourceUpdateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedResourceUpdateResponseToPorcelain(plumbings []*proto.ResourceUpdateResponse) []*ResourceUpdateResponse {
	var items []*ResourceUpdateResponse
	for _, plumbing := range plumbings {
		items = append(items, convertResourceUpdateResponseToPorcelain(plumbing))
	}
	return items
}
func convertResourceDeleteResponseToPorcelain(plumbing *proto.ResourceDeleteResponse) *ResourceDeleteResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &ResourceDeleteResponse{}
	porcelain.Meta = convertDeleteResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertResourceDeleteResponseToPlumbing(porcelain *ResourceDeleteResponse) *proto.ResourceDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ResourceDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedResourceDeleteResponseToPlumbing(
	porcelains []*ResourceDeleteResponse,
) []*proto.ResourceDeleteResponse {
	var items []*proto.ResourceDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertResourceDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedResourceDeleteResponseToPorcelain(plumbings []*proto.ResourceDeleteResponse) []*ResourceDeleteResponse {
	var items []*ResourceDeleteResponse
	for _, plumbing := range plumbings {
		items = append(items, convertResourceDeleteResponseToPorcelain(plumbing))
	}
	return items
}
func convertRoleAttachmentCreateResponseToPorcelain(plumbing *proto.RoleAttachmentCreateResponse) *RoleAttachmentCreateResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &RoleAttachmentCreateResponse{}
	porcelain.Meta = convertCreateResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.RoleAttachment = convertRoleAttachmentToPorcelain(plumbing.RoleAttachment)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertRoleAttachmentCreateResponseToPlumbing(porcelain *RoleAttachmentCreateResponse) *proto.RoleAttachmentCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleAttachmentCreateResponse{}
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RoleAttachment = convertRoleAttachmentToPlumbing(porcelain.RoleAttachment)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedRoleAttachmentCreateResponseToPlumbing(
	porcelains []*RoleAttachmentCreateResponse,
) []*proto.RoleAttachmentCreateResponse {
	var items []*proto.RoleAttachmentCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRoleAttachmentCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleAttachmentCreateResponseToPorcelain(plumbings []*proto.RoleAttachmentCreateResponse) []*RoleAttachmentCreateResponse {
	var items []*RoleAttachmentCreateResponse
	for _, plumbing := range plumbings {
		items = append(items, convertRoleAttachmentCreateResponseToPorcelain(plumbing))
	}
	return items
}
func convertRoleAttachmentGetResponseToPorcelain(plumbing *proto.RoleAttachmentGetResponse) *RoleAttachmentGetResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &RoleAttachmentGetResponse{}
	porcelain.Meta = convertGetResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.RoleAttachment = convertRoleAttachmentToPorcelain(plumbing.RoleAttachment)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertRoleAttachmentGetResponseToPlumbing(porcelain *RoleAttachmentGetResponse) *proto.RoleAttachmentGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleAttachmentGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RoleAttachment = convertRoleAttachmentToPlumbing(porcelain.RoleAttachment)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedRoleAttachmentGetResponseToPlumbing(
	porcelains []*RoleAttachmentGetResponse,
) []*proto.RoleAttachmentGetResponse {
	var items []*proto.RoleAttachmentGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRoleAttachmentGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleAttachmentGetResponseToPorcelain(plumbings []*proto.RoleAttachmentGetResponse) []*RoleAttachmentGetResponse {
	var items []*RoleAttachmentGetResponse
	for _, plumbing := range plumbings {
		items = append(items, convertRoleAttachmentGetResponseToPorcelain(plumbing))
	}
	return items
}
func convertRoleAttachmentDeleteResponseToPorcelain(plumbing *proto.RoleAttachmentDeleteResponse) *RoleAttachmentDeleteResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &RoleAttachmentDeleteResponse{}
	porcelain.Meta = convertDeleteResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertRoleAttachmentDeleteResponseToPlumbing(porcelain *RoleAttachmentDeleteResponse) *proto.RoleAttachmentDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleAttachmentDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedRoleAttachmentDeleteResponseToPlumbing(
	porcelains []*RoleAttachmentDeleteResponse,
) []*proto.RoleAttachmentDeleteResponse {
	var items []*proto.RoleAttachmentDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRoleAttachmentDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleAttachmentDeleteResponseToPorcelain(plumbings []*proto.RoleAttachmentDeleteResponse) []*RoleAttachmentDeleteResponse {
	var items []*RoleAttachmentDeleteResponse
	for _, plumbing := range plumbings {
		items = append(items, convertRoleAttachmentDeleteResponseToPorcelain(plumbing))
	}
	return items
}
func convertRoleAttachmentToPorcelain(plumbing *proto.RoleAttachment) *RoleAttachment {
	if plumbing == nil {
		return nil
	}
	porcelain := &RoleAttachment{}
	porcelain.ID = (plumbing.Id)
	porcelain.CompositeRoleID = (plumbing.CompositeRoleId)
	porcelain.AttachedRoleID = (plumbing.AttachedRoleId)
	return porcelain
}

func convertRoleAttachmentToPlumbing(porcelain *RoleAttachment) *proto.RoleAttachment {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleAttachment{}
	plumbing.Id = (porcelain.ID)
	plumbing.CompositeRoleId = (porcelain.CompositeRoleID)
	plumbing.AttachedRoleId = (porcelain.AttachedRoleID)
	return plumbing
}
func convertRepeatedRoleAttachmentToPlumbing(
	porcelains []*RoleAttachment,
) []*proto.RoleAttachment {
	var items []*proto.RoleAttachment
	for _, porcelain := range porcelains {
		items = append(items, convertRoleAttachmentToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleAttachmentToPorcelain(plumbings []*proto.RoleAttachment) []*RoleAttachment {
	var items []*RoleAttachment
	for _, plumbing := range plumbings {
		items = append(items, convertRoleAttachmentToPorcelain(plumbing))
	}
	return items
}
func convertRoleGrantCreateResponseToPorcelain(plumbing *proto.RoleGrantCreateResponse) *RoleGrantCreateResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &RoleGrantCreateResponse{}
	porcelain.Meta = convertCreateResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.RoleGrant = convertRoleGrantToPorcelain(plumbing.RoleGrant)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertRoleGrantCreateResponseToPlumbing(porcelain *RoleGrantCreateResponse) *proto.RoleGrantCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleGrantCreateResponse{}
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RoleGrant = convertRoleGrantToPlumbing(porcelain.RoleGrant)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedRoleGrantCreateResponseToPlumbing(
	porcelains []*RoleGrantCreateResponse,
) []*proto.RoleGrantCreateResponse {
	var items []*proto.RoleGrantCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRoleGrantCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleGrantCreateResponseToPorcelain(plumbings []*proto.RoleGrantCreateResponse) []*RoleGrantCreateResponse {
	var items []*RoleGrantCreateResponse
	for _, plumbing := range plumbings {
		items = append(items, convertRoleGrantCreateResponseToPorcelain(plumbing))
	}
	return items
}
func convertRoleGrantGetResponseToPorcelain(plumbing *proto.RoleGrantGetResponse) *RoleGrantGetResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &RoleGrantGetResponse{}
	porcelain.Meta = convertGetResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.RoleGrant = convertRoleGrantToPorcelain(plumbing.RoleGrant)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertRoleGrantGetResponseToPlumbing(porcelain *RoleGrantGetResponse) *proto.RoleGrantGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleGrantGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RoleGrant = convertRoleGrantToPlumbing(porcelain.RoleGrant)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedRoleGrantGetResponseToPlumbing(
	porcelains []*RoleGrantGetResponse,
) []*proto.RoleGrantGetResponse {
	var items []*proto.RoleGrantGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRoleGrantGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleGrantGetResponseToPorcelain(plumbings []*proto.RoleGrantGetResponse) []*RoleGrantGetResponse {
	var items []*RoleGrantGetResponse
	for _, plumbing := range plumbings {
		items = append(items, convertRoleGrantGetResponseToPorcelain(plumbing))
	}
	return items
}
func convertRoleGrantDeleteResponseToPorcelain(plumbing *proto.RoleGrantDeleteResponse) *RoleGrantDeleteResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &RoleGrantDeleteResponse{}
	porcelain.Meta = convertDeleteResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertRoleGrantDeleteResponseToPlumbing(porcelain *RoleGrantDeleteResponse) *proto.RoleGrantDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleGrantDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedRoleGrantDeleteResponseToPlumbing(
	porcelains []*RoleGrantDeleteResponse,
) []*proto.RoleGrantDeleteResponse {
	var items []*proto.RoleGrantDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRoleGrantDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleGrantDeleteResponseToPorcelain(plumbings []*proto.RoleGrantDeleteResponse) []*RoleGrantDeleteResponse {
	var items []*RoleGrantDeleteResponse
	for _, plumbing := range plumbings {
		items = append(items, convertRoleGrantDeleteResponseToPorcelain(plumbing))
	}
	return items
}
func convertRoleGrantToPorcelain(plumbing *proto.RoleGrant) *RoleGrant {
	if plumbing == nil {
		return nil
	}
	porcelain := &RoleGrant{}
	porcelain.ID = (plumbing.Id)
	porcelain.ResourceID = (plumbing.ResourceId)
	porcelain.RoleID = (plumbing.RoleId)
	return porcelain
}

func convertRoleGrantToPlumbing(porcelain *RoleGrant) *proto.RoleGrant {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleGrant{}
	plumbing.Id = (porcelain.ID)
	plumbing.ResourceId = (porcelain.ResourceID)
	plumbing.RoleId = (porcelain.RoleID)
	return plumbing
}
func convertRepeatedRoleGrantToPlumbing(
	porcelains []*RoleGrant,
) []*proto.RoleGrant {
	var items []*proto.RoleGrant
	for _, porcelain := range porcelains {
		items = append(items, convertRoleGrantToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleGrantToPorcelain(plumbings []*proto.RoleGrant) []*RoleGrant {
	var items []*RoleGrant
	for _, plumbing := range plumbings {
		items = append(items, convertRoleGrantToPorcelain(plumbing))
	}
	return items
}
func convertRoleCreateResponseToPorcelain(plumbing *proto.RoleCreateResponse) *RoleCreateResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &RoleCreateResponse{}
	porcelain.Meta = convertCreateResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.Role = convertRoleToPorcelain(plumbing.Role)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertRoleCreateResponseToPlumbing(porcelain *RoleCreateResponse) *proto.RoleCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleCreateResponse{}
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.Role = convertRoleToPlumbing(porcelain.Role)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedRoleCreateResponseToPlumbing(
	porcelains []*RoleCreateResponse,
) []*proto.RoleCreateResponse {
	var items []*proto.RoleCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRoleCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleCreateResponseToPorcelain(plumbings []*proto.RoleCreateResponse) []*RoleCreateResponse {
	var items []*RoleCreateResponse
	for _, plumbing := range plumbings {
		items = append(items, convertRoleCreateResponseToPorcelain(plumbing))
	}
	return items
}
func convertRoleGetResponseToPorcelain(plumbing *proto.RoleGetResponse) *RoleGetResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &RoleGetResponse{}
	porcelain.Meta = convertGetResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.Role = convertRoleToPorcelain(plumbing.Role)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertRoleGetResponseToPlumbing(porcelain *RoleGetResponse) *proto.RoleGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.Role = convertRoleToPlumbing(porcelain.Role)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedRoleGetResponseToPlumbing(
	porcelains []*RoleGetResponse,
) []*proto.RoleGetResponse {
	var items []*proto.RoleGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRoleGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleGetResponseToPorcelain(plumbings []*proto.RoleGetResponse) []*RoleGetResponse {
	var items []*RoleGetResponse
	for _, plumbing := range plumbings {
		items = append(items, convertRoleGetResponseToPorcelain(plumbing))
	}
	return items
}
func convertRoleUpdateResponseToPorcelain(plumbing *proto.RoleUpdateResponse) *RoleUpdateResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &RoleUpdateResponse{}
	porcelain.Meta = convertUpdateResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.Role = convertRoleToPorcelain(plumbing.Role)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertRoleUpdateResponseToPlumbing(porcelain *RoleUpdateResponse) *proto.RoleUpdateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleUpdateResponse{}
	plumbing.Meta = convertUpdateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.Role = convertRoleToPlumbing(porcelain.Role)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedRoleUpdateResponseToPlumbing(
	porcelains []*RoleUpdateResponse,
) []*proto.RoleUpdateResponse {
	var items []*proto.RoleUpdateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRoleUpdateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleUpdateResponseToPorcelain(plumbings []*proto.RoleUpdateResponse) []*RoleUpdateResponse {
	var items []*RoleUpdateResponse
	for _, plumbing := range plumbings {
		items = append(items, convertRoleUpdateResponseToPorcelain(plumbing))
	}
	return items
}
func convertRoleDeleteResponseToPorcelain(plumbing *proto.RoleDeleteResponse) *RoleDeleteResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &RoleDeleteResponse{}
	porcelain.Meta = convertDeleteResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertRoleDeleteResponseToPlumbing(porcelain *RoleDeleteResponse) *proto.RoleDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedRoleDeleteResponseToPlumbing(
	porcelains []*RoleDeleteResponse,
) []*proto.RoleDeleteResponse {
	var items []*proto.RoleDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRoleDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleDeleteResponseToPorcelain(plumbings []*proto.RoleDeleteResponse) []*RoleDeleteResponse {
	var items []*RoleDeleteResponse
	for _, plumbing := range plumbings {
		items = append(items, convertRoleDeleteResponseToPorcelain(plumbing))
	}
	return items
}
func convertRoleToPorcelain(plumbing *proto.Role) *Role {
	if plumbing == nil {
		return nil
	}
	porcelain := &Role{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Composite = (plumbing.Composite)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	return porcelain
}

func convertRoleToPlumbing(porcelain *Role) *proto.Role {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Role{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Composite = (porcelain.Composite)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedRoleToPlumbing(
	porcelains []*Role,
) []*proto.Role {
	var items []*proto.Role
	for _, porcelain := range porcelains {
		items = append(items, convertRoleToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleToPorcelain(plumbings []*proto.Role) []*Role {
	var items []*Role
	for _, plumbing := range plumbings {
		items = append(items, convertRoleToPorcelain(plumbing))
	}
	return items
}
func convertSecretStoreToPlumbing(porcelain SecretStore) *proto.SecretStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SecretStore{}

	switch v := porcelain.(type) {
	case *AWSStore:
		plumbing.SecretStore = &proto.SecretStore_Aws{Aws: convertAWSStoreToPlumbing(v)}
	case *VaultTLSStore:
		plumbing.SecretStore = &proto.SecretStore_VaultTls{VaultTls: convertVaultTLSStoreToPlumbing(v)}
	case *VaultTokenStore:
		plumbing.SecretStore = &proto.SecretStore_VaultToken{VaultToken: convertVaultTokenStoreToPlumbing(v)}
	}
	return plumbing
}

func convertSecretStoreToPorcelain(plumbing *proto.SecretStore) SecretStore {
	if plumbing.GetAws() != nil {
		return convertAWSStoreToPorcelain(plumbing.GetAws())
	}
	if plumbing.GetVaultTls() != nil {
		return convertVaultTLSStoreToPorcelain(plumbing.GetVaultTls())
	}
	if plumbing.GetVaultToken() != nil {
		return convertVaultTokenStoreToPorcelain(plumbing.GetVaultToken())
	}
	return nil
}
func convertRepeatedSecretStoreToPlumbing(
	porcelains []SecretStore,
) []*proto.SecretStore {
	var items []*proto.SecretStore
	for _, porcelain := range porcelains {
		items = append(items, convertSecretStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSecretStoreToPorcelain(plumbings []*proto.SecretStore) []SecretStore {
	var items []SecretStore
	for _, plumbing := range plumbings {
		items = append(items, convertSecretStoreToPorcelain(plumbing))
	}
	return items
}
func convertAWSStoreToPorcelain(plumbing *proto.AWSStore) *AWSStore {
	if plumbing == nil {
		return nil
	}
	porcelain := &AWSStore{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.Region = (plumbing.Region)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	return porcelain
}

func convertAWSStoreToPlumbing(porcelain *AWSStore) *proto.AWSStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AWSStore{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Region = (porcelain.Region)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedAWSStoreToPlumbing(
	porcelains []*AWSStore,
) []*proto.AWSStore {
	var items []*proto.AWSStore
	for _, porcelain := range porcelains {
		items = append(items, convertAWSStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAWSStoreToPorcelain(plumbings []*proto.AWSStore) []*AWSStore {
	var items []*AWSStore
	for _, plumbing := range plumbings {
		items = append(items, convertAWSStoreToPorcelain(plumbing))
	}
	return items
}
func convertVaultTLSStoreToPorcelain(plumbing *proto.VaultTLSStore) *VaultTLSStore {
	if plumbing == nil {
		return nil
	}
	porcelain := &VaultTLSStore{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.ServerAddress = (plumbing.ServerAddress)
	porcelain.CACertPath = (plumbing.CACertPath)
	porcelain.ClientCertPath = (plumbing.ClientCertPath)
	porcelain.ClientKeyPath = (plumbing.ClientKeyPath)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	return porcelain
}

func convertVaultTLSStoreToPlumbing(porcelain *VaultTLSStore) *proto.VaultTLSStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.VaultTLSStore{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.ServerAddress = (porcelain.ServerAddress)
	plumbing.CACertPath = (porcelain.CACertPath)
	plumbing.ClientCertPath = (porcelain.ClientCertPath)
	plumbing.ClientKeyPath = (porcelain.ClientKeyPath)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedVaultTLSStoreToPlumbing(
	porcelains []*VaultTLSStore,
) []*proto.VaultTLSStore {
	var items []*proto.VaultTLSStore
	for _, porcelain := range porcelains {
		items = append(items, convertVaultTLSStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedVaultTLSStoreToPorcelain(plumbings []*proto.VaultTLSStore) []*VaultTLSStore {
	var items []*VaultTLSStore
	for _, plumbing := range plumbings {
		items = append(items, convertVaultTLSStoreToPorcelain(plumbing))
	}
	return items
}
func convertVaultTokenStoreToPorcelain(plumbing *proto.VaultTokenStore) *VaultTokenStore {
	if plumbing == nil {
		return nil
	}
	porcelain := &VaultTokenStore{}
	porcelain.ID = (plumbing.Id)
	porcelain.Name = (plumbing.Name)
	porcelain.ServerAddress = (plumbing.ServerAddress)
	porcelain.Tags = convertTagsToPorcelain(plumbing.Tags)
	return porcelain
}

func convertVaultTokenStoreToPlumbing(porcelain *VaultTokenStore) *proto.VaultTokenStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.VaultTokenStore{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.ServerAddress = (porcelain.ServerAddress)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedVaultTokenStoreToPlumbing(
	porcelains []*VaultTokenStore,
) []*proto.VaultTokenStore {
	var items []*proto.VaultTokenStore
	for _, porcelain := range porcelains {
		items = append(items, convertVaultTokenStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedVaultTokenStoreToPorcelain(plumbings []*proto.VaultTokenStore) []*VaultTokenStore {
	var items []*VaultTokenStore
	for _, plumbing := range plumbings {
		items = append(items, convertVaultTokenStoreToPorcelain(plumbing))
	}
	return items
}
func convertSecretStoreCreateResponseToPorcelain(plumbing *proto.SecretStoreCreateResponse) *SecretStoreCreateResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &SecretStoreCreateResponse{}
	porcelain.Meta = convertCreateResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.SecretStore = convertSecretStoreToPorcelain(plumbing.SecretStore)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertSecretStoreCreateResponseToPlumbing(porcelain *SecretStoreCreateResponse) *proto.SecretStoreCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SecretStoreCreateResponse{}
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.SecretStore = convertSecretStoreToPlumbing(porcelain.SecretStore)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedSecretStoreCreateResponseToPlumbing(
	porcelains []*SecretStoreCreateResponse,
) []*proto.SecretStoreCreateResponse {
	var items []*proto.SecretStoreCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertSecretStoreCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSecretStoreCreateResponseToPorcelain(plumbings []*proto.SecretStoreCreateResponse) []*SecretStoreCreateResponse {
	var items []*SecretStoreCreateResponse
	for _, plumbing := range plumbings {
		items = append(items, convertSecretStoreCreateResponseToPorcelain(plumbing))
	}
	return items
}
func convertSecretStoreGetResponseToPorcelain(plumbing *proto.SecretStoreGetResponse) *SecretStoreGetResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &SecretStoreGetResponse{}
	porcelain.Meta = convertGetResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.SecretStore = convertSecretStoreToPorcelain(plumbing.SecretStore)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertSecretStoreGetResponseToPlumbing(porcelain *SecretStoreGetResponse) *proto.SecretStoreGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SecretStoreGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.SecretStore = convertSecretStoreToPlumbing(porcelain.SecretStore)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedSecretStoreGetResponseToPlumbing(
	porcelains []*SecretStoreGetResponse,
) []*proto.SecretStoreGetResponse {
	var items []*proto.SecretStoreGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertSecretStoreGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSecretStoreGetResponseToPorcelain(plumbings []*proto.SecretStoreGetResponse) []*SecretStoreGetResponse {
	var items []*SecretStoreGetResponse
	for _, plumbing := range plumbings {
		items = append(items, convertSecretStoreGetResponseToPorcelain(plumbing))
	}
	return items
}
func convertSecretStoreUpdateResponseToPorcelain(plumbing *proto.SecretStoreUpdateResponse) *SecretStoreUpdateResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &SecretStoreUpdateResponse{}
	porcelain.Meta = convertUpdateResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.SecretStore = convertSecretStoreToPorcelain(plumbing.SecretStore)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertSecretStoreUpdateResponseToPlumbing(porcelain *SecretStoreUpdateResponse) *proto.SecretStoreUpdateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SecretStoreUpdateResponse{}
	plumbing.Meta = convertUpdateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.SecretStore = convertSecretStoreToPlumbing(porcelain.SecretStore)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedSecretStoreUpdateResponseToPlumbing(
	porcelains []*SecretStoreUpdateResponse,
) []*proto.SecretStoreUpdateResponse {
	var items []*proto.SecretStoreUpdateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertSecretStoreUpdateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSecretStoreUpdateResponseToPorcelain(plumbings []*proto.SecretStoreUpdateResponse) []*SecretStoreUpdateResponse {
	var items []*SecretStoreUpdateResponse
	for _, plumbing := range plumbings {
		items = append(items, convertSecretStoreUpdateResponseToPorcelain(plumbing))
	}
	return items
}
func convertSecretStoreDeleteResponseToPorcelain(plumbing *proto.SecretStoreDeleteResponse) *SecretStoreDeleteResponse {
	if plumbing == nil {
		return nil
	}
	porcelain := &SecretStoreDeleteResponse{}
	porcelain.Meta = convertDeleteResponseMetadataToPorcelain(plumbing.Meta)
	porcelain.RateLimit = convertRateLimitMetadataToPorcelain(plumbing.RateLimit)
	return porcelain
}

func convertSecretStoreDeleteResponseToPlumbing(porcelain *SecretStoreDeleteResponse) *proto.SecretStoreDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SecretStoreDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedSecretStoreDeleteResponseToPlumbing(
	porcelains []*SecretStoreDeleteResponse,
) []*proto.SecretStoreDeleteResponse {
	var items []*proto.SecretStoreDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertSecretStoreDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSecretStoreDeleteResponseToPorcelain(plumbings []*proto.SecretStoreDeleteResponse) []*SecretStoreDeleteResponse {
	var items []*SecretStoreDeleteResponse
	for _, plumbing := range plumbings {
		items = append(items, convertSecretStoreDeleteResponseToPorcelain(plumbing))
	}
	return items
}

type rpcError struct {
	wrapped error
	code    int
}

func (e *rpcError) Error() string {
	return e.wrapped.Error()
}

func (e *rpcError) Unwrap() error {
	return e.wrapped
}

func (e *rpcError) Code() int {
	return e.code
}

func convertErrorToPorcelain(err error) error {
	if s, ok := status.FromError(err); ok {
		switch s.Code() {
		case codes.Canceled:
			return &ContextCanceledError{Wrapped: err}
		case codes.DeadlineExceeded:
			return &DeadlineExceededError{Wrapped: err}
		case codes.AlreadyExists:
			return &AlreadyExistsError{Message: s.Message()}
		case codes.NotFound:
			return &NotFoundError{Message: s.Message()}
		case codes.InvalidArgument:
			return &BadRequestError{Message: s.Message()}
		case codes.Unauthenticated:
			return &AuthenticationError{Message: s.Message()}
		case codes.PermissionDenied:
			return &PermissionError{Message: s.Message()}
		case codes.Internal:
			return &InternalError{Message: s.Message()}
		case codes.ResourceExhausted:
			for _, d := range s.Details() {
				if d, ok := d.(*proto.RateLimitMetadata); ok {
					return &RateLimitError{Message: s.Message(), RateLimit: convertRateLimitMetadataToPorcelain(d)}
				}
			}
		}
		return &rpcError{wrapped: err, code: int(s.Code())}
	}
	return &UnknownError{Wrapped: err}
}

type accountAttachmentIteratorImplFetchFunc func() (
	[]*AccountAttachment,
	bool, error)
type accountAttachmentIteratorImpl struct {
	buffer      []*AccountAttachment
	index       int
	hasNextPage bool
	err         error
	fetch       accountAttachmentIteratorImplFetchFunc
}

func newAccountAttachmentIteratorImpl(f accountAttachmentIteratorImplFetchFunc) *accountAttachmentIteratorImpl {
	return &accountAttachmentIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (a *accountAttachmentIteratorImpl) Next() bool {
	if a.index < len(a.buffer)-1 {
		a.index++
		return true
	}

	// reached end of buffer
	if !a.hasNextPage {
		return false
	}

	a.index = 0
	a.buffer, a.hasNextPage, a.err = a.fetch()
	return len(a.buffer) > 0
}

func (a *accountAttachmentIteratorImpl) Value() *AccountAttachment {
	if a.index >= len(a.buffer) {
		return nil
	}
	return a.buffer[a.index]
}

func (a *accountAttachmentIteratorImpl) Err() error {
	return a.err
}

type accountGrantIteratorImplFetchFunc func() (
	[]*AccountGrant,
	bool, error)
type accountGrantIteratorImpl struct {
	buffer      []*AccountGrant
	index       int
	hasNextPage bool
	err         error
	fetch       accountGrantIteratorImplFetchFunc
}

func newAccountGrantIteratorImpl(f accountGrantIteratorImplFetchFunc) *accountGrantIteratorImpl {
	return &accountGrantIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (a *accountGrantIteratorImpl) Next() bool {
	if a.index < len(a.buffer)-1 {
		a.index++
		return true
	}

	// reached end of buffer
	if !a.hasNextPage {
		return false
	}

	a.index = 0
	a.buffer, a.hasNextPage, a.err = a.fetch()
	return len(a.buffer) > 0
}

func (a *accountGrantIteratorImpl) Value() *AccountGrant {
	if a.index >= len(a.buffer) {
		return nil
	}
	return a.buffer[a.index]
}

func (a *accountGrantIteratorImpl) Err() error {
	return a.err
}

type accountIteratorImplFetchFunc func() (
	[]Account,
	bool, error)
type accountIteratorImpl struct {
	buffer      []Account
	index       int
	hasNextPage bool
	err         error
	fetch       accountIteratorImplFetchFunc
}

func newAccountIteratorImpl(f accountIteratorImplFetchFunc) *accountIteratorImpl {
	return &accountIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (a *accountIteratorImpl) Next() bool {
	if a.index < len(a.buffer)-1 {
		a.index++
		return true
	}

	// reached end of buffer
	if !a.hasNextPage {
		return false
	}

	a.index = 0
	a.buffer, a.hasNextPage, a.err = a.fetch()
	return len(a.buffer) > 0
}

func (a *accountIteratorImpl) Value() Account {
	if a.index >= len(a.buffer) {
		return nil
	}
	return a.buffer[a.index]
}

func (a *accountIteratorImpl) Err() error {
	return a.err
}

type nodeIteratorImplFetchFunc func() (
	[]Node,
	bool, error)
type nodeIteratorImpl struct {
	buffer      []Node
	index       int
	hasNextPage bool
	err         error
	fetch       nodeIteratorImplFetchFunc
}

func newNodeIteratorImpl(f nodeIteratorImplFetchFunc) *nodeIteratorImpl {
	return &nodeIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (n *nodeIteratorImpl) Next() bool {
	if n.index < len(n.buffer)-1 {
		n.index++
		return true
	}

	// reached end of buffer
	if !n.hasNextPage {
		return false
	}

	n.index = 0
	n.buffer, n.hasNextPage, n.err = n.fetch()
	return len(n.buffer) > 0
}

func (n *nodeIteratorImpl) Value() Node {
	if n.index >= len(n.buffer) {
		return nil
	}
	return n.buffer[n.index]
}

func (n *nodeIteratorImpl) Err() error {
	return n.err
}

type tagIteratorImplFetchFunc func() (
	[]*Tag,
	bool, error)
type tagIteratorImpl struct {
	buffer      []*Tag
	index       int
	hasNextPage bool
	err         error
	fetch       tagIteratorImplFetchFunc
}

func newTagIteratorImpl(f tagIteratorImplFetchFunc) *tagIteratorImpl {
	return &tagIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (t *tagIteratorImpl) Next() bool {
	if t.index < len(t.buffer)-1 {
		t.index++
		return true
	}

	// reached end of buffer
	if !t.hasNextPage {
		return false
	}

	t.index = 0
	t.buffer, t.hasNextPage, t.err = t.fetch()
	return len(t.buffer) > 0
}

func (t *tagIteratorImpl) Value() *Tag {
	if t.index >= len(t.buffer) {
		return nil
	}
	return t.buffer[t.index]
}

func (t *tagIteratorImpl) Err() error {
	return t.err
}

type resourceIteratorImplFetchFunc func() (
	[]Resource,
	bool, error)
type resourceIteratorImpl struct {
	buffer      []Resource
	index       int
	hasNextPage bool
	err         error
	fetch       resourceIteratorImplFetchFunc
}

func newResourceIteratorImpl(f resourceIteratorImplFetchFunc) *resourceIteratorImpl {
	return &resourceIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (r *resourceIteratorImpl) Next() bool {
	if r.index < len(r.buffer)-1 {
		r.index++
		return true
	}

	// reached end of buffer
	if !r.hasNextPage {
		return false
	}

	r.index = 0
	r.buffer, r.hasNextPage, r.err = r.fetch()
	return len(r.buffer) > 0
}

func (r *resourceIteratorImpl) Value() Resource {
	if r.index >= len(r.buffer) {
		return nil
	}
	return r.buffer[r.index]
}

func (r *resourceIteratorImpl) Err() error {
	return r.err
}

type roleAttachmentIteratorImplFetchFunc func() (
	[]*RoleAttachment,
	bool, error)
type roleAttachmentIteratorImpl struct {
	buffer      []*RoleAttachment
	index       int
	hasNextPage bool
	err         error
	fetch       roleAttachmentIteratorImplFetchFunc
}

func newRoleAttachmentIteratorImpl(f roleAttachmentIteratorImplFetchFunc) *roleAttachmentIteratorImpl {
	return &roleAttachmentIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (r *roleAttachmentIteratorImpl) Next() bool {
	if r.index < len(r.buffer)-1 {
		r.index++
		return true
	}

	// reached end of buffer
	if !r.hasNextPage {
		return false
	}

	r.index = 0
	r.buffer, r.hasNextPage, r.err = r.fetch()
	return len(r.buffer) > 0
}

func (r *roleAttachmentIteratorImpl) Value() *RoleAttachment {
	if r.index >= len(r.buffer) {
		return nil
	}
	return r.buffer[r.index]
}

func (r *roleAttachmentIteratorImpl) Err() error {
	return r.err
}

type roleGrantIteratorImplFetchFunc func() (
	[]*RoleGrant,
	bool, error)
type roleGrantIteratorImpl struct {
	buffer      []*RoleGrant
	index       int
	hasNextPage bool
	err         error
	fetch       roleGrantIteratorImplFetchFunc
}

func newRoleGrantIteratorImpl(f roleGrantIteratorImplFetchFunc) *roleGrantIteratorImpl {
	return &roleGrantIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (r *roleGrantIteratorImpl) Next() bool {
	if r.index < len(r.buffer)-1 {
		r.index++
		return true
	}

	// reached end of buffer
	if !r.hasNextPage {
		return false
	}

	r.index = 0
	r.buffer, r.hasNextPage, r.err = r.fetch()
	return len(r.buffer) > 0
}

func (r *roleGrantIteratorImpl) Value() *RoleGrant {
	if r.index >= len(r.buffer) {
		return nil
	}
	return r.buffer[r.index]
}

func (r *roleGrantIteratorImpl) Err() error {
	return r.err
}

type roleIteratorImplFetchFunc func() (
	[]*Role,
	bool, error)
type roleIteratorImpl struct {
	buffer      []*Role
	index       int
	hasNextPage bool
	err         error
	fetch       roleIteratorImplFetchFunc
}

func newRoleIteratorImpl(f roleIteratorImplFetchFunc) *roleIteratorImpl {
	return &roleIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (r *roleIteratorImpl) Next() bool {
	if r.index < len(r.buffer)-1 {
		r.index++
		return true
	}

	// reached end of buffer
	if !r.hasNextPage {
		return false
	}

	r.index = 0
	r.buffer, r.hasNextPage, r.err = r.fetch()
	return len(r.buffer) > 0
}

func (r *roleIteratorImpl) Value() *Role {
	if r.index >= len(r.buffer) {
		return nil
	}
	return r.buffer[r.index]
}

func (r *roleIteratorImpl) Err() error {
	return r.err
}

type secretStoreIteratorImplFetchFunc func() (
	[]SecretStore,
	bool, error)
type secretStoreIteratorImpl struct {
	buffer      []SecretStore
	index       int
	hasNextPage bool
	err         error
	fetch       secretStoreIteratorImplFetchFunc
}

func newSecretStoreIteratorImpl(f secretStoreIteratorImplFetchFunc) *secretStoreIteratorImpl {
	return &secretStoreIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (s *secretStoreIteratorImpl) Next() bool {
	if s.index < len(s.buffer)-1 {
		s.index++
		return true
	}

	// reached end of buffer
	if !s.hasNextPage {
		return false
	}

	s.index = 0
	s.buffer, s.hasNextPage, s.err = s.fetch()
	return len(s.buffer) > 0
}

func (s *secretStoreIteratorImpl) Value() SecretStore {
	if s.index >= len(s.buffer) {
		return nil
	}
	return s.buffer[s.index]
}

func (s *secretStoreIteratorImpl) Err() error {
	return s.err
}
