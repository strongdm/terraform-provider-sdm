// Code generated by protogen. DO NOT EDIT.

package sdm

import (
	"context"
	"errors"
	"fmt"
	"net/url"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	sdm "github.com/strongdm/terraform-provider-sdm/sdm/internal/sdk"
)

func resourceResource() *schema.Resource {
	return &schema.Resource{
		CreateContext: wrapCrudOperation(resourceResourceCreate),
		ReadContext:   wrapCrudOperation(resourceResourceRead),
		UpdateContext: wrapCrudOperation(resourceResourceUpdate),
		DeleteContext: wrapCrudOperation(resourceResourceDelete),
		Importer: &schema.ResourceImporter{
			State: schema.ImportStatePassthrough,
		},
		Schema: map[string]*schema.Schema{
			"aerospike": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "Aerospike is currently unstable, and its API may change, or it may be removed, without a major version bump.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"aks": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"allow_resource_role_bypass": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The CA to authenticate TLS connections with.",
						},
						"client_certificate": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The certificate to authenticate TLS connections with.",
						},
						"client_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The key to authenticate TLS connections with.",
						},
						"discovery_enabled": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, configures discovery of a cluster to be run from a node.",
						},
						"discovery_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"identity_alias_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to use for healthchecks, when clients otherwise connect with their own identity alias username.",
						},
						"identity_set_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The ID of the identity set to use for identity connections.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"aks_basic_auth": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "AKSBasicAuth is currently unstable, and its API may change, or it may be removed, without a major version bump.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"aks_service_account": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"allow_resource_role_bypass": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"discovery_enabled": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, configures discovery of a cluster to be run from a node.",
						},
						"discovery_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"identity_alias_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to use for healthchecks, when clients otherwise connect with their own identity alias username.",
						},
						"identity_set_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The ID of the identity set to use for identity connections.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"token": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The API token to authenticate with.",
						},
					},
				},
			},
			"aks_service_account_user_impersonation": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"token": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The API token to authenticate with.",
						},
					},
				},
			},
			"aks_user_impersonation": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The CA to authenticate TLS connections with.",
						},
						"client_certificate": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The certificate to authenticate TLS connections with.",
						},
						"client_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The key to authenticate TLS connections with.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"amazon_eks": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The Access Key ID to use to authenticate.",
						},
						"allow_resource_role_bypass": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The CA to authenticate TLS connections with.",
						},
						"cluster_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The name of the cluster to connect to.",
						},
						"discovery_enabled": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, configures discovery of a cluster to be run from a node.",
						},
						"discovery_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The endpoint to dial.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"identity_alias_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to use for healthchecks, when clients otherwise connect with their own identity alias username.",
						},
						"identity_set_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The ID of the identity set to use for identity connections.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The AWS region to connect to e.g. us-east-1.",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The role to assume after logging in.",
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The Secret Access Key to use to authenticate.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"amazon_eks_instance_profile": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"allow_resource_role_bypass": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The CA to authenticate TLS connections with.",
						},
						"cluster_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The name of the cluster to connect to.",
						},
						"discovery_enabled": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, configures discovery of a cluster to be run from a node.",
						},
						"discovery_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The endpoint to dial.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"identity_alias_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to use for healthchecks, when clients otherwise connect with their own identity alias username.",
						},
						"identity_set_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The ID of the identity set to use for identity connections.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The AWS region to connect to e.g. us-east-1.",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The role to assume after logging in.",
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"amazon_eks_instance_profile_user_impersonation": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The CA to authenticate TLS connections with.",
						},
						"cluster_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The name of the cluster to connect to.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The endpoint to dial.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The AWS region to connect to e.g. us-east-1.",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The role to assume after logging in.",
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"amazon_eks_user_impersonation": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The Access Key ID to use to authenticate.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The CA to authenticate TLS connections with.",
						},
						"cluster_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The name of the cluster to connect to.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The endpoint to dial.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The AWS region to connect to e.g. us-east-1.",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The role to assume after logging in.",
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The Secret Access Key to use to authenticate.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"amazon_es": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The Access Key ID to use to authenticate.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The endpoint to dial e.g. search-?.region.es.amazonaws.com\"",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The AWS region to connect to e.g. us-east-1.",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The role to assume after logging in.",
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The Secret Access Key to use to authenticate.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"amazon_esiam": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The endpoint to dial e.g. search-?.region.es.amazonaws.com\"",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The AWS region to connect to.",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The role to assume after logging in.",
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Use TLS to connect to the OpenSearch server",
						},
					},
				},
			},
			"amazonmq_amqp_091": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, TLS must be used to connect to this resource.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"athena": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The Access Key ID to use to authenticate.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"output": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The AWS S3 output location.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"region": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The AWS region to connect to e.g. us-east-1.",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The role to assume after logging in.",
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The Secret Access Key to use to authenticate.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"athena_iam": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"output": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The AWS S3 output location.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"region": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The AWS region to connect to e.g. us-east-1.",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The role to assume after logging in.",
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"aurora_mysql": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The database for healthchecks. Does not affect client requests",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"require_native_auth": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"use_azure_single_server_usernames": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, appends the hostname to the username when hitting a database.azure.com address",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"aurora_mysql_iam": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The database for healthchecks. Does not affect client requests",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The AWS region to connect to.",
						},
						"role_assumption_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"aurora_postgres": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"aurora_postgres_iam": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The AWS region to connect to.",
						},
						"role_assumption_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"aws": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The Access Key ID to use to authenticate.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The AWS region healthcheck requests should attempt to connect to.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The role to assume after logging in.",
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The Secret Access Key to use to authenticate.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"aws_console": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"enable_env_variables": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, prefer environment variables to authenticate connection even if EC2 roles are configured.",
						},
						"identity_alias_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to use for healthchecks, when clients otherwise connect with their own identity alias username.",
						},
						"identity_set_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The ID of the identity set to use for identity connections.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The AWS region to connect to.",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The role to assume after logging in.",
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"session_expiry": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The length of time in seconds AWS console sessions will live before needing to reauthenticate.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"aws_console_static_key_pair": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The Access Key ID to authenticate with.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"identity_alias_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to use for healthchecks, when clients otherwise connect with their own identity alias username.",
						},
						"identity_set_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The ID of the identity set to use for identity connections.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The AWS region to connect to.",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The role to assume after logging in.",
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The Secret Access Key to authenticate with.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"session_expiry": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The length of time in seconds AWS console sessions will live before needing to reauthenticate.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"aws_instance_profile": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"enable_env_variables": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, prefer environment variables to authenticate connection even if EC2 roles are configured.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The AWS region to connect to.",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The role to assume after logging in.",
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"azure": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"app_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The application ID to authenticate with.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tenant_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The tenant ID to authenticate to.",
						},
					},
				},
			},
			"azure_certificate": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"app_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The application ID to authenticate with.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"client_certificate": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The service Principal certificate file, both private and public key included.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tenant_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The tenant ID to authenticate to.",
						},
					},
				},
			},
			"azure_mysql": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The database for healthchecks. Does not affect client requests.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"require_native_auth": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"use_azure_single_server_usernames": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, appends the hostname to the username when hitting a database.azure.com address",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"azure_postgres": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with. For Azure Postgres, this also will include the hostname of the target server for Azure Single Server compatibility. For Flexible servers, use the normal Postgres type.",
						},
					},
				},
			},
			"azure_postgres_managed_identity": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"use_azure_single_server_usernames": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, appends the hostname to the username when hitting a database.azure.com address",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"big_query": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The endpoint to dial.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"private_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The JSON Private key to authenticate with.",
						},
						"project": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The project to connect to.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"cassandra": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, TLS must be used to connect to this resource.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"citus": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"click_house_http": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"url": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The URL to dial to initiate a connection from the egress node to this resource.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"click_house_my_sql": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The database for healthchecks. Does not affect client requests.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"require_native_auth": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"click_house_tcp": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, TLS must be used to connect to this resource.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"clustrix": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The database for healthchecks. Does not affect client requests.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"require_native_auth": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"use_azure_single_server_usernames": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, appends the hostname to the username when hitting a database.azure.com address",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"cockroach": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"couchbase_database": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"n_1_ql_port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The port number for N1QL queries. Default HTTP is 8093. Default HTTPS is 18093.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, TLS must be used to connect to this resource.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"couchbase_web_ui": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"url": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The base address of your website without the path.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"db_2_i": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, TLS must be used to connect to this resource.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"db_2_luw": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"document_db_host": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The authentication database to use.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"document_db_host_iam": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The AWS region to connect to.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"document_db_replica_set": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The authentication database to use.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"connect_to_replica": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Set to connect to a replica instead of the primary node.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Hostname must contain the hostname/port pairs of all instances in the replica set separated by commas.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"replica_set": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The name of the mongo replicaset.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"document_db_replica_set_iam": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "DocumentDBReplicaSetIAM is currently unstable, and its API may change, or it may be removed, without a major version bump.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"connect_to_replica": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Set to connect to a replica instead of the primary node.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Hostname must contain the hostname/port pairs of all instances in the replica set separated by commas.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The region of the document db cluster",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"druid": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"dynamo_db": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The Access Key ID to use to authenticate.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The endpoint to dial e.g. dynamodb.region.amazonaws.com",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The region to authenticate requests against e.g. us-east-1",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The role to assume after logging in.",
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The Secret Access Key to use to authenticate.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"dynamo_dbiam": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The endpoint to dial e.g. dynamodb.region.amazonaws.com",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The region to authenticate requests against e.g. us-east-1",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The role to assume after logging in.",
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"elastic": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, TLS must be used to connect to this resource.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"elasticache_redis": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, TLS must be used to connect to this resource.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"gcp": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"keyfile": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The service account keyfile to authenticate with.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"scopes": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Space separated scopes that this login should assume into when authenticating.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"gcp_console": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"identity_alias_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to use for healthchecks, when clients otherwise connect with their own identity alias username.",
						},
						"identity_set_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The ID of the identity set to use for identity connections.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"session_expiry": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The length of time in seconds console sessions will live before needing to reauthenticate.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"workforce_pool_id": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The ID of the Workforce Identity Pool in GCP to use for federated authentication.",
						},
						"workforce_provider_id": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The ID of the Workforce Identity Provider in GCP to use for federated authentication.",
						},
					},
				},
			},
			"gcpwif": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"identity_alias_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to use for healthchecks, when clients otherwise connect with their own identity alias username.",
						},
						"identity_set_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The ID of the identity set to use for identity connections.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"project_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "When specified, all project scoped requests will use this Project ID, overriding the project ID specified by clients",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"scopes": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Space separated scopes that this login should assume into when authenticating.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"session_expiry": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The length of time in seconds console sessions will live before needing to reauthenticate.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"workforce_pool_id": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The ID of the Workforce Identity Pool in GCP to use for federated authentication.",
						},
						"workforce_provider_id": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The ID of the Workforce Identity Provider in GCP to use for federated authentication.",
						},
					},
				},
			},
			"google_gke": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"allow_resource_role_bypass": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The CA to authenticate TLS connections with.",
						},
						"discovery_enabled": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, configures discovery of a cluster to be run from a node.",
						},
						"discovery_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The endpoint to dial.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"identity_alias_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to use for healthchecks, when clients otherwise connect with their own identity alias username.",
						},
						"identity_set_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The ID of the identity set to use for identity connections.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"service_account_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The service account key to authenticate with.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"google_gke_user_impersonation": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The CA to authenticate TLS connections with.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The endpoint to dial.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"service_account_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The service account key to authenticate with.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"greenplum": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"http_auth": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_header": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The content to set as the authorization header.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"default_path": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Automatically redirect to this path upon connecting.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"headers_blacklist": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Header names (e.g. Authorization), to omit from logs.",
						},
						"healthcheck_path": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "This path will be used to check the health of your site.",
						},
						"host_override": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The host header will be overwritten with this field if provided.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"url": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The base address of your website without the path.",
						},
					},
				},
			},
			"http_basic_auth": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"default_path": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Automatically redirect to this path upon connecting.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"headers_blacklist": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Header names (e.g. Authorization), to omit from logs.",
						},
						"healthcheck_path": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "This path will be used to check the health of your site.",
						},
						"host_override": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The host header will be overwritten with this field if provided.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"url": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The base address of your website without the path.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"http_no_auth": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"default_path": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Automatically redirect to this path upon connecting.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"headers_blacklist": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Header names (e.g. Authorization), to omit from logs.",
						},
						"healthcheck_path": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "This path will be used to check the health of your site.",
						},
						"host_override": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The host header will be overwritten with this field if provided.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"url": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The base address of your website without the path.",
						},
					},
				},
			},
			"kubernetes": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"allow_resource_role_bypass": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The CA to authenticate TLS connections with.",
						},
						"client_certificate": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The certificate to authenticate TLS connections with.",
						},
						"client_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The key to authenticate TLS connections with.",
						},
						"discovery_enabled": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, configures discovery of a cluster to be run from a node.",
						},
						"discovery_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"identity_alias_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to use for healthchecks, when clients otherwise connect with their own identity alias username.",
						},
						"identity_set_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The ID of the identity set to use for identity connections.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"kubernetes_basic_auth": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "KubernetesBasicAuth is currently unstable, and its API may change, or it may be removed, without a major version bump.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"kubernetes_pod_identity": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"allow_resource_role_bypass": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The CA to authenticate TLS connections with.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"identity_alias_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to use for healthchecks, when clients otherwise connect with their own identity alias username.",
						},
						"identity_set_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The ID of the identity set to use for identity connections.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"kubernetes_service_account": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"allow_resource_role_bypass": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"discovery_enabled": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, configures discovery of a cluster to be run from a node.",
						},
						"discovery_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"identity_alias_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to use for healthchecks, when clients otherwise connect with their own identity alias username.",
						},
						"identity_set_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The ID of the identity set to use for identity connections.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"token": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The API token to authenticate with.",
						},
					},
				},
			},
			"kubernetes_service_account_user_impersonation": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"token": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The API token to authenticate with.",
						},
					},
				},
			},
			"kubernetes_user_impersonation": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The CA to authenticate TLS connections with.",
						},
						"client_certificate": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The certificate to authenticate TLS connections with.",
						},
						"client_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The key to authenticate TLS connections with.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"maria": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The database for healthchecks. Does not affect client requests.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"require_native_auth": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"use_azure_single_server_usernames": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, appends the hostname to the username when hitting a database.azure.com address",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"memcached": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"memsql": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The database for healthchecks. Does not affect client requests.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"require_native_auth": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"use_azure_single_server_usernames": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, appends the hostname to the username when hitting a database.azure.com address",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"mongo_host": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The authentication database to use.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, TLS must be used to connect to this resource.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"mongo_legacy_host": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "MongoLegacyHost is currently unstable, and its API may change, or it may be removed, without a major version bump.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The authentication database to use.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, TLS must be used to connect to this resource.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"mongo_legacy_replicaset": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "MongoLegacyReplicaset is currently unstable, and its API may change, or it may be removed, without a major version bump.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The authentication database to use.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"connect_to_replica": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Set to connect to a replica instead of the primary node.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"replica_set": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The name of the mongo replicaset.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, TLS must be used to connect to this resource.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"mongo_replica_set": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The authentication database to use.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"connect_to_replica": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Set to connect to a replica instead of the primary node.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"replica_set": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The name of the mongo replicaset.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, TLS must be used to connect to this resource.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"mongo_sharded_cluster": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The authentication database to use.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, TLS must be used to connect to this resource.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"mtls_mysql": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "MTLSMysql is currently unstable, and its API may change, or it may be removed, without a major version bump.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The CA to authenticate TLS connections with.",
						},
						"client_certificate": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The certificate to authenticate TLS connections with.",
						},
						"client_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The key to authenticate TLS connections with.",
						},
						"database": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The database for healthchecks. Does not affect client requests.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"require_native_auth": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"server_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Server name for TLS verification (unverified by StrongDM if empty)",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"use_azure_single_server_usernames": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, appends the hostname to the username when hitting a database.azure.com address",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"mtls_postgres": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The CA to authenticate TLS connections with.",
						},
						"client_certificate": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The certificate to authenticate TLS connections with.",
						},
						"client_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The key to authenticate TLS connections with.",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"server_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Server name for TLS verification (unverified by StrongDM if empty)",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"mysql": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The database for healthchecks. Does not affect client requests.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"require_native_auth": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"use_azure_single_server_usernames": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, appends the hostname to the username when hitting a database.azure.com address",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"neptune": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"neptune_iam": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The Access Key ID to use to authenticate.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The AWS region to connect to.",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The role to assume after logging in.",
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The Secret Access Key to use to authenticate.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"oracle": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, TLS must be used to connect to this resource.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"oracle_nne": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "OracleNNE is currently unstable, and its API may change, or it may be removed, without a major version bump.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"postgres": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"presto": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, TLS must be used to connect to this resource.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"rabbitmq_amqp_091": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, TLS must be used to connect to this resource.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"raw_tcp": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"rdp": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"downgrade_nla_connections": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "When set, network level authentication will not be used. May resolve unexpected authentication errors to older servers. When set, healthchecks cannot detect if a provided username / password pair is correct.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"lock_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"rdp_cert": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"identity_alias_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to use for healthchecks, when clients otherwise connect with their own identity alias username.",
						},
						"identity_set_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The ID of the identity set to use for identity connections.",
						},
						"lock_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"rds_postgres_iam": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The AWS region to connect to.",
						},
						"role_assumption_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"redis": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, TLS must be used to connect to this resource.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"redis_cluster": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Hostname must contain the hostname/port pairs of all instances in the replica set separated by commas.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, TLS must be used to connect to this resource.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"redshift": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"redshift_iam": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"cluster_id": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Cluster Identified of Redshift cluster",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The AWS region to connect to.",
						},
						"role_assumption_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"redshift_serverless_iam": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The AWS region to connect to.",
						},
						"role_assumption_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"workgroup": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Workgroup name in the serverless Redshift",
						},
					},
				},
			},
			"single_store": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The database for healthchecks. Does not affect client requests.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"require_native_auth": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"use_azure_single_server_usernames": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If true, appends the hostname to the username when hitting a database.azure.com address",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"snowflake": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"schema": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The schema to provide on authentication.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"snowsight": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The StrongDM user email to use for healthchecks.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"saml_metadata": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The Metadata for your snowflake IDP integration",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"sql_server": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"allow_deprecated_encryption": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The database for healthchecks, and used for clients if Override Default Database is true.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"schema": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The Schema to use to direct initial requests.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"sql_server_azure_ad": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"allow_deprecated_encryption": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"client_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The Azure AD application (client) ID with which to authenticate.",
						},
						"database": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The database for healthchecks, and used for clients if Override Default Database is true.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"schema": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The Schema to use to direct initial requests.",
						},
						"secret": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The Azure AD client secret (application password) with which to authenticate.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tenant_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The Azure AD directory (tenant) ID with which to authenticate.",
						},
					},
				},
			},
			"sql_server_kerberos_ad": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"allow_deprecated_encryption": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The database for healthchecks, and used for clients if Override Default Database is true.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"keytab": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The keytab file in base64 format containing an entry with the principal name (username@realm) and key version number with which to authenticate.",
						},
						"krb_config": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The Kerberos 5 configuration file (krb5.conf) specifying the Active Directory server (KDC) for the configured realm.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"realm": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The Active Directory domain (realm) to which the configured username belongs.",
						},
						"schema": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The Schema to use to direct initial requests.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"server_spn": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The Service Principal Name of the Microsoft SQL Server instance in Active Directory.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"ssh": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"allow_deprecated_key_exchanges": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"key_type": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The key type to use e.g. rsa-2048 or ed25519",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_forwarding": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether port forwarding is allowed through this server.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"public_key": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The public key to append to a server's authorized keys. This will be generated after resource creation.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"ssh_cert": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"allow_deprecated_key_exchanges": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"identity_alias_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to use for healthchecks, when clients otherwise connect with their own identity alias username.",
						},
						"identity_set_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The ID of the identity set to use for identity connections.",
						},
						"key_type": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The key type to use e.g. rsa-2048 or ed25519",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_forwarding": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether port forwarding is allowed through this server.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"ssh_customer_key": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"allow_deprecated_key_exchanges": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"identity_alias_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to use for healthchecks, when clients otherwise connect with their own identity alias username.",
						},
						"identity_set_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The ID of the identity set to use for identity connections.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_forwarding": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether port forwarding is allowed through this server.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"private_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The private key used to authenticate with the server.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"ssh_password": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"allow_deprecated_key_exchanges": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_forwarding": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether port forwarding is allowed through this server.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"sybase": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"sybase_iq": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"teradata": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"trino": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "Trino is currently unstable, and its API may change, or it may be removed, without a major version bump.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
			"vertica": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The host to dial to initiate a connection from the egress node to this resource.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "The password to authenticate with.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The port to dial to initiate a connection from the egress node to this resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "The local port used by clients to connect to this resource.",
						},
						"proxy_cluster_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the proxy cluster for this resource, if any.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The username to authenticate with.",
						},
					},
				},
			},
		},
		Timeouts: &schema.ResourceTimeout{
			Default: schema.DefaultTimeout(60 * time.Second),
			Create:  schema.DefaultTimeout(60 * time.Second),
			Read:    schema.DefaultTimeout(60 * time.Second),
			Update:  schema.DefaultTimeout(60 * time.Second),
			Delete:  schema.DefaultTimeout(60 * time.Second),
		},
	}
}
func secretStoreValuesForResource(d *schema.ResourceData) (map[string]string, error) {
	if list := d.Get("aerospike").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("aks").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential certificate_authority was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["client_certificate"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential client_certificate was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["client_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential client_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"certificate_authority": convertStringToPlumbing(raw["certificate_authority"]),
			"client_certificate":    convertStringToPlumbing(raw["client_certificate"]),
			"client_key":            convertStringToPlumbing(raw["client_key"]),
		}, nil
	}
	if list := d.Get("aks_basic_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("aks_service_account").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["token"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential token was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"token": convertStringToPlumbing(raw["token"]),
		}, nil
	}
	if list := d.Get("aks_service_account_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["token"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential token was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"token": convertStringToPlumbing(raw["token"]),
		}, nil
	}
	if list := d.Get("aks_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential certificate_authority was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["client_certificate"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential client_certificate was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["client_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential client_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"certificate_authority": convertStringToPlumbing(raw["certificate_authority"]),
			"client_certificate":    convertStringToPlumbing(raw["client_certificate"]),
			"client_key":            convertStringToPlumbing(raw["client_key"]),
		}, nil
	}
	if list := d.Get("amazon_eks").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["access_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential access_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential certificate_authority was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_arn was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_external_id was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["secret_access_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential secret_access_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"access_key":            convertStringToPlumbing(raw["access_key"]),
			"certificate_authority": convertStringToPlumbing(raw["certificate_authority"]),
			"role_arn":              convertStringToPlumbing(raw["role_arn"]),
			"role_external_id":      convertStringToPlumbing(raw["role_external_id"]),
			"secret_access_key":     convertStringToPlumbing(raw["secret_access_key"]),
		}, nil
	}
	if list := d.Get("amazon_eks_instance_profile").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential certificate_authority was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_arn was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_external_id was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"certificate_authority": convertStringToPlumbing(raw["certificate_authority"]),
			"role_arn":              convertStringToPlumbing(raw["role_arn"]),
			"role_external_id":      convertStringToPlumbing(raw["role_external_id"]),
		}, nil
	}
	if list := d.Get("amazon_eks_instance_profile_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential certificate_authority was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_arn was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_external_id was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"certificate_authority": convertStringToPlumbing(raw["certificate_authority"]),
			"role_arn":              convertStringToPlumbing(raw["role_arn"]),
			"role_external_id":      convertStringToPlumbing(raw["role_external_id"]),
		}, nil
	}
	if list := d.Get("amazon_eks_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["access_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential access_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential certificate_authority was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_arn was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_external_id was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["secret_access_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential secret_access_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"access_key":            convertStringToPlumbing(raw["access_key"]),
			"certificate_authority": convertStringToPlumbing(raw["certificate_authority"]),
			"role_arn":              convertStringToPlumbing(raw["role_arn"]),
			"role_external_id":      convertStringToPlumbing(raw["role_external_id"]),
			"secret_access_key":     convertStringToPlumbing(raw["secret_access_key"]),
		}, nil
	}
	if list := d.Get("amazon_es").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["access_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential access_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_arn was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_external_id was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["secret_access_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential secret_access_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"access_key":        convertStringToPlumbing(raw["access_key"]),
			"role_arn":          convertStringToPlumbing(raw["role_arn"]),
			"role_external_id":  convertStringToPlumbing(raw["role_external_id"]),
			"secret_access_key": convertStringToPlumbing(raw["secret_access_key"]),
		}, nil
	}
	if list := d.Get("amazon_esiam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_arn was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_external_id was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"role_arn":         convertStringToPlumbing(raw["role_arn"]),
			"role_external_id": convertStringToPlumbing(raw["role_external_id"]),
		}, nil
	}
	if list := d.Get("amazonmq_amqp_091").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("athena").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["access_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential access_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_arn was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_external_id was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["secret_access_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential secret_access_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"access_key":        convertStringToPlumbing(raw["access_key"]),
			"role_arn":          convertStringToPlumbing(raw["role_arn"]),
			"role_external_id":  convertStringToPlumbing(raw["role_external_id"]),
			"secret_access_key": convertStringToPlumbing(raw["secret_access_key"]),
		}, nil
	}
	if list := d.Get("athena_iam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_arn was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_external_id was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"role_arn":         convertStringToPlumbing(raw["role_arn"]),
			"role_external_id": convertStringToPlumbing(raw["role_external_id"]),
		}, nil
	}
	if list := d.Get("aurora_mysql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("aurora_mysql_iam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("aurora_postgres").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("aurora_postgres_iam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("aws").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["access_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential access_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_arn was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_external_id was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["secret_access_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential secret_access_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"access_key":        convertStringToPlumbing(raw["access_key"]),
			"role_arn":          convertStringToPlumbing(raw["role_arn"]),
			"role_external_id":  convertStringToPlumbing(raw["role_external_id"]),
			"secret_access_key": convertStringToPlumbing(raw["secret_access_key"]),
		}, nil
	}
	if list := d.Get("aws_console").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_arn was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_external_id was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"role_arn":         convertStringToPlumbing(raw["role_arn"]),
			"role_external_id": convertStringToPlumbing(raw["role_external_id"]),
		}, nil
	}
	if list := d.Get("aws_console_static_key_pair").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["access_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential access_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_arn was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_external_id was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["secret_access_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential secret_access_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"access_key":        convertStringToPlumbing(raw["access_key"]),
			"role_arn":          convertStringToPlumbing(raw["role_arn"]),
			"role_external_id":  convertStringToPlumbing(raw["role_external_id"]),
			"secret_access_key": convertStringToPlumbing(raw["secret_access_key"]),
		}, nil
	}
	if list := d.Get("aws_instance_profile").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_arn was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_external_id was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"role_arn":         convertStringToPlumbing(raw["role_arn"]),
			"role_external_id": convertStringToPlumbing(raw["role_external_id"]),
		}, nil
	}
	if list := d.Get("azure").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["app_id"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential app_id was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["tenant_id"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential tenant_id was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"app_id":    convertStringToPlumbing(raw["app_id"]),
			"password":  convertStringToPlumbing(raw["password"]),
			"tenant_id": convertStringToPlumbing(raw["tenant_id"]),
		}, nil
	}
	if list := d.Get("azure_certificate").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["app_id"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential app_id was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["client_certificate"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential client_certificate was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["tenant_id"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential tenant_id was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"app_id":             convertStringToPlumbing(raw["app_id"]),
			"client_certificate": convertStringToPlumbing(raw["client_certificate"]),
			"tenant_id":          convertStringToPlumbing(raw["tenant_id"]),
		}, nil
	}
	if list := d.Get("azure_mysql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("azure_postgres").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("azure_postgres_managed_identity").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("big_query").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["private_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential private_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"private_key": convertStringToPlumbing(raw["private_key"]),
		}, nil
	}
	if list := d.Get("cassandra").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("citus").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("click_house_http").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("click_house_my_sql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("click_house_tcp").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("clustrix").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("cockroach").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("couchbase_database").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("couchbase_web_ui").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("db_2_i").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("db_2_luw").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("document_db_host").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("document_db_host_iam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
		}

		return map[string]string{}, nil
	}
	if list := d.Get("document_db_replica_set").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("document_db_replica_set_iam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
		}

		return map[string]string{}, nil
	}
	if list := d.Get("druid").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("dynamo_db").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["access_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential access_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_arn was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_external_id was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["secret_access_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential secret_access_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"access_key":        convertStringToPlumbing(raw["access_key"]),
			"role_arn":          convertStringToPlumbing(raw["role_arn"]),
			"role_external_id":  convertStringToPlumbing(raw["role_external_id"]),
			"secret_access_key": convertStringToPlumbing(raw["secret_access_key"]),
		}, nil
	}
	if list := d.Get("dynamo_dbiam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_arn was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_external_id was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"role_arn":         convertStringToPlumbing(raw["role_arn"]),
			"role_external_id": convertStringToPlumbing(raw["role_external_id"]),
		}, nil
	}
	if list := d.Get("elastic").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("elasticache_redis").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("gcp").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["keyfile"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential keyfile was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"keyfile": convertStringToPlumbing(raw["keyfile"]),
		}, nil
	}
	if list := d.Get("gcp_console").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
		}

		return map[string]string{}, nil
	}
	if list := d.Get("gcpwif").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
		}

		return map[string]string{}, nil
	}
	if list := d.Get("google_gke").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential certificate_authority was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["service_account_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential service_account_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"certificate_authority": convertStringToPlumbing(raw["certificate_authority"]),
			"service_account_key":   convertStringToPlumbing(raw["service_account_key"]),
		}, nil
	}
	if list := d.Get("google_gke_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential certificate_authority was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["service_account_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential service_account_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"certificate_authority": convertStringToPlumbing(raw["certificate_authority"]),
			"service_account_key":   convertStringToPlumbing(raw["service_account_key"]),
		}, nil
	}
	if list := d.Get("greenplum").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("http_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["auth_header"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential auth_header was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"auth_header": convertStringToPlumbing(raw["auth_header"]),
		}, nil
	}
	if list := d.Get("http_basic_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("http_no_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
		}

		return map[string]string{}, nil
	}
	if list := d.Get("kubernetes").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential certificate_authority was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["client_certificate"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential client_certificate was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["client_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential client_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"certificate_authority": convertStringToPlumbing(raw["certificate_authority"]),
			"client_certificate":    convertStringToPlumbing(raw["client_certificate"]),
			"client_key":            convertStringToPlumbing(raw["client_key"]),
		}, nil
	}
	if list := d.Get("kubernetes_basic_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("kubernetes_pod_identity").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential certificate_authority was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"certificate_authority": convertStringToPlumbing(raw["certificate_authority"]),
		}, nil
	}
	if list := d.Get("kubernetes_service_account").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["token"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential token was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"token": convertStringToPlumbing(raw["token"]),
		}, nil
	}
	if list := d.Get("kubernetes_service_account_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["token"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential token was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"token": convertStringToPlumbing(raw["token"]),
		}, nil
	}
	if list := d.Get("kubernetes_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential certificate_authority was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["client_certificate"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential client_certificate was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["client_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential client_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"certificate_authority": convertStringToPlumbing(raw["certificate_authority"]),
			"client_certificate":    convertStringToPlumbing(raw["client_certificate"]),
			"client_key":            convertStringToPlumbing(raw["client_key"]),
		}, nil
	}
	if list := d.Get("maria").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("memcached").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
		}

		return map[string]string{}, nil
	}
	if list := d.Get("memsql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("mongo_host").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("mongo_legacy_host").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("mongo_legacy_replicaset").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("mongo_replica_set").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("mongo_sharded_cluster").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("mtls_mysql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential certificate_authority was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["client_certificate"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential client_certificate was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["client_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential client_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"certificate_authority": convertStringToPlumbing(raw["certificate_authority"]),
			"client_certificate":    convertStringToPlumbing(raw["client_certificate"]),
			"client_key":            convertStringToPlumbing(raw["client_key"]),
			"password":              convertStringToPlumbing(raw["password"]),
			"username":              convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("mtls_postgres").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential certificate_authority was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["client_certificate"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential client_certificate was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["client_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential client_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"certificate_authority": convertStringToPlumbing(raw["certificate_authority"]),
			"client_certificate":    convertStringToPlumbing(raw["client_certificate"]),
			"client_key":            convertStringToPlumbing(raw["client_key"]),
			"password":              convertStringToPlumbing(raw["password"]),
			"username":              convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("mysql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("neptune").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
		}

		return map[string]string{}, nil
	}
	if list := d.Get("neptune_iam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["access_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential access_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_arn was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential role_external_id was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["secret_access_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential secret_access_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"access_key":        convertStringToPlumbing(raw["access_key"]),
			"role_arn":          convertStringToPlumbing(raw["role_arn"]),
			"role_external_id":  convertStringToPlumbing(raw["role_external_id"]),
			"secret_access_key": convertStringToPlumbing(raw["secret_access_key"]),
		}, nil
	}
	if list := d.Get("oracle").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("oracle_nne").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("postgres").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("presto").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
		}, nil
	}
	if list := d.Get("rabbitmq_amqp_091").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("raw_tcp").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
		}

		return map[string]string{}, nil
	}
	if list := d.Get("rdp").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("rdp_cert").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("rds_postgres_iam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("redis").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("redis_cluster").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("redshift").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("redshift_iam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
		}

		return map[string]string{}, nil
	}
	if list := d.Get("redshift_serverless_iam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
		}

		return map[string]string{}, nil
	}
	if list := d.Get("single_store").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("snowflake").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("snowsight").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["saml_metadata"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential saml_metadata was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"saml_metadata": convertStringToPlumbing(raw["saml_metadata"]),
		}, nil
	}
	if list := d.Get("sql_server").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("sql_server_azure_ad").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["client_id"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential client_id was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["secret"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential secret was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["tenant_id"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential tenant_id was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"client_id": convertStringToPlumbing(raw["client_id"]),
			"secret":    convertStringToPlumbing(raw["secret"]),
			"tenant_id": convertStringToPlumbing(raw["tenant_id"]),
		}, nil
	}
	if list := d.Get("sql_server_kerberos_ad").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["keytab"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential keytab was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["krb_config"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential krb_config was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["realm"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential realm was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"keytab":     convertStringToPlumbing(raw["keytab"]),
			"krb_config": convertStringToPlumbing(raw["krb_config"]),
			"realm":      convertStringToPlumbing(raw["realm"]),
			"username":   convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("ssh").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("ssh_cert").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("ssh_customer_key").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["private_key"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential private_key was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"private_key": convertStringToPlumbing(raw["private_key"]),
			"username":    convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("ssh_password").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("sybase").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("sybase_iq").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("teradata").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	if list := d.Get("trino").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
		}, nil
	}
	if list := d.Get("vertica").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential password was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				_, err := url.ParseRequestURI("secretstore://store/" + v.(string))
				if err != nil {
					return nil, fmt.Errorf("secret store credential username was not parseable, unset secret_store_id or use the path/to/secret?key=key format")
				}
			}
		}

		return map[string]string{
			"password": convertStringToPlumbing(raw["password"]),
			"username": convertStringToPlumbing(raw["username"]),
		}, nil
	}
	return map[string]string{}, nil
}
func convertResourceToPlumbing(d *schema.ResourceData) sdm.Resource {
	if list := d.Get("aerospike").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Aerospike{}
		}
		out := &sdm.Aerospike{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("aks").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AKS{}
		}
		out := &sdm.AKS{
			ID:                               d.Id(),
			AllowResourceRoleBypass:          convertBoolToPlumbing(raw["allow_resource_role_bypass"]),
			BindInterface:                    convertStringToPlumbing(raw["bind_interface"]),
			CertificateAuthority:             convertStringToPlumbing(raw["certificate_authority"]),
			ClientCertificate:                convertStringToPlumbing(raw["client_certificate"]),
			ClientKey:                        convertStringToPlumbing(raw["client_key"]),
			DiscoveryEnabled:                 convertBoolToPlumbing(raw["discovery_enabled"]),
			DiscoveryUsername:                convertStringToPlumbing(raw["discovery_username"]),
			EgressFilter:                     convertStringToPlumbing(raw["egress_filter"]),
			HealthcheckNamespace:             convertStringToPlumbing(raw["healthcheck_namespace"]),
			Hostname:                         convertStringToPlumbing(raw["hostname"]),
			IdentityAliasHealthcheckUsername: convertStringToPlumbing(raw["identity_alias_healthcheck_username"]),
			IdentitySetID:                    convertStringToPlumbing(raw["identity_set_id"]),
			Name:                             convertStringToPlumbing(raw["name"]),
			Port:                             convertInt32ToPlumbing(raw["port"]),
			PortOverride:                     convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:                   convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:                    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                        convertStringToPlumbing(raw["subdomain"]),
			Tags:                             convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("aks_basic_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AKSBasicAuth{}
		}
		out := &sdm.AKSBasicAuth{
			ID:                   d.Id(),
			BindInterface:        convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:         convertStringToPlumbing(raw["egress_filter"]),
			HealthcheckNamespace: convertStringToPlumbing(raw["healthcheck_namespace"]),
			Hostname:             convertStringToPlumbing(raw["hostname"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			Password:             convertStringToPlumbing(raw["password"]),
			Port:                 convertInt32ToPlumbing(raw["port"]),
			PortOverride:         convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:       convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:        convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:            convertStringToPlumbing(raw["subdomain"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
			Username:             convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("aks_service_account").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AKSServiceAccount{}
		}
		out := &sdm.AKSServiceAccount{
			ID:                               d.Id(),
			AllowResourceRoleBypass:          convertBoolToPlumbing(raw["allow_resource_role_bypass"]),
			BindInterface:                    convertStringToPlumbing(raw["bind_interface"]),
			DiscoveryEnabled:                 convertBoolToPlumbing(raw["discovery_enabled"]),
			DiscoveryUsername:                convertStringToPlumbing(raw["discovery_username"]),
			EgressFilter:                     convertStringToPlumbing(raw["egress_filter"]),
			HealthcheckNamespace:             convertStringToPlumbing(raw["healthcheck_namespace"]),
			Hostname:                         convertStringToPlumbing(raw["hostname"]),
			IdentityAliasHealthcheckUsername: convertStringToPlumbing(raw["identity_alias_healthcheck_username"]),
			IdentitySetID:                    convertStringToPlumbing(raw["identity_set_id"]),
			Name:                             convertStringToPlumbing(raw["name"]),
			Port:                             convertInt32ToPlumbing(raw["port"]),
			PortOverride:                     convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:                   convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:                    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                        convertStringToPlumbing(raw["subdomain"]),
			Tags:                             convertTagsToPlumbing(raw["tags"]),
			Token:                            convertStringToPlumbing(raw["token"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("aks_service_account_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AKSServiceAccountUserImpersonation{}
		}
		out := &sdm.AKSServiceAccountUserImpersonation{
			ID:                   d.Id(),
			BindInterface:        convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:         convertStringToPlumbing(raw["egress_filter"]),
			HealthcheckNamespace: convertStringToPlumbing(raw["healthcheck_namespace"]),
			Hostname:             convertStringToPlumbing(raw["hostname"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			Port:                 convertInt32ToPlumbing(raw["port"]),
			PortOverride:         convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:       convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:        convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:            convertStringToPlumbing(raw["subdomain"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
			Token:                convertStringToPlumbing(raw["token"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("aks_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AKSUserImpersonation{}
		}
		out := &sdm.AKSUserImpersonation{
			ID:                   d.Id(),
			BindInterface:        convertStringToPlumbing(raw["bind_interface"]),
			CertificateAuthority: convertStringToPlumbing(raw["certificate_authority"]),
			ClientCertificate:    convertStringToPlumbing(raw["client_certificate"]),
			ClientKey:            convertStringToPlumbing(raw["client_key"]),
			EgressFilter:         convertStringToPlumbing(raw["egress_filter"]),
			HealthcheckNamespace: convertStringToPlumbing(raw["healthcheck_namespace"]),
			Hostname:             convertStringToPlumbing(raw["hostname"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			Port:                 convertInt32ToPlumbing(raw["port"]),
			PortOverride:         convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:       convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:        convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:            convertStringToPlumbing(raw["subdomain"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("amazon_eks").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AmazonEKS{}
		}
		out := &sdm.AmazonEKS{
			ID:                               d.Id(),
			AccessKey:                        convertStringToPlumbing(raw["access_key"]),
			AllowResourceRoleBypass:          convertBoolToPlumbing(raw["allow_resource_role_bypass"]),
			BindInterface:                    convertStringToPlumbing(raw["bind_interface"]),
			CertificateAuthority:             convertStringToPlumbing(raw["certificate_authority"]),
			ClusterName:                      convertStringToPlumbing(raw["cluster_name"]),
			DiscoveryEnabled:                 convertBoolToPlumbing(raw["discovery_enabled"]),
			DiscoveryUsername:                convertStringToPlumbing(raw["discovery_username"]),
			EgressFilter:                     convertStringToPlumbing(raw["egress_filter"]),
			Endpoint:                         convertStringToPlumbing(raw["endpoint"]),
			HealthcheckNamespace:             convertStringToPlumbing(raw["healthcheck_namespace"]),
			IdentityAliasHealthcheckUsername: convertStringToPlumbing(raw["identity_alias_healthcheck_username"]),
			IdentitySetID:                    convertStringToPlumbing(raw["identity_set_id"]),
			Name:                             convertStringToPlumbing(raw["name"]),
			PortOverride:                     convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:                   convertStringToPlumbing(raw["proxy_cluster_id"]),
			Region:                           convertStringToPlumbing(raw["region"]),
			RoleArn:                          convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID:                   convertStringToPlumbing(raw["role_external_id"]),
			SecretAccessKey:                  convertStringToPlumbing(raw["secret_access_key"]),
			SecretStoreID:                    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                        convertStringToPlumbing(raw["subdomain"]),
			Tags:                             convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("amazon_eks_instance_profile").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AmazonEKSInstanceProfile{}
		}
		out := &sdm.AmazonEKSInstanceProfile{
			ID:                               d.Id(),
			AllowResourceRoleBypass:          convertBoolToPlumbing(raw["allow_resource_role_bypass"]),
			BindInterface:                    convertStringToPlumbing(raw["bind_interface"]),
			CertificateAuthority:             convertStringToPlumbing(raw["certificate_authority"]),
			ClusterName:                      convertStringToPlumbing(raw["cluster_name"]),
			DiscoveryEnabled:                 convertBoolToPlumbing(raw["discovery_enabled"]),
			DiscoveryUsername:                convertStringToPlumbing(raw["discovery_username"]),
			EgressFilter:                     convertStringToPlumbing(raw["egress_filter"]),
			Endpoint:                         convertStringToPlumbing(raw["endpoint"]),
			HealthcheckNamespace:             convertStringToPlumbing(raw["healthcheck_namespace"]),
			IdentityAliasHealthcheckUsername: convertStringToPlumbing(raw["identity_alias_healthcheck_username"]),
			IdentitySetID:                    convertStringToPlumbing(raw["identity_set_id"]),
			Name:                             convertStringToPlumbing(raw["name"]),
			PortOverride:                     convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:                   convertStringToPlumbing(raw["proxy_cluster_id"]),
			Region:                           convertStringToPlumbing(raw["region"]),
			RoleArn:                          convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID:                   convertStringToPlumbing(raw["role_external_id"]),
			SecretStoreID:                    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                        convertStringToPlumbing(raw["subdomain"]),
			Tags:                             convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("amazon_eks_instance_profile_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AmazonEKSInstanceProfileUserImpersonation{}
		}
		out := &sdm.AmazonEKSInstanceProfileUserImpersonation{
			ID:                   d.Id(),
			BindInterface:        convertStringToPlumbing(raw["bind_interface"]),
			CertificateAuthority: convertStringToPlumbing(raw["certificate_authority"]),
			ClusterName:          convertStringToPlumbing(raw["cluster_name"]),
			EgressFilter:         convertStringToPlumbing(raw["egress_filter"]),
			Endpoint:             convertStringToPlumbing(raw["endpoint"]),
			HealthcheckNamespace: convertStringToPlumbing(raw["healthcheck_namespace"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			PortOverride:         convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:       convertStringToPlumbing(raw["proxy_cluster_id"]),
			Region:               convertStringToPlumbing(raw["region"]),
			RoleArn:              convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID:       convertStringToPlumbing(raw["role_external_id"]),
			SecretStoreID:        convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:            convertStringToPlumbing(raw["subdomain"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("amazon_eks_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AmazonEKSUserImpersonation{}
		}
		out := &sdm.AmazonEKSUserImpersonation{
			ID:                   d.Id(),
			AccessKey:            convertStringToPlumbing(raw["access_key"]),
			BindInterface:        convertStringToPlumbing(raw["bind_interface"]),
			CertificateAuthority: convertStringToPlumbing(raw["certificate_authority"]),
			ClusterName:          convertStringToPlumbing(raw["cluster_name"]),
			EgressFilter:         convertStringToPlumbing(raw["egress_filter"]),
			Endpoint:             convertStringToPlumbing(raw["endpoint"]),
			HealthcheckNamespace: convertStringToPlumbing(raw["healthcheck_namespace"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			PortOverride:         convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:       convertStringToPlumbing(raw["proxy_cluster_id"]),
			Region:               convertStringToPlumbing(raw["region"]),
			RoleArn:              convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID:       convertStringToPlumbing(raw["role_external_id"]),
			SecretAccessKey:      convertStringToPlumbing(raw["secret_access_key"]),
			SecretStoreID:        convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:            convertStringToPlumbing(raw["subdomain"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("amazon_es").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AmazonES{}
		}
		out := &sdm.AmazonES{
			ID:              d.Id(),
			AccessKey:       convertStringToPlumbing(raw["access_key"]),
			BindInterface:   convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:    convertStringToPlumbing(raw["egress_filter"]),
			Endpoint:        convertStringToPlumbing(raw["endpoint"]),
			Name:            convertStringToPlumbing(raw["name"]),
			PortOverride:    convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:  convertStringToPlumbing(raw["proxy_cluster_id"]),
			Region:          convertStringToPlumbing(raw["region"]),
			RoleArn:         convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID:  convertStringToPlumbing(raw["role_external_id"]),
			SecretAccessKey: convertStringToPlumbing(raw["secret_access_key"]),
			SecretStoreID:   convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:       convertStringToPlumbing(raw["subdomain"]),
			Tags:            convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("amazon_esiam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AmazonESIAM{}
		}
		out := &sdm.AmazonESIAM{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Endpoint:       convertStringToPlumbing(raw["endpoint"]),
			Name:           convertStringToPlumbing(raw["name"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			Region:         convertStringToPlumbing(raw["region"]),
			RoleArn:        convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID: convertStringToPlumbing(raw["role_external_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			TlsRequired:    convertBoolToPlumbing(raw["tls_required"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("amazonmq_amqp_091").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AmazonMQAMQP091{}
		}
		out := &sdm.AmazonMQAMQP091{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			TlsRequired:    convertBoolToPlumbing(raw["tls_required"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("athena").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Athena{}
		}
		out := &sdm.Athena{
			ID:              d.Id(),
			AccessKey:       convertStringToPlumbing(raw["access_key"]),
			BindInterface:   convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:    convertStringToPlumbing(raw["egress_filter"]),
			Name:            convertStringToPlumbing(raw["name"]),
			Output:          convertStringToPlumbing(raw["output"]),
			PortOverride:    convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:  convertStringToPlumbing(raw["proxy_cluster_id"]),
			Region:          convertStringToPlumbing(raw["region"]),
			RoleArn:         convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID:  convertStringToPlumbing(raw["role_external_id"]),
			SecretAccessKey: convertStringToPlumbing(raw["secret_access_key"]),
			SecretStoreID:   convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:       convertStringToPlumbing(raw["subdomain"]),
			Tags:            convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("athena_iam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AthenaIAM{}
		}
		out := &sdm.AthenaIAM{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Output:         convertStringToPlumbing(raw["output"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			Region:         convertStringToPlumbing(raw["region"]),
			RoleArn:        convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID: convertStringToPlumbing(raw["role_external_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("aurora_mysql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AuroraMysql{}
		}
		out := &sdm.AuroraMysql{
			ID:                            d.Id(),
			BindInterface:                 convertStringToPlumbing(raw["bind_interface"]),
			Database:                      convertStringToPlumbing(raw["database"]),
			EgressFilter:                  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:                      convertStringToPlumbing(raw["hostname"]),
			Name:                          convertStringToPlumbing(raw["name"]),
			Password:                      convertStringToPlumbing(raw["password"]),
			Port:                          convertInt32ToPlumbing(raw["port"]),
			PortOverride:                  convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:                convertStringToPlumbing(raw["proxy_cluster_id"]),
			RequireNativeAuth:             convertBoolToPlumbing(raw["require_native_auth"]),
			SecretStoreID:                 convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                     convertStringToPlumbing(raw["subdomain"]),
			Tags:                          convertTagsToPlumbing(raw["tags"]),
			UseAzureSingleServerUsernames: convertBoolToPlumbing(raw["use_azure_single_server_usernames"]),
			Username:                      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("aurora_mysql_iam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AuroraMysqlIAM{}
		}
		out := &sdm.AuroraMysqlIAM{
			ID:                d.Id(),
			BindInterface:     convertStringToPlumbing(raw["bind_interface"]),
			Database:          convertStringToPlumbing(raw["database"]),
			EgressFilter:      convertStringToPlumbing(raw["egress_filter"]),
			Hostname:          convertStringToPlumbing(raw["hostname"]),
			Name:              convertStringToPlumbing(raw["name"]),
			Port:              convertInt32ToPlumbing(raw["port"]),
			PortOverride:      convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:    convertStringToPlumbing(raw["proxy_cluster_id"]),
			Region:            convertStringToPlumbing(raw["region"]),
			RoleAssumptionArn: convertStringToPlumbing(raw["role_assumption_arn"]),
			SecretStoreID:     convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:         convertStringToPlumbing(raw["subdomain"]),
			Tags:              convertTagsToPlumbing(raw["tags"]),
			Username:          convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("aurora_postgres").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AuroraPostgres{}
		}
		out := &sdm.AuroraPostgres{
			ID:               d.Id(),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			Database:         convertStringToPlumbing(raw["database"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			Hostname:         convertStringToPlumbing(raw["hostname"]),
			Name:             convertStringToPlumbing(raw["name"]),
			OverrideDatabase: convertBoolToPlumbing(raw["override_database"]),
			Password:         convertStringToPlumbing(raw["password"]),
			Port:             convertInt32ToPlumbing(raw["port"]),
			PortOverride:     convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:   convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			Username:         convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("aurora_postgres_iam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AuroraPostgresIAM{}
		}
		out := &sdm.AuroraPostgresIAM{
			ID:                d.Id(),
			BindInterface:     convertStringToPlumbing(raw["bind_interface"]),
			Database:          convertStringToPlumbing(raw["database"]),
			EgressFilter:      convertStringToPlumbing(raw["egress_filter"]),
			Hostname:          convertStringToPlumbing(raw["hostname"]),
			Name:              convertStringToPlumbing(raw["name"]),
			OverrideDatabase:  convertBoolToPlumbing(raw["override_database"]),
			Port:              convertInt32ToPlumbing(raw["port"]),
			PortOverride:      convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:    convertStringToPlumbing(raw["proxy_cluster_id"]),
			Region:            convertStringToPlumbing(raw["region"]),
			RoleAssumptionArn: convertStringToPlumbing(raw["role_assumption_arn"]),
			SecretStoreID:     convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:         convertStringToPlumbing(raw["subdomain"]),
			Tags:              convertTagsToPlumbing(raw["tags"]),
			Username:          convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("aws").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AWS{}
		}
		out := &sdm.AWS{
			ID:                d.Id(),
			AccessKey:         convertStringToPlumbing(raw["access_key"]),
			BindInterface:     convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:      convertStringToPlumbing(raw["egress_filter"]),
			HealthcheckRegion: convertStringToPlumbing(raw["healthcheck_region"]),
			Name:              convertStringToPlumbing(raw["name"]),
			PortOverride:      convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:    convertStringToPlumbing(raw["proxy_cluster_id"]),
			RoleArn:           convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID:    convertStringToPlumbing(raw["role_external_id"]),
			SecretAccessKey:   convertStringToPlumbing(raw["secret_access_key"]),
			SecretStoreID:     convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:         convertStringToPlumbing(raw["subdomain"]),
			Tags:              convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("aws_console").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AWSConsole{}
		}
		out := &sdm.AWSConsole{
			ID:                               d.Id(),
			BindInterface:                    convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:                     convertStringToPlumbing(raw["egress_filter"]),
			EnableEnvVariables:               convertBoolToPlumbing(raw["enable_env_variables"]),
			IdentityAliasHealthcheckUsername: convertStringToPlumbing(raw["identity_alias_healthcheck_username"]),
			IdentitySetID:                    convertStringToPlumbing(raw["identity_set_id"]),
			Name:                             convertStringToPlumbing(raw["name"]),
			PortOverride:                     convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:                   convertStringToPlumbing(raw["proxy_cluster_id"]),
			Region:                           convertStringToPlumbing(raw["region"]),
			RoleArn:                          convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID:                   convertStringToPlumbing(raw["role_external_id"]),
			SecretStoreID:                    convertStringToPlumbing(raw["secret_store_id"]),
			SessionExpiry:                    convertInt32ToPlumbing(raw["session_expiry"]),
			Subdomain:                        convertStringToPlumbing(raw["subdomain"]),
			Tags:                             convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("aws_console_static_key_pair").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AWSConsoleStaticKeyPair{}
		}
		out := &sdm.AWSConsoleStaticKeyPair{
			ID:                               d.Id(),
			AccessKey:                        convertStringToPlumbing(raw["access_key"]),
			BindInterface:                    convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:                     convertStringToPlumbing(raw["egress_filter"]),
			IdentityAliasHealthcheckUsername: convertStringToPlumbing(raw["identity_alias_healthcheck_username"]),
			IdentitySetID:                    convertStringToPlumbing(raw["identity_set_id"]),
			Name:                             convertStringToPlumbing(raw["name"]),
			PortOverride:                     convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:                   convertStringToPlumbing(raw["proxy_cluster_id"]),
			Region:                           convertStringToPlumbing(raw["region"]),
			RoleArn:                          convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID:                   convertStringToPlumbing(raw["role_external_id"]),
			SecretAccessKey:                  convertStringToPlumbing(raw["secret_access_key"]),
			SecretStoreID:                    convertStringToPlumbing(raw["secret_store_id"]),
			SessionExpiry:                    convertInt32ToPlumbing(raw["session_expiry"]),
			Subdomain:                        convertStringToPlumbing(raw["subdomain"]),
			Tags:                             convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("aws_instance_profile").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AWSInstanceProfile{}
		}
		out := &sdm.AWSInstanceProfile{
			ID:                 d.Id(),
			BindInterface:      convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:       convertStringToPlumbing(raw["egress_filter"]),
			EnableEnvVariables: convertBoolToPlumbing(raw["enable_env_variables"]),
			Name:               convertStringToPlumbing(raw["name"]),
			PortOverride:       convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:     convertStringToPlumbing(raw["proxy_cluster_id"]),
			Region:             convertStringToPlumbing(raw["region"]),
			RoleArn:            convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID:     convertStringToPlumbing(raw["role_external_id"]),
			SecretStoreID:      convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:          convertStringToPlumbing(raw["subdomain"]),
			Tags:               convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("azure").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Azure{}
		}
		out := &sdm.Azure{
			ID:             d.Id(),
			AppID:          convertStringToPlumbing(raw["app_id"]),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			TenantID:       convertStringToPlumbing(raw["tenant_id"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("azure_certificate").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AzureCertificate{}
		}
		out := &sdm.AzureCertificate{
			ID:                d.Id(),
			AppID:             convertStringToPlumbing(raw["app_id"]),
			BindInterface:     convertStringToPlumbing(raw["bind_interface"]),
			ClientCertificate: convertStringToPlumbing(raw["client_certificate"]),
			EgressFilter:      convertStringToPlumbing(raw["egress_filter"]),
			Name:              convertStringToPlumbing(raw["name"]),
			PortOverride:      convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:    convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:     convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:         convertStringToPlumbing(raw["subdomain"]),
			Tags:              convertTagsToPlumbing(raw["tags"]),
			TenantID:          convertStringToPlumbing(raw["tenant_id"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("azure_mysql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AzureMysql{}
		}
		out := &sdm.AzureMysql{
			ID:                            d.Id(),
			BindInterface:                 convertStringToPlumbing(raw["bind_interface"]),
			Database:                      convertStringToPlumbing(raw["database"]),
			EgressFilter:                  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:                      convertStringToPlumbing(raw["hostname"]),
			Name:                          convertStringToPlumbing(raw["name"]),
			Password:                      convertStringToPlumbing(raw["password"]),
			Port:                          convertInt32ToPlumbing(raw["port"]),
			PortOverride:                  convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:                convertStringToPlumbing(raw["proxy_cluster_id"]),
			RequireNativeAuth:             convertBoolToPlumbing(raw["require_native_auth"]),
			SecretStoreID:                 convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                     convertStringToPlumbing(raw["subdomain"]),
			Tags:                          convertTagsToPlumbing(raw["tags"]),
			UseAzureSingleServerUsernames: convertBoolToPlumbing(raw["use_azure_single_server_usernames"]),
			Username:                      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("azure_postgres").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AzurePostgres{}
		}
		out := &sdm.AzurePostgres{
			ID:               d.Id(),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			Database:         convertStringToPlumbing(raw["database"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			Hostname:         convertStringToPlumbing(raw["hostname"]),
			Name:             convertStringToPlumbing(raw["name"]),
			OverrideDatabase: convertBoolToPlumbing(raw["override_database"]),
			Password:         convertStringToPlumbing(raw["password"]),
			Port:             convertInt32ToPlumbing(raw["port"]),
			PortOverride:     convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:   convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			Username:         convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("azure_postgres_managed_identity").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AzurePostgresManagedIdentity{}
		}
		out := &sdm.AzurePostgresManagedIdentity{
			ID:                            d.Id(),
			BindInterface:                 convertStringToPlumbing(raw["bind_interface"]),
			Database:                      convertStringToPlumbing(raw["database"]),
			EgressFilter:                  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:                      convertStringToPlumbing(raw["hostname"]),
			Name:                          convertStringToPlumbing(raw["name"]),
			OverrideDatabase:              convertBoolToPlumbing(raw["override_database"]),
			Password:                      convertStringToPlumbing(raw["password"]),
			Port:                          convertInt32ToPlumbing(raw["port"]),
			PortOverride:                  convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:                convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:                 convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                     convertStringToPlumbing(raw["subdomain"]),
			Tags:                          convertTagsToPlumbing(raw["tags"]),
			UseAzureSingleServerUsernames: convertBoolToPlumbing(raw["use_azure_single_server_usernames"]),
			Username:                      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("big_query").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.BigQuery{}
		}
		out := &sdm.BigQuery{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Endpoint:       convertStringToPlumbing(raw["endpoint"]),
			Name:           convertStringToPlumbing(raw["name"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			PrivateKey:     convertStringToPlumbing(raw["private_key"]),
			Project:        convertStringToPlumbing(raw["project"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("cassandra").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Cassandra{}
		}
		out := &sdm.Cassandra{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			TlsRequired:    convertBoolToPlumbing(raw["tls_required"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("citus").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Citus{}
		}
		out := &sdm.Citus{
			ID:               d.Id(),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			Database:         convertStringToPlumbing(raw["database"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			Hostname:         convertStringToPlumbing(raw["hostname"]),
			Name:             convertStringToPlumbing(raw["name"]),
			OverrideDatabase: convertBoolToPlumbing(raw["override_database"]),
			Password:         convertStringToPlumbing(raw["password"]),
			Port:             convertInt32ToPlumbing(raw["port"]),
			PortOverride:     convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:   convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			Username:         convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("click_house_http").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.ClickHouseHTTP{}
		}
		out := &sdm.ClickHouseHTTP{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			Database:       convertStringToPlumbing(raw["database"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			Url:            convertStringToPlumbing(raw["url"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("click_house_my_sql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.ClickHouseMySQL{}
		}
		out := &sdm.ClickHouseMySQL{
			ID:                d.Id(),
			BindInterface:     convertStringToPlumbing(raw["bind_interface"]),
			Database:          convertStringToPlumbing(raw["database"]),
			EgressFilter:      convertStringToPlumbing(raw["egress_filter"]),
			Hostname:          convertStringToPlumbing(raw["hostname"]),
			Name:              convertStringToPlumbing(raw["name"]),
			Password:          convertStringToPlumbing(raw["password"]),
			Port:              convertInt32ToPlumbing(raw["port"]),
			PortOverride:      convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:    convertStringToPlumbing(raw["proxy_cluster_id"]),
			RequireNativeAuth: convertBoolToPlumbing(raw["require_native_auth"]),
			SecretStoreID:     convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:         convertStringToPlumbing(raw["subdomain"]),
			Tags:              convertTagsToPlumbing(raw["tags"]),
			Username:          convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("click_house_tcp").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.ClickHouseTCP{}
		}
		out := &sdm.ClickHouseTCP{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			Database:       convertStringToPlumbing(raw["database"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			TlsRequired:    convertBoolToPlumbing(raw["tls_required"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("clustrix").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Clustrix{}
		}
		out := &sdm.Clustrix{
			ID:                            d.Id(),
			BindInterface:                 convertStringToPlumbing(raw["bind_interface"]),
			Database:                      convertStringToPlumbing(raw["database"]),
			EgressFilter:                  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:                      convertStringToPlumbing(raw["hostname"]),
			Name:                          convertStringToPlumbing(raw["name"]),
			Password:                      convertStringToPlumbing(raw["password"]),
			Port:                          convertInt32ToPlumbing(raw["port"]),
			PortOverride:                  convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:                convertStringToPlumbing(raw["proxy_cluster_id"]),
			RequireNativeAuth:             convertBoolToPlumbing(raw["require_native_auth"]),
			SecretStoreID:                 convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                     convertStringToPlumbing(raw["subdomain"]),
			Tags:                          convertTagsToPlumbing(raw["tags"]),
			UseAzureSingleServerUsernames: convertBoolToPlumbing(raw["use_azure_single_server_usernames"]),
			Username:                      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("cockroach").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Cockroach{}
		}
		out := &sdm.Cockroach{
			ID:               d.Id(),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			Database:         convertStringToPlumbing(raw["database"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			Hostname:         convertStringToPlumbing(raw["hostname"]),
			Name:             convertStringToPlumbing(raw["name"]),
			OverrideDatabase: convertBoolToPlumbing(raw["override_database"]),
			Password:         convertStringToPlumbing(raw["password"]),
			Port:             convertInt32ToPlumbing(raw["port"]),
			PortOverride:     convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:   convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			Username:         convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("couchbase_database").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.CouchbaseDatabase{}
		}
		out := &sdm.CouchbaseDatabase{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			N1QlPort:       convertInt32ToPlumbing(raw["n_1_ql_port"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			TlsRequired:    convertBoolToPlumbing(raw["tls_required"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("couchbase_web_ui").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.CouchbaseWebUI{}
		}
		out := &sdm.CouchbaseWebUI{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			Url:            convertStringToPlumbing(raw["url"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("db_2_i").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.DB2I{}
		}
		out := &sdm.DB2I{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			TlsRequired:    convertBoolToPlumbing(raw["tls_required"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("db_2_luw").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.DB2LUW{}
		}
		out := &sdm.DB2LUW{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			Database:       convertStringToPlumbing(raw["database"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("document_db_host").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.DocumentDBHost{}
		}
		out := &sdm.DocumentDBHost{
			ID:             d.Id(),
			AuthDatabase:   convertStringToPlumbing(raw["auth_database"]),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("document_db_host_iam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.DocumentDBHostIAM{}
		}
		out := &sdm.DocumentDBHostIAM{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			Region:         convertStringToPlumbing(raw["region"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("document_db_replica_set").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.DocumentDBReplicaSet{}
		}
		out := &sdm.DocumentDBReplicaSet{
			ID:               d.Id(),
			AuthDatabase:     convertStringToPlumbing(raw["auth_database"]),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			ConnectToReplica: convertBoolToPlumbing(raw["connect_to_replica"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			Hostname:         convertStringToPlumbing(raw["hostname"]),
			Name:             convertStringToPlumbing(raw["name"]),
			Password:         convertStringToPlumbing(raw["password"]),
			PortOverride:     convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:   convertStringToPlumbing(raw["proxy_cluster_id"]),
			ReplicaSet:       convertStringToPlumbing(raw["replica_set"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			Username:         convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("document_db_replica_set_iam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.DocumentDBReplicaSetIAM{}
		}
		out := &sdm.DocumentDBReplicaSetIAM{
			ID:               d.Id(),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			ConnectToReplica: convertBoolToPlumbing(raw["connect_to_replica"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			Hostname:         convertStringToPlumbing(raw["hostname"]),
			Name:             convertStringToPlumbing(raw["name"]),
			PortOverride:     convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:   convertStringToPlumbing(raw["proxy_cluster_id"]),
			Region:           convertStringToPlumbing(raw["region"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("druid").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Druid{}
		}
		out := &sdm.Druid{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("dynamo_db").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.DynamoDB{}
		}
		out := &sdm.DynamoDB{
			ID:              d.Id(),
			AccessKey:       convertStringToPlumbing(raw["access_key"]),
			BindInterface:   convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:    convertStringToPlumbing(raw["egress_filter"]),
			Endpoint:        convertStringToPlumbing(raw["endpoint"]),
			Name:            convertStringToPlumbing(raw["name"]),
			PortOverride:    convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:  convertStringToPlumbing(raw["proxy_cluster_id"]),
			Region:          convertStringToPlumbing(raw["region"]),
			RoleArn:         convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID:  convertStringToPlumbing(raw["role_external_id"]),
			SecretAccessKey: convertStringToPlumbing(raw["secret_access_key"]),
			SecretStoreID:   convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:       convertStringToPlumbing(raw["subdomain"]),
			Tags:            convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("dynamo_dbiam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.DynamoDBIAM{}
		}
		out := &sdm.DynamoDBIAM{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Endpoint:       convertStringToPlumbing(raw["endpoint"]),
			Name:           convertStringToPlumbing(raw["name"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			Region:         convertStringToPlumbing(raw["region"]),
			RoleArn:        convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID: convertStringToPlumbing(raw["role_external_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("elastic").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Elastic{}
		}
		out := &sdm.Elastic{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			TlsRequired:    convertBoolToPlumbing(raw["tls_required"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("elasticache_redis").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.ElasticacheRedis{}
		}
		out := &sdm.ElasticacheRedis{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			TlsRequired:    convertBoolToPlumbing(raw["tls_required"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("gcp").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.GCP{}
		}
		out := &sdm.GCP{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Keyfile:        convertStringToPlumbing(raw["keyfile"]),
			Name:           convertStringToPlumbing(raw["name"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			Scopes:         convertStringToPlumbing(raw["scopes"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("gcp_console").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.GCPConsole{}
		}
		out := &sdm.GCPConsole{
			ID:                               d.Id(),
			BindInterface:                    convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:                     convertStringToPlumbing(raw["egress_filter"]),
			IdentityAliasHealthcheckUsername: convertStringToPlumbing(raw["identity_alias_healthcheck_username"]),
			IdentitySetID:                    convertStringToPlumbing(raw["identity_set_id"]),
			Name:                             convertStringToPlumbing(raw["name"]),
			PortOverride:                     convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:                   convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:                    convertStringToPlumbing(raw["secret_store_id"]),
			SessionExpiry:                    convertInt32ToPlumbing(raw["session_expiry"]),
			Subdomain:                        convertStringToPlumbing(raw["subdomain"]),
			Tags:                             convertTagsToPlumbing(raw["tags"]),
			WorkforcePoolID:                  convertStringToPlumbing(raw["workforce_pool_id"]),
			WorkforceProviderID:              convertStringToPlumbing(raw["workforce_provider_id"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("gcpwif").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.GCPWIF{}
		}
		out := &sdm.GCPWIF{
			ID:                               d.Id(),
			BindInterface:                    convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:                     convertStringToPlumbing(raw["egress_filter"]),
			IdentityAliasHealthcheckUsername: convertStringToPlumbing(raw["identity_alias_healthcheck_username"]),
			IdentitySetID:                    convertStringToPlumbing(raw["identity_set_id"]),
			Name:                             convertStringToPlumbing(raw["name"]),
			PortOverride:                     convertInt32ToPlumbing(raw["port_override"]),
			ProjectID:                        convertStringToPlumbing(raw["project_id"]),
			ProxyClusterID:                   convertStringToPlumbing(raw["proxy_cluster_id"]),
			Scopes:                           convertStringToPlumbing(raw["scopes"]),
			SecretStoreID:                    convertStringToPlumbing(raw["secret_store_id"]),
			SessionExpiry:                    convertInt32ToPlumbing(raw["session_expiry"]),
			Subdomain:                        convertStringToPlumbing(raw["subdomain"]),
			Tags:                             convertTagsToPlumbing(raw["tags"]),
			WorkforcePoolID:                  convertStringToPlumbing(raw["workforce_pool_id"]),
			WorkforceProviderID:              convertStringToPlumbing(raw["workforce_provider_id"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("google_gke").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.GoogleGKE{}
		}
		out := &sdm.GoogleGKE{
			ID:                               d.Id(),
			AllowResourceRoleBypass:          convertBoolToPlumbing(raw["allow_resource_role_bypass"]),
			BindInterface:                    convertStringToPlumbing(raw["bind_interface"]),
			CertificateAuthority:             convertStringToPlumbing(raw["certificate_authority"]),
			DiscoveryEnabled:                 convertBoolToPlumbing(raw["discovery_enabled"]),
			DiscoveryUsername:                convertStringToPlumbing(raw["discovery_username"]),
			EgressFilter:                     convertStringToPlumbing(raw["egress_filter"]),
			Endpoint:                         convertStringToPlumbing(raw["endpoint"]),
			HealthcheckNamespace:             convertStringToPlumbing(raw["healthcheck_namespace"]),
			IdentityAliasHealthcheckUsername: convertStringToPlumbing(raw["identity_alias_healthcheck_username"]),
			IdentitySetID:                    convertStringToPlumbing(raw["identity_set_id"]),
			Name:                             convertStringToPlumbing(raw["name"]),
			PortOverride:                     convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:                   convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:                    convertStringToPlumbing(raw["secret_store_id"]),
			ServiceAccountKey:                convertStringToPlumbing(raw["service_account_key"]),
			Subdomain:                        convertStringToPlumbing(raw["subdomain"]),
			Tags:                             convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("google_gke_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.GoogleGKEUserImpersonation{}
		}
		out := &sdm.GoogleGKEUserImpersonation{
			ID:                   d.Id(),
			BindInterface:        convertStringToPlumbing(raw["bind_interface"]),
			CertificateAuthority: convertStringToPlumbing(raw["certificate_authority"]),
			EgressFilter:         convertStringToPlumbing(raw["egress_filter"]),
			Endpoint:             convertStringToPlumbing(raw["endpoint"]),
			HealthcheckNamespace: convertStringToPlumbing(raw["healthcheck_namespace"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			PortOverride:         convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:       convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:        convertStringToPlumbing(raw["secret_store_id"]),
			ServiceAccountKey:    convertStringToPlumbing(raw["service_account_key"]),
			Subdomain:            convertStringToPlumbing(raw["subdomain"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("greenplum").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Greenplum{}
		}
		out := &sdm.Greenplum{
			ID:               d.Id(),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			Database:         convertStringToPlumbing(raw["database"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			Hostname:         convertStringToPlumbing(raw["hostname"]),
			Name:             convertStringToPlumbing(raw["name"]),
			OverrideDatabase: convertBoolToPlumbing(raw["override_database"]),
			Password:         convertStringToPlumbing(raw["password"]),
			Port:             convertInt32ToPlumbing(raw["port"]),
			PortOverride:     convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:   convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			Username:         convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("http_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.HTTPAuth{}
		}
		out := &sdm.HTTPAuth{
			ID:               d.Id(),
			AuthHeader:       convertStringToPlumbing(raw["auth_header"]),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			DefaultPath:      convertStringToPlumbing(raw["default_path"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			HeadersBlacklist: convertStringToPlumbing(raw["headers_blacklist"]),
			HealthcheckPath:  convertStringToPlumbing(raw["healthcheck_path"]),
			HostOverride:     convertStringToPlumbing(raw["host_override"]),
			Name:             convertStringToPlumbing(raw["name"]),
			ProxyClusterID:   convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			Url:              convertStringToPlumbing(raw["url"]),
		}
		return out
	}
	if list := d.Get("http_basic_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.HTTPBasicAuth{}
		}
		out := &sdm.HTTPBasicAuth{
			ID:               d.Id(),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			DefaultPath:      convertStringToPlumbing(raw["default_path"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			HeadersBlacklist: convertStringToPlumbing(raw["headers_blacklist"]),
			HealthcheckPath:  convertStringToPlumbing(raw["healthcheck_path"]),
			HostOverride:     convertStringToPlumbing(raw["host_override"]),
			Name:             convertStringToPlumbing(raw["name"]),
			Password:         convertStringToPlumbing(raw["password"]),
			ProxyClusterID:   convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			Url:              convertStringToPlumbing(raw["url"]),
			Username:         convertStringToPlumbing(raw["username"]),
		}
		return out
	}
	if list := d.Get("http_no_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.HTTPNoAuth{}
		}
		out := &sdm.HTTPNoAuth{
			ID:               d.Id(),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			DefaultPath:      convertStringToPlumbing(raw["default_path"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			HeadersBlacklist: convertStringToPlumbing(raw["headers_blacklist"]),
			HealthcheckPath:  convertStringToPlumbing(raw["healthcheck_path"]),
			HostOverride:     convertStringToPlumbing(raw["host_override"]),
			Name:             convertStringToPlumbing(raw["name"]),
			ProxyClusterID:   convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			Url:              convertStringToPlumbing(raw["url"]),
		}
		return out
	}
	if list := d.Get("kubernetes").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Kubernetes{}
		}
		out := &sdm.Kubernetes{
			ID:                               d.Id(),
			AllowResourceRoleBypass:          convertBoolToPlumbing(raw["allow_resource_role_bypass"]),
			BindInterface:                    convertStringToPlumbing(raw["bind_interface"]),
			CertificateAuthority:             convertStringToPlumbing(raw["certificate_authority"]),
			ClientCertificate:                convertStringToPlumbing(raw["client_certificate"]),
			ClientKey:                        convertStringToPlumbing(raw["client_key"]),
			DiscoveryEnabled:                 convertBoolToPlumbing(raw["discovery_enabled"]),
			DiscoveryUsername:                convertStringToPlumbing(raw["discovery_username"]),
			EgressFilter:                     convertStringToPlumbing(raw["egress_filter"]),
			HealthcheckNamespace:             convertStringToPlumbing(raw["healthcheck_namespace"]),
			Hostname:                         convertStringToPlumbing(raw["hostname"]),
			IdentityAliasHealthcheckUsername: convertStringToPlumbing(raw["identity_alias_healthcheck_username"]),
			IdentitySetID:                    convertStringToPlumbing(raw["identity_set_id"]),
			Name:                             convertStringToPlumbing(raw["name"]),
			Port:                             convertInt32ToPlumbing(raw["port"]),
			PortOverride:                     convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:                   convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:                    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                        convertStringToPlumbing(raw["subdomain"]),
			Tags:                             convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("kubernetes_basic_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.KubernetesBasicAuth{}
		}
		out := &sdm.KubernetesBasicAuth{
			ID:                   d.Id(),
			BindInterface:        convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:         convertStringToPlumbing(raw["egress_filter"]),
			HealthcheckNamespace: convertStringToPlumbing(raw["healthcheck_namespace"]),
			Hostname:             convertStringToPlumbing(raw["hostname"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			Password:             convertStringToPlumbing(raw["password"]),
			Port:                 convertInt32ToPlumbing(raw["port"]),
			PortOverride:         convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:       convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:        convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:            convertStringToPlumbing(raw["subdomain"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
			Username:             convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("kubernetes_pod_identity").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.KubernetesPodIdentity{}
		}
		out := &sdm.KubernetesPodIdentity{
			ID:                               d.Id(),
			AllowResourceRoleBypass:          convertBoolToPlumbing(raw["allow_resource_role_bypass"]),
			BindInterface:                    convertStringToPlumbing(raw["bind_interface"]),
			CertificateAuthority:             convertStringToPlumbing(raw["certificate_authority"]),
			EgressFilter:                     convertStringToPlumbing(raw["egress_filter"]),
			HealthcheckNamespace:             convertStringToPlumbing(raw["healthcheck_namespace"]),
			IdentityAliasHealthcheckUsername: convertStringToPlumbing(raw["identity_alias_healthcheck_username"]),
			IdentitySetID:                    convertStringToPlumbing(raw["identity_set_id"]),
			Name:                             convertStringToPlumbing(raw["name"]),
			PortOverride:                     convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:                   convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:                    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                        convertStringToPlumbing(raw["subdomain"]),
			Tags:                             convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("kubernetes_service_account").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.KubernetesServiceAccount{}
		}
		out := &sdm.KubernetesServiceAccount{
			ID:                               d.Id(),
			AllowResourceRoleBypass:          convertBoolToPlumbing(raw["allow_resource_role_bypass"]),
			BindInterface:                    convertStringToPlumbing(raw["bind_interface"]),
			DiscoveryEnabled:                 convertBoolToPlumbing(raw["discovery_enabled"]),
			DiscoveryUsername:                convertStringToPlumbing(raw["discovery_username"]),
			EgressFilter:                     convertStringToPlumbing(raw["egress_filter"]),
			HealthcheckNamespace:             convertStringToPlumbing(raw["healthcheck_namespace"]),
			Hostname:                         convertStringToPlumbing(raw["hostname"]),
			IdentityAliasHealthcheckUsername: convertStringToPlumbing(raw["identity_alias_healthcheck_username"]),
			IdentitySetID:                    convertStringToPlumbing(raw["identity_set_id"]),
			Name:                             convertStringToPlumbing(raw["name"]),
			Port:                             convertInt32ToPlumbing(raw["port"]),
			PortOverride:                     convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:                   convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:                    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                        convertStringToPlumbing(raw["subdomain"]),
			Tags:                             convertTagsToPlumbing(raw["tags"]),
			Token:                            convertStringToPlumbing(raw["token"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("kubernetes_service_account_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.KubernetesServiceAccountUserImpersonation{}
		}
		out := &sdm.KubernetesServiceAccountUserImpersonation{
			ID:                   d.Id(),
			BindInterface:        convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:         convertStringToPlumbing(raw["egress_filter"]),
			HealthcheckNamespace: convertStringToPlumbing(raw["healthcheck_namespace"]),
			Hostname:             convertStringToPlumbing(raw["hostname"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			Port:                 convertInt32ToPlumbing(raw["port"]),
			PortOverride:         convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:       convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:        convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:            convertStringToPlumbing(raw["subdomain"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
			Token:                convertStringToPlumbing(raw["token"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("kubernetes_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.KubernetesUserImpersonation{}
		}
		out := &sdm.KubernetesUserImpersonation{
			ID:                   d.Id(),
			BindInterface:        convertStringToPlumbing(raw["bind_interface"]),
			CertificateAuthority: convertStringToPlumbing(raw["certificate_authority"]),
			ClientCertificate:    convertStringToPlumbing(raw["client_certificate"]),
			ClientKey:            convertStringToPlumbing(raw["client_key"]),
			EgressFilter:         convertStringToPlumbing(raw["egress_filter"]),
			HealthcheckNamespace: convertStringToPlumbing(raw["healthcheck_namespace"]),
			Hostname:             convertStringToPlumbing(raw["hostname"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			Port:                 convertInt32ToPlumbing(raw["port"]),
			PortOverride:         convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:       convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:        convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:            convertStringToPlumbing(raw["subdomain"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("maria").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Maria{}
		}
		out := &sdm.Maria{
			ID:                            d.Id(),
			BindInterface:                 convertStringToPlumbing(raw["bind_interface"]),
			Database:                      convertStringToPlumbing(raw["database"]),
			EgressFilter:                  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:                      convertStringToPlumbing(raw["hostname"]),
			Name:                          convertStringToPlumbing(raw["name"]),
			Password:                      convertStringToPlumbing(raw["password"]),
			Port:                          convertInt32ToPlumbing(raw["port"]),
			PortOverride:                  convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:                convertStringToPlumbing(raw["proxy_cluster_id"]),
			RequireNativeAuth:             convertBoolToPlumbing(raw["require_native_auth"]),
			SecretStoreID:                 convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                     convertStringToPlumbing(raw["subdomain"]),
			Tags:                          convertTagsToPlumbing(raw["tags"]),
			UseAzureSingleServerUsernames: convertBoolToPlumbing(raw["use_azure_single_server_usernames"]),
			Username:                      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("memcached").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Memcached{}
		}
		out := &sdm.Memcached{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("memsql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Memsql{}
		}
		out := &sdm.Memsql{
			ID:                            d.Id(),
			BindInterface:                 convertStringToPlumbing(raw["bind_interface"]),
			Database:                      convertStringToPlumbing(raw["database"]),
			EgressFilter:                  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:                      convertStringToPlumbing(raw["hostname"]),
			Name:                          convertStringToPlumbing(raw["name"]),
			Password:                      convertStringToPlumbing(raw["password"]),
			Port:                          convertInt32ToPlumbing(raw["port"]),
			PortOverride:                  convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:                convertStringToPlumbing(raw["proxy_cluster_id"]),
			RequireNativeAuth:             convertBoolToPlumbing(raw["require_native_auth"]),
			SecretStoreID:                 convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                     convertStringToPlumbing(raw["subdomain"]),
			Tags:                          convertTagsToPlumbing(raw["tags"]),
			UseAzureSingleServerUsernames: convertBoolToPlumbing(raw["use_azure_single_server_usernames"]),
			Username:                      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("mongo_host").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.MongoHost{}
		}
		out := &sdm.MongoHost{
			ID:             d.Id(),
			AuthDatabase:   convertStringToPlumbing(raw["auth_database"]),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			TlsRequired:    convertBoolToPlumbing(raw["tls_required"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("mongo_legacy_host").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.MongoLegacyHost{}
		}
		out := &sdm.MongoLegacyHost{
			ID:             d.Id(),
			AuthDatabase:   convertStringToPlumbing(raw["auth_database"]),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			TlsRequired:    convertBoolToPlumbing(raw["tls_required"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("mongo_legacy_replicaset").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.MongoLegacyReplicaset{}
		}
		out := &sdm.MongoLegacyReplicaset{
			ID:               d.Id(),
			AuthDatabase:     convertStringToPlumbing(raw["auth_database"]),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			ConnectToReplica: convertBoolToPlumbing(raw["connect_to_replica"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			Hostname:         convertStringToPlumbing(raw["hostname"]),
			Name:             convertStringToPlumbing(raw["name"]),
			Password:         convertStringToPlumbing(raw["password"]),
			Port:             convertInt32ToPlumbing(raw["port"]),
			PortOverride:     convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:   convertStringToPlumbing(raw["proxy_cluster_id"]),
			ReplicaSet:       convertStringToPlumbing(raw["replica_set"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			TlsRequired:      convertBoolToPlumbing(raw["tls_required"]),
			Username:         convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("mongo_replica_set").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.MongoReplicaSet{}
		}
		out := &sdm.MongoReplicaSet{
			ID:               d.Id(),
			AuthDatabase:     convertStringToPlumbing(raw["auth_database"]),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			ConnectToReplica: convertBoolToPlumbing(raw["connect_to_replica"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			Hostname:         convertStringToPlumbing(raw["hostname"]),
			Name:             convertStringToPlumbing(raw["name"]),
			Password:         convertStringToPlumbing(raw["password"]),
			Port:             convertInt32ToPlumbing(raw["port"]),
			PortOverride:     convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:   convertStringToPlumbing(raw["proxy_cluster_id"]),
			ReplicaSet:       convertStringToPlumbing(raw["replica_set"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			TlsRequired:      convertBoolToPlumbing(raw["tls_required"]),
			Username:         convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("mongo_sharded_cluster").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.MongoShardedCluster{}
		}
		out := &sdm.MongoShardedCluster{
			ID:             d.Id(),
			AuthDatabase:   convertStringToPlumbing(raw["auth_database"]),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			TlsRequired:    convertBoolToPlumbing(raw["tls_required"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("mtls_mysql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.MTLSMysql{}
		}
		out := &sdm.MTLSMysql{
			ID:                            d.Id(),
			BindInterface:                 convertStringToPlumbing(raw["bind_interface"]),
			CertificateAuthority:          convertStringToPlumbing(raw["certificate_authority"]),
			ClientCertificate:             convertStringToPlumbing(raw["client_certificate"]),
			ClientKey:                     convertStringToPlumbing(raw["client_key"]),
			Database:                      convertStringToPlumbing(raw["database"]),
			EgressFilter:                  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:                      convertStringToPlumbing(raw["hostname"]),
			Name:                          convertStringToPlumbing(raw["name"]),
			Password:                      convertStringToPlumbing(raw["password"]),
			Port:                          convertInt32ToPlumbing(raw["port"]),
			PortOverride:                  convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:                convertStringToPlumbing(raw["proxy_cluster_id"]),
			RequireNativeAuth:             convertBoolToPlumbing(raw["require_native_auth"]),
			SecretStoreID:                 convertStringToPlumbing(raw["secret_store_id"]),
			ServerName:                    convertStringToPlumbing(raw["server_name"]),
			Subdomain:                     convertStringToPlumbing(raw["subdomain"]),
			Tags:                          convertTagsToPlumbing(raw["tags"]),
			UseAzureSingleServerUsernames: convertBoolToPlumbing(raw["use_azure_single_server_usernames"]),
			Username:                      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("mtls_postgres").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.MTLSPostgres{}
		}
		out := &sdm.MTLSPostgres{
			ID:                   d.Id(),
			BindInterface:        convertStringToPlumbing(raw["bind_interface"]),
			CertificateAuthority: convertStringToPlumbing(raw["certificate_authority"]),
			ClientCertificate:    convertStringToPlumbing(raw["client_certificate"]),
			ClientKey:            convertStringToPlumbing(raw["client_key"]),
			Database:             convertStringToPlumbing(raw["database"]),
			EgressFilter:         convertStringToPlumbing(raw["egress_filter"]),
			Hostname:             convertStringToPlumbing(raw["hostname"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			OverrideDatabase:     convertBoolToPlumbing(raw["override_database"]),
			Password:             convertStringToPlumbing(raw["password"]),
			Port:                 convertInt32ToPlumbing(raw["port"]),
			PortOverride:         convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:       convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:        convertStringToPlumbing(raw["secret_store_id"]),
			ServerName:           convertStringToPlumbing(raw["server_name"]),
			Subdomain:            convertStringToPlumbing(raw["subdomain"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
			Username:             convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("mysql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Mysql{}
		}
		out := &sdm.Mysql{
			ID:                            d.Id(),
			BindInterface:                 convertStringToPlumbing(raw["bind_interface"]),
			Database:                      convertStringToPlumbing(raw["database"]),
			EgressFilter:                  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:                      convertStringToPlumbing(raw["hostname"]),
			Name:                          convertStringToPlumbing(raw["name"]),
			Password:                      convertStringToPlumbing(raw["password"]),
			Port:                          convertInt32ToPlumbing(raw["port"]),
			PortOverride:                  convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:                convertStringToPlumbing(raw["proxy_cluster_id"]),
			RequireNativeAuth:             convertBoolToPlumbing(raw["require_native_auth"]),
			SecretStoreID:                 convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                     convertStringToPlumbing(raw["subdomain"]),
			Tags:                          convertTagsToPlumbing(raw["tags"]),
			UseAzureSingleServerUsernames: convertBoolToPlumbing(raw["use_azure_single_server_usernames"]),
			Username:                      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("neptune").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Neptune{}
		}
		out := &sdm.Neptune{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Endpoint:       convertStringToPlumbing(raw["endpoint"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("neptune_iam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.NeptuneIAM{}
		}
		out := &sdm.NeptuneIAM{
			ID:              d.Id(),
			AccessKey:       convertStringToPlumbing(raw["access_key"]),
			BindInterface:   convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:    convertStringToPlumbing(raw["egress_filter"]),
			Endpoint:        convertStringToPlumbing(raw["endpoint"]),
			Name:            convertStringToPlumbing(raw["name"]),
			Port:            convertInt32ToPlumbing(raw["port"]),
			PortOverride:    convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:  convertStringToPlumbing(raw["proxy_cluster_id"]),
			Region:          convertStringToPlumbing(raw["region"]),
			RoleArn:         convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID:  convertStringToPlumbing(raw["role_external_id"]),
			SecretAccessKey: convertStringToPlumbing(raw["secret_access_key"]),
			SecretStoreID:   convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:       convertStringToPlumbing(raw["subdomain"]),
			Tags:            convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("oracle").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Oracle{}
		}
		out := &sdm.Oracle{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			Database:       convertStringToPlumbing(raw["database"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			TlsRequired:    convertBoolToPlumbing(raw["tls_required"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("oracle_nne").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.OracleNNE{}
		}
		out := &sdm.OracleNNE{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			Database:       convertStringToPlumbing(raw["database"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("postgres").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Postgres{}
		}
		out := &sdm.Postgres{
			ID:               d.Id(),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			Database:         convertStringToPlumbing(raw["database"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			Hostname:         convertStringToPlumbing(raw["hostname"]),
			Name:             convertStringToPlumbing(raw["name"]),
			OverrideDatabase: convertBoolToPlumbing(raw["override_database"]),
			Password:         convertStringToPlumbing(raw["password"]),
			Port:             convertInt32ToPlumbing(raw["port"]),
			PortOverride:     convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:   convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			Username:         convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("presto").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Presto{}
		}
		out := &sdm.Presto{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			Database:       convertStringToPlumbing(raw["database"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			TlsRequired:    convertBoolToPlumbing(raw["tls_required"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("rabbitmq_amqp_091").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.RabbitMQAMQP091{}
		}
		out := &sdm.RabbitMQAMQP091{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			TlsRequired:    convertBoolToPlumbing(raw["tls_required"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("raw_tcp").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.RawTCP{}
		}
		out := &sdm.RawTCP{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("rdp").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.RDP{}
		}
		out := &sdm.RDP{
			ID:                      d.Id(),
			BindInterface:           convertStringToPlumbing(raw["bind_interface"]),
			DowngradeNlaConnections: convertBoolToPlumbing(raw["downgrade_nla_connections"]),
			EgressFilter:            convertStringToPlumbing(raw["egress_filter"]),
			Hostname:                convertStringToPlumbing(raw["hostname"]),
			LockRequired:            convertBoolToPlumbing(raw["lock_required"]),
			Name:                    convertStringToPlumbing(raw["name"]),
			Password:                convertStringToPlumbing(raw["password"]),
			Port:                    convertInt32ToPlumbing(raw["port"]),
			PortOverride:            convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:          convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:           convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:               convertStringToPlumbing(raw["subdomain"]),
			Tags:                    convertTagsToPlumbing(raw["tags"]),
			Username:                convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("rdp_cert").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.RDPCert{}
		}
		out := &sdm.RDPCert{
			ID:                               d.Id(),
			BindInterface:                    convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:                     convertStringToPlumbing(raw["egress_filter"]),
			Hostname:                         convertStringToPlumbing(raw["hostname"]),
			IdentityAliasHealthcheckUsername: convertStringToPlumbing(raw["identity_alias_healthcheck_username"]),
			IdentitySetID:                    convertStringToPlumbing(raw["identity_set_id"]),
			LockRequired:                     convertBoolToPlumbing(raw["lock_required"]),
			Name:                             convertStringToPlumbing(raw["name"]),
			Port:                             convertInt32ToPlumbing(raw["port"]),
			PortOverride:                     convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:                   convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:                    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                        convertStringToPlumbing(raw["subdomain"]),
			Tags:                             convertTagsToPlumbing(raw["tags"]),
			Username:                         convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("rds_postgres_iam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.RDSPostgresIAM{}
		}
		out := &sdm.RDSPostgresIAM{
			ID:                d.Id(),
			BindInterface:     convertStringToPlumbing(raw["bind_interface"]),
			Database:          convertStringToPlumbing(raw["database"]),
			EgressFilter:      convertStringToPlumbing(raw["egress_filter"]),
			Hostname:          convertStringToPlumbing(raw["hostname"]),
			Name:              convertStringToPlumbing(raw["name"]),
			OverrideDatabase:  convertBoolToPlumbing(raw["override_database"]),
			Port:              convertInt32ToPlumbing(raw["port"]),
			PortOverride:      convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:    convertStringToPlumbing(raw["proxy_cluster_id"]),
			Region:            convertStringToPlumbing(raw["region"]),
			RoleAssumptionArn: convertStringToPlumbing(raw["role_assumption_arn"]),
			SecretStoreID:     convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:         convertStringToPlumbing(raw["subdomain"]),
			Tags:              convertTagsToPlumbing(raw["tags"]),
			Username:          convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("redis").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Redis{}
		}
		out := &sdm.Redis{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			TlsRequired:    convertBoolToPlumbing(raw["tls_required"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("redis_cluster").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.RedisCluster{}
		}
		out := &sdm.RedisCluster{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			TlsRequired:    convertBoolToPlumbing(raw["tls_required"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("redshift").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Redshift{}
		}
		out := &sdm.Redshift{
			ID:               d.Id(),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			Database:         convertStringToPlumbing(raw["database"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			Hostname:         convertStringToPlumbing(raw["hostname"]),
			Name:             convertStringToPlumbing(raw["name"]),
			OverrideDatabase: convertBoolToPlumbing(raw["override_database"]),
			Password:         convertStringToPlumbing(raw["password"]),
			Port:             convertInt32ToPlumbing(raw["port"]),
			PortOverride:     convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:   convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			Username:         convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("redshift_iam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.RedshiftIAM{}
		}
		out := &sdm.RedshiftIAM{
			ID:                d.Id(),
			BindInterface:     convertStringToPlumbing(raw["bind_interface"]),
			ClusterID:         convertStringToPlumbing(raw["cluster_id"]),
			Database:          convertStringToPlumbing(raw["database"]),
			EgressFilter:      convertStringToPlumbing(raw["egress_filter"]),
			Hostname:          convertStringToPlumbing(raw["hostname"]),
			Name:              convertStringToPlumbing(raw["name"]),
			OverrideDatabase:  convertBoolToPlumbing(raw["override_database"]),
			Port:              convertInt32ToPlumbing(raw["port"]),
			PortOverride:      convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:    convertStringToPlumbing(raw["proxy_cluster_id"]),
			Region:            convertStringToPlumbing(raw["region"]),
			RoleAssumptionArn: convertStringToPlumbing(raw["role_assumption_arn"]),
			SecretStoreID:     convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:         convertStringToPlumbing(raw["subdomain"]),
			Tags:              convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("redshift_serverless_iam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.RedshiftServerlessIAM{}
		}
		out := &sdm.RedshiftServerlessIAM{
			ID:                d.Id(),
			BindInterface:     convertStringToPlumbing(raw["bind_interface"]),
			Database:          convertStringToPlumbing(raw["database"]),
			EgressFilter:      convertStringToPlumbing(raw["egress_filter"]),
			Hostname:          convertStringToPlumbing(raw["hostname"]),
			Name:              convertStringToPlumbing(raw["name"]),
			OverrideDatabase:  convertBoolToPlumbing(raw["override_database"]),
			Port:              convertInt32ToPlumbing(raw["port"]),
			PortOverride:      convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:    convertStringToPlumbing(raw["proxy_cluster_id"]),
			Region:            convertStringToPlumbing(raw["region"]),
			RoleAssumptionArn: convertStringToPlumbing(raw["role_assumption_arn"]),
			SecretStoreID:     convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:         convertStringToPlumbing(raw["subdomain"]),
			Tags:              convertTagsToPlumbing(raw["tags"]),
			Workgroup:         convertStringToPlumbing(raw["workgroup"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("single_store").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.SingleStore{}
		}
		out := &sdm.SingleStore{
			ID:                            d.Id(),
			BindInterface:                 convertStringToPlumbing(raw["bind_interface"]),
			Database:                      convertStringToPlumbing(raw["database"]),
			EgressFilter:                  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:                      convertStringToPlumbing(raw["hostname"]),
			Name:                          convertStringToPlumbing(raw["name"]),
			Password:                      convertStringToPlumbing(raw["password"]),
			Port:                          convertInt32ToPlumbing(raw["port"]),
			PortOverride:                  convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:                convertStringToPlumbing(raw["proxy_cluster_id"]),
			RequireNativeAuth:             convertBoolToPlumbing(raw["require_native_auth"]),
			SecretStoreID:                 convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                     convertStringToPlumbing(raw["subdomain"]),
			Tags:                          convertTagsToPlumbing(raw["tags"]),
			UseAzureSingleServerUsernames: convertBoolToPlumbing(raw["use_azure_single_server_usernames"]),
			Username:                      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("snowflake").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Snowflake{}
		}
		out := &sdm.Snowflake{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			Database:       convertStringToPlumbing(raw["database"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			Schema:         convertStringToPlumbing(raw["schema"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("snowsight").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Snowsight{}
		}
		out := &sdm.Snowsight{
			ID:                  d.Id(),
			BindInterface:       convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:        convertStringToPlumbing(raw["egress_filter"]),
			HealthcheckUsername: convertStringToPlumbing(raw["healthcheck_username"]),
			Name:                convertStringToPlumbing(raw["name"]),
			PortOverride:        convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:      convertStringToPlumbing(raw["proxy_cluster_id"]),
			SamlMetadata:        convertStringToPlumbing(raw["saml_metadata"]),
			SecretStoreID:       convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:           convertStringToPlumbing(raw["subdomain"]),
			Tags:                convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("sql_server").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.SQLServer{}
		}
		out := &sdm.SQLServer{
			ID:                        d.Id(),
			AllowDeprecatedEncryption: convertBoolToPlumbing(raw["allow_deprecated_encryption"]),
			BindInterface:             convertStringToPlumbing(raw["bind_interface"]),
			Database:                  convertStringToPlumbing(raw["database"]),
			EgressFilter:              convertStringToPlumbing(raw["egress_filter"]),
			Hostname:                  convertStringToPlumbing(raw["hostname"]),
			Name:                      convertStringToPlumbing(raw["name"]),
			OverrideDatabase:          convertBoolToPlumbing(raw["override_database"]),
			Password:                  convertStringToPlumbing(raw["password"]),
			Port:                      convertInt32ToPlumbing(raw["port"]),
			PortOverride:              convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:            convertStringToPlumbing(raw["proxy_cluster_id"]),
			Schema:                    convertStringToPlumbing(raw["schema"]),
			SecretStoreID:             convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                 convertStringToPlumbing(raw["subdomain"]),
			Tags:                      convertTagsToPlumbing(raw["tags"]),
			Username:                  convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("sql_server_azure_ad").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.SQLServerAzureAD{}
		}
		out := &sdm.SQLServerAzureAD{
			ID:                        d.Id(),
			AllowDeprecatedEncryption: convertBoolToPlumbing(raw["allow_deprecated_encryption"]),
			BindInterface:             convertStringToPlumbing(raw["bind_interface"]),
			ClientID:                  convertStringToPlumbing(raw["client_id"]),
			Database:                  convertStringToPlumbing(raw["database"]),
			EgressFilter:              convertStringToPlumbing(raw["egress_filter"]),
			Hostname:                  convertStringToPlumbing(raw["hostname"]),
			Name:                      convertStringToPlumbing(raw["name"]),
			OverrideDatabase:          convertBoolToPlumbing(raw["override_database"]),
			Port:                      convertInt32ToPlumbing(raw["port"]),
			PortOverride:              convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:            convertStringToPlumbing(raw["proxy_cluster_id"]),
			Schema:                    convertStringToPlumbing(raw["schema"]),
			Secret:                    convertStringToPlumbing(raw["secret"]),
			SecretStoreID:             convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                 convertStringToPlumbing(raw["subdomain"]),
			Tags:                      convertTagsToPlumbing(raw["tags"]),
			TenantID:                  convertStringToPlumbing(raw["tenant_id"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("sql_server_kerberos_ad").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.SQLServerKerberosAD{}
		}
		out := &sdm.SQLServerKerberosAD{
			ID:                        d.Id(),
			AllowDeprecatedEncryption: convertBoolToPlumbing(raw["allow_deprecated_encryption"]),
			BindInterface:             convertStringToPlumbing(raw["bind_interface"]),
			Database:                  convertStringToPlumbing(raw["database"]),
			EgressFilter:              convertStringToPlumbing(raw["egress_filter"]),
			Hostname:                  convertStringToPlumbing(raw["hostname"]),
			Keytab:                    convertStringToPlumbing(raw["keytab"]),
			KrbConfig:                 convertStringToPlumbing(raw["krb_config"]),
			Name:                      convertStringToPlumbing(raw["name"]),
			OverrideDatabase:          convertBoolToPlumbing(raw["override_database"]),
			Port:                      convertInt32ToPlumbing(raw["port"]),
			PortOverride:              convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:            convertStringToPlumbing(raw["proxy_cluster_id"]),
			Realm:                     convertStringToPlumbing(raw["realm"]),
			Schema:                    convertStringToPlumbing(raw["schema"]),
			SecretStoreID:             convertStringToPlumbing(raw["secret_store_id"]),
			ServerSpn:                 convertStringToPlumbing(raw["server_spn"]),
			Subdomain:                 convertStringToPlumbing(raw["subdomain"]),
			Tags:                      convertTagsToPlumbing(raw["tags"]),
			Username:                  convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("ssh").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.SSH{}
		}
		out := &sdm.SSH{
			ID:                          d.Id(),
			AllowDeprecatedKeyExchanges: convertBoolToPlumbing(raw["allow_deprecated_key_exchanges"]),
			BindInterface:               convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:                convertStringToPlumbing(raw["egress_filter"]),
			Hostname:                    convertStringToPlumbing(raw["hostname"]),
			KeyType:                     convertStringToPlumbing(raw["key_type"]),
			Name:                        convertStringToPlumbing(raw["name"]),
			Port:                        convertInt32ToPlumbing(raw["port"]),
			PortForwarding:              convertBoolToPlumbing(raw["port_forwarding"]),
			PortOverride:                convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:              convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:               convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                   convertStringToPlumbing(raw["subdomain"]),
			Tags:                        convertTagsToPlumbing(raw["tags"]),
			Username:                    convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("ssh_cert").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.SSHCert{}
		}
		out := &sdm.SSHCert{
			ID:                               d.Id(),
			AllowDeprecatedKeyExchanges:      convertBoolToPlumbing(raw["allow_deprecated_key_exchanges"]),
			BindInterface:                    convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:                     convertStringToPlumbing(raw["egress_filter"]),
			Hostname:                         convertStringToPlumbing(raw["hostname"]),
			IdentityAliasHealthcheckUsername: convertStringToPlumbing(raw["identity_alias_healthcheck_username"]),
			IdentitySetID:                    convertStringToPlumbing(raw["identity_set_id"]),
			KeyType:                          convertStringToPlumbing(raw["key_type"]),
			Name:                             convertStringToPlumbing(raw["name"]),
			Port:                             convertInt32ToPlumbing(raw["port"]),
			PortForwarding:                   convertBoolToPlumbing(raw["port_forwarding"]),
			PortOverride:                     convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:                   convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:                    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                        convertStringToPlumbing(raw["subdomain"]),
			Tags:                             convertTagsToPlumbing(raw["tags"]),
			Username:                         convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("ssh_customer_key").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.SSHCustomerKey{}
		}
		out := &sdm.SSHCustomerKey{
			ID:                               d.Id(),
			AllowDeprecatedKeyExchanges:      convertBoolToPlumbing(raw["allow_deprecated_key_exchanges"]),
			BindInterface:                    convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:                     convertStringToPlumbing(raw["egress_filter"]),
			Hostname:                         convertStringToPlumbing(raw["hostname"]),
			IdentityAliasHealthcheckUsername: convertStringToPlumbing(raw["identity_alias_healthcheck_username"]),
			IdentitySetID:                    convertStringToPlumbing(raw["identity_set_id"]),
			Name:                             convertStringToPlumbing(raw["name"]),
			Port:                             convertInt32ToPlumbing(raw["port"]),
			PortForwarding:                   convertBoolToPlumbing(raw["port_forwarding"]),
			PortOverride:                     convertInt32ToPlumbing(raw["port_override"]),
			PrivateKey:                       convertStringToPlumbing(raw["private_key"]),
			ProxyClusterID:                   convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:                    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                        convertStringToPlumbing(raw["subdomain"]),
			Tags:                             convertTagsToPlumbing(raw["tags"]),
			Username:                         convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("ssh_password").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.SSHPassword{}
		}
		out := &sdm.SSHPassword{
			ID:                          d.Id(),
			AllowDeprecatedKeyExchanges: convertBoolToPlumbing(raw["allow_deprecated_key_exchanges"]),
			BindInterface:               convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:                convertStringToPlumbing(raw["egress_filter"]),
			Hostname:                    convertStringToPlumbing(raw["hostname"]),
			Name:                        convertStringToPlumbing(raw["name"]),
			Password:                    convertStringToPlumbing(raw["password"]),
			Port:                        convertInt32ToPlumbing(raw["port"]),
			PortForwarding:              convertBoolToPlumbing(raw["port_forwarding"]),
			PortOverride:                convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID:              convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:               convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                   convertStringToPlumbing(raw["subdomain"]),
			Tags:                        convertTagsToPlumbing(raw["tags"]),
			Username:                    convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("sybase").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Sybase{}
		}
		out := &sdm.Sybase{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("sybase_iq").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.SybaseIQ{}
		}
		out := &sdm.SybaseIQ{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("teradata").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Teradata{}
		}
		out := &sdm.Teradata{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("trino").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Trino{}
		}
		out := &sdm.Trino{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			Database:       convertStringToPlumbing(raw["database"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("vertica").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Vertica{}
		}
		out := &sdm.Vertica{
			ID:             d.Id(),
			BindInterface:  convertStringToPlumbing(raw["bind_interface"]),
			Database:       convertStringToPlumbing(raw["database"]),
			EgressFilter:   convertStringToPlumbing(raw["egress_filter"]),
			Hostname:       convertStringToPlumbing(raw["hostname"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Password:       convertStringToPlumbing(raw["password"]),
			Port:           convertInt32ToPlumbing(raw["port"]),
			PortOverride:   convertInt32ToPlumbing(raw["port_override"]),
			ProxyClusterID: convertStringToPlumbing(raw["proxy_cluster_id"]),
			SecretStoreID:  convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:      convertStringToPlumbing(raw["subdomain"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
			Username:       convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	return nil
}

func resourceResourceCreate(ctx context.Context, d *schema.ResourceData, cc *sdm.Client) error {
	ctx, cancel := context.WithTimeout(ctx, d.Timeout(schema.TimeoutCreate))
	defer cancel()
	localVersion := convertResourceToPlumbing(d)
	seValues, err := secretStoreValuesForResource(d)
	if err != nil {
		return fmt.Errorf("cannot create Resource: %w", err)
	}
	resp, err := cc.Resources().Create(ctx, localVersion)
	if err != nil {
		return fmt.Errorf("cannot create Resource: %w", err)
	}
	d.SetId(resp.Resource.GetID())
	switch v := resp.Resource.(type) {
	case *sdm.Aerospike:
		localV, _ := localVersion.(*sdm.Aerospike)
		_ = localV
		d.Set("aerospike", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"username":         seValues["username"],
			},
		})
	case *sdm.AKS:
		localV, _ := localVersion.(*sdm.AKS)
		_ = localV
		d.Set("aks", []map[string]interface{}{
			{
				"allow_resource_role_bypass":          (v.AllowResourceRoleBypass),
				"bind_interface":                      (v.BindInterface),
				"certificate_authority":               seValues["certificate_authority"],
				"client_certificate":                  seValues["client_certificate"],
				"client_key":                          seValues["client_key"],
				"discovery_enabled":                   (v.DiscoveryEnabled),
				"discovery_username":                  (v.DiscoveryUsername),
				"egress_filter":                       (v.EgressFilter),
				"healthcheck_namespace":               (v.HealthcheckNamespace),
				"hostname":                            (v.Hostname),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port":                                (v.Port),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AKSBasicAuth:
		localV, _ := localVersion.(*sdm.AKSBasicAuth)
		_ = localV
		d.Set("aks_basic_auth", []map[string]interface{}{
			{
				"bind_interface":        (v.BindInterface),
				"egress_filter":         (v.EgressFilter),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"hostname":              (v.Hostname),
				"name":                  (v.Name),
				"password":              seValues["password"],
				"port":                  (v.Port),
				"port_override":         (v.PortOverride),
				"proxy_cluster_id":      (v.ProxyClusterID),
				"secret_store_id":       (v.SecretStoreID),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
				"username":              seValues["username"],
			},
		})
	case *sdm.AKSServiceAccount:
		localV, _ := localVersion.(*sdm.AKSServiceAccount)
		_ = localV
		d.Set("aks_service_account", []map[string]interface{}{
			{
				"allow_resource_role_bypass":          (v.AllowResourceRoleBypass),
				"bind_interface":                      (v.BindInterface),
				"discovery_enabled":                   (v.DiscoveryEnabled),
				"discovery_username":                  (v.DiscoveryUsername),
				"egress_filter":                       (v.EgressFilter),
				"healthcheck_namespace":               (v.HealthcheckNamespace),
				"hostname":                            (v.Hostname),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port":                                (v.Port),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
				"token":                               seValues["token"],
			},
		})
	case *sdm.AKSServiceAccountUserImpersonation:
		localV, _ := localVersion.(*sdm.AKSServiceAccountUserImpersonation)
		_ = localV
		d.Set("aks_service_account_user_impersonation", []map[string]interface{}{
			{
				"bind_interface":        (v.BindInterface),
				"egress_filter":         (v.EgressFilter),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"hostname":              (v.Hostname),
				"name":                  (v.Name),
				"port":                  (v.Port),
				"port_override":         (v.PortOverride),
				"proxy_cluster_id":      (v.ProxyClusterID),
				"secret_store_id":       (v.SecretStoreID),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
				"token":                 seValues["token"],
			},
		})
	case *sdm.AKSUserImpersonation:
		localV, _ := localVersion.(*sdm.AKSUserImpersonation)
		_ = localV
		d.Set("aks_user_impersonation", []map[string]interface{}{
			{
				"bind_interface":        (v.BindInterface),
				"certificate_authority": seValues["certificate_authority"],
				"client_certificate":    seValues["client_certificate"],
				"client_key":            seValues["client_key"],
				"egress_filter":         (v.EgressFilter),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"hostname":              (v.Hostname),
				"name":                  (v.Name),
				"port":                  (v.Port),
				"port_override":         (v.PortOverride),
				"proxy_cluster_id":      (v.ProxyClusterID),
				"secret_store_id":       (v.SecretStoreID),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AmazonEKS:
		localV, _ := localVersion.(*sdm.AmazonEKS)
		_ = localV
		d.Set("amazon_eks", []map[string]interface{}{
			{
				"access_key":                          seValues["access_key"],
				"allow_resource_role_bypass":          (v.AllowResourceRoleBypass),
				"bind_interface":                      (v.BindInterface),
				"certificate_authority":               seValues["certificate_authority"],
				"cluster_name":                        (v.ClusterName),
				"discovery_enabled":                   (v.DiscoveryEnabled),
				"discovery_username":                  (v.DiscoveryUsername),
				"egress_filter":                       (v.EgressFilter),
				"endpoint":                            (v.Endpoint),
				"healthcheck_namespace":               (v.HealthcheckNamespace),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"region":                              (v.Region),
				"role_arn":                            seValues["role_arn"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_access_key":                   seValues["secret_access_key"],
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AmazonEKSInstanceProfile:
		localV, _ := localVersion.(*sdm.AmazonEKSInstanceProfile)
		_ = localV
		d.Set("amazon_eks_instance_profile", []map[string]interface{}{
			{
				"allow_resource_role_bypass":          (v.AllowResourceRoleBypass),
				"bind_interface":                      (v.BindInterface),
				"certificate_authority":               seValues["certificate_authority"],
				"cluster_name":                        (v.ClusterName),
				"discovery_enabled":                   (v.DiscoveryEnabled),
				"discovery_username":                  (v.DiscoveryUsername),
				"egress_filter":                       (v.EgressFilter),
				"endpoint":                            (v.Endpoint),
				"healthcheck_namespace":               (v.HealthcheckNamespace),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"region":                              (v.Region),
				"role_arn":                            seValues["role_arn"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AmazonEKSInstanceProfileUserImpersonation:
		localV, _ := localVersion.(*sdm.AmazonEKSInstanceProfileUserImpersonation)
		_ = localV
		d.Set("amazon_eks_instance_profile_user_impersonation", []map[string]interface{}{
			{
				"bind_interface":        (v.BindInterface),
				"certificate_authority": seValues["certificate_authority"],
				"cluster_name":          (v.ClusterName),
				"egress_filter":         (v.EgressFilter),
				"endpoint":              (v.Endpoint),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"name":                  (v.Name),
				"port_override":         (v.PortOverride),
				"proxy_cluster_id":      (v.ProxyClusterID),
				"region":                (v.Region),
				"role_arn":              seValues["role_arn"],
				"role_external_id":      seValues["role_external_id"],
				"secret_store_id":       (v.SecretStoreID),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AmazonEKSUserImpersonation:
		localV, _ := localVersion.(*sdm.AmazonEKSUserImpersonation)
		_ = localV
		d.Set("amazon_eks_user_impersonation", []map[string]interface{}{
			{
				"access_key":            seValues["access_key"],
				"bind_interface":        (v.BindInterface),
				"certificate_authority": seValues["certificate_authority"],
				"cluster_name":          (v.ClusterName),
				"egress_filter":         (v.EgressFilter),
				"endpoint":              (v.Endpoint),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"name":                  (v.Name),
				"port_override":         (v.PortOverride),
				"proxy_cluster_id":      (v.ProxyClusterID),
				"region":                (v.Region),
				"role_arn":              seValues["role_arn"],
				"role_external_id":      seValues["role_external_id"],
				"secret_access_key":     seValues["secret_access_key"],
				"secret_store_id":       (v.SecretStoreID),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AmazonES:
		localV, _ := localVersion.(*sdm.AmazonES)
		_ = localV
		d.Set("amazon_es", []map[string]interface{}{
			{
				"access_key":        seValues["access_key"],
				"bind_interface":    (v.BindInterface),
				"egress_filter":     (v.EgressFilter),
				"endpoint":          (v.Endpoint),
				"name":              (v.Name),
				"port_override":     (v.PortOverride),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"region":            (v.Region),
				"role_arn":          seValues["role_arn"],
				"role_external_id":  seValues["role_external_id"],
				"secret_access_key": seValues["secret_access_key"],
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AmazonESIAM:
		localV, _ := localVersion.(*sdm.AmazonESIAM)
		_ = localV
		d.Set("amazon_esiam", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"endpoint":         (v.Endpoint),
				"name":             (v.Name),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"region":           (v.Region),
				"role_arn":         seValues["role_arn"],
				"role_external_id": seValues["role_external_id"],
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
			},
		})
	case *sdm.AmazonMQAMQP091:
		localV, _ := localVersion.(*sdm.AmazonMQAMQP091)
		_ = localV
		d.Set("amazonmq_amqp_091", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.Athena:
		localV, _ := localVersion.(*sdm.Athena)
		_ = localV
		d.Set("athena", []map[string]interface{}{
			{
				"access_key":        seValues["access_key"],
				"bind_interface":    (v.BindInterface),
				"egress_filter":     (v.EgressFilter),
				"name":              (v.Name),
				"output":            (v.Output),
				"port_override":     (v.PortOverride),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"region":            (v.Region),
				"role_arn":          seValues["role_arn"],
				"role_external_id":  seValues["role_external_id"],
				"secret_access_key": seValues["secret_access_key"],
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AthenaIAM:
		localV, _ := localVersion.(*sdm.AthenaIAM)
		_ = localV
		d.Set("athena_iam", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"name":             (v.Name),
				"output":           (v.Output),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"region":           (v.Region),
				"role_arn":         seValues["role_arn"],
				"role_external_id": seValues["role_external_id"],
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AuroraMysql:
		localV, _ := localVersion.(*sdm.AuroraMysql)
		_ = localV
		d.Set("aurora_mysql", []map[string]interface{}{
			{
				"bind_interface":                    (v.BindInterface),
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"name":                              (v.Name),
				"password":                          seValues["password"],
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"proxy_cluster_id":                  (v.ProxyClusterID),
				"require_native_auth":               (v.RequireNativeAuth),
				"secret_store_id":                   (v.SecretStoreID),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          seValues["username"],
			},
		})
	case *sdm.AuroraMysqlIAM:
		localV, _ := localVersion.(*sdm.AuroraMysqlIAM)
		_ = localV
		d.Set("aurora_mysql_iam", []map[string]interface{}{
			{
				"bind_interface":      (v.BindInterface),
				"database":            (v.Database),
				"egress_filter":       (v.EgressFilter),
				"hostname":            (v.Hostname),
				"name":                (v.Name),
				"port":                (v.Port),
				"port_override":       (v.PortOverride),
				"proxy_cluster_id":    (v.ProxyClusterID),
				"region":              (v.Region),
				"role_assumption_arn": (v.RoleAssumptionArn),
				"secret_store_id":     (v.SecretStoreID),
				"subdomain":           (v.Subdomain),
				"tags":                convertTagsToPorcelain(v.Tags),
				"username":            seValues["username"],
			},
		})
	case *sdm.AuroraPostgres:
		localV, _ := localVersion.(*sdm.AuroraPostgres)
		_ = localV
		d.Set("aurora_postgres", []map[string]interface{}{
			{
				"bind_interface":    (v.BindInterface),
				"database":          (v.Database),
				"egress_filter":     (v.EgressFilter),
				"hostname":          (v.Hostname),
				"name":              (v.Name),
				"override_database": (v.OverrideDatabase),
				"password":          seValues["password"],
				"port":              (v.Port),
				"port_override":     (v.PortOverride),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"username":          seValues["username"],
			},
		})
	case *sdm.AuroraPostgresIAM:
		localV, _ := localVersion.(*sdm.AuroraPostgresIAM)
		_ = localV
		d.Set("aurora_postgres_iam", []map[string]interface{}{
			{
				"bind_interface":      (v.BindInterface),
				"database":            (v.Database),
				"egress_filter":       (v.EgressFilter),
				"hostname":            (v.Hostname),
				"name":                (v.Name),
				"override_database":   (v.OverrideDatabase),
				"port":                (v.Port),
				"port_override":       (v.PortOverride),
				"proxy_cluster_id":    (v.ProxyClusterID),
				"region":              (v.Region),
				"role_assumption_arn": (v.RoleAssumptionArn),
				"secret_store_id":     (v.SecretStoreID),
				"subdomain":           (v.Subdomain),
				"tags":                convertTagsToPorcelain(v.Tags),
				"username":            seValues["username"],
			},
		})
	case *sdm.AWS:
		localV, _ := localVersion.(*sdm.AWS)
		_ = localV
		d.Set("aws", []map[string]interface{}{
			{
				"access_key":         seValues["access_key"],
				"bind_interface":     (v.BindInterface),
				"egress_filter":      (v.EgressFilter),
				"healthcheck_region": (v.HealthcheckRegion),
				"name":               (v.Name),
				"port_override":      (v.PortOverride),
				"proxy_cluster_id":   (v.ProxyClusterID),
				"role_arn":           seValues["role_arn"],
				"role_external_id":   seValues["role_external_id"],
				"secret_access_key":  seValues["secret_access_key"],
				"secret_store_id":    (v.SecretStoreID),
				"subdomain":          (v.Subdomain),
				"tags":               convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AWSConsole:
		localV, _ := localVersion.(*sdm.AWSConsole)
		_ = localV
		d.Set("aws_console", []map[string]interface{}{
			{
				"bind_interface":                      (v.BindInterface),
				"egress_filter":                       (v.EgressFilter),
				"enable_env_variables":                (v.EnableEnvVariables),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"region":                              (v.Region),
				"role_arn":                            seValues["role_arn"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_store_id":                     (v.SecretStoreID),
				"session_expiry":                      (v.SessionExpiry),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AWSConsoleStaticKeyPair:
		localV, _ := localVersion.(*sdm.AWSConsoleStaticKeyPair)
		_ = localV
		d.Set("aws_console_static_key_pair", []map[string]interface{}{
			{
				"access_key":                          seValues["access_key"],
				"bind_interface":                      (v.BindInterface),
				"egress_filter":                       (v.EgressFilter),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"region":                              (v.Region),
				"role_arn":                            seValues["role_arn"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_access_key":                   seValues["secret_access_key"],
				"secret_store_id":                     (v.SecretStoreID),
				"session_expiry":                      (v.SessionExpiry),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AWSInstanceProfile:
		localV, _ := localVersion.(*sdm.AWSInstanceProfile)
		_ = localV
		d.Set("aws_instance_profile", []map[string]interface{}{
			{
				"bind_interface":       (v.BindInterface),
				"egress_filter":        (v.EgressFilter),
				"enable_env_variables": (v.EnableEnvVariables),
				"name":                 (v.Name),
				"port_override":        (v.PortOverride),
				"proxy_cluster_id":     (v.ProxyClusterID),
				"region":               (v.Region),
				"role_arn":             seValues["role_arn"],
				"role_external_id":     seValues["role_external_id"],
				"secret_store_id":      (v.SecretStoreID),
				"subdomain":            (v.Subdomain),
				"tags":                 convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Azure:
		localV, _ := localVersion.(*sdm.Azure)
		_ = localV
		d.Set("azure", []map[string]interface{}{
			{
				"app_id":           seValues["app_id"],
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tenant_id":        seValues["tenant_id"],
			},
		})
	case *sdm.AzureCertificate:
		localV, _ := localVersion.(*sdm.AzureCertificate)
		_ = localV
		d.Set("azure_certificate", []map[string]interface{}{
			{
				"app_id":             seValues["app_id"],
				"bind_interface":     (v.BindInterface),
				"client_certificate": seValues["client_certificate"],
				"egress_filter":      (v.EgressFilter),
				"name":               (v.Name),
				"port_override":      (v.PortOverride),
				"proxy_cluster_id":   (v.ProxyClusterID),
				"secret_store_id":    (v.SecretStoreID),
				"subdomain":          (v.Subdomain),
				"tags":               convertTagsToPorcelain(v.Tags),
				"tenant_id":          seValues["tenant_id"],
			},
		})
	case *sdm.AzureMysql:
		localV, _ := localVersion.(*sdm.AzureMysql)
		_ = localV
		d.Set("azure_mysql", []map[string]interface{}{
			{
				"bind_interface":                    (v.BindInterface),
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"name":                              (v.Name),
				"password":                          seValues["password"],
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"proxy_cluster_id":                  (v.ProxyClusterID),
				"require_native_auth":               (v.RequireNativeAuth),
				"secret_store_id":                   (v.SecretStoreID),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          seValues["username"],
			},
		})
	case *sdm.AzurePostgres:
		localV, _ := localVersion.(*sdm.AzurePostgres)
		_ = localV
		d.Set("azure_postgres", []map[string]interface{}{
			{
				"bind_interface":    (v.BindInterface),
				"database":          (v.Database),
				"egress_filter":     (v.EgressFilter),
				"hostname":          (v.Hostname),
				"name":              (v.Name),
				"override_database": (v.OverrideDatabase),
				"password":          seValues["password"],
				"port":              (v.Port),
				"port_override":     (v.PortOverride),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"username":          seValues["username"],
			},
		})
	case *sdm.AzurePostgresManagedIdentity:
		localV, _ := localVersion.(*sdm.AzurePostgresManagedIdentity)
		_ = localV
		d.Set("azure_postgres_managed_identity", []map[string]interface{}{
			{
				"bind_interface":                    (v.BindInterface),
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"name":                              (v.Name),
				"override_database":                 (v.OverrideDatabase),
				"password":                          seValues["password"],
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"proxy_cluster_id":                  (v.ProxyClusterID),
				"secret_store_id":                   (v.SecretStoreID),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          seValues["username"],
			},
		})
	case *sdm.BigQuery:
		localV, _ := localVersion.(*sdm.BigQuery)
		_ = localV
		d.Set("big_query", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"endpoint":         (v.Endpoint),
				"name":             (v.Name),
				"port_override":    (v.PortOverride),
				"private_key":      seValues["private_key"],
				"project":          (v.Project),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"username":         (v.Username),
			},
		})
	case *sdm.Cassandra:
		localV, _ := localVersion.(*sdm.Cassandra)
		_ = localV
		d.Set("cassandra", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.Citus:
		localV, _ := localVersion.(*sdm.Citus)
		_ = localV
		d.Set("citus", []map[string]interface{}{
			{
				"bind_interface":    (v.BindInterface),
				"database":          (v.Database),
				"egress_filter":     (v.EgressFilter),
				"hostname":          (v.Hostname),
				"name":              (v.Name),
				"override_database": (v.OverrideDatabase),
				"password":          seValues["password"],
				"port":              (v.Port),
				"port_override":     (v.PortOverride),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"username":          seValues["username"],
			},
		})
	case *sdm.ClickHouseHTTP:
		localV, _ := localVersion.(*sdm.ClickHouseHTTP)
		_ = localV
		d.Set("click_house_http", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"database":         (v.Database),
				"egress_filter":    (v.EgressFilter),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"tags":             convertTagsToPorcelain(v.Tags),
				"url":              (v.Url),
				"username":         seValues["username"],
			},
		})
	case *sdm.ClickHouseMySQL:
		localV, _ := localVersion.(*sdm.ClickHouseMySQL)
		_ = localV
		d.Set("click_house_my_sql", []map[string]interface{}{
			{
				"bind_interface":      (v.BindInterface),
				"database":            (v.Database),
				"egress_filter":       (v.EgressFilter),
				"hostname":            (v.Hostname),
				"name":                (v.Name),
				"password":            seValues["password"],
				"port":                (v.Port),
				"port_override":       (v.PortOverride),
				"proxy_cluster_id":    (v.ProxyClusterID),
				"require_native_auth": (v.RequireNativeAuth),
				"secret_store_id":     (v.SecretStoreID),
				"subdomain":           (v.Subdomain),
				"tags":                convertTagsToPorcelain(v.Tags),
				"username":            seValues["username"],
			},
		})
	case *sdm.ClickHouseTCP:
		localV, _ := localVersion.(*sdm.ClickHouseTCP)
		_ = localV
		d.Set("click_house_tcp", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"database":         (v.Database),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.Clustrix:
		localV, _ := localVersion.(*sdm.Clustrix)
		_ = localV
		d.Set("clustrix", []map[string]interface{}{
			{
				"bind_interface":                    (v.BindInterface),
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"name":                              (v.Name),
				"password":                          seValues["password"],
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"proxy_cluster_id":                  (v.ProxyClusterID),
				"require_native_auth":               (v.RequireNativeAuth),
				"secret_store_id":                   (v.SecretStoreID),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          seValues["username"],
			},
		})
	case *sdm.Cockroach:
		localV, _ := localVersion.(*sdm.Cockroach)
		_ = localV
		d.Set("cockroach", []map[string]interface{}{
			{
				"bind_interface":    (v.BindInterface),
				"database":          (v.Database),
				"egress_filter":     (v.EgressFilter),
				"hostname":          (v.Hostname),
				"name":              (v.Name),
				"override_database": (v.OverrideDatabase),
				"password":          seValues["password"],
				"port":              (v.Port),
				"port_override":     (v.PortOverride),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"username":          seValues["username"],
			},
		})
	case *sdm.CouchbaseDatabase:
		localV, _ := localVersion.(*sdm.CouchbaseDatabase)
		_ = localV
		d.Set("couchbase_database", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"n_1_ql_port":      (v.N1QlPort),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.CouchbaseWebUI:
		localV, _ := localVersion.(*sdm.CouchbaseWebUI)
		_ = localV
		d.Set("couchbase_web_ui", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"url":              (v.Url),
				"username":         seValues["username"],
			},
		})
	case *sdm.DB2I:
		localV, _ := localVersion.(*sdm.DB2I)
		_ = localV
		d.Set("db_2_i", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.DB2LUW:
		localV, _ := localVersion.(*sdm.DB2LUW)
		_ = localV
		d.Set("db_2_luw", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"database":         (v.Database),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"username":         seValues["username"],
			},
		})
	case *sdm.DocumentDBHost:
		localV, _ := localVersion.(*sdm.DocumentDBHost)
		_ = localV
		d.Set("document_db_host", []map[string]interface{}{
			{
				"auth_database":    (v.AuthDatabase),
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"username":         seValues["username"],
			},
		})
	case *sdm.DocumentDBHostIAM:
		localV, _ := localVersion.(*sdm.DocumentDBHostIAM)
		_ = localV
		d.Set("document_db_host_iam", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"region":           (v.Region),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.DocumentDBReplicaSet:
		localV, _ := localVersion.(*sdm.DocumentDBReplicaSet)
		_ = localV
		d.Set("document_db_replica_set", []map[string]interface{}{
			{
				"auth_database":      (v.AuthDatabase),
				"bind_interface":     (v.BindInterface),
				"connect_to_replica": (v.ConnectToReplica),
				"egress_filter":      (v.EgressFilter),
				"hostname":           (v.Hostname),
				"name":               (v.Name),
				"password":           seValues["password"],
				"port_override":      (v.PortOverride),
				"proxy_cluster_id":   (v.ProxyClusterID),
				"replica_set":        (v.ReplicaSet),
				"secret_store_id":    (v.SecretStoreID),
				"subdomain":          (v.Subdomain),
				"tags":               convertTagsToPorcelain(v.Tags),
				"username":           seValues["username"],
			},
		})
	case *sdm.DocumentDBReplicaSetIAM:
		localV, _ := localVersion.(*sdm.DocumentDBReplicaSetIAM)
		_ = localV
		d.Set("document_db_replica_set_iam", []map[string]interface{}{
			{
				"bind_interface":     (v.BindInterface),
				"connect_to_replica": (v.ConnectToReplica),
				"egress_filter":      (v.EgressFilter),
				"hostname":           (v.Hostname),
				"name":               (v.Name),
				"port_override":      (v.PortOverride),
				"proxy_cluster_id":   (v.ProxyClusterID),
				"region":             (v.Region),
				"secret_store_id":    (v.SecretStoreID),
				"subdomain":          (v.Subdomain),
				"tags":               convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Druid:
		localV, _ := localVersion.(*sdm.Druid)
		_ = localV
		d.Set("druid", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"username":         seValues["username"],
			},
		})
	case *sdm.DynamoDB:
		localV, _ := localVersion.(*sdm.DynamoDB)
		_ = localV
		d.Set("dynamo_db", []map[string]interface{}{
			{
				"access_key":        seValues["access_key"],
				"bind_interface":    (v.BindInterface),
				"egress_filter":     (v.EgressFilter),
				"endpoint":          (v.Endpoint),
				"name":              (v.Name),
				"port_override":     (v.PortOverride),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"region":            (v.Region),
				"role_arn":          seValues["role_arn"],
				"role_external_id":  seValues["role_external_id"],
				"secret_access_key": seValues["secret_access_key"],
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.DynamoDBIAM:
		localV, _ := localVersion.(*sdm.DynamoDBIAM)
		_ = localV
		d.Set("dynamo_dbiam", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"endpoint":         (v.Endpoint),
				"name":             (v.Name),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"region":           (v.Region),
				"role_arn":         seValues["role_arn"],
				"role_external_id": seValues["role_external_id"],
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Elastic:
		localV, _ := localVersion.(*sdm.Elastic)
		_ = localV
		d.Set("elastic", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.ElasticacheRedis:
		localV, _ := localVersion.(*sdm.ElasticacheRedis)
		_ = localV
		d.Set("elasticache_redis", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.GCP:
		localV, _ := localVersion.(*sdm.GCP)
		_ = localV
		d.Set("gcp", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"keyfile":          seValues["keyfile"],
				"name":             (v.Name),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"scopes":           (v.Scopes),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.GCPConsole:
		localV, _ := localVersion.(*sdm.GCPConsole)
		_ = localV
		d.Set("gcp_console", []map[string]interface{}{
			{
				"bind_interface":                      (v.BindInterface),
				"egress_filter":                       (v.EgressFilter),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"secret_store_id":                     (v.SecretStoreID),
				"session_expiry":                      (v.SessionExpiry),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
				"workforce_pool_id":                   (v.WorkforcePoolID),
				"workforce_provider_id":               (v.WorkforceProviderID),
			},
		})
	case *sdm.GCPWIF:
		localV, _ := localVersion.(*sdm.GCPWIF)
		_ = localV
		d.Set("gcpwif", []map[string]interface{}{
			{
				"bind_interface":                      (v.BindInterface),
				"egress_filter":                       (v.EgressFilter),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"project_id":                          (v.ProjectID),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"scopes":                              (v.Scopes),
				"secret_store_id":                     (v.SecretStoreID),
				"session_expiry":                      (v.SessionExpiry),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
				"workforce_pool_id":                   (v.WorkforcePoolID),
				"workforce_provider_id":               (v.WorkforceProviderID),
			},
		})
	case *sdm.GoogleGKE:
		localV, _ := localVersion.(*sdm.GoogleGKE)
		_ = localV
		d.Set("google_gke", []map[string]interface{}{
			{
				"allow_resource_role_bypass":          (v.AllowResourceRoleBypass),
				"bind_interface":                      (v.BindInterface),
				"certificate_authority":               seValues["certificate_authority"],
				"discovery_enabled":                   (v.DiscoveryEnabled),
				"discovery_username":                  (v.DiscoveryUsername),
				"egress_filter":                       (v.EgressFilter),
				"endpoint":                            (v.Endpoint),
				"healthcheck_namespace":               (v.HealthcheckNamespace),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"secret_store_id":                     (v.SecretStoreID),
				"service_account_key":                 seValues["service_account_key"],
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.GoogleGKEUserImpersonation:
		localV, _ := localVersion.(*sdm.GoogleGKEUserImpersonation)
		_ = localV
		d.Set("google_gke_user_impersonation", []map[string]interface{}{
			{
				"bind_interface":        (v.BindInterface),
				"certificate_authority": seValues["certificate_authority"],
				"egress_filter":         (v.EgressFilter),
				"endpoint":              (v.Endpoint),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"name":                  (v.Name),
				"port_override":         (v.PortOverride),
				"proxy_cluster_id":      (v.ProxyClusterID),
				"secret_store_id":       (v.SecretStoreID),
				"service_account_key":   seValues["service_account_key"],
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Greenplum:
		localV, _ := localVersion.(*sdm.Greenplum)
		_ = localV
		d.Set("greenplum", []map[string]interface{}{
			{
				"bind_interface":    (v.BindInterface),
				"database":          (v.Database),
				"egress_filter":     (v.EgressFilter),
				"hostname":          (v.Hostname),
				"name":              (v.Name),
				"override_database": (v.OverrideDatabase),
				"password":          seValues["password"],
				"port":              (v.Port),
				"port_override":     (v.PortOverride),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"username":          seValues["username"],
			},
		})
	case *sdm.HTTPAuth:
		localV, _ := localVersion.(*sdm.HTTPAuth)
		_ = localV
		d.Set("http_auth", []map[string]interface{}{
			{
				"auth_header":       seValues["auth_header"],
				"bind_interface":    (v.BindInterface),
				"default_path":      (v.DefaultPath),
				"egress_filter":     (v.EgressFilter),
				"headers_blacklist": (v.HeadersBlacklist),
				"healthcheck_path":  (v.HealthcheckPath),
				"host_override":     (v.HostOverride),
				"name":              (v.Name),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"url":               (v.Url),
			},
		})
	case *sdm.HTTPBasicAuth:
		localV, _ := localVersion.(*sdm.HTTPBasicAuth)
		_ = localV
		d.Set("http_basic_auth", []map[string]interface{}{
			{
				"bind_interface":    (v.BindInterface),
				"default_path":      (v.DefaultPath),
				"egress_filter":     (v.EgressFilter),
				"headers_blacklist": (v.HeadersBlacklist),
				"healthcheck_path":  (v.HealthcheckPath),
				"host_override":     (v.HostOverride),
				"name":              (v.Name),
				"password":          seValues["password"],
				"proxy_cluster_id":  (v.ProxyClusterID),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"url":               (v.Url),
				"username":          seValues["username"],
			},
		})
	case *sdm.HTTPNoAuth:
		localV, _ := localVersion.(*sdm.HTTPNoAuth)
		_ = localV
		d.Set("http_no_auth", []map[string]interface{}{
			{
				"bind_interface":    (v.BindInterface),
				"default_path":      (v.DefaultPath),
				"egress_filter":     (v.EgressFilter),
				"headers_blacklist": (v.HeadersBlacklist),
				"healthcheck_path":  (v.HealthcheckPath),
				"host_override":     (v.HostOverride),
				"name":              (v.Name),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"url":               (v.Url),
			},
		})
	case *sdm.Kubernetes:
		localV, _ := localVersion.(*sdm.Kubernetes)
		_ = localV
		d.Set("kubernetes", []map[string]interface{}{
			{
				"allow_resource_role_bypass":          (v.AllowResourceRoleBypass),
				"bind_interface":                      (v.BindInterface),
				"certificate_authority":               seValues["certificate_authority"],
				"client_certificate":                  seValues["client_certificate"],
				"client_key":                          seValues["client_key"],
				"discovery_enabled":                   (v.DiscoveryEnabled),
				"discovery_username":                  (v.DiscoveryUsername),
				"egress_filter":                       (v.EgressFilter),
				"healthcheck_namespace":               (v.HealthcheckNamespace),
				"hostname":                            (v.Hostname),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port":                                (v.Port),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.KubernetesBasicAuth:
		localV, _ := localVersion.(*sdm.KubernetesBasicAuth)
		_ = localV
		d.Set("kubernetes_basic_auth", []map[string]interface{}{
			{
				"bind_interface":        (v.BindInterface),
				"egress_filter":         (v.EgressFilter),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"hostname":              (v.Hostname),
				"name":                  (v.Name),
				"password":              seValues["password"],
				"port":                  (v.Port),
				"port_override":         (v.PortOverride),
				"proxy_cluster_id":      (v.ProxyClusterID),
				"secret_store_id":       (v.SecretStoreID),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
				"username":              seValues["username"],
			},
		})
	case *sdm.KubernetesPodIdentity:
		localV, _ := localVersion.(*sdm.KubernetesPodIdentity)
		_ = localV
		d.Set("kubernetes_pod_identity", []map[string]interface{}{
			{
				"allow_resource_role_bypass":          (v.AllowResourceRoleBypass),
				"bind_interface":                      (v.BindInterface),
				"certificate_authority":               seValues["certificate_authority"],
				"egress_filter":                       (v.EgressFilter),
				"healthcheck_namespace":               (v.HealthcheckNamespace),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.KubernetesServiceAccount:
		localV, _ := localVersion.(*sdm.KubernetesServiceAccount)
		_ = localV
		d.Set("kubernetes_service_account", []map[string]interface{}{
			{
				"allow_resource_role_bypass":          (v.AllowResourceRoleBypass),
				"bind_interface":                      (v.BindInterface),
				"discovery_enabled":                   (v.DiscoveryEnabled),
				"discovery_username":                  (v.DiscoveryUsername),
				"egress_filter":                       (v.EgressFilter),
				"healthcheck_namespace":               (v.HealthcheckNamespace),
				"hostname":                            (v.Hostname),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port":                                (v.Port),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
				"token":                               seValues["token"],
			},
		})
	case *sdm.KubernetesServiceAccountUserImpersonation:
		localV, _ := localVersion.(*sdm.KubernetesServiceAccountUserImpersonation)
		_ = localV
		d.Set("kubernetes_service_account_user_impersonation", []map[string]interface{}{
			{
				"bind_interface":        (v.BindInterface),
				"egress_filter":         (v.EgressFilter),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"hostname":              (v.Hostname),
				"name":                  (v.Name),
				"port":                  (v.Port),
				"port_override":         (v.PortOverride),
				"proxy_cluster_id":      (v.ProxyClusterID),
				"secret_store_id":       (v.SecretStoreID),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
				"token":                 seValues["token"],
			},
		})
	case *sdm.KubernetesUserImpersonation:
		localV, _ := localVersion.(*sdm.KubernetesUserImpersonation)
		_ = localV
		d.Set("kubernetes_user_impersonation", []map[string]interface{}{
			{
				"bind_interface":        (v.BindInterface),
				"certificate_authority": seValues["certificate_authority"],
				"client_certificate":    seValues["client_certificate"],
				"client_key":            seValues["client_key"],
				"egress_filter":         (v.EgressFilter),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"hostname":              (v.Hostname),
				"name":                  (v.Name),
				"port":                  (v.Port),
				"port_override":         (v.PortOverride),
				"proxy_cluster_id":      (v.ProxyClusterID),
				"secret_store_id":       (v.SecretStoreID),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Maria:
		localV, _ := localVersion.(*sdm.Maria)
		_ = localV
		d.Set("maria", []map[string]interface{}{
			{
				"bind_interface":                    (v.BindInterface),
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"name":                              (v.Name),
				"password":                          seValues["password"],
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"proxy_cluster_id":                  (v.ProxyClusterID),
				"require_native_auth":               (v.RequireNativeAuth),
				"secret_store_id":                   (v.SecretStoreID),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          seValues["username"],
			},
		})
	case *sdm.Memcached:
		localV, _ := localVersion.(*sdm.Memcached)
		_ = localV
		d.Set("memcached", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Memsql:
		localV, _ := localVersion.(*sdm.Memsql)
		_ = localV
		d.Set("memsql", []map[string]interface{}{
			{
				"bind_interface":                    (v.BindInterface),
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"name":                              (v.Name),
				"password":                          seValues["password"],
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"proxy_cluster_id":                  (v.ProxyClusterID),
				"require_native_auth":               (v.RequireNativeAuth),
				"secret_store_id":                   (v.SecretStoreID),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          seValues["username"],
			},
		})
	case *sdm.MongoHost:
		localV, _ := localVersion.(*sdm.MongoHost)
		_ = localV
		d.Set("mongo_host", []map[string]interface{}{
			{
				"auth_database":    (v.AuthDatabase),
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.MongoLegacyHost:
		localV, _ := localVersion.(*sdm.MongoLegacyHost)
		_ = localV
		d.Set("mongo_legacy_host", []map[string]interface{}{
			{
				"auth_database":    (v.AuthDatabase),
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.MongoLegacyReplicaset:
		localV, _ := localVersion.(*sdm.MongoLegacyReplicaset)
		_ = localV
		d.Set("mongo_legacy_replicaset", []map[string]interface{}{
			{
				"auth_database":      (v.AuthDatabase),
				"bind_interface":     (v.BindInterface),
				"connect_to_replica": (v.ConnectToReplica),
				"egress_filter":      (v.EgressFilter),
				"hostname":           (v.Hostname),
				"name":               (v.Name),
				"password":           seValues["password"],
				"port":               (v.Port),
				"port_override":      (v.PortOverride),
				"proxy_cluster_id":   (v.ProxyClusterID),
				"replica_set":        (v.ReplicaSet),
				"secret_store_id":    (v.SecretStoreID),
				"subdomain":          (v.Subdomain),
				"tags":               convertTagsToPorcelain(v.Tags),
				"tls_required":       (v.TlsRequired),
				"username":           seValues["username"],
			},
		})
	case *sdm.MongoReplicaSet:
		localV, _ := localVersion.(*sdm.MongoReplicaSet)
		_ = localV
		d.Set("mongo_replica_set", []map[string]interface{}{
			{
				"auth_database":      (v.AuthDatabase),
				"bind_interface":     (v.BindInterface),
				"connect_to_replica": (v.ConnectToReplica),
				"egress_filter":      (v.EgressFilter),
				"hostname":           (v.Hostname),
				"name":               (v.Name),
				"password":           seValues["password"],
				"port":               (v.Port),
				"port_override":      (v.PortOverride),
				"proxy_cluster_id":   (v.ProxyClusterID),
				"replica_set":        (v.ReplicaSet),
				"secret_store_id":    (v.SecretStoreID),
				"subdomain":          (v.Subdomain),
				"tags":               convertTagsToPorcelain(v.Tags),
				"tls_required":       (v.TlsRequired),
				"username":           seValues["username"],
			},
		})
	case *sdm.MongoShardedCluster:
		localV, _ := localVersion.(*sdm.MongoShardedCluster)
		_ = localV
		d.Set("mongo_sharded_cluster", []map[string]interface{}{
			{
				"auth_database":    (v.AuthDatabase),
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.MTLSMysql:
		localV, _ := localVersion.(*sdm.MTLSMysql)
		_ = localV
		d.Set("mtls_mysql", []map[string]interface{}{
			{
				"bind_interface":                    (v.BindInterface),
				"certificate_authority":             seValues["certificate_authority"],
				"client_certificate":                seValues["client_certificate"],
				"client_key":                        seValues["client_key"],
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"name":                              (v.Name),
				"password":                          seValues["password"],
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"proxy_cluster_id":                  (v.ProxyClusterID),
				"require_native_auth":               (v.RequireNativeAuth),
				"secret_store_id":                   (v.SecretStoreID),
				"server_name":                       (v.ServerName),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          seValues["username"],
			},
		})
	case *sdm.MTLSPostgres:
		localV, _ := localVersion.(*sdm.MTLSPostgres)
		_ = localV
		d.Set("mtls_postgres", []map[string]interface{}{
			{
				"bind_interface":        (v.BindInterface),
				"certificate_authority": seValues["certificate_authority"],
				"client_certificate":    seValues["client_certificate"],
				"client_key":            seValues["client_key"],
				"database":              (v.Database),
				"egress_filter":         (v.EgressFilter),
				"hostname":              (v.Hostname),
				"name":                  (v.Name),
				"override_database":     (v.OverrideDatabase),
				"password":              seValues["password"],
				"port":                  (v.Port),
				"port_override":         (v.PortOverride),
				"proxy_cluster_id":      (v.ProxyClusterID),
				"secret_store_id":       (v.SecretStoreID),
				"server_name":           (v.ServerName),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
				"username":              seValues["username"],
			},
		})
	case *sdm.Mysql:
		localV, _ := localVersion.(*sdm.Mysql)
		_ = localV
		d.Set("mysql", []map[string]interface{}{
			{
				"bind_interface":                    (v.BindInterface),
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"name":                              (v.Name),
				"password":                          seValues["password"],
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"proxy_cluster_id":                  (v.ProxyClusterID),
				"require_native_auth":               (v.RequireNativeAuth),
				"secret_store_id":                   (v.SecretStoreID),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          seValues["username"],
			},
		})
	case *sdm.Neptune:
		localV, _ := localVersion.(*sdm.Neptune)
		_ = localV
		d.Set("neptune", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"endpoint":         (v.Endpoint),
				"name":             (v.Name),
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.NeptuneIAM:
		localV, _ := localVersion.(*sdm.NeptuneIAM)
		_ = localV
		d.Set("neptune_iam", []map[string]interface{}{
			{
				"access_key":        seValues["access_key"],
				"bind_interface":    (v.BindInterface),
				"egress_filter":     (v.EgressFilter),
				"endpoint":          (v.Endpoint),
				"name":              (v.Name),
				"port":              (v.Port),
				"port_override":     (v.PortOverride),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"region":            (v.Region),
				"role_arn":          seValues["role_arn"],
				"role_external_id":  seValues["role_external_id"],
				"secret_access_key": seValues["secret_access_key"],
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Oracle:
		localV, _ := localVersion.(*sdm.Oracle)
		_ = localV
		d.Set("oracle", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"database":         (v.Database),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.OracleNNE:
		localV, _ := localVersion.(*sdm.OracleNNE)
		_ = localV
		d.Set("oracle_nne", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"database":         (v.Database),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"username":         seValues["username"],
			},
		})
	case *sdm.Postgres:
		localV, _ := localVersion.(*sdm.Postgres)
		_ = localV
		d.Set("postgres", []map[string]interface{}{
			{
				"bind_interface":    (v.BindInterface),
				"database":          (v.Database),
				"egress_filter":     (v.EgressFilter),
				"hostname":          (v.Hostname),
				"name":              (v.Name),
				"override_database": (v.OverrideDatabase),
				"password":          seValues["password"],
				"port":              (v.Port),
				"port_override":     (v.PortOverride),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"username":          seValues["username"],
			},
		})
	case *sdm.Presto:
		localV, _ := localVersion.(*sdm.Presto)
		_ = localV
		d.Set("presto", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"database":         (v.Database),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         (v.Username),
			},
		})
	case *sdm.RabbitMQAMQP091:
		localV, _ := localVersion.(*sdm.RabbitMQAMQP091)
		_ = localV
		d.Set("rabbitmq_amqp_091", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.RawTCP:
		localV, _ := localVersion.(*sdm.RawTCP)
		_ = localV
		d.Set("raw_tcp", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.RDP:
		localV, _ := localVersion.(*sdm.RDP)
		_ = localV
		d.Set("rdp", []map[string]interface{}{
			{
				"bind_interface":            (v.BindInterface),
				"downgrade_nla_connections": (v.DowngradeNlaConnections),
				"egress_filter":             (v.EgressFilter),
				"hostname":                  (v.Hostname),
				"lock_required":             (v.LockRequired),
				"name":                      (v.Name),
				"password":                  seValues["password"],
				"port":                      (v.Port),
				"port_override":             (v.PortOverride),
				"proxy_cluster_id":          (v.ProxyClusterID),
				"secret_store_id":           (v.SecretStoreID),
				"subdomain":                 (v.Subdomain),
				"tags":                      convertTagsToPorcelain(v.Tags),
				"username":                  seValues["username"],
			},
		})
	case *sdm.RDPCert:
		localV, _ := localVersion.(*sdm.RDPCert)
		_ = localV
		d.Set("rdp_cert", []map[string]interface{}{
			{
				"bind_interface":                      (v.BindInterface),
				"egress_filter":                       (v.EgressFilter),
				"hostname":                            (v.Hostname),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"lock_required":                       (v.LockRequired),
				"name":                                (v.Name),
				"port":                                (v.Port),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
				"username":                            seValues["username"],
			},
		})
	case *sdm.RDSPostgresIAM:
		localV, _ := localVersion.(*sdm.RDSPostgresIAM)
		_ = localV
		d.Set("rds_postgres_iam", []map[string]interface{}{
			{
				"bind_interface":      (v.BindInterface),
				"database":            (v.Database),
				"egress_filter":       (v.EgressFilter),
				"hostname":            (v.Hostname),
				"name":                (v.Name),
				"override_database":   (v.OverrideDatabase),
				"port":                (v.Port),
				"port_override":       (v.PortOverride),
				"proxy_cluster_id":    (v.ProxyClusterID),
				"region":              (v.Region),
				"role_assumption_arn": (v.RoleAssumptionArn),
				"secret_store_id":     (v.SecretStoreID),
				"subdomain":           (v.Subdomain),
				"tags":                convertTagsToPorcelain(v.Tags),
				"username":            seValues["username"],
			},
		})
	case *sdm.Redis:
		localV, _ := localVersion.(*sdm.Redis)
		_ = localV
		d.Set("redis", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.RedisCluster:
		localV, _ := localVersion.(*sdm.RedisCluster)
		_ = localV
		d.Set("redis_cluster", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.Redshift:
		localV, _ := localVersion.(*sdm.Redshift)
		_ = localV
		d.Set("redshift", []map[string]interface{}{
			{
				"bind_interface":    (v.BindInterface),
				"database":          (v.Database),
				"egress_filter":     (v.EgressFilter),
				"hostname":          (v.Hostname),
				"name":              (v.Name),
				"override_database": (v.OverrideDatabase),
				"password":          seValues["password"],
				"port":              (v.Port),
				"port_override":     (v.PortOverride),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"username":          seValues["username"],
			},
		})
	case *sdm.RedshiftIAM:
		localV, _ := localVersion.(*sdm.RedshiftIAM)
		_ = localV
		d.Set("redshift_iam", []map[string]interface{}{
			{
				"bind_interface":      (v.BindInterface),
				"cluster_id":          (v.ClusterID),
				"database":            (v.Database),
				"egress_filter":       (v.EgressFilter),
				"hostname":            (v.Hostname),
				"name":                (v.Name),
				"override_database":   (v.OverrideDatabase),
				"port":                (v.Port),
				"port_override":       (v.PortOverride),
				"proxy_cluster_id":    (v.ProxyClusterID),
				"region":              (v.Region),
				"role_assumption_arn": (v.RoleAssumptionArn),
				"secret_store_id":     (v.SecretStoreID),
				"subdomain":           (v.Subdomain),
				"tags":                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.RedshiftServerlessIAM:
		localV, _ := localVersion.(*sdm.RedshiftServerlessIAM)
		_ = localV
		d.Set("redshift_serverless_iam", []map[string]interface{}{
			{
				"bind_interface":      (v.BindInterface),
				"database":            (v.Database),
				"egress_filter":       (v.EgressFilter),
				"hostname":            (v.Hostname),
				"name":                (v.Name),
				"override_database":   (v.OverrideDatabase),
				"port":                (v.Port),
				"port_override":       (v.PortOverride),
				"proxy_cluster_id":    (v.ProxyClusterID),
				"region":              (v.Region),
				"role_assumption_arn": (v.RoleAssumptionArn),
				"secret_store_id":     (v.SecretStoreID),
				"subdomain":           (v.Subdomain),
				"tags":                convertTagsToPorcelain(v.Tags),
				"workgroup":           (v.Workgroup),
			},
		})
	case *sdm.SingleStore:
		localV, _ := localVersion.(*sdm.SingleStore)
		_ = localV
		d.Set("single_store", []map[string]interface{}{
			{
				"bind_interface":                    (v.BindInterface),
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"name":                              (v.Name),
				"password":                          seValues["password"],
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"proxy_cluster_id":                  (v.ProxyClusterID),
				"require_native_auth":               (v.RequireNativeAuth),
				"secret_store_id":                   (v.SecretStoreID),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          seValues["username"],
			},
		})
	case *sdm.Snowflake:
		localV, _ := localVersion.(*sdm.Snowflake)
		_ = localV
		d.Set("snowflake", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"database":         (v.Database),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"schema":           (v.Schema),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"username":         seValues["username"],
			},
		})
	case *sdm.Snowsight:
		localV, _ := localVersion.(*sdm.Snowsight)
		_ = localV
		d.Set("snowsight", []map[string]interface{}{
			{
				"bind_interface":       (v.BindInterface),
				"egress_filter":        (v.EgressFilter),
				"healthcheck_username": (v.HealthcheckUsername),
				"name":                 (v.Name),
				"port_override":        (v.PortOverride),
				"proxy_cluster_id":     (v.ProxyClusterID),
				"saml_metadata":        seValues["saml_metadata"],
				"secret_store_id":      (v.SecretStoreID),
				"subdomain":            (v.Subdomain),
				"tags":                 convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.SQLServer:
		localV, _ := localVersion.(*sdm.SQLServer)
		_ = localV
		d.Set("sql_server", []map[string]interface{}{
			{
				"allow_deprecated_encryption": (v.AllowDeprecatedEncryption),
				"bind_interface":              (v.BindInterface),
				"database":                    (v.Database),
				"egress_filter":               (v.EgressFilter),
				"hostname":                    (v.Hostname),
				"name":                        (v.Name),
				"override_database":           (v.OverrideDatabase),
				"password":                    seValues["password"],
				"port":                        (v.Port),
				"port_override":               (v.PortOverride),
				"proxy_cluster_id":            (v.ProxyClusterID),
				"schema":                      (v.Schema),
				"secret_store_id":             (v.SecretStoreID),
				"subdomain":                   (v.Subdomain),
				"tags":                        convertTagsToPorcelain(v.Tags),
				"username":                    seValues["username"],
			},
		})
	case *sdm.SQLServerAzureAD:
		localV, _ := localVersion.(*sdm.SQLServerAzureAD)
		_ = localV
		d.Set("sql_server_azure_ad", []map[string]interface{}{
			{
				"allow_deprecated_encryption": (v.AllowDeprecatedEncryption),
				"bind_interface":              (v.BindInterface),
				"client_id":                   seValues["client_id"],
				"database":                    (v.Database),
				"egress_filter":               (v.EgressFilter),
				"hostname":                    (v.Hostname),
				"name":                        (v.Name),
				"override_database":           (v.OverrideDatabase),
				"port":                        (v.Port),
				"port_override":               (v.PortOverride),
				"proxy_cluster_id":            (v.ProxyClusterID),
				"schema":                      (v.Schema),
				"secret":                      seValues["secret"],
				"secret_store_id":             (v.SecretStoreID),
				"subdomain":                   (v.Subdomain),
				"tags":                        convertTagsToPorcelain(v.Tags),
				"tenant_id":                   seValues["tenant_id"],
			},
		})
	case *sdm.SQLServerKerberosAD:
		localV, _ := localVersion.(*sdm.SQLServerKerberosAD)
		_ = localV
		d.Set("sql_server_kerberos_ad", []map[string]interface{}{
			{
				"allow_deprecated_encryption": (v.AllowDeprecatedEncryption),
				"bind_interface":              (v.BindInterface),
				"database":                    (v.Database),
				"egress_filter":               (v.EgressFilter),
				"hostname":                    (v.Hostname),
				"keytab":                      seValues["keytab"],
				"krb_config":                  seValues["krb_config"],
				"name":                        (v.Name),
				"override_database":           (v.OverrideDatabase),
				"port":                        (v.Port),
				"port_override":               (v.PortOverride),
				"proxy_cluster_id":            (v.ProxyClusterID),
				"realm":                       seValues["realm"],
				"schema":                      (v.Schema),
				"secret_store_id":             (v.SecretStoreID),
				"server_spn":                  (v.ServerSpn),
				"subdomain":                   (v.Subdomain),
				"tags":                        convertTagsToPorcelain(v.Tags),
				"username":                    seValues["username"],
			},
		})
	case *sdm.SSH:
		localV, _ := localVersion.(*sdm.SSH)
		_ = localV
		d.Set("ssh", []map[string]interface{}{
			{
				"allow_deprecated_key_exchanges": (v.AllowDeprecatedKeyExchanges),
				"bind_interface":                 (v.BindInterface),
				"egress_filter":                  (v.EgressFilter),
				"hostname":                       (v.Hostname),
				"key_type":                       (v.KeyType),
				"name":                           (v.Name),
				"port":                           (v.Port),
				"port_forwarding":                (v.PortForwarding),
				"port_override":                  (v.PortOverride),
				"proxy_cluster_id":               (v.ProxyClusterID),
				"public_key":                     (v.PublicKey),
				"secret_store_id":                (v.SecretStoreID),
				"subdomain":                      (v.Subdomain),
				"tags":                           convertTagsToPorcelain(v.Tags),
				"username":                       seValues["username"],
			},
		})
	case *sdm.SSHCert:
		localV, _ := localVersion.(*sdm.SSHCert)
		_ = localV
		d.Set("ssh_cert", []map[string]interface{}{
			{
				"allow_deprecated_key_exchanges":      (v.AllowDeprecatedKeyExchanges),
				"bind_interface":                      (v.BindInterface),
				"egress_filter":                       (v.EgressFilter),
				"hostname":                            (v.Hostname),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"key_type":                            (v.KeyType),
				"name":                                (v.Name),
				"port":                                (v.Port),
				"port_forwarding":                     (v.PortForwarding),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
				"username":                            seValues["username"],
			},
		})
	case *sdm.SSHCustomerKey:
		localV, _ := localVersion.(*sdm.SSHCustomerKey)
		_ = localV
		d.Set("ssh_customer_key", []map[string]interface{}{
			{
				"allow_deprecated_key_exchanges":      (v.AllowDeprecatedKeyExchanges),
				"bind_interface":                      (v.BindInterface),
				"egress_filter":                       (v.EgressFilter),
				"hostname":                            (v.Hostname),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port":                                (v.Port),
				"port_forwarding":                     (v.PortForwarding),
				"port_override":                       (v.PortOverride),
				"private_key":                         seValues["private_key"],
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
				"username":                            seValues["username"],
			},
		})
	case *sdm.SSHPassword:
		localV, _ := localVersion.(*sdm.SSHPassword)
		_ = localV
		d.Set("ssh_password", []map[string]interface{}{
			{
				"allow_deprecated_key_exchanges": (v.AllowDeprecatedKeyExchanges),
				"bind_interface":                 (v.BindInterface),
				"egress_filter":                  (v.EgressFilter),
				"hostname":                       (v.Hostname),
				"name":                           (v.Name),
				"password":                       seValues["password"],
				"port":                           (v.Port),
				"port_forwarding":                (v.PortForwarding),
				"port_override":                  (v.PortOverride),
				"proxy_cluster_id":               (v.ProxyClusterID),
				"secret_store_id":                (v.SecretStoreID),
				"subdomain":                      (v.Subdomain),
				"tags":                           convertTagsToPorcelain(v.Tags),
				"username":                       seValues["username"],
			},
		})
	case *sdm.Sybase:
		localV, _ := localVersion.(*sdm.Sybase)
		_ = localV
		d.Set("sybase", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"username":         seValues["username"],
			},
		})
	case *sdm.SybaseIQ:
		localV, _ := localVersion.(*sdm.SybaseIQ)
		_ = localV
		d.Set("sybase_iq", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"username":         seValues["username"],
			},
		})
	case *sdm.Teradata:
		localV, _ := localVersion.(*sdm.Teradata)
		_ = localV
		d.Set("teradata", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"username":         seValues["username"],
			},
		})
	case *sdm.Trino:
		localV, _ := localVersion.(*sdm.Trino)
		_ = localV
		d.Set("trino", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"database":         (v.Database),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"username":         (v.Username),
			},
		})
	case *sdm.Vertica:
		localV, _ := localVersion.(*sdm.Vertica)
		_ = localV
		d.Set("vertica", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"database":         (v.Database),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"username":         seValues["username"],
			},
		})
	}
	return nil
}

func resourceResourceRead(ctx context.Context, d *schema.ResourceData, cc *sdm.Client) error {
	ctx, cancel := context.WithTimeout(ctx, d.Timeout(schema.TimeoutRead))
	defer cancel()
	localVersion := convertResourceToPlumbing(d)
	_ = localVersion
	seValues, err := secretStoreValuesForResource(d)
	if err != nil {
		return fmt.Errorf("cannot read Resource %s: %w", d.Id(), err)
	}
	resp, err := cc.Resources().Get(ctx, d.Id())
	var errNotFound *sdm.NotFoundError
	if err != nil && errors.As(err, &errNotFound) {
		d.SetId("")
		return nil
	} else if err != nil {
		return fmt.Errorf("cannot read Resource %s: %w", d.Id(), err)
	}
	switch v := resp.Resource.(type) {
	case *sdm.Aerospike:
		localV, ok := localVersion.(*sdm.Aerospike)
		if !ok {
			localV = &sdm.Aerospike{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("aerospike", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"username":         seValues["username"],
			},
		})
	case *sdm.AKS:
		localV, ok := localVersion.(*sdm.AKS)
		if !ok {
			localV = &sdm.AKS{}
		}
		_ = localV
		if v.CertificateAuthority != "" {
			seValues["certificate_authority"] = v.CertificateAuthority
		}
		if v.ClientCertificate != "" {
			seValues["client_certificate"] = v.ClientCertificate
		}
		if v.ClientKey != "" {
			seValues["client_key"] = v.ClientKey
		}
		d.Set("aks", []map[string]interface{}{
			{
				"allow_resource_role_bypass":          (v.AllowResourceRoleBypass),
				"bind_interface":                      (v.BindInterface),
				"certificate_authority":               seValues["certificate_authority"],
				"client_certificate":                  seValues["client_certificate"],
				"client_key":                          seValues["client_key"],
				"discovery_enabled":                   (v.DiscoveryEnabled),
				"discovery_username":                  (v.DiscoveryUsername),
				"egress_filter":                       (v.EgressFilter),
				"healthcheck_namespace":               (v.HealthcheckNamespace),
				"hostname":                            (v.Hostname),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port":                                (v.Port),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AKSBasicAuth:
		localV, ok := localVersion.(*sdm.AKSBasicAuth)
		if !ok {
			localV = &sdm.AKSBasicAuth{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("aks_basic_auth", []map[string]interface{}{
			{
				"bind_interface":        (v.BindInterface),
				"egress_filter":         (v.EgressFilter),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"hostname":              (v.Hostname),
				"name":                  (v.Name),
				"password":              seValues["password"],
				"port":                  (v.Port),
				"port_override":         (v.PortOverride),
				"proxy_cluster_id":      (v.ProxyClusterID),
				"secret_store_id":       (v.SecretStoreID),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
				"username":              seValues["username"],
			},
		})
	case *sdm.AKSServiceAccount:
		localV, ok := localVersion.(*sdm.AKSServiceAccount)
		if !ok {
			localV = &sdm.AKSServiceAccount{}
		}
		_ = localV
		if v.Token != "" {
			seValues["token"] = v.Token
		}
		d.Set("aks_service_account", []map[string]interface{}{
			{
				"allow_resource_role_bypass":          (v.AllowResourceRoleBypass),
				"bind_interface":                      (v.BindInterface),
				"discovery_enabled":                   (v.DiscoveryEnabled),
				"discovery_username":                  (v.DiscoveryUsername),
				"egress_filter":                       (v.EgressFilter),
				"healthcheck_namespace":               (v.HealthcheckNamespace),
				"hostname":                            (v.Hostname),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port":                                (v.Port),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
				"token":                               seValues["token"],
			},
		})
	case *sdm.AKSServiceAccountUserImpersonation:
		localV, ok := localVersion.(*sdm.AKSServiceAccountUserImpersonation)
		if !ok {
			localV = &sdm.AKSServiceAccountUserImpersonation{}
		}
		_ = localV
		if v.Token != "" {
			seValues["token"] = v.Token
		}
		d.Set("aks_service_account_user_impersonation", []map[string]interface{}{
			{
				"bind_interface":        (v.BindInterface),
				"egress_filter":         (v.EgressFilter),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"hostname":              (v.Hostname),
				"name":                  (v.Name),
				"port":                  (v.Port),
				"port_override":         (v.PortOverride),
				"proxy_cluster_id":      (v.ProxyClusterID),
				"secret_store_id":       (v.SecretStoreID),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
				"token":                 seValues["token"],
			},
		})
	case *sdm.AKSUserImpersonation:
		localV, ok := localVersion.(*sdm.AKSUserImpersonation)
		if !ok {
			localV = &sdm.AKSUserImpersonation{}
		}
		_ = localV
		if v.CertificateAuthority != "" {
			seValues["certificate_authority"] = v.CertificateAuthority
		}
		if v.ClientCertificate != "" {
			seValues["client_certificate"] = v.ClientCertificate
		}
		if v.ClientKey != "" {
			seValues["client_key"] = v.ClientKey
		}
		d.Set("aks_user_impersonation", []map[string]interface{}{
			{
				"bind_interface":        (v.BindInterface),
				"certificate_authority": seValues["certificate_authority"],
				"client_certificate":    seValues["client_certificate"],
				"client_key":            seValues["client_key"],
				"egress_filter":         (v.EgressFilter),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"hostname":              (v.Hostname),
				"name":                  (v.Name),
				"port":                  (v.Port),
				"port_override":         (v.PortOverride),
				"proxy_cluster_id":      (v.ProxyClusterID),
				"secret_store_id":       (v.SecretStoreID),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AmazonEKS:
		localV, ok := localVersion.(*sdm.AmazonEKS)
		if !ok {
			localV = &sdm.AmazonEKS{}
		}
		_ = localV
		if v.AccessKey != "" {
			seValues["access_key"] = v.AccessKey
		}
		if v.CertificateAuthority != "" {
			seValues["certificate_authority"] = v.CertificateAuthority
		}
		if v.RoleArn != "" {
			seValues["role_arn"] = v.RoleArn
		}
		if v.RoleExternalID != "" {
			seValues["role_external_id"] = v.RoleExternalID
		}
		if v.SecretAccessKey != "" {
			seValues["secret_access_key"] = v.SecretAccessKey
		}
		d.Set("amazon_eks", []map[string]interface{}{
			{
				"access_key":                          seValues["access_key"],
				"allow_resource_role_bypass":          (v.AllowResourceRoleBypass),
				"bind_interface":                      (v.BindInterface),
				"certificate_authority":               seValues["certificate_authority"],
				"cluster_name":                        (v.ClusterName),
				"discovery_enabled":                   (v.DiscoveryEnabled),
				"discovery_username":                  (v.DiscoveryUsername),
				"egress_filter":                       (v.EgressFilter),
				"endpoint":                            (v.Endpoint),
				"healthcheck_namespace":               (v.HealthcheckNamespace),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"region":                              (v.Region),
				"role_arn":                            seValues["role_arn"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_access_key":                   seValues["secret_access_key"],
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AmazonEKSInstanceProfile:
		localV, ok := localVersion.(*sdm.AmazonEKSInstanceProfile)
		if !ok {
			localV = &sdm.AmazonEKSInstanceProfile{}
		}
		_ = localV
		if v.CertificateAuthority != "" {
			seValues["certificate_authority"] = v.CertificateAuthority
		}
		if v.RoleArn != "" {
			seValues["role_arn"] = v.RoleArn
		}
		if v.RoleExternalID != "" {
			seValues["role_external_id"] = v.RoleExternalID
		}
		d.Set("amazon_eks_instance_profile", []map[string]interface{}{
			{
				"allow_resource_role_bypass":          (v.AllowResourceRoleBypass),
				"bind_interface":                      (v.BindInterface),
				"certificate_authority":               seValues["certificate_authority"],
				"cluster_name":                        (v.ClusterName),
				"discovery_enabled":                   (v.DiscoveryEnabled),
				"discovery_username":                  (v.DiscoveryUsername),
				"egress_filter":                       (v.EgressFilter),
				"endpoint":                            (v.Endpoint),
				"healthcheck_namespace":               (v.HealthcheckNamespace),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"region":                              (v.Region),
				"role_arn":                            seValues["role_arn"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AmazonEKSInstanceProfileUserImpersonation:
		localV, ok := localVersion.(*sdm.AmazonEKSInstanceProfileUserImpersonation)
		if !ok {
			localV = &sdm.AmazonEKSInstanceProfileUserImpersonation{}
		}
		_ = localV
		if v.CertificateAuthority != "" {
			seValues["certificate_authority"] = v.CertificateAuthority
		}
		if v.RoleArn != "" {
			seValues["role_arn"] = v.RoleArn
		}
		if v.RoleExternalID != "" {
			seValues["role_external_id"] = v.RoleExternalID
		}
		d.Set("amazon_eks_instance_profile_user_impersonation", []map[string]interface{}{
			{
				"bind_interface":        (v.BindInterface),
				"certificate_authority": seValues["certificate_authority"],
				"cluster_name":          (v.ClusterName),
				"egress_filter":         (v.EgressFilter),
				"endpoint":              (v.Endpoint),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"name":                  (v.Name),
				"port_override":         (v.PortOverride),
				"proxy_cluster_id":      (v.ProxyClusterID),
				"region":                (v.Region),
				"role_arn":              seValues["role_arn"],
				"role_external_id":      seValues["role_external_id"],
				"secret_store_id":       (v.SecretStoreID),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AmazonEKSUserImpersonation:
		localV, ok := localVersion.(*sdm.AmazonEKSUserImpersonation)
		if !ok {
			localV = &sdm.AmazonEKSUserImpersonation{}
		}
		_ = localV
		if v.AccessKey != "" {
			seValues["access_key"] = v.AccessKey
		}
		if v.CertificateAuthority != "" {
			seValues["certificate_authority"] = v.CertificateAuthority
		}
		if v.RoleArn != "" {
			seValues["role_arn"] = v.RoleArn
		}
		if v.RoleExternalID != "" {
			seValues["role_external_id"] = v.RoleExternalID
		}
		if v.SecretAccessKey != "" {
			seValues["secret_access_key"] = v.SecretAccessKey
		}
		d.Set("amazon_eks_user_impersonation", []map[string]interface{}{
			{
				"access_key":            seValues["access_key"],
				"bind_interface":        (v.BindInterface),
				"certificate_authority": seValues["certificate_authority"],
				"cluster_name":          (v.ClusterName),
				"egress_filter":         (v.EgressFilter),
				"endpoint":              (v.Endpoint),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"name":                  (v.Name),
				"port_override":         (v.PortOverride),
				"proxy_cluster_id":      (v.ProxyClusterID),
				"region":                (v.Region),
				"role_arn":              seValues["role_arn"],
				"role_external_id":      seValues["role_external_id"],
				"secret_access_key":     seValues["secret_access_key"],
				"secret_store_id":       (v.SecretStoreID),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AmazonES:
		localV, ok := localVersion.(*sdm.AmazonES)
		if !ok {
			localV = &sdm.AmazonES{}
		}
		_ = localV
		if v.AccessKey != "" {
			seValues["access_key"] = v.AccessKey
		}
		if v.RoleArn != "" {
			seValues["role_arn"] = v.RoleArn
		}
		if v.RoleExternalID != "" {
			seValues["role_external_id"] = v.RoleExternalID
		}
		if v.SecretAccessKey != "" {
			seValues["secret_access_key"] = v.SecretAccessKey
		}
		d.Set("amazon_es", []map[string]interface{}{
			{
				"access_key":        seValues["access_key"],
				"bind_interface":    (v.BindInterface),
				"egress_filter":     (v.EgressFilter),
				"endpoint":          (v.Endpoint),
				"name":              (v.Name),
				"port_override":     (v.PortOverride),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"region":            (v.Region),
				"role_arn":          seValues["role_arn"],
				"role_external_id":  seValues["role_external_id"],
				"secret_access_key": seValues["secret_access_key"],
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AmazonESIAM:
		localV, ok := localVersion.(*sdm.AmazonESIAM)
		if !ok {
			localV = &sdm.AmazonESIAM{}
		}
		_ = localV
		if v.RoleArn != "" {
			seValues["role_arn"] = v.RoleArn
		}
		if v.RoleExternalID != "" {
			seValues["role_external_id"] = v.RoleExternalID
		}
		d.Set("amazon_esiam", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"endpoint":         (v.Endpoint),
				"name":             (v.Name),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"region":           (v.Region),
				"role_arn":         seValues["role_arn"],
				"role_external_id": seValues["role_external_id"],
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
			},
		})
	case *sdm.AmazonMQAMQP091:
		localV, ok := localVersion.(*sdm.AmazonMQAMQP091)
		if !ok {
			localV = &sdm.AmazonMQAMQP091{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("amazonmq_amqp_091", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.Athena:
		localV, ok := localVersion.(*sdm.Athena)
		if !ok {
			localV = &sdm.Athena{}
		}
		_ = localV
		if v.AccessKey != "" {
			seValues["access_key"] = v.AccessKey
		}
		if v.RoleArn != "" {
			seValues["role_arn"] = v.RoleArn
		}
		if v.RoleExternalID != "" {
			seValues["role_external_id"] = v.RoleExternalID
		}
		if v.SecretAccessKey != "" {
			seValues["secret_access_key"] = v.SecretAccessKey
		}
		d.Set("athena", []map[string]interface{}{
			{
				"access_key":        seValues["access_key"],
				"bind_interface":    (v.BindInterface),
				"egress_filter":     (v.EgressFilter),
				"name":              (v.Name),
				"output":            (v.Output),
				"port_override":     (v.PortOverride),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"region":            (v.Region),
				"role_arn":          seValues["role_arn"],
				"role_external_id":  seValues["role_external_id"],
				"secret_access_key": seValues["secret_access_key"],
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AthenaIAM:
		localV, ok := localVersion.(*sdm.AthenaIAM)
		if !ok {
			localV = &sdm.AthenaIAM{}
		}
		_ = localV
		if v.RoleArn != "" {
			seValues["role_arn"] = v.RoleArn
		}
		if v.RoleExternalID != "" {
			seValues["role_external_id"] = v.RoleExternalID
		}
		d.Set("athena_iam", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"name":             (v.Name),
				"output":           (v.Output),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"region":           (v.Region),
				"role_arn":         seValues["role_arn"],
				"role_external_id": seValues["role_external_id"],
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AuroraMysql:
		localV, ok := localVersion.(*sdm.AuroraMysql)
		if !ok {
			localV = &sdm.AuroraMysql{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("aurora_mysql", []map[string]interface{}{
			{
				"bind_interface":                    (v.BindInterface),
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"name":                              (v.Name),
				"password":                          seValues["password"],
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"proxy_cluster_id":                  (v.ProxyClusterID),
				"require_native_auth":               (v.RequireNativeAuth),
				"secret_store_id":                   (v.SecretStoreID),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          seValues["username"],
			},
		})
	case *sdm.AuroraMysqlIAM:
		localV, ok := localVersion.(*sdm.AuroraMysqlIAM)
		if !ok {
			localV = &sdm.AuroraMysqlIAM{}
		}
		_ = localV
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("aurora_mysql_iam", []map[string]interface{}{
			{
				"bind_interface":      (v.BindInterface),
				"database":            (v.Database),
				"egress_filter":       (v.EgressFilter),
				"hostname":            (v.Hostname),
				"name":                (v.Name),
				"port":                (v.Port),
				"port_override":       (v.PortOverride),
				"proxy_cluster_id":    (v.ProxyClusterID),
				"region":              (v.Region),
				"role_assumption_arn": (v.RoleAssumptionArn),
				"secret_store_id":     (v.SecretStoreID),
				"subdomain":           (v.Subdomain),
				"tags":                convertTagsToPorcelain(v.Tags),
				"username":            seValues["username"],
			},
		})
	case *sdm.AuroraPostgres:
		localV, ok := localVersion.(*sdm.AuroraPostgres)
		if !ok {
			localV = &sdm.AuroraPostgres{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("aurora_postgres", []map[string]interface{}{
			{
				"bind_interface":    (v.BindInterface),
				"database":          (v.Database),
				"egress_filter":     (v.EgressFilter),
				"hostname":          (v.Hostname),
				"name":              (v.Name),
				"override_database": (v.OverrideDatabase),
				"password":          seValues["password"],
				"port":              (v.Port),
				"port_override":     (v.PortOverride),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"username":          seValues["username"],
			},
		})
	case *sdm.AuroraPostgresIAM:
		localV, ok := localVersion.(*sdm.AuroraPostgresIAM)
		if !ok {
			localV = &sdm.AuroraPostgresIAM{}
		}
		_ = localV
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("aurora_postgres_iam", []map[string]interface{}{
			{
				"bind_interface":      (v.BindInterface),
				"database":            (v.Database),
				"egress_filter":       (v.EgressFilter),
				"hostname":            (v.Hostname),
				"name":                (v.Name),
				"override_database":   (v.OverrideDatabase),
				"port":                (v.Port),
				"port_override":       (v.PortOverride),
				"proxy_cluster_id":    (v.ProxyClusterID),
				"region":              (v.Region),
				"role_assumption_arn": (v.RoleAssumptionArn),
				"secret_store_id":     (v.SecretStoreID),
				"subdomain":           (v.Subdomain),
				"tags":                convertTagsToPorcelain(v.Tags),
				"username":            seValues["username"],
			},
		})
	case *sdm.AWS:
		localV, ok := localVersion.(*sdm.AWS)
		if !ok {
			localV = &sdm.AWS{}
		}
		_ = localV
		if v.AccessKey != "" {
			seValues["access_key"] = v.AccessKey
		}
		if v.RoleArn != "" {
			seValues["role_arn"] = v.RoleArn
		}
		if v.RoleExternalID != "" {
			seValues["role_external_id"] = v.RoleExternalID
		}
		if v.SecretAccessKey != "" {
			seValues["secret_access_key"] = v.SecretAccessKey
		}
		d.Set("aws", []map[string]interface{}{
			{
				"access_key":         seValues["access_key"],
				"bind_interface":     (v.BindInterface),
				"egress_filter":      (v.EgressFilter),
				"healthcheck_region": (v.HealthcheckRegion),
				"name":               (v.Name),
				"port_override":      (v.PortOverride),
				"proxy_cluster_id":   (v.ProxyClusterID),
				"role_arn":           seValues["role_arn"],
				"role_external_id":   seValues["role_external_id"],
				"secret_access_key":  seValues["secret_access_key"],
				"secret_store_id":    (v.SecretStoreID),
				"subdomain":          (v.Subdomain),
				"tags":               convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AWSConsole:
		localV, ok := localVersion.(*sdm.AWSConsole)
		if !ok {
			localV = &sdm.AWSConsole{}
		}
		_ = localV
		if v.RoleArn != "" {
			seValues["role_arn"] = v.RoleArn
		}
		if v.RoleExternalID != "" {
			seValues["role_external_id"] = v.RoleExternalID
		}
		d.Set("aws_console", []map[string]interface{}{
			{
				"bind_interface":                      (v.BindInterface),
				"egress_filter":                       (v.EgressFilter),
				"enable_env_variables":                (v.EnableEnvVariables),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"region":                              (v.Region),
				"role_arn":                            seValues["role_arn"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_store_id":                     (v.SecretStoreID),
				"session_expiry":                      (v.SessionExpiry),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AWSConsoleStaticKeyPair:
		localV, ok := localVersion.(*sdm.AWSConsoleStaticKeyPair)
		if !ok {
			localV = &sdm.AWSConsoleStaticKeyPair{}
		}
		_ = localV
		if v.AccessKey != "" {
			seValues["access_key"] = v.AccessKey
		}
		if v.RoleArn != "" {
			seValues["role_arn"] = v.RoleArn
		}
		if v.RoleExternalID != "" {
			seValues["role_external_id"] = v.RoleExternalID
		}
		if v.SecretAccessKey != "" {
			seValues["secret_access_key"] = v.SecretAccessKey
		}
		d.Set("aws_console_static_key_pair", []map[string]interface{}{
			{
				"access_key":                          seValues["access_key"],
				"bind_interface":                      (v.BindInterface),
				"egress_filter":                       (v.EgressFilter),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"region":                              (v.Region),
				"role_arn":                            seValues["role_arn"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_access_key":                   seValues["secret_access_key"],
				"secret_store_id":                     (v.SecretStoreID),
				"session_expiry":                      (v.SessionExpiry),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AWSInstanceProfile:
		localV, ok := localVersion.(*sdm.AWSInstanceProfile)
		if !ok {
			localV = &sdm.AWSInstanceProfile{}
		}
		_ = localV
		if v.RoleArn != "" {
			seValues["role_arn"] = v.RoleArn
		}
		if v.RoleExternalID != "" {
			seValues["role_external_id"] = v.RoleExternalID
		}
		d.Set("aws_instance_profile", []map[string]interface{}{
			{
				"bind_interface":       (v.BindInterface),
				"egress_filter":        (v.EgressFilter),
				"enable_env_variables": (v.EnableEnvVariables),
				"name":                 (v.Name),
				"port_override":        (v.PortOverride),
				"proxy_cluster_id":     (v.ProxyClusterID),
				"region":               (v.Region),
				"role_arn":             seValues["role_arn"],
				"role_external_id":     seValues["role_external_id"],
				"secret_store_id":      (v.SecretStoreID),
				"subdomain":            (v.Subdomain),
				"tags":                 convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Azure:
		localV, ok := localVersion.(*sdm.Azure)
		if !ok {
			localV = &sdm.Azure{}
		}
		_ = localV
		if v.AppID != "" {
			seValues["app_id"] = v.AppID
		}
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.TenantID != "" {
			seValues["tenant_id"] = v.TenantID
		}
		d.Set("azure", []map[string]interface{}{
			{
				"app_id":           seValues["app_id"],
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tenant_id":        seValues["tenant_id"],
			},
		})
	case *sdm.AzureCertificate:
		localV, ok := localVersion.(*sdm.AzureCertificate)
		if !ok {
			localV = &sdm.AzureCertificate{}
		}
		_ = localV
		if v.AppID != "" {
			seValues["app_id"] = v.AppID
		}
		if v.ClientCertificate != "" {
			seValues["client_certificate"] = v.ClientCertificate
		}
		if v.TenantID != "" {
			seValues["tenant_id"] = v.TenantID
		}
		d.Set("azure_certificate", []map[string]interface{}{
			{
				"app_id":             seValues["app_id"],
				"bind_interface":     (v.BindInterface),
				"client_certificate": seValues["client_certificate"],
				"egress_filter":      (v.EgressFilter),
				"name":               (v.Name),
				"port_override":      (v.PortOverride),
				"proxy_cluster_id":   (v.ProxyClusterID),
				"secret_store_id":    (v.SecretStoreID),
				"subdomain":          (v.Subdomain),
				"tags":               convertTagsToPorcelain(v.Tags),
				"tenant_id":          seValues["tenant_id"],
			},
		})
	case *sdm.AzureMysql:
		localV, ok := localVersion.(*sdm.AzureMysql)
		if !ok {
			localV = &sdm.AzureMysql{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("azure_mysql", []map[string]interface{}{
			{
				"bind_interface":                    (v.BindInterface),
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"name":                              (v.Name),
				"password":                          seValues["password"],
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"proxy_cluster_id":                  (v.ProxyClusterID),
				"require_native_auth":               (v.RequireNativeAuth),
				"secret_store_id":                   (v.SecretStoreID),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          seValues["username"],
			},
		})
	case *sdm.AzurePostgres:
		localV, ok := localVersion.(*sdm.AzurePostgres)
		if !ok {
			localV = &sdm.AzurePostgres{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("azure_postgres", []map[string]interface{}{
			{
				"bind_interface":    (v.BindInterface),
				"database":          (v.Database),
				"egress_filter":     (v.EgressFilter),
				"hostname":          (v.Hostname),
				"name":              (v.Name),
				"override_database": (v.OverrideDatabase),
				"password":          seValues["password"],
				"port":              (v.Port),
				"port_override":     (v.PortOverride),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"username":          seValues["username"],
			},
		})
	case *sdm.AzurePostgresManagedIdentity:
		localV, ok := localVersion.(*sdm.AzurePostgresManagedIdentity)
		if !ok {
			localV = &sdm.AzurePostgresManagedIdentity{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("azure_postgres_managed_identity", []map[string]interface{}{
			{
				"bind_interface":                    (v.BindInterface),
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"name":                              (v.Name),
				"override_database":                 (v.OverrideDatabase),
				"password":                          seValues["password"],
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"proxy_cluster_id":                  (v.ProxyClusterID),
				"secret_store_id":                   (v.SecretStoreID),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          seValues["username"],
			},
		})
	case *sdm.BigQuery:
		localV, ok := localVersion.(*sdm.BigQuery)
		if !ok {
			localV = &sdm.BigQuery{}
		}
		_ = localV
		if v.PrivateKey != "" {
			seValues["private_key"] = v.PrivateKey
		}
		d.Set("big_query", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"endpoint":         (v.Endpoint),
				"name":             (v.Name),
				"port_override":    (v.PortOverride),
				"private_key":      seValues["private_key"],
				"project":          (v.Project),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"username":         (v.Username),
			},
		})
	case *sdm.Cassandra:
		localV, ok := localVersion.(*sdm.Cassandra)
		if !ok {
			localV = &sdm.Cassandra{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("cassandra", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.Citus:
		localV, ok := localVersion.(*sdm.Citus)
		if !ok {
			localV = &sdm.Citus{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("citus", []map[string]interface{}{
			{
				"bind_interface":    (v.BindInterface),
				"database":          (v.Database),
				"egress_filter":     (v.EgressFilter),
				"hostname":          (v.Hostname),
				"name":              (v.Name),
				"override_database": (v.OverrideDatabase),
				"password":          seValues["password"],
				"port":              (v.Port),
				"port_override":     (v.PortOverride),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"username":          seValues["username"],
			},
		})
	case *sdm.ClickHouseHTTP:
		localV, ok := localVersion.(*sdm.ClickHouseHTTP)
		if !ok {
			localV = &sdm.ClickHouseHTTP{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("click_house_http", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"database":         (v.Database),
				"egress_filter":    (v.EgressFilter),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"tags":             convertTagsToPorcelain(v.Tags),
				"url":              (v.Url),
				"username":         seValues["username"],
			},
		})
	case *sdm.ClickHouseMySQL:
		localV, ok := localVersion.(*sdm.ClickHouseMySQL)
		if !ok {
			localV = &sdm.ClickHouseMySQL{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("click_house_my_sql", []map[string]interface{}{
			{
				"bind_interface":      (v.BindInterface),
				"database":            (v.Database),
				"egress_filter":       (v.EgressFilter),
				"hostname":            (v.Hostname),
				"name":                (v.Name),
				"password":            seValues["password"],
				"port":                (v.Port),
				"port_override":       (v.PortOverride),
				"proxy_cluster_id":    (v.ProxyClusterID),
				"require_native_auth": (v.RequireNativeAuth),
				"secret_store_id":     (v.SecretStoreID),
				"subdomain":           (v.Subdomain),
				"tags":                convertTagsToPorcelain(v.Tags),
				"username":            seValues["username"],
			},
		})
	case *sdm.ClickHouseTCP:
		localV, ok := localVersion.(*sdm.ClickHouseTCP)
		if !ok {
			localV = &sdm.ClickHouseTCP{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("click_house_tcp", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"database":         (v.Database),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.Clustrix:
		localV, ok := localVersion.(*sdm.Clustrix)
		if !ok {
			localV = &sdm.Clustrix{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("clustrix", []map[string]interface{}{
			{
				"bind_interface":                    (v.BindInterface),
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"name":                              (v.Name),
				"password":                          seValues["password"],
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"proxy_cluster_id":                  (v.ProxyClusterID),
				"require_native_auth":               (v.RequireNativeAuth),
				"secret_store_id":                   (v.SecretStoreID),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          seValues["username"],
			},
		})
	case *sdm.Cockroach:
		localV, ok := localVersion.(*sdm.Cockroach)
		if !ok {
			localV = &sdm.Cockroach{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("cockroach", []map[string]interface{}{
			{
				"bind_interface":    (v.BindInterface),
				"database":          (v.Database),
				"egress_filter":     (v.EgressFilter),
				"hostname":          (v.Hostname),
				"name":              (v.Name),
				"override_database": (v.OverrideDatabase),
				"password":          seValues["password"],
				"port":              (v.Port),
				"port_override":     (v.PortOverride),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"username":          seValues["username"],
			},
		})
	case *sdm.CouchbaseDatabase:
		localV, ok := localVersion.(*sdm.CouchbaseDatabase)
		if !ok {
			localV = &sdm.CouchbaseDatabase{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("couchbase_database", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"n_1_ql_port":      (v.N1QlPort),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.CouchbaseWebUI:
		localV, ok := localVersion.(*sdm.CouchbaseWebUI)
		if !ok {
			localV = &sdm.CouchbaseWebUI{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("couchbase_web_ui", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"url":              (v.Url),
				"username":         seValues["username"],
			},
		})
	case *sdm.DB2I:
		localV, ok := localVersion.(*sdm.DB2I)
		if !ok {
			localV = &sdm.DB2I{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("db_2_i", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.DB2LUW:
		localV, ok := localVersion.(*sdm.DB2LUW)
		if !ok {
			localV = &sdm.DB2LUW{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("db_2_luw", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"database":         (v.Database),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"username":         seValues["username"],
			},
		})
	case *sdm.DocumentDBHost:
		localV, ok := localVersion.(*sdm.DocumentDBHost)
		if !ok {
			localV = &sdm.DocumentDBHost{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("document_db_host", []map[string]interface{}{
			{
				"auth_database":    (v.AuthDatabase),
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"username":         seValues["username"],
			},
		})
	case *sdm.DocumentDBHostIAM:
		localV, ok := localVersion.(*sdm.DocumentDBHostIAM)
		if !ok {
			localV = &sdm.DocumentDBHostIAM{}
		}
		_ = localV
		d.Set("document_db_host_iam", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"region":           (v.Region),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.DocumentDBReplicaSet:
		localV, ok := localVersion.(*sdm.DocumentDBReplicaSet)
		if !ok {
			localV = &sdm.DocumentDBReplicaSet{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("document_db_replica_set", []map[string]interface{}{
			{
				"auth_database":      (v.AuthDatabase),
				"bind_interface":     (v.BindInterface),
				"connect_to_replica": (v.ConnectToReplica),
				"egress_filter":      (v.EgressFilter),
				"hostname":           (v.Hostname),
				"name":               (v.Name),
				"password":           seValues["password"],
				"port_override":      (v.PortOverride),
				"proxy_cluster_id":   (v.ProxyClusterID),
				"replica_set":        (v.ReplicaSet),
				"secret_store_id":    (v.SecretStoreID),
				"subdomain":          (v.Subdomain),
				"tags":               convertTagsToPorcelain(v.Tags),
				"username":           seValues["username"],
			},
		})
	case *sdm.DocumentDBReplicaSetIAM:
		localV, ok := localVersion.(*sdm.DocumentDBReplicaSetIAM)
		if !ok {
			localV = &sdm.DocumentDBReplicaSetIAM{}
		}
		_ = localV
		d.Set("document_db_replica_set_iam", []map[string]interface{}{
			{
				"bind_interface":     (v.BindInterface),
				"connect_to_replica": (v.ConnectToReplica),
				"egress_filter":      (v.EgressFilter),
				"hostname":           (v.Hostname),
				"name":               (v.Name),
				"port_override":      (v.PortOverride),
				"proxy_cluster_id":   (v.ProxyClusterID),
				"region":             (v.Region),
				"secret_store_id":    (v.SecretStoreID),
				"subdomain":          (v.Subdomain),
				"tags":               convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Druid:
		localV, ok := localVersion.(*sdm.Druid)
		if !ok {
			localV = &sdm.Druid{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("druid", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"username":         seValues["username"],
			},
		})
	case *sdm.DynamoDB:
		localV, ok := localVersion.(*sdm.DynamoDB)
		if !ok {
			localV = &sdm.DynamoDB{}
		}
		_ = localV
		if v.AccessKey != "" {
			seValues["access_key"] = v.AccessKey
		}
		if v.RoleArn != "" {
			seValues["role_arn"] = v.RoleArn
		}
		if v.RoleExternalID != "" {
			seValues["role_external_id"] = v.RoleExternalID
		}
		if v.SecretAccessKey != "" {
			seValues["secret_access_key"] = v.SecretAccessKey
		}
		d.Set("dynamo_db", []map[string]interface{}{
			{
				"access_key":        seValues["access_key"],
				"bind_interface":    (v.BindInterface),
				"egress_filter":     (v.EgressFilter),
				"endpoint":          (v.Endpoint),
				"name":              (v.Name),
				"port_override":     (v.PortOverride),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"region":            (v.Region),
				"role_arn":          seValues["role_arn"],
				"role_external_id":  seValues["role_external_id"],
				"secret_access_key": seValues["secret_access_key"],
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.DynamoDBIAM:
		localV, ok := localVersion.(*sdm.DynamoDBIAM)
		if !ok {
			localV = &sdm.DynamoDBIAM{}
		}
		_ = localV
		if v.RoleArn != "" {
			seValues["role_arn"] = v.RoleArn
		}
		if v.RoleExternalID != "" {
			seValues["role_external_id"] = v.RoleExternalID
		}
		d.Set("dynamo_dbiam", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"endpoint":         (v.Endpoint),
				"name":             (v.Name),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"region":           (v.Region),
				"role_arn":         seValues["role_arn"],
				"role_external_id": seValues["role_external_id"],
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Elastic:
		localV, ok := localVersion.(*sdm.Elastic)
		if !ok {
			localV = &sdm.Elastic{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("elastic", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.ElasticacheRedis:
		localV, ok := localVersion.(*sdm.ElasticacheRedis)
		if !ok {
			localV = &sdm.ElasticacheRedis{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("elasticache_redis", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.GCP:
		localV, ok := localVersion.(*sdm.GCP)
		if !ok {
			localV = &sdm.GCP{}
		}
		_ = localV
		if v.Keyfile != "" {
			seValues["keyfile"] = v.Keyfile
		}
		d.Set("gcp", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"keyfile":          seValues["keyfile"],
				"name":             (v.Name),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"scopes":           (v.Scopes),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.GCPConsole:
		localV, ok := localVersion.(*sdm.GCPConsole)
		if !ok {
			localV = &sdm.GCPConsole{}
		}
		_ = localV
		d.Set("gcp_console", []map[string]interface{}{
			{
				"bind_interface":                      (v.BindInterface),
				"egress_filter":                       (v.EgressFilter),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"secret_store_id":                     (v.SecretStoreID),
				"session_expiry":                      (v.SessionExpiry),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
				"workforce_pool_id":                   (v.WorkforcePoolID),
				"workforce_provider_id":               (v.WorkforceProviderID),
			},
		})
	case *sdm.GCPWIF:
		localV, ok := localVersion.(*sdm.GCPWIF)
		if !ok {
			localV = &sdm.GCPWIF{}
		}
		_ = localV
		d.Set("gcpwif", []map[string]interface{}{
			{
				"bind_interface":                      (v.BindInterface),
				"egress_filter":                       (v.EgressFilter),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"project_id":                          (v.ProjectID),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"scopes":                              (v.Scopes),
				"secret_store_id":                     (v.SecretStoreID),
				"session_expiry":                      (v.SessionExpiry),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
				"workforce_pool_id":                   (v.WorkforcePoolID),
				"workforce_provider_id":               (v.WorkforceProviderID),
			},
		})
	case *sdm.GoogleGKE:
		localV, ok := localVersion.(*sdm.GoogleGKE)
		if !ok {
			localV = &sdm.GoogleGKE{}
		}
		_ = localV
		if v.CertificateAuthority != "" {
			seValues["certificate_authority"] = v.CertificateAuthority
		}
		if v.ServiceAccountKey != "" {
			seValues["service_account_key"] = v.ServiceAccountKey
		}
		d.Set("google_gke", []map[string]interface{}{
			{
				"allow_resource_role_bypass":          (v.AllowResourceRoleBypass),
				"bind_interface":                      (v.BindInterface),
				"certificate_authority":               seValues["certificate_authority"],
				"discovery_enabled":                   (v.DiscoveryEnabled),
				"discovery_username":                  (v.DiscoveryUsername),
				"egress_filter":                       (v.EgressFilter),
				"endpoint":                            (v.Endpoint),
				"healthcheck_namespace":               (v.HealthcheckNamespace),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"secret_store_id":                     (v.SecretStoreID),
				"service_account_key":                 seValues["service_account_key"],
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.GoogleGKEUserImpersonation:
		localV, ok := localVersion.(*sdm.GoogleGKEUserImpersonation)
		if !ok {
			localV = &sdm.GoogleGKEUserImpersonation{}
		}
		_ = localV
		if v.CertificateAuthority != "" {
			seValues["certificate_authority"] = v.CertificateAuthority
		}
		if v.ServiceAccountKey != "" {
			seValues["service_account_key"] = v.ServiceAccountKey
		}
		d.Set("google_gke_user_impersonation", []map[string]interface{}{
			{
				"bind_interface":        (v.BindInterface),
				"certificate_authority": seValues["certificate_authority"],
				"egress_filter":         (v.EgressFilter),
				"endpoint":              (v.Endpoint),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"name":                  (v.Name),
				"port_override":         (v.PortOverride),
				"proxy_cluster_id":      (v.ProxyClusterID),
				"secret_store_id":       (v.SecretStoreID),
				"service_account_key":   seValues["service_account_key"],
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Greenplum:
		localV, ok := localVersion.(*sdm.Greenplum)
		if !ok {
			localV = &sdm.Greenplum{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("greenplum", []map[string]interface{}{
			{
				"bind_interface":    (v.BindInterface),
				"database":          (v.Database),
				"egress_filter":     (v.EgressFilter),
				"hostname":          (v.Hostname),
				"name":              (v.Name),
				"override_database": (v.OverrideDatabase),
				"password":          seValues["password"],
				"port":              (v.Port),
				"port_override":     (v.PortOverride),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"username":          seValues["username"],
			},
		})
	case *sdm.HTTPAuth:
		localV, ok := localVersion.(*sdm.HTTPAuth)
		if !ok {
			localV = &sdm.HTTPAuth{}
		}
		_ = localV
		if v.AuthHeader != "" {
			seValues["auth_header"] = v.AuthHeader
		}
		d.Set("http_auth", []map[string]interface{}{
			{
				"auth_header":       seValues["auth_header"],
				"bind_interface":    (v.BindInterface),
				"default_path":      (v.DefaultPath),
				"egress_filter":     (v.EgressFilter),
				"headers_blacklist": (v.HeadersBlacklist),
				"healthcheck_path":  (v.HealthcheckPath),
				"host_override":     (v.HostOverride),
				"name":              (v.Name),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"url":               (v.Url),
			},
		})
	case *sdm.HTTPBasicAuth:
		localV, ok := localVersion.(*sdm.HTTPBasicAuth)
		if !ok {
			localV = &sdm.HTTPBasicAuth{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("http_basic_auth", []map[string]interface{}{
			{
				"bind_interface":    (v.BindInterface),
				"default_path":      (v.DefaultPath),
				"egress_filter":     (v.EgressFilter),
				"headers_blacklist": (v.HeadersBlacklist),
				"healthcheck_path":  (v.HealthcheckPath),
				"host_override":     (v.HostOverride),
				"name":              (v.Name),
				"password":          seValues["password"],
				"proxy_cluster_id":  (v.ProxyClusterID),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"url":               (v.Url),
				"username":          seValues["username"],
			},
		})
	case *sdm.HTTPNoAuth:
		localV, ok := localVersion.(*sdm.HTTPNoAuth)
		if !ok {
			localV = &sdm.HTTPNoAuth{}
		}
		_ = localV
		d.Set("http_no_auth", []map[string]interface{}{
			{
				"bind_interface":    (v.BindInterface),
				"default_path":      (v.DefaultPath),
				"egress_filter":     (v.EgressFilter),
				"headers_blacklist": (v.HeadersBlacklist),
				"healthcheck_path":  (v.HealthcheckPath),
				"host_override":     (v.HostOverride),
				"name":              (v.Name),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"url":               (v.Url),
			},
		})
	case *sdm.Kubernetes:
		localV, ok := localVersion.(*sdm.Kubernetes)
		if !ok {
			localV = &sdm.Kubernetes{}
		}
		_ = localV
		if v.CertificateAuthority != "" {
			seValues["certificate_authority"] = v.CertificateAuthority
		}
		if v.ClientCertificate != "" {
			seValues["client_certificate"] = v.ClientCertificate
		}
		if v.ClientKey != "" {
			seValues["client_key"] = v.ClientKey
		}
		d.Set("kubernetes", []map[string]interface{}{
			{
				"allow_resource_role_bypass":          (v.AllowResourceRoleBypass),
				"bind_interface":                      (v.BindInterface),
				"certificate_authority":               seValues["certificate_authority"],
				"client_certificate":                  seValues["client_certificate"],
				"client_key":                          seValues["client_key"],
				"discovery_enabled":                   (v.DiscoveryEnabled),
				"discovery_username":                  (v.DiscoveryUsername),
				"egress_filter":                       (v.EgressFilter),
				"healthcheck_namespace":               (v.HealthcheckNamespace),
				"hostname":                            (v.Hostname),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port":                                (v.Port),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.KubernetesBasicAuth:
		localV, ok := localVersion.(*sdm.KubernetesBasicAuth)
		if !ok {
			localV = &sdm.KubernetesBasicAuth{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("kubernetes_basic_auth", []map[string]interface{}{
			{
				"bind_interface":        (v.BindInterface),
				"egress_filter":         (v.EgressFilter),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"hostname":              (v.Hostname),
				"name":                  (v.Name),
				"password":              seValues["password"],
				"port":                  (v.Port),
				"port_override":         (v.PortOverride),
				"proxy_cluster_id":      (v.ProxyClusterID),
				"secret_store_id":       (v.SecretStoreID),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
				"username":              seValues["username"],
			},
		})
	case *sdm.KubernetesPodIdentity:
		localV, ok := localVersion.(*sdm.KubernetesPodIdentity)
		if !ok {
			localV = &sdm.KubernetesPodIdentity{}
		}
		_ = localV
		if v.CertificateAuthority != "" {
			seValues["certificate_authority"] = v.CertificateAuthority
		}
		d.Set("kubernetes_pod_identity", []map[string]interface{}{
			{
				"allow_resource_role_bypass":          (v.AllowResourceRoleBypass),
				"bind_interface":                      (v.BindInterface),
				"certificate_authority":               seValues["certificate_authority"],
				"egress_filter":                       (v.EgressFilter),
				"healthcheck_namespace":               (v.HealthcheckNamespace),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.KubernetesServiceAccount:
		localV, ok := localVersion.(*sdm.KubernetesServiceAccount)
		if !ok {
			localV = &sdm.KubernetesServiceAccount{}
		}
		_ = localV
		if v.Token != "" {
			seValues["token"] = v.Token
		}
		d.Set("kubernetes_service_account", []map[string]interface{}{
			{
				"allow_resource_role_bypass":          (v.AllowResourceRoleBypass),
				"bind_interface":                      (v.BindInterface),
				"discovery_enabled":                   (v.DiscoveryEnabled),
				"discovery_username":                  (v.DiscoveryUsername),
				"egress_filter":                       (v.EgressFilter),
				"healthcheck_namespace":               (v.HealthcheckNamespace),
				"hostname":                            (v.Hostname),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port":                                (v.Port),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
				"token":                               seValues["token"],
			},
		})
	case *sdm.KubernetesServiceAccountUserImpersonation:
		localV, ok := localVersion.(*sdm.KubernetesServiceAccountUserImpersonation)
		if !ok {
			localV = &sdm.KubernetesServiceAccountUserImpersonation{}
		}
		_ = localV
		if v.Token != "" {
			seValues["token"] = v.Token
		}
		d.Set("kubernetes_service_account_user_impersonation", []map[string]interface{}{
			{
				"bind_interface":        (v.BindInterface),
				"egress_filter":         (v.EgressFilter),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"hostname":              (v.Hostname),
				"name":                  (v.Name),
				"port":                  (v.Port),
				"port_override":         (v.PortOverride),
				"proxy_cluster_id":      (v.ProxyClusterID),
				"secret_store_id":       (v.SecretStoreID),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
				"token":                 seValues["token"],
			},
		})
	case *sdm.KubernetesUserImpersonation:
		localV, ok := localVersion.(*sdm.KubernetesUserImpersonation)
		if !ok {
			localV = &sdm.KubernetesUserImpersonation{}
		}
		_ = localV
		if v.CertificateAuthority != "" {
			seValues["certificate_authority"] = v.CertificateAuthority
		}
		if v.ClientCertificate != "" {
			seValues["client_certificate"] = v.ClientCertificate
		}
		if v.ClientKey != "" {
			seValues["client_key"] = v.ClientKey
		}
		d.Set("kubernetes_user_impersonation", []map[string]interface{}{
			{
				"bind_interface":        (v.BindInterface),
				"certificate_authority": seValues["certificate_authority"],
				"client_certificate":    seValues["client_certificate"],
				"client_key":            seValues["client_key"],
				"egress_filter":         (v.EgressFilter),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"hostname":              (v.Hostname),
				"name":                  (v.Name),
				"port":                  (v.Port),
				"port_override":         (v.PortOverride),
				"proxy_cluster_id":      (v.ProxyClusterID),
				"secret_store_id":       (v.SecretStoreID),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Maria:
		localV, ok := localVersion.(*sdm.Maria)
		if !ok {
			localV = &sdm.Maria{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("maria", []map[string]interface{}{
			{
				"bind_interface":                    (v.BindInterface),
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"name":                              (v.Name),
				"password":                          seValues["password"],
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"proxy_cluster_id":                  (v.ProxyClusterID),
				"require_native_auth":               (v.RequireNativeAuth),
				"secret_store_id":                   (v.SecretStoreID),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          seValues["username"],
			},
		})
	case *sdm.Memcached:
		localV, ok := localVersion.(*sdm.Memcached)
		if !ok {
			localV = &sdm.Memcached{}
		}
		_ = localV
		d.Set("memcached", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Memsql:
		localV, ok := localVersion.(*sdm.Memsql)
		if !ok {
			localV = &sdm.Memsql{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("memsql", []map[string]interface{}{
			{
				"bind_interface":                    (v.BindInterface),
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"name":                              (v.Name),
				"password":                          seValues["password"],
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"proxy_cluster_id":                  (v.ProxyClusterID),
				"require_native_auth":               (v.RequireNativeAuth),
				"secret_store_id":                   (v.SecretStoreID),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          seValues["username"],
			},
		})
	case *sdm.MongoHost:
		localV, ok := localVersion.(*sdm.MongoHost)
		if !ok {
			localV = &sdm.MongoHost{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("mongo_host", []map[string]interface{}{
			{
				"auth_database":    (v.AuthDatabase),
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.MongoLegacyHost:
		localV, ok := localVersion.(*sdm.MongoLegacyHost)
		if !ok {
			localV = &sdm.MongoLegacyHost{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("mongo_legacy_host", []map[string]interface{}{
			{
				"auth_database":    (v.AuthDatabase),
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.MongoLegacyReplicaset:
		localV, ok := localVersion.(*sdm.MongoLegacyReplicaset)
		if !ok {
			localV = &sdm.MongoLegacyReplicaset{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("mongo_legacy_replicaset", []map[string]interface{}{
			{
				"auth_database":      (v.AuthDatabase),
				"bind_interface":     (v.BindInterface),
				"connect_to_replica": (v.ConnectToReplica),
				"egress_filter":      (v.EgressFilter),
				"hostname":           (v.Hostname),
				"name":               (v.Name),
				"password":           seValues["password"],
				"port":               (v.Port),
				"port_override":      (v.PortOverride),
				"proxy_cluster_id":   (v.ProxyClusterID),
				"replica_set":        (v.ReplicaSet),
				"secret_store_id":    (v.SecretStoreID),
				"subdomain":          (v.Subdomain),
				"tags":               convertTagsToPorcelain(v.Tags),
				"tls_required":       (v.TlsRequired),
				"username":           seValues["username"],
			},
		})
	case *sdm.MongoReplicaSet:
		localV, ok := localVersion.(*sdm.MongoReplicaSet)
		if !ok {
			localV = &sdm.MongoReplicaSet{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("mongo_replica_set", []map[string]interface{}{
			{
				"auth_database":      (v.AuthDatabase),
				"bind_interface":     (v.BindInterface),
				"connect_to_replica": (v.ConnectToReplica),
				"egress_filter":      (v.EgressFilter),
				"hostname":           (v.Hostname),
				"name":               (v.Name),
				"password":           seValues["password"],
				"port":               (v.Port),
				"port_override":      (v.PortOverride),
				"proxy_cluster_id":   (v.ProxyClusterID),
				"replica_set":        (v.ReplicaSet),
				"secret_store_id":    (v.SecretStoreID),
				"subdomain":          (v.Subdomain),
				"tags":               convertTagsToPorcelain(v.Tags),
				"tls_required":       (v.TlsRequired),
				"username":           seValues["username"],
			},
		})
	case *sdm.MongoShardedCluster:
		localV, ok := localVersion.(*sdm.MongoShardedCluster)
		if !ok {
			localV = &sdm.MongoShardedCluster{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("mongo_sharded_cluster", []map[string]interface{}{
			{
				"auth_database":    (v.AuthDatabase),
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.MTLSMysql:
		localV, ok := localVersion.(*sdm.MTLSMysql)
		if !ok {
			localV = &sdm.MTLSMysql{}
		}
		_ = localV
		if v.CertificateAuthority != "" {
			seValues["certificate_authority"] = v.CertificateAuthority
		}
		if v.ClientCertificate != "" {
			seValues["client_certificate"] = v.ClientCertificate
		}
		if v.ClientKey != "" {
			seValues["client_key"] = v.ClientKey
		}
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("mtls_mysql", []map[string]interface{}{
			{
				"bind_interface":                    (v.BindInterface),
				"certificate_authority":             seValues["certificate_authority"],
				"client_certificate":                seValues["client_certificate"],
				"client_key":                        seValues["client_key"],
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"name":                              (v.Name),
				"password":                          seValues["password"],
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"proxy_cluster_id":                  (v.ProxyClusterID),
				"require_native_auth":               (v.RequireNativeAuth),
				"secret_store_id":                   (v.SecretStoreID),
				"server_name":                       (v.ServerName),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          seValues["username"],
			},
		})
	case *sdm.MTLSPostgres:
		localV, ok := localVersion.(*sdm.MTLSPostgres)
		if !ok {
			localV = &sdm.MTLSPostgres{}
		}
		_ = localV
		if v.CertificateAuthority != "" {
			seValues["certificate_authority"] = v.CertificateAuthority
		}
		if v.ClientCertificate != "" {
			seValues["client_certificate"] = v.ClientCertificate
		}
		if v.ClientKey != "" {
			seValues["client_key"] = v.ClientKey
		}
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("mtls_postgres", []map[string]interface{}{
			{
				"bind_interface":        (v.BindInterface),
				"certificate_authority": seValues["certificate_authority"],
				"client_certificate":    seValues["client_certificate"],
				"client_key":            seValues["client_key"],
				"database":              (v.Database),
				"egress_filter":         (v.EgressFilter),
				"hostname":              (v.Hostname),
				"name":                  (v.Name),
				"override_database":     (v.OverrideDatabase),
				"password":              seValues["password"],
				"port":                  (v.Port),
				"port_override":         (v.PortOverride),
				"proxy_cluster_id":      (v.ProxyClusterID),
				"secret_store_id":       (v.SecretStoreID),
				"server_name":           (v.ServerName),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
				"username":              seValues["username"],
			},
		})
	case *sdm.Mysql:
		localV, ok := localVersion.(*sdm.Mysql)
		if !ok {
			localV = &sdm.Mysql{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("mysql", []map[string]interface{}{
			{
				"bind_interface":                    (v.BindInterface),
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"name":                              (v.Name),
				"password":                          seValues["password"],
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"proxy_cluster_id":                  (v.ProxyClusterID),
				"require_native_auth":               (v.RequireNativeAuth),
				"secret_store_id":                   (v.SecretStoreID),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          seValues["username"],
			},
		})
	case *sdm.Neptune:
		localV, ok := localVersion.(*sdm.Neptune)
		if !ok {
			localV = &sdm.Neptune{}
		}
		_ = localV
		d.Set("neptune", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"endpoint":         (v.Endpoint),
				"name":             (v.Name),
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.NeptuneIAM:
		localV, ok := localVersion.(*sdm.NeptuneIAM)
		if !ok {
			localV = &sdm.NeptuneIAM{}
		}
		_ = localV
		if v.AccessKey != "" {
			seValues["access_key"] = v.AccessKey
		}
		if v.RoleArn != "" {
			seValues["role_arn"] = v.RoleArn
		}
		if v.RoleExternalID != "" {
			seValues["role_external_id"] = v.RoleExternalID
		}
		if v.SecretAccessKey != "" {
			seValues["secret_access_key"] = v.SecretAccessKey
		}
		d.Set("neptune_iam", []map[string]interface{}{
			{
				"access_key":        seValues["access_key"],
				"bind_interface":    (v.BindInterface),
				"egress_filter":     (v.EgressFilter),
				"endpoint":          (v.Endpoint),
				"name":              (v.Name),
				"port":              (v.Port),
				"port_override":     (v.PortOverride),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"region":            (v.Region),
				"role_arn":          seValues["role_arn"],
				"role_external_id":  seValues["role_external_id"],
				"secret_access_key": seValues["secret_access_key"],
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Oracle:
		localV, ok := localVersion.(*sdm.Oracle)
		if !ok {
			localV = &sdm.Oracle{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("oracle", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"database":         (v.Database),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.OracleNNE:
		localV, ok := localVersion.(*sdm.OracleNNE)
		if !ok {
			localV = &sdm.OracleNNE{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("oracle_nne", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"database":         (v.Database),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"username":         seValues["username"],
			},
		})
	case *sdm.Postgres:
		localV, ok := localVersion.(*sdm.Postgres)
		if !ok {
			localV = &sdm.Postgres{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("postgres", []map[string]interface{}{
			{
				"bind_interface":    (v.BindInterface),
				"database":          (v.Database),
				"egress_filter":     (v.EgressFilter),
				"hostname":          (v.Hostname),
				"name":              (v.Name),
				"override_database": (v.OverrideDatabase),
				"password":          seValues["password"],
				"port":              (v.Port),
				"port_override":     (v.PortOverride),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"username":          seValues["username"],
			},
		})
	case *sdm.Presto:
		localV, ok := localVersion.(*sdm.Presto)
		if !ok {
			localV = &sdm.Presto{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		d.Set("presto", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"database":         (v.Database),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         (v.Username),
			},
		})
	case *sdm.RabbitMQAMQP091:
		localV, ok := localVersion.(*sdm.RabbitMQAMQP091)
		if !ok {
			localV = &sdm.RabbitMQAMQP091{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("rabbitmq_amqp_091", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.RawTCP:
		localV, ok := localVersion.(*sdm.RawTCP)
		if !ok {
			localV = &sdm.RawTCP{}
		}
		_ = localV
		d.Set("raw_tcp", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.RDP:
		localV, ok := localVersion.(*sdm.RDP)
		if !ok {
			localV = &sdm.RDP{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("rdp", []map[string]interface{}{
			{
				"bind_interface":            (v.BindInterface),
				"downgrade_nla_connections": (v.DowngradeNlaConnections),
				"egress_filter":             (v.EgressFilter),
				"hostname":                  (v.Hostname),
				"lock_required":             (v.LockRequired),
				"name":                      (v.Name),
				"password":                  seValues["password"],
				"port":                      (v.Port),
				"port_override":             (v.PortOverride),
				"proxy_cluster_id":          (v.ProxyClusterID),
				"secret_store_id":           (v.SecretStoreID),
				"subdomain":                 (v.Subdomain),
				"tags":                      convertTagsToPorcelain(v.Tags),
				"username":                  seValues["username"],
			},
		})
	case *sdm.RDPCert:
		localV, ok := localVersion.(*sdm.RDPCert)
		if !ok {
			localV = &sdm.RDPCert{}
		}
		_ = localV
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("rdp_cert", []map[string]interface{}{
			{
				"bind_interface":                      (v.BindInterface),
				"egress_filter":                       (v.EgressFilter),
				"hostname":                            (v.Hostname),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"lock_required":                       (v.LockRequired),
				"name":                                (v.Name),
				"port":                                (v.Port),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
				"username":                            seValues["username"],
			},
		})
	case *sdm.RDSPostgresIAM:
		localV, ok := localVersion.(*sdm.RDSPostgresIAM)
		if !ok {
			localV = &sdm.RDSPostgresIAM{}
		}
		_ = localV
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("rds_postgres_iam", []map[string]interface{}{
			{
				"bind_interface":      (v.BindInterface),
				"database":            (v.Database),
				"egress_filter":       (v.EgressFilter),
				"hostname":            (v.Hostname),
				"name":                (v.Name),
				"override_database":   (v.OverrideDatabase),
				"port":                (v.Port),
				"port_override":       (v.PortOverride),
				"proxy_cluster_id":    (v.ProxyClusterID),
				"region":              (v.Region),
				"role_assumption_arn": (v.RoleAssumptionArn),
				"secret_store_id":     (v.SecretStoreID),
				"subdomain":           (v.Subdomain),
				"tags":                convertTagsToPorcelain(v.Tags),
				"username":            seValues["username"],
			},
		})
	case *sdm.Redis:
		localV, ok := localVersion.(*sdm.Redis)
		if !ok {
			localV = &sdm.Redis{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("redis", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.RedisCluster:
		localV, ok := localVersion.(*sdm.RedisCluster)
		if !ok {
			localV = &sdm.RedisCluster{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("redis_cluster", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"tls_required":     (v.TlsRequired),
				"username":         seValues["username"],
			},
		})
	case *sdm.Redshift:
		localV, ok := localVersion.(*sdm.Redshift)
		if !ok {
			localV = &sdm.Redshift{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("redshift", []map[string]interface{}{
			{
				"bind_interface":    (v.BindInterface),
				"database":          (v.Database),
				"egress_filter":     (v.EgressFilter),
				"hostname":          (v.Hostname),
				"name":              (v.Name),
				"override_database": (v.OverrideDatabase),
				"password":          seValues["password"],
				"port":              (v.Port),
				"port_override":     (v.PortOverride),
				"proxy_cluster_id":  (v.ProxyClusterID),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"username":          seValues["username"],
			},
		})
	case *sdm.RedshiftIAM:
		localV, ok := localVersion.(*sdm.RedshiftIAM)
		if !ok {
			localV = &sdm.RedshiftIAM{}
		}
		_ = localV
		d.Set("redshift_iam", []map[string]interface{}{
			{
				"bind_interface":      (v.BindInterface),
				"cluster_id":          (v.ClusterID),
				"database":            (v.Database),
				"egress_filter":       (v.EgressFilter),
				"hostname":            (v.Hostname),
				"name":                (v.Name),
				"override_database":   (v.OverrideDatabase),
				"port":                (v.Port),
				"port_override":       (v.PortOverride),
				"proxy_cluster_id":    (v.ProxyClusterID),
				"region":              (v.Region),
				"role_assumption_arn": (v.RoleAssumptionArn),
				"secret_store_id":     (v.SecretStoreID),
				"subdomain":           (v.Subdomain),
				"tags":                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.RedshiftServerlessIAM:
		localV, ok := localVersion.(*sdm.RedshiftServerlessIAM)
		if !ok {
			localV = &sdm.RedshiftServerlessIAM{}
		}
		_ = localV
		d.Set("redshift_serverless_iam", []map[string]interface{}{
			{
				"bind_interface":      (v.BindInterface),
				"database":            (v.Database),
				"egress_filter":       (v.EgressFilter),
				"hostname":            (v.Hostname),
				"name":                (v.Name),
				"override_database":   (v.OverrideDatabase),
				"port":                (v.Port),
				"port_override":       (v.PortOverride),
				"proxy_cluster_id":    (v.ProxyClusterID),
				"region":              (v.Region),
				"role_assumption_arn": (v.RoleAssumptionArn),
				"secret_store_id":     (v.SecretStoreID),
				"subdomain":           (v.Subdomain),
				"tags":                convertTagsToPorcelain(v.Tags),
				"workgroup":           (v.Workgroup),
			},
		})
	case *sdm.SingleStore:
		localV, ok := localVersion.(*sdm.SingleStore)
		if !ok {
			localV = &sdm.SingleStore{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("single_store", []map[string]interface{}{
			{
				"bind_interface":                    (v.BindInterface),
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"name":                              (v.Name),
				"password":                          seValues["password"],
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"proxy_cluster_id":                  (v.ProxyClusterID),
				"require_native_auth":               (v.RequireNativeAuth),
				"secret_store_id":                   (v.SecretStoreID),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          seValues["username"],
			},
		})
	case *sdm.Snowflake:
		localV, ok := localVersion.(*sdm.Snowflake)
		if !ok {
			localV = &sdm.Snowflake{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("snowflake", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"database":         (v.Database),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"schema":           (v.Schema),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"username":         seValues["username"],
			},
		})
	case *sdm.Snowsight:
		localV, ok := localVersion.(*sdm.Snowsight)
		if !ok {
			localV = &sdm.Snowsight{}
		}
		_ = localV
		if v.SamlMetadata != "" {
			seValues["saml_metadata"] = v.SamlMetadata
		}
		d.Set("snowsight", []map[string]interface{}{
			{
				"bind_interface":       (v.BindInterface),
				"egress_filter":        (v.EgressFilter),
				"healthcheck_username": (v.HealthcheckUsername),
				"name":                 (v.Name),
				"port_override":        (v.PortOverride),
				"proxy_cluster_id":     (v.ProxyClusterID),
				"saml_metadata":        seValues["saml_metadata"],
				"secret_store_id":      (v.SecretStoreID),
				"subdomain":            (v.Subdomain),
				"tags":                 convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.SQLServer:
		localV, ok := localVersion.(*sdm.SQLServer)
		if !ok {
			localV = &sdm.SQLServer{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("sql_server", []map[string]interface{}{
			{
				"allow_deprecated_encryption": (v.AllowDeprecatedEncryption),
				"bind_interface":              (v.BindInterface),
				"database":                    (v.Database),
				"egress_filter":               (v.EgressFilter),
				"hostname":                    (v.Hostname),
				"name":                        (v.Name),
				"override_database":           (v.OverrideDatabase),
				"password":                    seValues["password"],
				"port":                        (v.Port),
				"port_override":               (v.PortOverride),
				"proxy_cluster_id":            (v.ProxyClusterID),
				"schema":                      (v.Schema),
				"secret_store_id":             (v.SecretStoreID),
				"subdomain":                   (v.Subdomain),
				"tags":                        convertTagsToPorcelain(v.Tags),
				"username":                    seValues["username"],
			},
		})
	case *sdm.SQLServerAzureAD:
		localV, ok := localVersion.(*sdm.SQLServerAzureAD)
		if !ok {
			localV = &sdm.SQLServerAzureAD{}
		}
		_ = localV
		if v.ClientID != "" {
			seValues["client_id"] = v.ClientID
		}
		if v.Secret != "" {
			seValues["secret"] = v.Secret
		}
		if v.TenantID != "" {
			seValues["tenant_id"] = v.TenantID
		}
		d.Set("sql_server_azure_ad", []map[string]interface{}{
			{
				"allow_deprecated_encryption": (v.AllowDeprecatedEncryption),
				"bind_interface":              (v.BindInterface),
				"client_id":                   seValues["client_id"],
				"database":                    (v.Database),
				"egress_filter":               (v.EgressFilter),
				"hostname":                    (v.Hostname),
				"name":                        (v.Name),
				"override_database":           (v.OverrideDatabase),
				"port":                        (v.Port),
				"port_override":               (v.PortOverride),
				"proxy_cluster_id":            (v.ProxyClusterID),
				"schema":                      (v.Schema),
				"secret":                      seValues["secret"],
				"secret_store_id":             (v.SecretStoreID),
				"subdomain":                   (v.Subdomain),
				"tags":                        convertTagsToPorcelain(v.Tags),
				"tenant_id":                   seValues["tenant_id"],
			},
		})
	case *sdm.SQLServerKerberosAD:
		localV, ok := localVersion.(*sdm.SQLServerKerberosAD)
		if !ok {
			localV = &sdm.SQLServerKerberosAD{}
		}
		_ = localV
		if v.Keytab != "" {
			seValues["keytab"] = v.Keytab
		}
		if v.KrbConfig != "" {
			seValues["krb_config"] = v.KrbConfig
		}
		if v.Realm != "" {
			seValues["realm"] = v.Realm
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("sql_server_kerberos_ad", []map[string]interface{}{
			{
				"allow_deprecated_encryption": (v.AllowDeprecatedEncryption),
				"bind_interface":              (v.BindInterface),
				"database":                    (v.Database),
				"egress_filter":               (v.EgressFilter),
				"hostname":                    (v.Hostname),
				"keytab":                      seValues["keytab"],
				"krb_config":                  seValues["krb_config"],
				"name":                        (v.Name),
				"override_database":           (v.OverrideDatabase),
				"port":                        (v.Port),
				"port_override":               (v.PortOverride),
				"proxy_cluster_id":            (v.ProxyClusterID),
				"realm":                       seValues["realm"],
				"schema":                      (v.Schema),
				"secret_store_id":             (v.SecretStoreID),
				"server_spn":                  (v.ServerSpn),
				"subdomain":                   (v.Subdomain),
				"tags":                        convertTagsToPorcelain(v.Tags),
				"username":                    seValues["username"],
			},
		})
	case *sdm.SSH:
		localV, ok := localVersion.(*sdm.SSH)
		if !ok {
			localV = &sdm.SSH{}
		}
		_ = localV
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("ssh", []map[string]interface{}{
			{
				"allow_deprecated_key_exchanges": (v.AllowDeprecatedKeyExchanges),
				"bind_interface":                 (v.BindInterface),
				"egress_filter":                  (v.EgressFilter),
				"hostname":                       (v.Hostname),
				"key_type":                       (v.KeyType),
				"name":                           (v.Name),
				"port":                           (v.Port),
				"port_forwarding":                (v.PortForwarding),
				"port_override":                  (v.PortOverride),
				"proxy_cluster_id":               (v.ProxyClusterID),
				"public_key":                     (v.PublicKey),
				"secret_store_id":                (v.SecretStoreID),
				"subdomain":                      (v.Subdomain),
				"tags":                           convertTagsToPorcelain(v.Tags),
				"username":                       seValues["username"],
			},
		})
	case *sdm.SSHCert:
		localV, ok := localVersion.(*sdm.SSHCert)
		if !ok {
			localV = &sdm.SSHCert{}
		}
		_ = localV
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("ssh_cert", []map[string]interface{}{
			{
				"allow_deprecated_key_exchanges":      (v.AllowDeprecatedKeyExchanges),
				"bind_interface":                      (v.BindInterface),
				"egress_filter":                       (v.EgressFilter),
				"hostname":                            (v.Hostname),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"key_type":                            (v.KeyType),
				"name":                                (v.Name),
				"port":                                (v.Port),
				"port_forwarding":                     (v.PortForwarding),
				"port_override":                       (v.PortOverride),
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
				"username":                            seValues["username"],
			},
		})
	case *sdm.SSHCustomerKey:
		localV, ok := localVersion.(*sdm.SSHCustomerKey)
		if !ok {
			localV = &sdm.SSHCustomerKey{}
		}
		_ = localV
		if v.PrivateKey != "" {
			seValues["private_key"] = v.PrivateKey
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("ssh_customer_key", []map[string]interface{}{
			{
				"allow_deprecated_key_exchanges":      (v.AllowDeprecatedKeyExchanges),
				"bind_interface":                      (v.BindInterface),
				"egress_filter":                       (v.EgressFilter),
				"hostname":                            (v.Hostname),
				"identity_alias_healthcheck_username": (v.IdentityAliasHealthcheckUsername),
				"identity_set_id":                     (v.IdentitySetID),
				"name":                                (v.Name),
				"port":                                (v.Port),
				"port_forwarding":                     (v.PortForwarding),
				"port_override":                       (v.PortOverride),
				"private_key":                         seValues["private_key"],
				"proxy_cluster_id":                    (v.ProxyClusterID),
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
				"username":                            seValues["username"],
			},
		})
	case *sdm.SSHPassword:
		localV, ok := localVersion.(*sdm.SSHPassword)
		if !ok {
			localV = &sdm.SSHPassword{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("ssh_password", []map[string]interface{}{
			{
				"allow_deprecated_key_exchanges": (v.AllowDeprecatedKeyExchanges),
				"bind_interface":                 (v.BindInterface),
				"egress_filter":                  (v.EgressFilter),
				"hostname":                       (v.Hostname),
				"name":                           (v.Name),
				"password":                       seValues["password"],
				"port":                           (v.Port),
				"port_forwarding":                (v.PortForwarding),
				"port_override":                  (v.PortOverride),
				"proxy_cluster_id":               (v.ProxyClusterID),
				"secret_store_id":                (v.SecretStoreID),
				"subdomain":                      (v.Subdomain),
				"tags":                           convertTagsToPorcelain(v.Tags),
				"username":                       seValues["username"],
			},
		})
	case *sdm.Sybase:
		localV, ok := localVersion.(*sdm.Sybase)
		if !ok {
			localV = &sdm.Sybase{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("sybase", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"username":         seValues["username"],
			},
		})
	case *sdm.SybaseIQ:
		localV, ok := localVersion.(*sdm.SybaseIQ)
		if !ok {
			localV = &sdm.SybaseIQ{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("sybase_iq", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"username":         seValues["username"],
			},
		})
	case *sdm.Teradata:
		localV, ok := localVersion.(*sdm.Teradata)
		if !ok {
			localV = &sdm.Teradata{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("teradata", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"username":         seValues["username"],
			},
		})
	case *sdm.Trino:
		localV, ok := localVersion.(*sdm.Trino)
		if !ok {
			localV = &sdm.Trino{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		d.Set("trino", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"database":         (v.Database),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"username":         (v.Username),
			},
		})
	case *sdm.Vertica:
		localV, ok := localVersion.(*sdm.Vertica)
		if !ok {
			localV = &sdm.Vertica{}
		}
		_ = localV
		if v.Password != "" {
			seValues["password"] = v.Password
		}
		if v.Username != "" {
			seValues["username"] = v.Username
		}
		d.Set("vertica", []map[string]interface{}{
			{
				"bind_interface":   (v.BindInterface),
				"database":         (v.Database),
				"egress_filter":    (v.EgressFilter),
				"hostname":         (v.Hostname),
				"name":             (v.Name),
				"password":         seValues["password"],
				"port":             (v.Port),
				"port_override":    (v.PortOverride),
				"proxy_cluster_id": (v.ProxyClusterID),
				"secret_store_id":  (v.SecretStoreID),
				"subdomain":        (v.Subdomain),
				"tags":             convertTagsToPorcelain(v.Tags),
				"username":         seValues["username"],
			},
		})
	}
	return nil
}
func resourceResourceUpdate(ctx context.Context, d *schema.ResourceData, cc *sdm.Client) error {
	ctx, cancel := context.WithTimeout(ctx, d.Timeout(schema.TimeoutUpdate))
	defer cancel()
	_, err := secretStoreValuesForResource(d)
	if err != nil {
		return fmt.Errorf("cannot update Resource %s: %w", d.Id(), err)
	}
	resp, err := cc.Resources().Update(ctx, convertResourceToPlumbing(d))
	if err != nil {
		return fmt.Errorf("cannot update Resource %s: %w", d.Id(), err)
	}
	d.SetId(resp.Resource.GetID())
	return resourceResourceRead(ctx, d, cc)
}
func resourceResourceDelete(ctx context.Context, d *schema.ResourceData, cc *sdm.Client) error {
	ctx, cancel := context.WithTimeout(ctx, d.Timeout(schema.TimeoutDelete))
	defer cancel()
	var errNotFound *sdm.NotFoundError
	_, err := cc.Resources().Delete(ctx, d.Id())
	if err != nil && errors.As(err, &errNotFound) {
		return nil
	}
	return err
}
