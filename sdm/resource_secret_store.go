// Code generated by protogen. DO NOT EDIT.

package sdm

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	sdm "github.com/strongdm/terraform-provider-sdm/sdm/internal/sdk"
)

func resourceSecretStore() *schema.Resource {
	return &schema.Resource{
		CreateContext: wrapCrudOperation(resourceSecretStoreCreate),
		ReadContext:   wrapCrudOperation(resourceSecretStoreRead),
		UpdateContext: wrapCrudOperation(resourceSecretStoreUpdate),
		DeleteContext: wrapCrudOperation(resourceSecretStoreDelete),
		Importer: &schema.ResourceImporter{
			State: schema.ImportStatePassthrough,
		},
		Schema: map[string]*schema.Schema{
			"active_directory_store": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the SecretStore.",
						},
						"server_address": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Hostname of server that is hosting NDES (Network Device Enrollment Services). Often this is the same host as Active Directory Certificate Services",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"aws": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the SecretStore.",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The AWS region to target e.g. us-east-1",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"aws_cert_x509": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"ca_arn": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The ARN of the CA in AWS Private CA",
						},
						"certificate_template_arn": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The ARN of the AWS certificate template for requested certificates. Must allow SAN, key usage, and ext key usage passthrough from CSR",
						},
						"issued_cert_ttl_minutes": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The lifetime of certificates issued by this CA represented in minutes.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the SecretStore.",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The AWS region to target e.g. us-east-1",
						},
						"signing_algo": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The specified signing algorithm family (RSA or ECDSA) must match the algorithm family of the CA's secret key. e.g. SHA256WITHRSA",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"azure_store": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the SecretStore.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"vault_uri": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The URI of the key vault to target e.g. https://myvault.vault.azure.net",
						},
					},
				},
			},
			"cyberark_conjur": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"app_url": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The URL of the Cyberark instance",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the SecretStore.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"cyberark_pam": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"app_url": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The URL of the Cyberark instance",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the SecretStore.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"cyberark_pam_experimental": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "CyberarkPAMExperimentalStore is currently unstable, and its API may change, or it may be removed, without a major version bump.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"app_url": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The URL of the Cyberark instance",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the SecretStore.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"delinea_store": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the SecretStore.",
						},
						"server_url": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The URL of the Delinea instance",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tenant_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The tenant name to target",
						},
					},
				},
			},
			"gcp_store": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the SecretStore.",
						},
						"project_id": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The GCP project ID to target.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"gcp_cert_x_509_store": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"ca_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The ID of the target CA",
						},
						"ca_pool_id": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The ID of the target CA pool",
						},
						"issued_cert_ttl_minutes": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The lifetime of certificates issued by this CA represented in minutes.",
						},
						"location": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The Region for the CA in GCP format e.g. us-west1",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the SecretStore.",
						},
						"project_id": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The GCP project ID to target.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"keyfactor_ssh_store": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"ca_file_path": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.",
						},
						"certificate_file_path": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.",
						},
						"default_certificate_authority_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Name of EJBCA certificate authority that will enroll CSR.",
						},
						"default_certificate_profile_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Certificate profile name that EJBCA will enroll the CSR with.",
						},
						"default_end_entity_profile_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "End entity profile that EJBCA will enroll the CSR with.",
						},
						"enrollment_code_env_var": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "code used by EJBCA during enrollment. May be left blank if no code is required.",
						},
						"enrollment_username_env_var": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.",
						},
						"key_file_path": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the SecretStore.",
						},
						"server_address": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "the host of the Key Factor CA",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"keyfactor_x_509_store": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"ca_file_path": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.",
						},
						"certificate_file_path": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.",
						},
						"default_certificate_authority_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Name of EJBCA certificate authority that will enroll CSR.",
						},
						"default_certificate_profile_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Certificate profile name that EJBCA will enroll the CSR with.",
						},
						"default_end_entity_profile_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "End entity profile that EJBCA will enroll the CSR with.",
						},
						"enrollment_code_env_var": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "code used by EJBCA during enrollment. May be left blank if no code is required.",
						},
						"enrollment_username_env_var": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.",
						},
						"key_file_path": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the SecretStore.",
						},
						"server_address": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "the host of the Key Factor CA",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"vault_approle": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the SecretStore.",
						},
						"namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The namespace to make requests within",
						},
						"server_address": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The URL of the Vault to target",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"vault_approle_cert_ssh": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"issued_cert_ttl_minutes": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The lifetime of certificates issued by this CA represented in minutes.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the SecretStore.",
						},
						"namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The namespace to make requests within",
						},
						"server_address": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The URL of the Vault to target",
						},
						"signing_role": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The signing role to be used for signing certificates",
						},
						"ssh_mount_point": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The mount point of the SSH engine configured with the desired CA",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"vault_approle_cert_x509": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"issued_cert_ttl_minutes": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The lifetime of certificates issued by this CA in minutes. Recommended value is 5.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the SecretStore.",
						},
						"namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The namespace to make requests within",
						},
						"pki_mount_point": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The mount point of the PKI engine configured with the desired CA",
						},
						"server_address": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The URL of the Vault to target",
						},
						"signing_role": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The signing role to be used for signing certificates",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"vault_aws_ec2": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "VaultAWSEC2Store is currently unstable, and its API may change, or it may be removed, without a major version bump.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the SecretStore.",
						},
						"namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The namespace to make requests within",
						},
						"server_address": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The URL of the Vault to target",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"vault_aws_iam": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "VaultAWSIAMStore is currently unstable, and its API may change, or it may be removed, without a major version bump.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the SecretStore.",
						},
						"namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The namespace to make requests within",
						},
						"server_address": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The URL of the Vault to target",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"vault_tls": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"ca_cert_path": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A path to a CA file accessible by a Node",
						},
						"client_cert_path": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "A path to a client certificate file accessible by a Node",
						},
						"client_key_path": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "A path to a client key file accessible by a Node",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the SecretStore.",
						},
						"namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The namespace to make requests within",
						},
						"server_address": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The URL of the Vault to target",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"vault_tls_cert_ssh": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"ca_cert_path": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A path to a CA file accessible by a Node",
						},
						"client_cert_path": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "A path to a client certificate file accessible by a Node",
						},
						"client_key_path": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "A path to a client key file accessible by a Node",
						},
						"issued_cert_ttl_minutes": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The lifetime of certificates issued by this CA represented in minutes.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the SecretStore.",
						},
						"namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The namespace to make requests within",
						},
						"server_address": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The URL of the Vault to target",
						},
						"signing_role": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The signing role to be used for signing certificates",
						},
						"ssh_mount_point": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The mount point of the SSH engine configured with the desired CA",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"vault_tls_cert_x509": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"ca_cert_path": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A path to a CA file accessible by a Node",
						},
						"client_cert_path": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "A path to a client certificate file accessible by a Node",
						},
						"client_key_path": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "A path to a client key file accessible by a Node",
						},
						"issued_cert_ttl_minutes": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The lifetime of certificates issued by this CA represented in minutes.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the SecretStore.",
						},
						"namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The namespace to make requests within",
						},
						"pki_mount_point": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The mount point of the PKI engine configured with the desired CA",
						},
						"server_address": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The URL of the Vault to target",
						},
						"signing_role": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The signing role to be used for signing certificates",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"vault_token": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the SecretStore.",
						},
						"namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The namespace to make requests within",
						},
						"server_address": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The URL of the Vault to target",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"vault_token_cert_ssh": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"issued_cert_ttl_minutes": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The lifetime of certificates issued by this CA in minutes. Recommended value is 5.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the SecretStore.",
						},
						"namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The namespace to make requests within",
						},
						"server_address": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The URL of the Vault to target",
						},
						"signing_role": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The signing role to be used for signing certificates",
						},
						"ssh_mount_point": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The mount point of the SSH engine configured with the desired CA",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"vault_token_cert_x509": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"issued_cert_ttl_minutes": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The lifetime of certificates issued by this CA represented in minutes.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the SecretStore.",
						},
						"namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The namespace to make requests within",
						},
						"pki_mount_point": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The mount point of the PKI engine configured with the desired CA",
						},
						"server_address": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The URL of the Vault to target",
						},
						"signing_role": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The signing role to be used for signing certificates",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
		},
		Timeouts: &schema.ResourceTimeout{
			Default: schema.DefaultTimeout(60 * time.Second),
			Create:  schema.DefaultTimeout(60 * time.Second),
			Read:    schema.DefaultTimeout(60 * time.Second),
			Update:  schema.DefaultTimeout(60 * time.Second),
			Delete:  schema.DefaultTimeout(60 * time.Second),
		},
	}
}
func convertSecretStoreToPlumbing(d *schema.ResourceData) sdm.SecretStore {
	if list := d.Get("active_directory_store").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.ActiveDirectoryStore{}
		}
		out := &sdm.ActiveDirectoryStore{
			ID:            d.Id(),
			Name:          convertStringToPlumbing(raw["name"]),
			ServerAddress: convertStringToPlumbing(raw["server_address"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
		}
		return out
	}
	if list := d.Get("aws").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AWSStore{}
		}
		out := &sdm.AWSStore{
			ID:     d.Id(),
			Name:   convertStringToPlumbing(raw["name"]),
			Region: convertStringToPlumbing(raw["region"]),
			Tags:   convertTagsToPlumbing(raw["tags"]),
		}
		return out
	}
	if list := d.Get("aws_cert_x509").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AWSCertX509Store{}
		}
		out := &sdm.AWSCertX509Store{
			ID:                     d.Id(),
			CaArn:                  convertStringToPlumbing(raw["ca_arn"]),
			CertificateTemplateArn: convertStringToPlumbing(raw["certificate_template_arn"]),
			IssuedCertTTLMinutes:   convertInt32ToPlumbing(raw["issued_cert_ttl_minutes"]),
			Name:                   convertStringToPlumbing(raw["name"]),
			Region:                 convertStringToPlumbing(raw["region"]),
			SigningAlgo:            convertStringToPlumbing(raw["signing_algo"]),
			Tags:                   convertTagsToPlumbing(raw["tags"]),
		}
		return out
	}
	if list := d.Get("azure_store").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AzureStore{}
		}
		out := &sdm.AzureStore{
			ID:       d.Id(),
			Name:     convertStringToPlumbing(raw["name"]),
			Tags:     convertTagsToPlumbing(raw["tags"]),
			VaultUri: convertStringToPlumbing(raw["vault_uri"]),
		}
		return out
	}
	if list := d.Get("cyberark_conjur").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.CyberarkConjurStore{}
		}
		out := &sdm.CyberarkConjurStore{
			ID:     d.Id(),
			AppURL: convertStringToPlumbing(raw["app_url"]),
			Name:   convertStringToPlumbing(raw["name"]),
			Tags:   convertTagsToPlumbing(raw["tags"]),
		}
		return out
	}
	if list := d.Get("cyberark_pam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.CyberarkPAMStore{}
		}
		out := &sdm.CyberarkPAMStore{
			ID:     d.Id(),
			AppURL: convertStringToPlumbing(raw["app_url"]),
			Name:   convertStringToPlumbing(raw["name"]),
			Tags:   convertTagsToPlumbing(raw["tags"]),
		}
		return out
	}
	if list := d.Get("cyberark_pam_experimental").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.CyberarkPAMExperimentalStore{}
		}
		out := &sdm.CyberarkPAMExperimentalStore{
			ID:     d.Id(),
			AppURL: convertStringToPlumbing(raw["app_url"]),
			Name:   convertStringToPlumbing(raw["name"]),
			Tags:   convertTagsToPlumbing(raw["tags"]),
		}
		return out
	}
	if list := d.Get("delinea_store").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.DelineaStore{}
		}
		out := &sdm.DelineaStore{
			ID:         d.Id(),
			Name:       convertStringToPlumbing(raw["name"]),
			ServerUrl:  convertStringToPlumbing(raw["server_url"]),
			Tags:       convertTagsToPlumbing(raw["tags"]),
			TenantName: convertStringToPlumbing(raw["tenant_name"]),
		}
		return out
	}
	if list := d.Get("gcp_store").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.GCPStore{}
		}
		out := &sdm.GCPStore{
			ID:        d.Id(),
			Name:      convertStringToPlumbing(raw["name"]),
			ProjectID: convertStringToPlumbing(raw["project_id"]),
			Tags:      convertTagsToPlumbing(raw["tags"]),
		}
		return out
	}
	if list := d.Get("gcp_cert_x_509_store").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.GCPCertX509Store{}
		}
		out := &sdm.GCPCertX509Store{
			ID:                   d.Id(),
			CaID:                 convertStringToPlumbing(raw["ca_id"]),
			CaPoolID:             convertStringToPlumbing(raw["ca_pool_id"]),
			IssuedCertTTLMinutes: convertInt32ToPlumbing(raw["issued_cert_ttl_minutes"]),
			Location:             convertStringToPlumbing(raw["location"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			ProjectID:            convertStringToPlumbing(raw["project_id"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
		}
		return out
	}
	if list := d.Get("keyfactor_ssh_store").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.KeyfactorSSHStore{}
		}
		out := &sdm.KeyfactorSSHStore{
			ID:                              d.Id(),
			CaFilePath:                      convertStringToPlumbing(raw["ca_file_path"]),
			CertificateFilePath:             convertStringToPlumbing(raw["certificate_file_path"]),
			DefaultCertificateAuthorityName: convertStringToPlumbing(raw["default_certificate_authority_name"]),
			DefaultCertificateProfileName:   convertStringToPlumbing(raw["default_certificate_profile_name"]),
			DefaultEndEntityProfileName:     convertStringToPlumbing(raw["default_end_entity_profile_name"]),
			EnrollmentCodeEnvVar:            convertStringToPlumbing(raw["enrollment_code_env_var"]),
			EnrollmentUsernameEnvVar:        convertStringToPlumbing(raw["enrollment_username_env_var"]),
			KeyFilePath:                     convertStringToPlumbing(raw["key_file_path"]),
			Name:                            convertStringToPlumbing(raw["name"]),
			ServerAddress:                   convertStringToPlumbing(raw["server_address"]),
			Tags:                            convertTagsToPlumbing(raw["tags"]),
		}
		return out
	}
	if list := d.Get("keyfactor_x_509_store").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.KeyfactorX509Store{}
		}
		out := &sdm.KeyfactorX509Store{
			ID:                              d.Id(),
			CaFilePath:                      convertStringToPlumbing(raw["ca_file_path"]),
			CertificateFilePath:             convertStringToPlumbing(raw["certificate_file_path"]),
			DefaultCertificateAuthorityName: convertStringToPlumbing(raw["default_certificate_authority_name"]),
			DefaultCertificateProfileName:   convertStringToPlumbing(raw["default_certificate_profile_name"]),
			DefaultEndEntityProfileName:     convertStringToPlumbing(raw["default_end_entity_profile_name"]),
			EnrollmentCodeEnvVar:            convertStringToPlumbing(raw["enrollment_code_env_var"]),
			EnrollmentUsernameEnvVar:        convertStringToPlumbing(raw["enrollment_username_env_var"]),
			KeyFilePath:                     convertStringToPlumbing(raw["key_file_path"]),
			Name:                            convertStringToPlumbing(raw["name"]),
			ServerAddress:                   convertStringToPlumbing(raw["server_address"]),
			Tags:                            convertTagsToPlumbing(raw["tags"]),
		}
		return out
	}
	if list := d.Get("vault_approle").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.VaultAppRoleStore{}
		}
		out := &sdm.VaultAppRoleStore{
			ID:            d.Id(),
			Name:          convertStringToPlumbing(raw["name"]),
			Namespace:     convertStringToPlumbing(raw["namespace"]),
			ServerAddress: convertStringToPlumbing(raw["server_address"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
		}
		return out
	}
	if list := d.Get("vault_approle_cert_ssh").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.VaultAppRoleCertSSHStore{}
		}
		out := &sdm.VaultAppRoleCertSSHStore{
			ID:                   d.Id(),
			IssuedCertTTLMinutes: convertInt32ToPlumbing(raw["issued_cert_ttl_minutes"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			Namespace:            convertStringToPlumbing(raw["namespace"]),
			ServerAddress:        convertStringToPlumbing(raw["server_address"]),
			SigningRole:          convertStringToPlumbing(raw["signing_role"]),
			SshMountPoint:        convertStringToPlumbing(raw["ssh_mount_point"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
		}
		return out
	}
	if list := d.Get("vault_approle_cert_x509").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.VaultAppRoleCertX509Store{}
		}
		out := &sdm.VaultAppRoleCertX509Store{
			ID:                   d.Id(),
			IssuedCertTTLMinutes: convertInt32ToPlumbing(raw["issued_cert_ttl_minutes"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			Namespace:            convertStringToPlumbing(raw["namespace"]),
			PkiMountPoint:        convertStringToPlumbing(raw["pki_mount_point"]),
			ServerAddress:        convertStringToPlumbing(raw["server_address"]),
			SigningRole:          convertStringToPlumbing(raw["signing_role"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
		}
		return out
	}
	if list := d.Get("vault_aws_ec2").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.VaultAWSEC2Store{}
		}
		out := &sdm.VaultAWSEC2Store{
			ID:            d.Id(),
			Name:          convertStringToPlumbing(raw["name"]),
			Namespace:     convertStringToPlumbing(raw["namespace"]),
			ServerAddress: convertStringToPlumbing(raw["server_address"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
		}
		return out
	}
	if list := d.Get("vault_aws_iam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.VaultAWSIAMStore{}
		}
		out := &sdm.VaultAWSIAMStore{
			ID:            d.Id(),
			Name:          convertStringToPlumbing(raw["name"]),
			Namespace:     convertStringToPlumbing(raw["namespace"]),
			ServerAddress: convertStringToPlumbing(raw["server_address"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
		}
		return out
	}
	if list := d.Get("vault_tls").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.VaultTLSStore{}
		}
		out := &sdm.VaultTLSStore{
			ID:             d.Id(),
			CACertPath:     convertStringToPlumbing(raw["ca_cert_path"]),
			ClientCertPath: convertStringToPlumbing(raw["client_cert_path"]),
			ClientKeyPath:  convertStringToPlumbing(raw["client_key_path"]),
			Name:           convertStringToPlumbing(raw["name"]),
			Namespace:      convertStringToPlumbing(raw["namespace"]),
			ServerAddress:  convertStringToPlumbing(raw["server_address"]),
			Tags:           convertTagsToPlumbing(raw["tags"]),
		}
		return out
	}
	if list := d.Get("vault_tls_cert_ssh").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.VaultTLSCertSSHStore{}
		}
		out := &sdm.VaultTLSCertSSHStore{
			ID:                   d.Id(),
			CACertPath:           convertStringToPlumbing(raw["ca_cert_path"]),
			ClientCertPath:       convertStringToPlumbing(raw["client_cert_path"]),
			ClientKeyPath:        convertStringToPlumbing(raw["client_key_path"]),
			IssuedCertTTLMinutes: convertInt32ToPlumbing(raw["issued_cert_ttl_minutes"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			Namespace:            convertStringToPlumbing(raw["namespace"]),
			ServerAddress:        convertStringToPlumbing(raw["server_address"]),
			SigningRole:          convertStringToPlumbing(raw["signing_role"]),
			SshMountPoint:        convertStringToPlumbing(raw["ssh_mount_point"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
		}
		return out
	}
	if list := d.Get("vault_tls_cert_x509").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.VaultTLSCertX509Store{}
		}
		out := &sdm.VaultTLSCertX509Store{
			ID:                   d.Id(),
			CACertPath:           convertStringToPlumbing(raw["ca_cert_path"]),
			ClientCertPath:       convertStringToPlumbing(raw["client_cert_path"]),
			ClientKeyPath:        convertStringToPlumbing(raw["client_key_path"]),
			IssuedCertTTLMinutes: convertInt32ToPlumbing(raw["issued_cert_ttl_minutes"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			Namespace:            convertStringToPlumbing(raw["namespace"]),
			PkiMountPoint:        convertStringToPlumbing(raw["pki_mount_point"]),
			ServerAddress:        convertStringToPlumbing(raw["server_address"]),
			SigningRole:          convertStringToPlumbing(raw["signing_role"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
		}
		return out
	}
	if list := d.Get("vault_token").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.VaultTokenStore{}
		}
		out := &sdm.VaultTokenStore{
			ID:            d.Id(),
			Name:          convertStringToPlumbing(raw["name"]),
			Namespace:     convertStringToPlumbing(raw["namespace"]),
			ServerAddress: convertStringToPlumbing(raw["server_address"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
		}
		return out
	}
	if list := d.Get("vault_token_cert_ssh").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.VaultTokenCertSSHStore{}
		}
		out := &sdm.VaultTokenCertSSHStore{
			ID:                   d.Id(),
			IssuedCertTTLMinutes: convertInt32ToPlumbing(raw["issued_cert_ttl_minutes"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			Namespace:            convertStringToPlumbing(raw["namespace"]),
			ServerAddress:        convertStringToPlumbing(raw["server_address"]),
			SigningRole:          convertStringToPlumbing(raw["signing_role"]),
			SshMountPoint:        convertStringToPlumbing(raw["ssh_mount_point"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
		}
		return out
	}
	if list := d.Get("vault_token_cert_x509").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.VaultTokenCertX509Store{}
		}
		out := &sdm.VaultTokenCertX509Store{
			ID:                   d.Id(),
			IssuedCertTTLMinutes: convertInt32ToPlumbing(raw["issued_cert_ttl_minutes"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			Namespace:            convertStringToPlumbing(raw["namespace"]),
			PkiMountPoint:        convertStringToPlumbing(raw["pki_mount_point"]),
			ServerAddress:        convertStringToPlumbing(raw["server_address"]),
			SigningRole:          convertStringToPlumbing(raw["signing_role"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
		}
		return out
	}
	return nil
}

func resourceSecretStoreCreate(ctx context.Context, d *schema.ResourceData, cc *sdm.Client) error {
	localVersion := convertSecretStoreToPlumbing(d)
	resp, err := cc.SecretStores().Create(ctx, localVersion)
	if err != nil {
		return fmt.Errorf("cannot create SecretStore: %w", err)
	}
	d.SetId(resp.SecretStore.GetID())
	switch v := resp.SecretStore.(type) {
	case *sdm.ActiveDirectoryStore:
		localV, _ := localVersion.(*sdm.ActiveDirectoryStore)
		_ = localV
		d.Set("active_directory_store", []map[string]interface{}{
			{
				"name":           (v.Name),
				"server_address": (v.ServerAddress),
				"tags":           convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AWSStore:
		localV, _ := localVersion.(*sdm.AWSStore)
		_ = localV
		d.Set("aws", []map[string]interface{}{
			{
				"name":   (v.Name),
				"region": (v.Region),
				"tags":   convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AWSCertX509Store:
		localV, _ := localVersion.(*sdm.AWSCertX509Store)
		_ = localV
		d.Set("aws_cert_x509", []map[string]interface{}{
			{
				"ca_arn":                   (v.CaArn),
				"certificate_template_arn": (v.CertificateTemplateArn),
				"issued_cert_ttl_minutes":  (v.IssuedCertTTLMinutes),
				"name":                     (v.Name),
				"region":                   (v.Region),
				"signing_algo":             (v.SigningAlgo),
				"tags":                     convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AzureStore:
		localV, _ := localVersion.(*sdm.AzureStore)
		_ = localV
		d.Set("azure_store", []map[string]interface{}{
			{
				"name":      (v.Name),
				"tags":      convertTagsToPorcelain(v.Tags),
				"vault_uri": (v.VaultUri),
			},
		})
	case *sdm.CyberarkConjurStore:
		localV, _ := localVersion.(*sdm.CyberarkConjurStore)
		_ = localV
		d.Set("cyberark_conjur", []map[string]interface{}{
			{
				"app_url": (v.AppURL),
				"name":    (v.Name),
				"tags":    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.CyberarkPAMStore:
		localV, _ := localVersion.(*sdm.CyberarkPAMStore)
		_ = localV
		d.Set("cyberark_pam", []map[string]interface{}{
			{
				"app_url": (v.AppURL),
				"name":    (v.Name),
				"tags":    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.CyberarkPAMExperimentalStore:
		localV, _ := localVersion.(*sdm.CyberarkPAMExperimentalStore)
		_ = localV
		d.Set("cyberark_pam_experimental", []map[string]interface{}{
			{
				"app_url": (v.AppURL),
				"name":    (v.Name),
				"tags":    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.DelineaStore:
		localV, _ := localVersion.(*sdm.DelineaStore)
		_ = localV
		d.Set("delinea_store", []map[string]interface{}{
			{
				"name":        (v.Name),
				"server_url":  (v.ServerUrl),
				"tags":        convertTagsToPorcelain(v.Tags),
				"tenant_name": (v.TenantName),
			},
		})
	case *sdm.GCPStore:
		localV, _ := localVersion.(*sdm.GCPStore)
		_ = localV
		d.Set("gcp_store", []map[string]interface{}{
			{
				"name":       (v.Name),
				"project_id": (v.ProjectID),
				"tags":       convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.GCPCertX509Store:
		localV, _ := localVersion.(*sdm.GCPCertX509Store)
		_ = localV
		d.Set("gcp_cert_x_509_store", []map[string]interface{}{
			{
				"ca_id":                   (v.CaID),
				"ca_pool_id":              (v.CaPoolID),
				"issued_cert_ttl_minutes": (v.IssuedCertTTLMinutes),
				"location":                (v.Location),
				"name":                    (v.Name),
				"project_id":              (v.ProjectID),
				"tags":                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.KeyfactorSSHStore:
		localV, _ := localVersion.(*sdm.KeyfactorSSHStore)
		_ = localV
		d.Set("keyfactor_ssh_store", []map[string]interface{}{
			{
				"ca_file_path":                       (v.CaFilePath),
				"certificate_file_path":              (v.CertificateFilePath),
				"default_certificate_authority_name": (v.DefaultCertificateAuthorityName),
				"default_certificate_profile_name":   (v.DefaultCertificateProfileName),
				"default_end_entity_profile_name":    (v.DefaultEndEntityProfileName),
				"enrollment_code_env_var":            (v.EnrollmentCodeEnvVar),
				"enrollment_username_env_var":        (v.EnrollmentUsernameEnvVar),
				"key_file_path":                      (v.KeyFilePath),
				"name":                               (v.Name),
				"server_address":                     (v.ServerAddress),
				"tags":                               convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.KeyfactorX509Store:
		localV, _ := localVersion.(*sdm.KeyfactorX509Store)
		_ = localV
		d.Set("keyfactor_x_509_store", []map[string]interface{}{
			{
				"ca_file_path":                       (v.CaFilePath),
				"certificate_file_path":              (v.CertificateFilePath),
				"default_certificate_authority_name": (v.DefaultCertificateAuthorityName),
				"default_certificate_profile_name":   (v.DefaultCertificateProfileName),
				"default_end_entity_profile_name":    (v.DefaultEndEntityProfileName),
				"enrollment_code_env_var":            (v.EnrollmentCodeEnvVar),
				"enrollment_username_env_var":        (v.EnrollmentUsernameEnvVar),
				"key_file_path":                      (v.KeyFilePath),
				"name":                               (v.Name),
				"server_address":                     (v.ServerAddress),
				"tags":                               convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.VaultAppRoleStore:
		localV, _ := localVersion.(*sdm.VaultAppRoleStore)
		_ = localV
		d.Set("vault_approle", []map[string]interface{}{
			{
				"name":           (v.Name),
				"namespace":      (v.Namespace),
				"server_address": (v.ServerAddress),
				"tags":           convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.VaultAppRoleCertSSHStore:
		localV, _ := localVersion.(*sdm.VaultAppRoleCertSSHStore)
		_ = localV
		d.Set("vault_approle_cert_ssh", []map[string]interface{}{
			{
				"issued_cert_ttl_minutes": (v.IssuedCertTTLMinutes),
				"name":                    (v.Name),
				"namespace":               (v.Namespace),
				"server_address":          (v.ServerAddress),
				"signing_role":            (v.SigningRole),
				"ssh_mount_point":         (v.SshMountPoint),
				"tags":                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.VaultAppRoleCertX509Store:
		localV, _ := localVersion.(*sdm.VaultAppRoleCertX509Store)
		_ = localV
		d.Set("vault_approle_cert_x509", []map[string]interface{}{
			{
				"issued_cert_ttl_minutes": (v.IssuedCertTTLMinutes),
				"name":                    (v.Name),
				"namespace":               (v.Namespace),
				"pki_mount_point":         (v.PkiMountPoint),
				"server_address":          (v.ServerAddress),
				"signing_role":            (v.SigningRole),
				"tags":                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.VaultAWSEC2Store:
		localV, _ := localVersion.(*sdm.VaultAWSEC2Store)
		_ = localV
		d.Set("vault_aws_ec2", []map[string]interface{}{
			{
				"name":           (v.Name),
				"namespace":      (v.Namespace),
				"server_address": (v.ServerAddress),
				"tags":           convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.VaultAWSIAMStore:
		localV, _ := localVersion.(*sdm.VaultAWSIAMStore)
		_ = localV
		d.Set("vault_aws_iam", []map[string]interface{}{
			{
				"name":           (v.Name),
				"namespace":      (v.Namespace),
				"server_address": (v.ServerAddress),
				"tags":           convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.VaultTLSStore:
		localV, _ := localVersion.(*sdm.VaultTLSStore)
		_ = localV
		d.Set("vault_tls", []map[string]interface{}{
			{
				"ca_cert_path":     (v.CACertPath),
				"client_cert_path": (v.ClientCertPath),
				"client_key_path":  (v.ClientKeyPath),
				"name":             (v.Name),
				"namespace":        (v.Namespace),
				"server_address":   (v.ServerAddress),
				"tags":             convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.VaultTLSCertSSHStore:
		localV, _ := localVersion.(*sdm.VaultTLSCertSSHStore)
		_ = localV
		d.Set("vault_tls_cert_ssh", []map[string]interface{}{
			{
				"ca_cert_path":            (v.CACertPath),
				"client_cert_path":        (v.ClientCertPath),
				"client_key_path":         (v.ClientKeyPath),
				"issued_cert_ttl_minutes": (v.IssuedCertTTLMinutes),
				"name":                    (v.Name),
				"namespace":               (v.Namespace),
				"server_address":          (v.ServerAddress),
				"signing_role":            (v.SigningRole),
				"ssh_mount_point":         (v.SshMountPoint),
				"tags":                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.VaultTLSCertX509Store:
		localV, _ := localVersion.(*sdm.VaultTLSCertX509Store)
		_ = localV
		d.Set("vault_tls_cert_x509", []map[string]interface{}{
			{
				"ca_cert_path":            (v.CACertPath),
				"client_cert_path":        (v.ClientCertPath),
				"client_key_path":         (v.ClientKeyPath),
				"issued_cert_ttl_minutes": (v.IssuedCertTTLMinutes),
				"name":                    (v.Name),
				"namespace":               (v.Namespace),
				"pki_mount_point":         (v.PkiMountPoint),
				"server_address":          (v.ServerAddress),
				"signing_role":            (v.SigningRole),
				"tags":                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.VaultTokenStore:
		localV, _ := localVersion.(*sdm.VaultTokenStore)
		_ = localV
		d.Set("vault_token", []map[string]interface{}{
			{
				"name":           (v.Name),
				"namespace":      (v.Namespace),
				"server_address": (v.ServerAddress),
				"tags":           convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.VaultTokenCertSSHStore:
		localV, _ := localVersion.(*sdm.VaultTokenCertSSHStore)
		_ = localV
		d.Set("vault_token_cert_ssh", []map[string]interface{}{
			{
				"issued_cert_ttl_minutes": (v.IssuedCertTTLMinutes),
				"name":                    (v.Name),
				"namespace":               (v.Namespace),
				"server_address":          (v.ServerAddress),
				"signing_role":            (v.SigningRole),
				"ssh_mount_point":         (v.SshMountPoint),
				"tags":                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.VaultTokenCertX509Store:
		localV, _ := localVersion.(*sdm.VaultTokenCertX509Store)
		_ = localV
		d.Set("vault_token_cert_x509", []map[string]interface{}{
			{
				"issued_cert_ttl_minutes": (v.IssuedCertTTLMinutes),
				"name":                    (v.Name),
				"namespace":               (v.Namespace),
				"pki_mount_point":         (v.PkiMountPoint),
				"server_address":          (v.ServerAddress),
				"signing_role":            (v.SigningRole),
				"tags":                    convertTagsToPorcelain(v.Tags),
			},
		})
	}
	return nil
}

func resourceSecretStoreRead(ctx context.Context, d *schema.ResourceData, cc *sdm.Client) error {
	localVersion := convertSecretStoreToPlumbing(d)
	_ = localVersion
	resp, err := cc.SecretStores().Get(ctx, d.Id())
	var errNotFound *sdm.NotFoundError
	if err != nil && errors.As(err, &errNotFound) {
		d.SetId("")
		return nil
	} else if err != nil {
		return fmt.Errorf("cannot read SecretStore %s: %w", d.Id(), err)
	}
	switch v := resp.SecretStore.(type) {
	case *sdm.ActiveDirectoryStore:
		localV, ok := localVersion.(*sdm.ActiveDirectoryStore)
		if !ok {
			localV = &sdm.ActiveDirectoryStore{}
		}
		_ = localV
		d.Set("active_directory_store", []map[string]interface{}{
			{
				"name":           (v.Name),
				"server_address": (v.ServerAddress),
				"tags":           convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AWSStore:
		localV, ok := localVersion.(*sdm.AWSStore)
		if !ok {
			localV = &sdm.AWSStore{}
		}
		_ = localV
		d.Set("aws", []map[string]interface{}{
			{
				"name":   (v.Name),
				"region": (v.Region),
				"tags":   convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AWSCertX509Store:
		localV, ok := localVersion.(*sdm.AWSCertX509Store)
		if !ok {
			localV = &sdm.AWSCertX509Store{}
		}
		_ = localV
		d.Set("aws_cert_x509", []map[string]interface{}{
			{
				"ca_arn":                   (v.CaArn),
				"certificate_template_arn": (v.CertificateTemplateArn),
				"issued_cert_ttl_minutes":  (v.IssuedCertTTLMinutes),
				"name":                     (v.Name),
				"region":                   (v.Region),
				"signing_algo":             (v.SigningAlgo),
				"tags":                     convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AzureStore:
		localV, ok := localVersion.(*sdm.AzureStore)
		if !ok {
			localV = &sdm.AzureStore{}
		}
		_ = localV
		d.Set("azure_store", []map[string]interface{}{
			{
				"name":      (v.Name),
				"tags":      convertTagsToPorcelain(v.Tags),
				"vault_uri": (v.VaultUri),
			},
		})
	case *sdm.CyberarkConjurStore:
		localV, ok := localVersion.(*sdm.CyberarkConjurStore)
		if !ok {
			localV = &sdm.CyberarkConjurStore{}
		}
		_ = localV
		d.Set("cyberark_conjur", []map[string]interface{}{
			{
				"app_url": (v.AppURL),
				"name":    (v.Name),
				"tags":    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.CyberarkPAMStore:
		localV, ok := localVersion.(*sdm.CyberarkPAMStore)
		if !ok {
			localV = &sdm.CyberarkPAMStore{}
		}
		_ = localV
		d.Set("cyberark_pam", []map[string]interface{}{
			{
				"app_url": (v.AppURL),
				"name":    (v.Name),
				"tags":    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.CyberarkPAMExperimentalStore:
		localV, ok := localVersion.(*sdm.CyberarkPAMExperimentalStore)
		if !ok {
			localV = &sdm.CyberarkPAMExperimentalStore{}
		}
		_ = localV
		d.Set("cyberark_pam_experimental", []map[string]interface{}{
			{
				"app_url": (v.AppURL),
				"name":    (v.Name),
				"tags":    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.DelineaStore:
		localV, ok := localVersion.(*sdm.DelineaStore)
		if !ok {
			localV = &sdm.DelineaStore{}
		}
		_ = localV
		d.Set("delinea_store", []map[string]interface{}{
			{
				"name":        (v.Name),
				"server_url":  (v.ServerUrl),
				"tags":        convertTagsToPorcelain(v.Tags),
				"tenant_name": (v.TenantName),
			},
		})
	case *sdm.GCPStore:
		localV, ok := localVersion.(*sdm.GCPStore)
		if !ok {
			localV = &sdm.GCPStore{}
		}
		_ = localV
		d.Set("gcp_store", []map[string]interface{}{
			{
				"name":       (v.Name),
				"project_id": (v.ProjectID),
				"tags":       convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.GCPCertX509Store:
		localV, ok := localVersion.(*sdm.GCPCertX509Store)
		if !ok {
			localV = &sdm.GCPCertX509Store{}
		}
		_ = localV
		d.Set("gcp_cert_x_509_store", []map[string]interface{}{
			{
				"ca_id":                   (v.CaID),
				"ca_pool_id":              (v.CaPoolID),
				"issued_cert_ttl_minutes": (v.IssuedCertTTLMinutes),
				"location":                (v.Location),
				"name":                    (v.Name),
				"project_id":              (v.ProjectID),
				"tags":                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.KeyfactorSSHStore:
		localV, ok := localVersion.(*sdm.KeyfactorSSHStore)
		if !ok {
			localV = &sdm.KeyfactorSSHStore{}
		}
		_ = localV
		d.Set("keyfactor_ssh_store", []map[string]interface{}{
			{
				"ca_file_path":                       (v.CaFilePath),
				"certificate_file_path":              (v.CertificateFilePath),
				"default_certificate_authority_name": (v.DefaultCertificateAuthorityName),
				"default_certificate_profile_name":   (v.DefaultCertificateProfileName),
				"default_end_entity_profile_name":    (v.DefaultEndEntityProfileName),
				"enrollment_code_env_var":            (v.EnrollmentCodeEnvVar),
				"enrollment_username_env_var":        (v.EnrollmentUsernameEnvVar),
				"key_file_path":                      (v.KeyFilePath),
				"name":                               (v.Name),
				"server_address":                     (v.ServerAddress),
				"tags":                               convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.KeyfactorX509Store:
		localV, ok := localVersion.(*sdm.KeyfactorX509Store)
		if !ok {
			localV = &sdm.KeyfactorX509Store{}
		}
		_ = localV
		d.Set("keyfactor_x_509_store", []map[string]interface{}{
			{
				"ca_file_path":                       (v.CaFilePath),
				"certificate_file_path":              (v.CertificateFilePath),
				"default_certificate_authority_name": (v.DefaultCertificateAuthorityName),
				"default_certificate_profile_name":   (v.DefaultCertificateProfileName),
				"default_end_entity_profile_name":    (v.DefaultEndEntityProfileName),
				"enrollment_code_env_var":            (v.EnrollmentCodeEnvVar),
				"enrollment_username_env_var":        (v.EnrollmentUsernameEnvVar),
				"key_file_path":                      (v.KeyFilePath),
				"name":                               (v.Name),
				"server_address":                     (v.ServerAddress),
				"tags":                               convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.VaultAppRoleStore:
		localV, ok := localVersion.(*sdm.VaultAppRoleStore)
		if !ok {
			localV = &sdm.VaultAppRoleStore{}
		}
		_ = localV
		d.Set("vault_approle", []map[string]interface{}{
			{
				"name":           (v.Name),
				"namespace":      (v.Namespace),
				"server_address": (v.ServerAddress),
				"tags":           convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.VaultAppRoleCertSSHStore:
		localV, ok := localVersion.(*sdm.VaultAppRoleCertSSHStore)
		if !ok {
			localV = &sdm.VaultAppRoleCertSSHStore{}
		}
		_ = localV
		d.Set("vault_approle_cert_ssh", []map[string]interface{}{
			{
				"issued_cert_ttl_minutes": (v.IssuedCertTTLMinutes),
				"name":                    (v.Name),
				"namespace":               (v.Namespace),
				"server_address":          (v.ServerAddress),
				"signing_role":            (v.SigningRole),
				"ssh_mount_point":         (v.SshMountPoint),
				"tags":                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.VaultAppRoleCertX509Store:
		localV, ok := localVersion.(*sdm.VaultAppRoleCertX509Store)
		if !ok {
			localV = &sdm.VaultAppRoleCertX509Store{}
		}
		_ = localV
		d.Set("vault_approle_cert_x509", []map[string]interface{}{
			{
				"issued_cert_ttl_minutes": (v.IssuedCertTTLMinutes),
				"name":                    (v.Name),
				"namespace":               (v.Namespace),
				"pki_mount_point":         (v.PkiMountPoint),
				"server_address":          (v.ServerAddress),
				"signing_role":            (v.SigningRole),
				"tags":                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.VaultAWSEC2Store:
		localV, ok := localVersion.(*sdm.VaultAWSEC2Store)
		if !ok {
			localV = &sdm.VaultAWSEC2Store{}
		}
		_ = localV
		d.Set("vault_aws_ec2", []map[string]interface{}{
			{
				"name":           (v.Name),
				"namespace":      (v.Namespace),
				"server_address": (v.ServerAddress),
				"tags":           convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.VaultAWSIAMStore:
		localV, ok := localVersion.(*sdm.VaultAWSIAMStore)
		if !ok {
			localV = &sdm.VaultAWSIAMStore{}
		}
		_ = localV
		d.Set("vault_aws_iam", []map[string]interface{}{
			{
				"name":           (v.Name),
				"namespace":      (v.Namespace),
				"server_address": (v.ServerAddress),
				"tags":           convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.VaultTLSStore:
		localV, ok := localVersion.(*sdm.VaultTLSStore)
		if !ok {
			localV = &sdm.VaultTLSStore{}
		}
		_ = localV
		d.Set("vault_tls", []map[string]interface{}{
			{
				"ca_cert_path":     (v.CACertPath),
				"client_cert_path": (v.ClientCertPath),
				"client_key_path":  (v.ClientKeyPath),
				"name":             (v.Name),
				"namespace":        (v.Namespace),
				"server_address":   (v.ServerAddress),
				"tags":             convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.VaultTLSCertSSHStore:
		localV, ok := localVersion.(*sdm.VaultTLSCertSSHStore)
		if !ok {
			localV = &sdm.VaultTLSCertSSHStore{}
		}
		_ = localV
		d.Set("vault_tls_cert_ssh", []map[string]interface{}{
			{
				"ca_cert_path":            (v.CACertPath),
				"client_cert_path":        (v.ClientCertPath),
				"client_key_path":         (v.ClientKeyPath),
				"issued_cert_ttl_minutes": (v.IssuedCertTTLMinutes),
				"name":                    (v.Name),
				"namespace":               (v.Namespace),
				"server_address":          (v.ServerAddress),
				"signing_role":            (v.SigningRole),
				"ssh_mount_point":         (v.SshMountPoint),
				"tags":                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.VaultTLSCertX509Store:
		localV, ok := localVersion.(*sdm.VaultTLSCertX509Store)
		if !ok {
			localV = &sdm.VaultTLSCertX509Store{}
		}
		_ = localV
		d.Set("vault_tls_cert_x509", []map[string]interface{}{
			{
				"ca_cert_path":            (v.CACertPath),
				"client_cert_path":        (v.ClientCertPath),
				"client_key_path":         (v.ClientKeyPath),
				"issued_cert_ttl_minutes": (v.IssuedCertTTLMinutes),
				"name":                    (v.Name),
				"namespace":               (v.Namespace),
				"pki_mount_point":         (v.PkiMountPoint),
				"server_address":          (v.ServerAddress),
				"signing_role":            (v.SigningRole),
				"tags":                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.VaultTokenStore:
		localV, ok := localVersion.(*sdm.VaultTokenStore)
		if !ok {
			localV = &sdm.VaultTokenStore{}
		}
		_ = localV
		d.Set("vault_token", []map[string]interface{}{
			{
				"name":           (v.Name),
				"namespace":      (v.Namespace),
				"server_address": (v.ServerAddress),
				"tags":           convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.VaultTokenCertSSHStore:
		localV, ok := localVersion.(*sdm.VaultTokenCertSSHStore)
		if !ok {
			localV = &sdm.VaultTokenCertSSHStore{}
		}
		_ = localV
		d.Set("vault_token_cert_ssh", []map[string]interface{}{
			{
				"issued_cert_ttl_minutes": (v.IssuedCertTTLMinutes),
				"name":                    (v.Name),
				"namespace":               (v.Namespace),
				"server_address":          (v.ServerAddress),
				"signing_role":            (v.SigningRole),
				"ssh_mount_point":         (v.SshMountPoint),
				"tags":                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.VaultTokenCertX509Store:
		localV, ok := localVersion.(*sdm.VaultTokenCertX509Store)
		if !ok {
			localV = &sdm.VaultTokenCertX509Store{}
		}
		_ = localV
		d.Set("vault_token_cert_x509", []map[string]interface{}{
			{
				"issued_cert_ttl_minutes": (v.IssuedCertTTLMinutes),
				"name":                    (v.Name),
				"namespace":               (v.Namespace),
				"pki_mount_point":         (v.PkiMountPoint),
				"server_address":          (v.ServerAddress),
				"signing_role":            (v.SigningRole),
				"tags":                    convertTagsToPorcelain(v.Tags),
			},
		})
	}
	return nil
}
func resourceSecretStoreUpdate(ctx context.Context, d *schema.ResourceData, cc *sdm.Client) error {
	resp, err := cc.SecretStores().Update(ctx, convertSecretStoreToPlumbing(d))
	if err != nil {
		return fmt.Errorf("cannot update SecretStore %s: %w", d.Id(), err)
	}
	d.SetId(resp.SecretStore.GetID())
	return resourceSecretStoreRead(ctx, d, cc)
}
func resourceSecretStoreDelete(ctx context.Context, d *schema.ResourceData, cc *sdm.Client) error {
	var errNotFound *sdm.NotFoundError
	_, err := cc.SecretStores().Delete(ctx, d.Id())
	if err != nil && errors.As(err, &errNotFound) {
		return nil
	}
	return err
}
