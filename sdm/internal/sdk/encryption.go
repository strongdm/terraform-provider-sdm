// Copyright 2020 StrongDM Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package sdm

// Code generated by protogen. DO NOT EDIT.

import (
	"context"
	"crypto/rand"
	crand "crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/pem"
	"fmt"

	plumbing "github.com/strongdm/terraform-provider-sdm/sdm/internal/sdk/v1"
	"google.golang.org/grpc"
)

func parseRSAPublicKey(keyData []byte) (*rsa.PublicKey, error) {
	pubPEM, _ := pem.Decode(keyData)
	if pubPEM == nil {
		return nil, fmt.Errorf("missing pem data")
	}
	pubPEMBytes := pubPEM.Bytes

	var parsedKey any
	var err error
	if parsedKey, err = x509.ParsePKCS1PublicKey(pubPEMBytes); err != nil {
		if parsedKey, err = x509.ParsePKIXPublicKey(pubPEMBytes); err != nil {
			return nil, fmt.Errorf("failed to parse PEM data: %w", err)
		}
	}

	pubKey, ok := parsedKey.(*rsa.PublicKey)
	if !ok {
		return nil, fmt.Errorf("not an RSA Public Key")
	}

	return pubKey, nil
}

func privKeyGenerator() *rsa.PrivateKey {
	key, err := rsa.GenerateKey(rand.Reader, 4096)
	if err != nil {
		return nil
	}
	return key
}

var defaultClientOptions []ClientOption = []ClientOption{
	withClientInterceptor("/v1.ManagedSecrets/Retrieve", func(c *Client, ctx context.Context, method string, req, reply any, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) (stop bool, err error) {
		retrieveReq, ok := req.(*plumbing.ManagedSecretRetrieveRequest)
		if !ok {
			return stop, nil
		}
		if len(retrieveReq.PublicKey) != 0 { // if there is no public key defined continue as usual
			return stop, nil
		}
		key := c.getEphemeralKeyFunc()
		pemEncodedPubKey := pem.EncodeToMemory(&pem.Block{
			Type:  "RSA PUBLIC KEY",
			Bytes: x509.MarshalPKCS1PublicKey(&key.PublicKey),
		})
		retrieveReq.PublicKey = pemEncodedPubKey
		stop = true
		// rewrap the context calculating new signed request
		err = invoker(c.wrapContext(ctx, retrieveReq, "ManagedSecrets.Retrieve"), method, req, reply, cc, opts...)
		if err != nil {
			return stop, err
		}
		retrieveResp, ok := reply.(*plumbing.ManagedSecretRetrieveResponse)
		if !ok {
			return stop, nil
		}
		secret := retrieveResp.GetManagedSecret()
		if secret == nil {
			return stop, nil
		}
		if val := secret.GetValue(); len(val) > 0 {
			secret.Value, err = rsa.DecryptOAEP(sha256.New(), crand.Reader, key, secret.GetValue(), nil)
			if err != nil {
				return stop, fmt.Errorf("failed to decrypt the secret: %w", err)
			}
		}
		return stop, nil
	}),
	withClientInterceptor("/v1.ManagedSecrets/Create", func(c *Client, ctx context.Context, method string, req, reply any, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) (stop bool, err error) {
		typedReq, ok := req.(*plumbing.ManagedSecretCreateRequest)
		if !ok {
			return stop, nil // continue normal flow
		}

		if err := c.encryptSecret(ctx, typedReq.GetManagedSecret()); err != nil {
			return stop, err
		}
		err = invoker(c.wrapContext(ctx, typedReq, "ManagedSecrets.Create"), method, req, reply, cc, opts...)
		return true, err
	}),
	withClientInterceptor("/v1.ManagedSecrets/Update", func(c *Client, ctx context.Context, method string, req, reply any, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) (stop bool, err error) {
		typedReq, ok := req.(*plumbing.ManagedSecretUpdateRequest)
		if !ok {
			return stop, nil // continue normal flow
		}
		if err := c.encryptSecret(ctx, typedReq.GetManagedSecret()); err != nil {
			return stop, err
		}
		err = invoker(c.wrapContext(ctx, typedReq, "ManagedSecrets.Update"), method, req, reply, cc, opts...)
		return true, err
	}),
	withClientInterceptor("/v1.SecretEngines/Get", func(c *Client, ctx context.Context, method string, req, reply any, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) (stop bool, err error) {
		stop = true
		err = invoker(ctx, method, req, reply, cc, opts...)
		if getResp, ok := reply.(*plumbing.SecretEngineGetResponse); ok {
			engine, err := convertSecretEngineToPorcelain(getResp.GetSecretEngine())
			if err != nil {
				return stop, err
			}
			c.updatePublicKeyCache(engine.GetID(), engine.GetPublicKey())
		}
		return stop, err
	}),
	withClientInterceptor("/v1.SecretEngines/List", func(c *Client, ctx context.Context, method string, req, reply any, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) (stop bool, err error) {
		stop = true
		err = invoker(ctx, method, req, reply, cc, opts...)
		if err != nil {
			return stop, err
		}
		typedResp, ok := reply.(*plumbing.SecretEngineListResponse)
		if !ok {
			return stop, nil
		}
		for _, se := range typedResp.SecretEngines {
			if se == nil {
				continue
			}
			engine, err := convertSecretEngineToPorcelain(se)
			if err != nil {
				continue
			}
			c.updatePublicKeyCache(engine.GetID(), engine.GetPublicKey())
		}
		return stop, nil
	}),
}

func (c *Client) updatePublicKeyCache(id string, publicKey []byte) {
	pubKey, err := parseRSAPublicKey(publicKey)
	if err != nil {
		return
	}
	if c.publicKeyCache == nil {
		c.publicKeyCache = make(map[string]*rsa.PublicKey)
	}
	c.publicKeyCache[id] = pubKey
}

func (c *Client) encryptSecret(ctx context.Context, secret *plumbing.ManagedSecret) error {
	if secret == nil {
		return nil
	}
	if len(secret.Value) == 0 {
		return nil
	}
	// fetch the key
	key, ok := c.publicKeyCache[secret.GetSecretEngineId()]
	if !ok {
		// Fill the key for secret engine
		_, err := c.SecretEngines().Get(ctx, secret.GetSecretEngineId())
		if err != nil {
			return err
		}
		key = c.publicKeyCache[secret.GetSecretEngineId()]
	}
	encrypted, err := rsa.EncryptOAEP(sha256.New(), crand.Reader, key, secret.GetValue(), nil)
	if err != nil {
		return err
	}
	secret.Value = encrypted
	return nil
}
