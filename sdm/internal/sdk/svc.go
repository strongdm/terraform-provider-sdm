// Copyright 2020 StrongDM Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package sdm

// Code generated by protogen. DO NOT EDIT.

import (
	"context"

	plumbing "github.com/strongdm/terraform-provider-sdm/sdm/internal/sdk/v1"
)

// AccessRequests are requests for access to a resource that may match a Workflow.
type AccessRequests struct {
	client plumbing.AccessRequestsClient
	parent *Client
}

// A SnapshotAccessRequests exposes the read only methods of the AccessRequests
// service for historical queries.
type SnapshotAccessRequests interface {
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		AccessRequestIterator,
		error)
}

// Lists existing access requests.
func (svc *AccessRequests) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccessRequestIterator,
	error) {
	req := &plumbing.AccessRequestListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccessRequestIteratorImpl(
		func() (
			[]*AccessRequest,
			bool, error) {
			var plumbingResponse *plumbing.AccessRequestListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "AccessRequests.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedAccessRequestToPorcelain(plumbingResponse.AccessRequests)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccessRequestEventsHistory provides records of all changes to the state of an AccessRequest.
type AccessRequestEventsHistory struct {
	client plumbing.AccessRequestEventsHistoryClient
	parent *Client
}

// List gets a list of AccessRequestEventHistory records matching a given set of criteria.
func (svc *AccessRequestEventsHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccessRequestEventHistoryIterator,
	error) {
	req := &plumbing.AccessRequestEventHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccessRequestEventHistoryIteratorImpl(
		func() (
			[]*AccessRequestEventHistory,
			bool, error) {
			var plumbingResponse *plumbing.AccessRequestEventHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "AccessRequestEventsHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedAccessRequestEventHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccessRequestsHistory provides records of all changes to the state of an AccessRequest.
type AccessRequestsHistory struct {
	client plumbing.AccessRequestsHistoryClient
	parent *Client
}

// List gets a list of AccessRequestHistory records matching a given set of criteria.
func (svc *AccessRequestsHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccessRequestHistoryIterator,
	error) {
	req := &plumbing.AccessRequestHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccessRequestHistoryIteratorImpl(
		func() (
			[]*AccessRequestHistory,
			bool, error) {
			var plumbingResponse *plumbing.AccessRequestHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "AccessRequestsHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedAccessRequestHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccountAttachments assign an account to a role.
type AccountAttachments struct {
	client plumbing.AccountAttachmentsClient
	parent *Client
}

// A SnapshotAccountAttachments exposes the read only methods of the AccountAttachments
// service for historical queries.
type SnapshotAccountAttachments interface {
	Get(
		ctx context.Context,
		id string) (
		*AccountAttachmentGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		AccountAttachmentIterator,
		error)
}

// Create registers a new AccountAttachment.
func (svc *AccountAttachments) Create(
	ctx context.Context,
	accountAttachment *AccountAttachment) (
	*AccountAttachmentCreateResponse,
	error) {
	req := &plumbing.AccountAttachmentCreateRequest{}

	req.AccountAttachment = convertAccountAttachmentToPlumbing(accountAttachment)
	var plumbingResponse *plumbing.AccountAttachmentCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "AccountAttachments.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &AccountAttachmentCreateResponse{}
	if v, err := convertAccountAttachmentToPorcelain(plumbingResponse.AccountAttachment); err != nil {
		return nil, err
	} else {
		resp.AccountAttachment = v
	}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads one AccountAttachment by ID.
func (svc *AccountAttachments) Get(
	ctx context.Context,
	id string) (
	*AccountAttachmentGetResponse,
	error) {
	req := &plumbing.AccountAttachmentGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.AccountAttachmentGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "AccountAttachments.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &AccountAttachmentGetResponse{}
	if v, err := convertAccountAttachmentToPorcelain(plumbingResponse.AccountAttachment); err != nil {
		return nil, err
	} else {
		resp.AccountAttachment = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete removes a AccountAttachment by ID.
func (svc *AccountAttachments) Delete(
	ctx context.Context,
	id string) (
	*AccountAttachmentDeleteResponse,
	error) {
	req := &plumbing.AccountAttachmentDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.AccountAttachmentDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "AccountAttachments.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &AccountAttachmentDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of AccountAttachments matching a given set of criteria.
func (svc *AccountAttachments) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountAttachmentIterator,
	error) {
	req := &plumbing.AccountAttachmentListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountAttachmentIteratorImpl(
		func() (
			[]*AccountAttachment,
			bool, error) {
			var plumbingResponse *plumbing.AccountAttachmentListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "AccountAttachments.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedAccountAttachmentToPorcelain(plumbingResponse.AccountAttachments)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccountAttachmentsHistory records all changes to the state of an AccountAttachment.
type AccountAttachmentsHistory struct {
	client plumbing.AccountAttachmentsHistoryClient
	parent *Client
}

// List gets a list of AccountAttachmentHistory records matching a given set of criteria.
func (svc *AccountAttachmentsHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountAttachmentHistoryIterator,
	error) {
	req := &plumbing.AccountAttachmentHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountAttachmentHistoryIteratorImpl(
		func() (
			[]*AccountAttachmentHistory,
			bool, error) {
			var plumbingResponse *plumbing.AccountAttachmentHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "AccountAttachmentsHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedAccountAttachmentHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccountGrants assign a resource directly to an account, giving the account the permission to connect to that resource.
type AccountGrants struct {
	client plumbing.AccountGrantsClient
	parent *Client
}

// A SnapshotAccountGrants exposes the read only methods of the AccountGrants
// service for historical queries.
type SnapshotAccountGrants interface {
	Get(
		ctx context.Context,
		id string) (
		*AccountGrantGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		AccountGrantIterator,
		error)
}

// Create registers a new AccountGrant.
func (svc *AccountGrants) Create(
	ctx context.Context,
	accountGrant *AccountGrant) (
	*AccountGrantCreateResponse,
	error) {
	req := &plumbing.AccountGrantCreateRequest{}

	req.AccountGrant = convertAccountGrantToPlumbing(accountGrant)
	var plumbingResponse *plumbing.AccountGrantCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "AccountGrants.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &AccountGrantCreateResponse{}
	if v, err := convertAccountGrantToPorcelain(plumbingResponse.AccountGrant); err != nil {
		return nil, err
	} else {
		resp.AccountGrant = v
	}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads one AccountGrant by ID.
func (svc *AccountGrants) Get(
	ctx context.Context,
	id string) (
	*AccountGrantGetResponse,
	error) {
	req := &plumbing.AccountGrantGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.AccountGrantGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "AccountGrants.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &AccountGrantGetResponse{}
	if v, err := convertAccountGrantToPorcelain(plumbingResponse.AccountGrant); err != nil {
		return nil, err
	} else {
		resp.AccountGrant = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete removes a AccountGrant by ID.
func (svc *AccountGrants) Delete(
	ctx context.Context,
	id string) (
	*AccountGrantDeleteResponse,
	error) {
	req := &plumbing.AccountGrantDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.AccountGrantDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "AccountGrants.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &AccountGrantDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of AccountGrants matching a given set of criteria.
func (svc *AccountGrants) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountGrantIterator,
	error) {
	req := &plumbing.AccountGrantListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountGrantIteratorImpl(
		func() (
			[]*AccountGrant,
			bool, error) {
			var plumbingResponse *plumbing.AccountGrantListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "AccountGrants.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedAccountGrantToPorcelain(plumbingResponse.AccountGrants)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccountGrantsHistory records all changes to the state of an AccountGrant.
type AccountGrantsHistory struct {
	client plumbing.AccountGrantsHistoryClient
	parent *Client
}

// List gets a list of AccountGrantHistory records matching a given set of criteria.
func (svc *AccountGrantsHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountGrantHistoryIterator,
	error) {
	req := &plumbing.AccountGrantHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountGrantHistoryIteratorImpl(
		func() (
			[]*AccountGrantHistory,
			bool, error) {
			var plumbingResponse *plumbing.AccountGrantHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "AccountGrantsHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedAccountGrantHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccountPermissions records the granular permissions accounts have, allowing them to execute
// relevant commands via StrongDM's APIs.
type AccountPermissions struct {
	client plumbing.AccountPermissionsClient
	parent *Client
}

// A SnapshotAccountPermissions exposes the read only methods of the AccountPermissions
// service for historical queries.
type SnapshotAccountPermissions interface {
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		AccountPermissionIterator,
		error)
}

// List gets a list of Permission records matching a given set of criteria.
func (svc *AccountPermissions) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountPermissionIterator,
	error) {
	req := &plumbing.AccountPermissionListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountPermissionIteratorImpl(
		func() (
			[]*AccountPermission,
			bool, error) {
			var plumbingResponse *plumbing.AccountPermissionListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "AccountPermissions.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedAccountPermissionToPorcelain(plumbingResponse.Permissions)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccountResources enumerates the resources to which accounts have access.
// The AccountResources service is read-only.
type AccountResources struct {
	client plumbing.AccountResourcesClient
	parent *Client
}

// A SnapshotAccountResources exposes the read only methods of the AccountResources
// service for historical queries.
type SnapshotAccountResources interface {
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		AccountResourceIterator,
		error)
}

// List gets a list of AccountResource records matching a given set of criteria.
func (svc *AccountResources) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountResourceIterator,
	error) {
	req := &plumbing.AccountResourceListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountResourceIteratorImpl(
		func() (
			[]*AccountResource,
			bool, error) {
			var plumbingResponse *plumbing.AccountResourceListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "AccountResources.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedAccountResourceToPorcelain(plumbingResponse.AccountResources)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccountResourcesHistory records all changes to the state of a AccountResource.
type AccountResourcesHistory struct {
	client plumbing.AccountResourcesHistoryClient
	parent *Client
}

// List gets a list of AccountResourceHistory records matching a given set of criteria.
func (svc *AccountResourcesHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountResourceHistoryIterator,
	error) {
	req := &plumbing.AccountResourceHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountResourceHistoryIteratorImpl(
		func() (
			[]*AccountResourceHistory,
			bool, error) {
			var plumbingResponse *plumbing.AccountResourceHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "AccountResourcesHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedAccountResourceHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// Accounts are users that have access to strongDM. There are two types of accounts:
// 1. **Users:** humans who are authenticated through username and password or SSO.
// 2. **Service Accounts:** machines that are authenticated using a service token.
// 3. **Tokens** are access keys with permissions that can be used for authentication.
type Accounts struct {
	client plumbing.AccountsClient
	parent *Client
}

// A SnapshotAccounts exposes the read only methods of the Accounts
// service for historical queries.
type SnapshotAccounts interface {
	Get(
		ctx context.Context,
		id string) (
		*AccountGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		AccountIterator,
		error)
}

// Create registers a new Account.
func (svc *Accounts) Create(
	ctx context.Context,
	account Account) (
	*AccountCreateResponse,
	error) {
	req := &plumbing.AccountCreateRequest{}

	req.Account = convertAccountToPlumbing(account)
	var plumbingResponse *plumbing.AccountCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "Accounts.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &AccountCreateResponse{}
	resp.AccessKey = (plumbingResponse.AccessKey)
	if v, err := convertAccountToPorcelain(plumbingResponse.Account); err != nil {
		return nil, err
	} else {
		resp.Account = v
	}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	resp.SecretKey = (plumbingResponse.SecretKey)
	resp.Token = (plumbingResponse.Token)
	return resp, nil
}

// Get reads one Account by ID.
func (svc *Accounts) Get(
	ctx context.Context,
	id string) (
	*AccountGetResponse,
	error) {
	req := &plumbing.AccountGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.AccountGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "Accounts.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &AccountGetResponse{}
	if v, err := convertAccountToPorcelain(plumbingResponse.Account); err != nil {
		return nil, err
	} else {
		resp.Account = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Update replaces all the fields of an Account by ID.
func (svc *Accounts) Update(
	ctx context.Context,
	account Account) (
	*AccountUpdateResponse,
	error) {
	req := &plumbing.AccountUpdateRequest{}

	req.Account = convertAccountToPlumbing(account)
	var plumbingResponse *plumbing.AccountUpdateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Update(svc.parent.wrapContext(ctx, req, "Accounts.Update"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &AccountUpdateResponse{}
	if v, err := convertAccountToPorcelain(plumbingResponse.Account); err != nil {
		return nil, err
	} else {
		resp.Account = v
	}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete removes an Account by ID.
func (svc *Accounts) Delete(
	ctx context.Context,
	id string) (
	*AccountDeleteResponse,
	error) {
	req := &plumbing.AccountDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.AccountDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "Accounts.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &AccountDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of Accounts matching a given set of criteria.
func (svc *Accounts) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountIterator,
	error) {
	req := &plumbing.AccountListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountIteratorImpl(
		func() (
			[]Account,
			bool, error) {
			var plumbingResponse *plumbing.AccountListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "Accounts.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedAccountToPorcelain(plumbingResponse.Accounts)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccountsHistory records all changes to the state of an Account.
type AccountsHistory struct {
	client plumbing.AccountsHistoryClient
	parent *Client
}

// List gets a list of AccountHistory records matching a given set of criteria.
func (svc *AccountsHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountHistoryIterator,
	error) {
	req := &plumbing.AccountHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountHistoryIteratorImpl(
		func() (
			[]*AccountHistory,
			bool, error) {
			var plumbingResponse *plumbing.AccountHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "AccountsHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedAccountHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// An Activity is a record of an action taken against a strongDM deployment, e.g.
// a user creation, resource deletion, sso configuration change, etc. The Activities
// service is read-only.
type Activities struct {
	client plumbing.ActivitiesClient
	parent *Client
}

// Get reads one Activity by ID.
func (svc *Activities) Get(
	ctx context.Context,
	id string) (
	*ActivityGetResponse,
	error) {
	req := &plumbing.ActivityGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.ActivityGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "Activities.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ActivityGetResponse{}
	if v, err := convertActivityToPorcelain(plumbingResponse.Activity); err != nil {
		return nil, err
	} else {
		resp.Activity = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of Activities matching a given set of criteria.
// The 'before' and 'after' filters can be used to control the time
// range of the output activities. If not provided, one week of back
// of activities will be returned.
func (svc *Activities) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ActivityIterator,
	error) {
	req := &plumbing.ActivityListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newActivityIteratorImpl(
		func() (
			[]*Activity,
			bool, error) {
			var plumbingResponse *plumbing.ActivityListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "Activities.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedActivityToPorcelain(plumbingResponse.Activities)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// ApprovalWorkflowApprovers link approval workflow approvers to an ApprovalWorkflowStep
type ApprovalWorkflowApprovers struct {
	client plumbing.ApprovalWorkflowApproversClient
	parent *Client
}

// A SnapshotApprovalWorkflowApprovers exposes the read only methods of the ApprovalWorkflowApprovers
// service for historical queries.
type SnapshotApprovalWorkflowApprovers interface {
	Get(
		ctx context.Context,
		id string) (
		*ApprovalWorkflowApproverGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		ApprovalWorkflowApproverIterator,
		error)
}

// Create creates a new approval workflow approver.
func (svc *ApprovalWorkflowApprovers) Create(
	ctx context.Context,
	approvalWorkflowApprover *ApprovalWorkflowApprover) (
	*ApprovalWorkflowApproverCreateResponse,
	error) {
	req := &plumbing.ApprovalWorkflowApproverCreateRequest{}

	req.ApprovalWorkflowApprover = convertApprovalWorkflowApproverToPlumbing(approvalWorkflowApprover)
	var plumbingResponse *plumbing.ApprovalWorkflowApproverCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "ApprovalWorkflowApprovers.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ApprovalWorkflowApproverCreateResponse{}
	if v, err := convertApprovalWorkflowApproverToPorcelain(plumbingResponse.ApprovalWorkflowApprover); err != nil {
		return nil, err
	} else {
		resp.ApprovalWorkflowApprover = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads one approval workflow approver by ID.
func (svc *ApprovalWorkflowApprovers) Get(
	ctx context.Context,
	id string) (
	*ApprovalWorkflowApproverGetResponse,
	error) {
	req := &plumbing.ApprovalWorkflowApproverGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.ApprovalWorkflowApproverGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "ApprovalWorkflowApprovers.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ApprovalWorkflowApproverGetResponse{}
	if v, err := convertApprovalWorkflowApproverToPorcelain(plumbingResponse.ApprovalWorkflowApprover); err != nil {
		return nil, err
	} else {
		resp.ApprovalWorkflowApprover = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete deletes an existing approval workflow approver.
func (svc *ApprovalWorkflowApprovers) Delete(
	ctx context.Context,
	id string) (
	*ApprovalWorkflowApproverDeleteResponse,
	error) {
	req := &plumbing.ApprovalWorkflowApproverDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.ApprovalWorkflowApproverDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "ApprovalWorkflowApprovers.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ApprovalWorkflowApproverDeleteResponse{}
	resp.ID = (plumbingResponse.Id)
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Lists existing approval workflow approvers.
func (svc *ApprovalWorkflowApprovers) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ApprovalWorkflowApproverIterator,
	error) {
	req := &plumbing.ApprovalWorkflowApproverListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newApprovalWorkflowApproverIteratorImpl(
		func() (
			[]*ApprovalWorkflowApprover,
			bool, error) {
			var plumbingResponse *plumbing.ApprovalWorkflowApproverListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "ApprovalWorkflowApprovers.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedApprovalWorkflowApproverToPorcelain(plumbingResponse.ApprovalWorkflowApprovers)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// ApprovalWorkflowApproversHistory records all changes to the state of an ApprovalWorkflowApprover.
type ApprovalWorkflowApproversHistory struct {
	client plumbing.ApprovalWorkflowApproversHistoryClient
	parent *Client
}

// List gets a list of ApprovalWorkflowApproverHistory records matching a given set of criteria.
func (svc *ApprovalWorkflowApproversHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ApprovalWorkflowApproverHistoryIterator,
	error) {
	req := &plumbing.ApprovalWorkflowApproverHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newApprovalWorkflowApproverHistoryIteratorImpl(
		func() (
			[]*ApprovalWorkflowApproverHistory,
			bool, error) {
			var plumbingResponse *plumbing.ApprovalWorkflowApproverHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "ApprovalWorkflowApproversHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedApprovalWorkflowApproverHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// ApprovalWorkflowSteps link approval workflow steps to an ApprovalWorkflow
type ApprovalWorkflowSteps struct {
	client plumbing.ApprovalWorkflowStepsClient
	parent *Client
}

// A SnapshotApprovalWorkflowSteps exposes the read only methods of the ApprovalWorkflowSteps
// service for historical queries.
type SnapshotApprovalWorkflowSteps interface {
	Get(
		ctx context.Context,
		id string) (
		*ApprovalWorkflowStepGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		ApprovalWorkflowStepIterator,
		error)
}

// Create creates a new approval workflow step.
func (svc *ApprovalWorkflowSteps) Create(
	ctx context.Context,
	approvalWorkflowStep *ApprovalWorkflowStep) (
	*ApprovalWorkflowStepCreateResponse,
	error) {
	req := &plumbing.ApprovalWorkflowStepCreateRequest{}

	req.ApprovalWorkflowStep = convertApprovalWorkflowStepToPlumbing(approvalWorkflowStep)
	var plumbingResponse *plumbing.ApprovalWorkflowStepCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "ApprovalWorkflowSteps.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ApprovalWorkflowStepCreateResponse{}
	if v, err := convertApprovalWorkflowStepToPorcelain(plumbingResponse.ApprovalWorkflowStep); err != nil {
		return nil, err
	} else {
		resp.ApprovalWorkflowStep = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads one approval workflow step by ID.
func (svc *ApprovalWorkflowSteps) Get(
	ctx context.Context,
	id string) (
	*ApprovalWorkflowStepGetResponse,
	error) {
	req := &plumbing.ApprovalWorkflowStepGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.ApprovalWorkflowStepGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "ApprovalWorkflowSteps.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ApprovalWorkflowStepGetResponse{}
	if v, err := convertApprovalWorkflowStepToPorcelain(plumbingResponse.ApprovalWorkflowStep); err != nil {
		return nil, err
	} else {
		resp.ApprovalWorkflowStep = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete deletes an existing approval workflow step.
func (svc *ApprovalWorkflowSteps) Delete(
	ctx context.Context,
	id string) (
	*ApprovalWorkflowStepDeleteResponse,
	error) {
	req := &plumbing.ApprovalWorkflowStepDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.ApprovalWorkflowStepDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "ApprovalWorkflowSteps.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ApprovalWorkflowStepDeleteResponse{}
	resp.ID = (plumbingResponse.Id)
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Lists existing approval workflow steps.
func (svc *ApprovalWorkflowSteps) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ApprovalWorkflowStepIterator,
	error) {
	req := &plumbing.ApprovalWorkflowStepListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newApprovalWorkflowStepIteratorImpl(
		func() (
			[]*ApprovalWorkflowStep,
			bool, error) {
			var plumbingResponse *plumbing.ApprovalWorkflowStepListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "ApprovalWorkflowSteps.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedApprovalWorkflowStepToPorcelain(plumbingResponse.ApprovalWorkflowSteps)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// ApprovalWorkflowStepsHistory records all changes to the state of an ApprovalWorkflowStep.
type ApprovalWorkflowStepsHistory struct {
	client plumbing.ApprovalWorkflowStepsHistoryClient
	parent *Client
}

// List gets a list of ApprovalWorkflowStepHistory records matching a given set of criteria.
func (svc *ApprovalWorkflowStepsHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ApprovalWorkflowStepHistoryIterator,
	error) {
	req := &plumbing.ApprovalWorkflowStepHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newApprovalWorkflowStepHistoryIteratorImpl(
		func() (
			[]*ApprovalWorkflowStepHistory,
			bool, error) {
			var plumbingResponse *plumbing.ApprovalWorkflowStepHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "ApprovalWorkflowStepsHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedApprovalWorkflowStepHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// ApprovalWorkflows are the mechanism by which requests for access can be viewed by authorized
// approvers and be approved or denied.
type ApprovalWorkflows struct {
	client plumbing.ApprovalWorkflowsClient
	parent *Client
}

// A SnapshotApprovalWorkflows exposes the read only methods of the ApprovalWorkflows
// service for historical queries.
type SnapshotApprovalWorkflows interface {
	Get(
		ctx context.Context,
		id string) (
		*ApprovalWorkflowGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		ApprovalWorkflowIterator,
		error)
}

// Create creates a new approval workflow and requires a name and approval mode for the approval workflow.
func (svc *ApprovalWorkflows) Create(
	ctx context.Context,
	approvalWorkflow *ApprovalWorkflow) (
	*ApprovalWorkflowCreateResponse,
	error) {
	req := &plumbing.ApprovalWorkflowCreateRequest{}

	req.ApprovalWorkflow = convertApprovalWorkflowToPlumbing(approvalWorkflow)
	var plumbingResponse *plumbing.ApprovalWorkflowCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "ApprovalWorkflows.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ApprovalWorkflowCreateResponse{}
	if v, err := convertApprovalWorkflowToPorcelain(plumbingResponse.ApprovalWorkflow); err != nil {
		return nil, err
	} else {
		resp.ApprovalWorkflow = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads one approval workflow by ID.
func (svc *ApprovalWorkflows) Get(
	ctx context.Context,
	id string) (
	*ApprovalWorkflowGetResponse,
	error) {
	req := &plumbing.ApprovalWorkflowGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.ApprovalWorkflowGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "ApprovalWorkflows.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ApprovalWorkflowGetResponse{}
	if v, err := convertApprovalWorkflowToPorcelain(plumbingResponse.ApprovalWorkflow); err != nil {
		return nil, err
	} else {
		resp.ApprovalWorkflow = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete deletes an existing approval workflow.
func (svc *ApprovalWorkflows) Delete(
	ctx context.Context,
	id string) (
	*ApprovalWorkflowDeleteResponse,
	error) {
	req := &plumbing.ApprovalWorkflowDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.ApprovalWorkflowDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "ApprovalWorkflows.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ApprovalWorkflowDeleteResponse{}
	resp.ID = (plumbingResponse.Id)
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Update updates an existing approval workflow.
func (svc *ApprovalWorkflows) Update(
	ctx context.Context,
	approvalWorkflow *ApprovalWorkflow) (
	*ApprovalWorkflowUpdateResponse,
	error) {
	req := &plumbing.ApprovalWorkflowUpdateRequest{}

	req.ApprovalWorkflow = convertApprovalWorkflowToPlumbing(approvalWorkflow)
	var plumbingResponse *plumbing.ApprovalWorkflowUpdateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Update(svc.parent.wrapContext(ctx, req, "ApprovalWorkflows.Update"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ApprovalWorkflowUpdateResponse{}
	if v, err := convertApprovalWorkflowToPorcelain(plumbingResponse.ApprovalWorkflow); err != nil {
		return nil, err
	} else {
		resp.ApprovalWorkflow = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Lists existing approval workflows.
func (svc *ApprovalWorkflows) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ApprovalWorkflowIterator,
	error) {
	req := &plumbing.ApprovalWorkflowListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newApprovalWorkflowIteratorImpl(
		func() (
			[]*ApprovalWorkflow,
			bool, error) {
			var plumbingResponse *plumbing.ApprovalWorkflowListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "ApprovalWorkflows.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedApprovalWorkflowToPorcelain(plumbingResponse.ApprovalWorkflows)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// ApprovalWorkflowsHistory records all changes to the state of an ApprovalWorkflow.
type ApprovalWorkflowsHistory struct {
	client plumbing.ApprovalWorkflowsHistoryClient
	parent *Client
}

// List gets a list of ApprovalWorkflowHistory records matching a given set of criteria.
func (svc *ApprovalWorkflowsHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ApprovalWorkflowHistoryIterator,
	error) {
	req := &plumbing.ApprovalWorkflowHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newApprovalWorkflowHistoryIteratorImpl(
		func() (
			[]*ApprovalWorkflowHistory,
			bool, error) {
			var plumbingResponse *plumbing.ApprovalWorkflowHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "ApprovalWorkflowsHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedApprovalWorkflowHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// ControlPanel contains all administrative controls.
type ControlPanel struct {
	client plumbing.ControlPanelClient
	parent *Client
}

// GetSSHCAPublicKey retrieves the SSH CA public key.
func (svc *ControlPanel) GetSSHCAPublicKey(
	ctx context.Context) (
	*ControlPanelGetSSHCAPublicKeyResponse,
	error) {
	req := &plumbing.ControlPanelGetSSHCAPublicKeyRequest{}

	var plumbingResponse *plumbing.ControlPanelGetSSHCAPublicKeyResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.GetSSHCAPublicKey(svc.parent.wrapContext(ctx, req, "ControlPanel.GetSSHCAPublicKey"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ControlPanelGetSSHCAPublicKeyResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	resp.PublicKey = (plumbingResponse.PublicKey)
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// GetRDPCAPublicKey retrieves the RDP CA public key.
func (svc *ControlPanel) GetRDPCAPublicKey(
	ctx context.Context) (
	*ControlPanelGetRDPCAPublicKeyResponse,
	error) {
	req := &plumbing.ControlPanelGetRDPCAPublicKeyRequest{}

	var plumbingResponse *plumbing.ControlPanelGetRDPCAPublicKeyResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.GetRDPCAPublicKey(svc.parent.wrapContext(ctx, req, "ControlPanel.GetRDPCAPublicKey"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ControlPanelGetRDPCAPublicKeyResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	resp.PublicKey = (plumbingResponse.PublicKey)
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// VerifyJWT reports whether the given JWT token (x-sdm-token) is valid.
func (svc *ControlPanel) VerifyJWT(
	ctx context.Context,
	token string) (
	*ControlPanelVerifyJWTResponse,
	error) {
	req := &plumbing.ControlPanelVerifyJWTRequest{}

	req.Token = (token)
	var plumbingResponse *plumbing.ControlPanelVerifyJWTResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.VerifyJWT(svc.parent.wrapContext(ctx, req, "ControlPanel.VerifyJWT"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ControlPanelVerifyJWTResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	resp.ValID = (plumbingResponse.Valid)
	return resp, nil
}

// IdentityAliases assign an alias to an account within an IdentitySet.
// The alias is used as the username when connecting to a identity supported resource.
type IdentityAliases struct {
	client plumbing.IdentityAliasesClient
	parent *Client
}

// A SnapshotIdentityAliases exposes the read only methods of the IdentityAliases
// service for historical queries.
type SnapshotIdentityAliases interface {
	Get(
		ctx context.Context,
		id string) (
		*IdentityAliasGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		IdentityAliasIterator,
		error)
}

// Create registers a new IdentityAlias.
func (svc *IdentityAliases) Create(
	ctx context.Context,
	identityAlias *IdentityAlias) (
	*IdentityAliasCreateResponse,
	error) {
	req := &plumbing.IdentityAliasCreateRequest{}

	req.IdentityAlias = convertIdentityAliasToPlumbing(identityAlias)
	var plumbingResponse *plumbing.IdentityAliasCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "IdentityAliases.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &IdentityAliasCreateResponse{}
	if v, err := convertIdentityAliasToPorcelain(plumbingResponse.IdentityAlias); err != nil {
		return nil, err
	} else {
		resp.IdentityAlias = v
	}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads one IdentityAlias by ID.
func (svc *IdentityAliases) Get(
	ctx context.Context,
	id string) (
	*IdentityAliasGetResponse,
	error) {
	req := &plumbing.IdentityAliasGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.IdentityAliasGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "IdentityAliases.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &IdentityAliasGetResponse{}
	if v, err := convertIdentityAliasToPorcelain(plumbingResponse.IdentityAlias); err != nil {
		return nil, err
	} else {
		resp.IdentityAlias = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Update replaces all the fields of a IdentityAlias by ID.
func (svc *IdentityAliases) Update(
	ctx context.Context,
	identityAlias *IdentityAlias) (
	*IdentityAliasUpdateResponse,
	error) {
	req := &plumbing.IdentityAliasUpdateRequest{}

	req.IdentityAlias = convertIdentityAliasToPlumbing(identityAlias)
	var plumbingResponse *plumbing.IdentityAliasUpdateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Update(svc.parent.wrapContext(ctx, req, "IdentityAliases.Update"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &IdentityAliasUpdateResponse{}
	if v, err := convertIdentityAliasToPorcelain(plumbingResponse.IdentityAlias); err != nil {
		return nil, err
	} else {
		resp.IdentityAlias = v
	}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete removes a IdentityAlias by ID.
func (svc *IdentityAliases) Delete(
	ctx context.Context,
	id string) (
	*IdentityAliasDeleteResponse,
	error) {
	req := &plumbing.IdentityAliasDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.IdentityAliasDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "IdentityAliases.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &IdentityAliasDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of IdentityAliases matching a given set of criteria.
func (svc *IdentityAliases) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	IdentityAliasIterator,
	error) {
	req := &plumbing.IdentityAliasListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newIdentityAliasIteratorImpl(
		func() (
			[]*IdentityAlias,
			bool, error) {
			var plumbingResponse *plumbing.IdentityAliasListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "IdentityAliases.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedIdentityAliasToPorcelain(plumbingResponse.IdentityAliases)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// IdentityAliasesHistory records all changes to the state of a IdentityAlias.
type IdentityAliasesHistory struct {
	client plumbing.IdentityAliasesHistoryClient
	parent *Client
}

// List gets a list of IdentityAliasHistory records matching a given set of criteria.
func (svc *IdentityAliasesHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	IdentityAliasHistoryIterator,
	error) {
	req := &plumbing.IdentityAliasHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newIdentityAliasHistoryIteratorImpl(
		func() (
			[]*IdentityAliasHistory,
			bool, error) {
			var plumbingResponse *plumbing.IdentityAliasHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "IdentityAliasesHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedIdentityAliasHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// A IdentitySet is a named grouping of Identity Aliases for Accounts.
// An Account's relationship to a IdentitySet is defined via IdentityAlias objects.
type IdentitySets struct {
	client plumbing.IdentitySetsClient
	parent *Client
}

// A SnapshotIdentitySets exposes the read only methods of the IdentitySets
// service for historical queries.
type SnapshotIdentitySets interface {
	Get(
		ctx context.Context,
		id string) (
		*IdentitySetGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		IdentitySetIterator,
		error)
}

// Create registers a new IdentitySet.
func (svc *IdentitySets) Create(
	ctx context.Context,
	identitySet *IdentitySet) (
	*IdentitySetCreateResponse,
	error) {
	req := &plumbing.IdentitySetCreateRequest{}

	req.IdentitySet = convertIdentitySetToPlumbing(identitySet)
	var plumbingResponse *plumbing.IdentitySetCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "IdentitySets.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &IdentitySetCreateResponse{}
	if v, err := convertIdentitySetToPorcelain(plumbingResponse.IdentitySet); err != nil {
		return nil, err
	} else {
		resp.IdentitySet = v
	}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads one IdentitySet by ID.
func (svc *IdentitySets) Get(
	ctx context.Context,
	id string) (
	*IdentitySetGetResponse,
	error) {
	req := &plumbing.IdentitySetGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.IdentitySetGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "IdentitySets.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &IdentitySetGetResponse{}
	if v, err := convertIdentitySetToPorcelain(plumbingResponse.IdentitySet); err != nil {
		return nil, err
	} else {
		resp.IdentitySet = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Update replaces all the fields of a IdentitySet by ID.
func (svc *IdentitySets) Update(
	ctx context.Context,
	identitySet *IdentitySet) (
	*IdentitySetUpdateResponse,
	error) {
	req := &plumbing.IdentitySetUpdateRequest{}

	req.IdentitySet = convertIdentitySetToPlumbing(identitySet)
	var plumbingResponse *plumbing.IdentitySetUpdateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Update(svc.parent.wrapContext(ctx, req, "IdentitySets.Update"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &IdentitySetUpdateResponse{}
	if v, err := convertIdentitySetToPorcelain(plumbingResponse.IdentitySet); err != nil {
		return nil, err
	} else {
		resp.IdentitySet = v
	}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete removes a IdentitySet by ID.
func (svc *IdentitySets) Delete(
	ctx context.Context,
	id string) (
	*IdentitySetDeleteResponse,
	error) {
	req := &plumbing.IdentitySetDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.IdentitySetDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "IdentitySets.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &IdentitySetDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of IdentitySets matching a given set of criteria.
func (svc *IdentitySets) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	IdentitySetIterator,
	error) {
	req := &plumbing.IdentitySetListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newIdentitySetIteratorImpl(
		func() (
			[]*IdentitySet,
			bool, error) {
			var plumbingResponse *plumbing.IdentitySetListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "IdentitySets.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedIdentitySetToPorcelain(plumbingResponse.IdentitySets)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// IdentitySetsHistory records all changes to the state of a IdentitySet.
type IdentitySetsHistory struct {
	client plumbing.IdentitySetsHistoryClient
	parent *Client
}

// List gets a list of IdentitySetHistory records matching a given set of criteria.
func (svc *IdentitySetsHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	IdentitySetHistoryIterator,
	error) {
	req := &plumbing.IdentitySetHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newIdentitySetHistoryIteratorImpl(
		func() (
			[]*IdentitySetHistory,
			bool, error) {
			var plumbingResponse *plumbing.IdentitySetHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "IdentitySetsHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedIdentitySetHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// Nodes make up the strongDM network, and allow your users to connect securely to your resources. There are two types of nodes:
// - **Gateways** are the entry points into network. They listen for connection from the strongDM client, and provide access to databases and servers.
// - **Relays** are used to extend the strongDM network into segmented subnets. They provide access to databases and servers but do not listen for incoming connections.
type Nodes struct {
	client plumbing.NodesClient
	parent *Client
}

// A SnapshotNodes exposes the read only methods of the Nodes
// service for historical queries.
type SnapshotNodes interface {
	Get(
		ctx context.Context,
		id string) (
		*NodeGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		NodeIterator,
		error)
}

// Create registers a new Node.
func (svc *Nodes) Create(
	ctx context.Context,
	node Node) (
	*NodeCreateResponse,
	error) {
	req := &plumbing.NodeCreateRequest{}

	req.Node = convertNodeToPlumbing(node)
	var plumbingResponse *plumbing.NodeCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "Nodes.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &NodeCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertNodeToPorcelain(plumbingResponse.Node); err != nil {
		return nil, err
	} else {
		resp.Node = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	resp.Token = (plumbingResponse.Token)
	return resp, nil
}

// Get reads one Node by ID.
func (svc *Nodes) Get(
	ctx context.Context,
	id string) (
	*NodeGetResponse,
	error) {
	req := &plumbing.NodeGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.NodeGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "Nodes.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &NodeGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertNodeToPorcelain(plumbingResponse.Node); err != nil {
		return nil, err
	} else {
		resp.Node = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Update replaces all the fields of a Node by ID.
func (svc *Nodes) Update(
	ctx context.Context,
	node Node) (
	*NodeUpdateResponse,
	error) {
	req := &plumbing.NodeUpdateRequest{}

	req.Node = convertNodeToPlumbing(node)
	var plumbingResponse *plumbing.NodeUpdateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Update(svc.parent.wrapContext(ctx, req, "Nodes.Update"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &NodeUpdateResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertNodeToPorcelain(plumbingResponse.Node); err != nil {
		return nil, err
	} else {
		resp.Node = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete removes a Node by ID.
func (svc *Nodes) Delete(
	ctx context.Context,
	id string) (
	*NodeDeleteResponse,
	error) {
	req := &plumbing.NodeDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.NodeDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "Nodes.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &NodeDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of Nodes matching a given set of criteria.
func (svc *Nodes) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	NodeIterator,
	error) {
	req := &plumbing.NodeListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newNodeIteratorImpl(
		func() (
			[]Node,
			bool, error) {
			var plumbingResponse *plumbing.NodeListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "Nodes.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedNodeToPorcelain(plumbingResponse.Nodes)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// NodesHistory records all changes to the state of a Node.
type NodesHistory struct {
	client plumbing.NodesHistoryClient
	parent *Client
}

// List gets a list of NodeHistory records matching a given set of criteria.
func (svc *NodesHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	NodeHistoryIterator,
	error) {
	req := &plumbing.NodeHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newNodeHistoryIteratorImpl(
		func() (
			[]*NodeHistory,
			bool, error) {
			var plumbingResponse *plumbing.NodeHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "NodesHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedNodeHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// OrganizationHistory records all changes to the state of an Organization.
type OrganizationHistory struct {
	client plumbing.OrganizationHistoryClient
	parent *Client
}

// List gets a list of OrganizationHistory records matching a given set of criteria.
func (svc *OrganizationHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	OrganizationHistoryRecordIterator,
	error) {
	req := &plumbing.OrganizationHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newOrganizationHistoryRecordIteratorImpl(
		func() (
			[]*OrganizationHistoryRecord,
			bool, error) {
			var plumbingResponse *plumbing.OrganizationHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "OrganizationHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedOrganizationHistoryRecordToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// PeeringGroupNodes provides the building blocks necessary to obtain attach a node to a peering group.
type PeeringGroupNodes struct {
	client plumbing.PeeringGroupNodesClient
	parent *Client
}

// Create attaches a Node to a PeeringGroup
func (svc *PeeringGroupNodes) Create(
	ctx context.Context,
	peeringGroupNode *PeeringGroupNode) (
	*PeeringGroupNodeCreateResponse,
	error) {
	req := &plumbing.PeeringGroupNodeCreateRequest{}

	req.PeeringGroupNode = convertPeeringGroupNodeToPlumbing(peeringGroupNode)
	var plumbingResponse *plumbing.PeeringGroupNodeCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "PeeringGroupNodes.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PeeringGroupNodeCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPeeringGroupNodeToPorcelain(plumbingResponse.PeeringGroupNode); err != nil {
		return nil, err
	} else {
		resp.PeeringGroupNode = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete detaches a Node to a PeeringGroup.
func (svc *PeeringGroupNodes) Delete(
	ctx context.Context,
	id string) (
	*PeeringGroupNodeDeleteResponse,
	error) {
	req := &plumbing.PeeringGroupNodeDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.PeeringGroupNodeDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "PeeringGroupNodes.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PeeringGroupNodeDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads the information of one peering group to node attachment.
func (svc *PeeringGroupNodes) Get(
	ctx context.Context,
	id string) (
	*PeeringGroupNodeGetResponse,
	error) {
	req := &plumbing.PeeringGroupNodeGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.PeeringGroupNodeGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "PeeringGroupNodes.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PeeringGroupNodeGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPeeringGroupNodeToPorcelain(plumbingResponse.PeeringGroupNode); err != nil {
		return nil, err
	} else {
		resp.PeeringGroupNode = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of peering group node attachments.
func (svc *PeeringGroupNodes) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	PeeringGroupNodeIterator,
	error) {
	req := &plumbing.PeeringGroupNodeListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newPeeringGroupNodeIteratorImpl(
		func() (
			[]*PeeringGroupNode,
			bool, error) {
			var plumbingResponse *plumbing.PeeringGroupNodeListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "PeeringGroupNodes.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedPeeringGroupNodeToPorcelain(plumbingResponse.PeeringGroupNodes)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// PeeringGroupPeers provides the building blocks necessary to link two peering groups.
type PeeringGroupPeers struct {
	client plumbing.PeeringGroupPeersClient
	parent *Client
}

// Create links two peering groups.
func (svc *PeeringGroupPeers) Create(
	ctx context.Context,
	peeringGroupPeer *PeeringGroupPeer) (
	*PeeringGroupPeerCreateResponse,
	error) {
	req := &plumbing.PeeringGroupPeerCreateRequest{}

	req.PeeringGroupPeer = convertPeeringGroupPeerToPlumbing(peeringGroupPeer)
	var plumbingResponse *plumbing.PeeringGroupPeerCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "PeeringGroupPeers.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PeeringGroupPeerCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPeeringGroupPeerToPorcelain(plumbingResponse.PeeringGroupPeer); err != nil {
		return nil, err
	} else {
		resp.PeeringGroupPeer = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete unlinks two peering groups.
func (svc *PeeringGroupPeers) Delete(
	ctx context.Context,
	id string) (
	*PeeringGroupPeerDeleteResponse,
	error) {
	req := &plumbing.PeeringGroupPeerDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.PeeringGroupPeerDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "PeeringGroupPeers.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PeeringGroupPeerDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads the information of one peering group link.
func (svc *PeeringGroupPeers) Get(
	ctx context.Context,
	id string) (
	*PeeringGroupPeerGetResponse,
	error) {
	req := &plumbing.PeeringGroupPeerGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.PeeringGroupPeerGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "PeeringGroupPeers.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PeeringGroupPeerGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPeeringGroupPeerToPorcelain(plumbingResponse.PeeringGroupPeer); err != nil {
		return nil, err
	} else {
		resp.PeeringGroupPeer = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of peering group links.
func (svc *PeeringGroupPeers) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	PeeringGroupPeerIterator,
	error) {
	req := &plumbing.PeeringGroupPeerListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newPeeringGroupPeerIteratorImpl(
		func() (
			[]*PeeringGroupPeer,
			bool, error) {
			var plumbingResponse *plumbing.PeeringGroupPeerListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "PeeringGroupPeers.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedPeeringGroupPeerToPorcelain(plumbingResponse.PeeringGroupPeers)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// PeeringGroupResources provides the building blocks necessary to obtain attach a resource to a peering group.
type PeeringGroupResources struct {
	client plumbing.PeeringGroupResourcesClient
	parent *Client
}

// Create attaches a Resource to a PeeringGroup
func (svc *PeeringGroupResources) Create(
	ctx context.Context,
	peeringGroupResource *PeeringGroupResource) (
	*PeeringGroupResourceCreateResponse,
	error) {
	req := &plumbing.PeeringGroupResourceCreateRequest{}

	req.PeeringGroupResource = convertPeeringGroupResourceToPlumbing(peeringGroupResource)
	var plumbingResponse *plumbing.PeeringGroupResourceCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "PeeringGroupResources.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PeeringGroupResourceCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPeeringGroupResourceToPorcelain(plumbingResponse.PeeringGroupResource); err != nil {
		return nil, err
	} else {
		resp.PeeringGroupResource = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete detaches a Resource to a PeeringGroup
func (svc *PeeringGroupResources) Delete(
	ctx context.Context,
	id string) (
	*PeeringGroupResourceDeleteResponse,
	error) {
	req := &plumbing.PeeringGroupResourceDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.PeeringGroupResourceDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "PeeringGroupResources.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PeeringGroupResourceDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads the information of one peering group to resource attachment.
func (svc *PeeringGroupResources) Get(
	ctx context.Context,
	id string) (
	*PeeringGroupResourceGetResponse,
	error) {
	req := &plumbing.PeeringGroupResourceGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.PeeringGroupResourceGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "PeeringGroupResources.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PeeringGroupResourceGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPeeringGroupResourceToPorcelain(plumbingResponse.PeeringGroupResource); err != nil {
		return nil, err
	} else {
		resp.PeeringGroupResource = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of peering group resource attachments.
func (svc *PeeringGroupResources) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	PeeringGroupResourceIterator,
	error) {
	req := &plumbing.PeeringGroupResourceListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newPeeringGroupResourceIteratorImpl(
		func() (
			[]*PeeringGroupResource,
			bool, error) {
			var plumbingResponse *plumbing.PeeringGroupResourceListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "PeeringGroupResources.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedPeeringGroupResourceToPorcelain(plumbingResponse.PeeringGroupResources)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// PeeringGroups provides the building blocks necessary to obtain explicit network topology and routing.
type PeeringGroups struct {
	client plumbing.PeeringGroupsClient
	parent *Client
}

// Create registers a new PeeringGroup.
func (svc *PeeringGroups) Create(
	ctx context.Context,
	peeringGroup *PeeringGroup) (
	*PeeringGroupCreateResponse,
	error) {
	req := &plumbing.PeeringGroupCreateRequest{}

	req.PeeringGroup = convertPeeringGroupToPlumbing(peeringGroup)
	var plumbingResponse *plumbing.PeeringGroupCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "PeeringGroups.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PeeringGroupCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPeeringGroupToPorcelain(plumbingResponse.PeeringGroup); err != nil {
		return nil, err
	} else {
		resp.PeeringGroup = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete removes a PeeringGroup by ID.
func (svc *PeeringGroups) Delete(
	ctx context.Context,
	id string) (
	*PeeringGroupDeleteResponse,
	error) {
	req := &plumbing.PeeringGroupDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.PeeringGroupDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "PeeringGroups.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PeeringGroupDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads one PeeringGroup by ID. It will load all its dependencies.
func (svc *PeeringGroups) Get(
	ctx context.Context,
	id string) (
	*PeeringGroupGetResponse,
	error) {
	req := &plumbing.PeeringGroupGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.PeeringGroupGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "PeeringGroups.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PeeringGroupGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPeeringGroupToPorcelain(plumbingResponse.PeeringGroup); err != nil {
		return nil, err
	} else {
		resp.PeeringGroup = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of Peering Groups.
func (svc *PeeringGroups) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	PeeringGroupIterator,
	error) {
	req := &plumbing.PeeringGroupListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newPeeringGroupIteratorImpl(
		func() (
			[]*PeeringGroup,
			bool, error) {
			var plumbingResponse *plumbing.PeeringGroupListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "PeeringGroups.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedPeeringGroupToPorcelain(plumbingResponse.PeeringGroups)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// Policies are the collection of one or more statements that enforce fine-grained access
// control for the users of an organization.
type Policies struct {
	client plumbing.PoliciesClient
	parent *Client
}

// A SnapshotPolicies exposes the read only methods of the Policies
// service for historical queries.
type SnapshotPolicies interface {
	Get(
		ctx context.Context,
		id string) (
		*PolicyGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		PolicyIterator,
		error)
}

// Create creates a new Policy.
func (svc *Policies) Create(
	ctx context.Context,
	policy *Policy) (
	*PolicyCreateResponse,
	error) {
	req := &plumbing.PolicyCreateRequest{}

	req.Policy = convertPolicyToPlumbing(policy)
	var plumbingResponse *plumbing.PolicyCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "Policies.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PolicyCreateResponse{}
	if v, err := convertPolicyToPorcelain(plumbingResponse.Policy); err != nil {
		return nil, err
	} else {
		resp.Policy = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete removes a Policy by ID.
func (svc *Policies) Delete(
	ctx context.Context,
	id string) (
	*PolicyDeleteResponse,
	error) {
	req := &plumbing.PolicyDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.PolicyDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "Policies.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PolicyDeleteResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Update replaces all the fields of a Policy by ID.
func (svc *Policies) Update(
	ctx context.Context,
	policy *Policy) (
	*PolicyUpdateResponse,
	error) {
	req := &plumbing.PolicyUpdateRequest{}

	req.Policy = convertPolicyToPlumbing(policy)
	var plumbingResponse *plumbing.PolicyUpdateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Update(svc.parent.wrapContext(ctx, req, "Policies.Update"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PolicyUpdateResponse{}
	if v, err := convertPolicyToPorcelain(plumbingResponse.Policy); err != nil {
		return nil, err
	} else {
		resp.Policy = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads one Policy by ID.
func (svc *Policies) Get(
	ctx context.Context,
	id string) (
	*PolicyGetResponse,
	error) {
	req := &plumbing.PolicyGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.PolicyGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "Policies.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PolicyGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPolicyToPorcelain(plumbingResponse.Policy); err != nil {
		return nil, err
	} else {
		resp.Policy = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of Policy matching a given set of criteria
func (svc *Policies) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	PolicyIterator,
	error) {
	req := &plumbing.PolicyListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newPolicyIteratorImpl(
		func() (
			[]*Policy,
			bool, error) {
			var plumbingResponse *plumbing.PolicyListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "Policies.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedPolicyToPorcelain(plumbingResponse.Policies)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// PoliciesHistory records all changes to the state of a Policy.
type PoliciesHistory struct {
	client plumbing.PoliciesHistoryClient
	parent *Client
}

// List gets a list of PolicyHistory records matching a given set of criteria.
func (svc *PoliciesHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	PolicyHistoryIterator,
	error) {
	req := &plumbing.PoliciesHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newPolicyHistoryIteratorImpl(
		func() (
			[]*PolicyHistory,
			bool, error) {
			var plumbingResponse *plumbing.PoliciesHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "PoliciesHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedPolicyHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// A Query is a record of a single client request to a resource, such as a SQL query.
// Long-running SSH, RDP, or Kubernetes interactive sessions also count as queries.
// The Queries service is read-only.
type Queries struct {
	client plumbing.QueriesClient
	parent *Client
}

// List gets a list of Queries matching a given set of criteria.
func (svc *Queries) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	QueryIterator,
	error) {
	req := &plumbing.QueryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newQueryIteratorImpl(
		func() (
			[]*Query,
			bool, error) {
			var plumbingResponse *plumbing.QueryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "Queries.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedQueryToPorcelain(plumbingResponse.Queries)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// RemoteIdentities assign a resource directly to an account, giving the account the permission to connect to that resource.
type RemoteIdentities struct {
	client plumbing.RemoteIdentitiesClient
	parent *Client
}

// A SnapshotRemoteIdentities exposes the read only methods of the RemoteIdentities
// service for historical queries.
type SnapshotRemoteIdentities interface {
	Get(
		ctx context.Context,
		id string) (
		*RemoteIdentityGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		RemoteIdentityIterator,
		error)
}

// Create registers a new RemoteIdentity.
func (svc *RemoteIdentities) Create(
	ctx context.Context,
	remoteIdentity *RemoteIdentity) (
	*RemoteIdentityCreateResponse,
	error) {
	req := &plumbing.RemoteIdentityCreateRequest{}

	req.RemoteIdentity = convertRemoteIdentityToPlumbing(remoteIdentity)
	var plumbingResponse *plumbing.RemoteIdentityCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "RemoteIdentities.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &RemoteIdentityCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertRemoteIdentityToPorcelain(plumbingResponse.RemoteIdentity); err != nil {
		return nil, err
	} else {
		resp.RemoteIdentity = v
	}
	return resp, nil
}

// Get reads one RemoteIdentity by ID.
func (svc *RemoteIdentities) Get(
	ctx context.Context,
	id string) (
	*RemoteIdentityGetResponse,
	error) {
	req := &plumbing.RemoteIdentityGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.RemoteIdentityGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "RemoteIdentities.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &RemoteIdentityGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertRemoteIdentityToPorcelain(plumbingResponse.RemoteIdentity); err != nil {
		return nil, err
	} else {
		resp.RemoteIdentity = v
	}
	return resp, nil
}

// Update replaces all the fields of a RemoteIdentity by ID.
func (svc *RemoteIdentities) Update(
	ctx context.Context,
	remoteIdentity *RemoteIdentity) (
	*RemoteIdentityUpdateResponse,
	error) {
	req := &plumbing.RemoteIdentityUpdateRequest{}

	req.RemoteIdentity = convertRemoteIdentityToPlumbing(remoteIdentity)
	var plumbingResponse *plumbing.RemoteIdentityUpdateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Update(svc.parent.wrapContext(ctx, req, "RemoteIdentities.Update"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &RemoteIdentityUpdateResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertRemoteIdentityToPorcelain(plumbingResponse.RemoteIdentity); err != nil {
		return nil, err
	} else {
		resp.RemoteIdentity = v
	}
	return resp, nil
}

// Delete removes a RemoteIdentity by ID.
func (svc *RemoteIdentities) Delete(
	ctx context.Context,
	id string) (
	*RemoteIdentityDeleteResponse,
	error) {
	req := &plumbing.RemoteIdentityDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.RemoteIdentityDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "RemoteIdentities.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &RemoteIdentityDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of RemoteIdentities matching a given set of criteria.
func (svc *RemoteIdentities) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	RemoteIdentityIterator,
	error) {
	req := &plumbing.RemoteIdentityListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newRemoteIdentityIteratorImpl(
		func() (
			[]*RemoteIdentity,
			bool, error) {
			var plumbingResponse *plumbing.RemoteIdentityListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "RemoteIdentities.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedRemoteIdentityToPorcelain(plumbingResponse.RemoteIdentities)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// RemoteIdentitiesHistory records all changes to the state of a RemoteIdentity.
type RemoteIdentitiesHistory struct {
	client plumbing.RemoteIdentitiesHistoryClient
	parent *Client
}

// List gets a list of RemoteIdentityHistory records matching a given set of criteria.
func (svc *RemoteIdentitiesHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	RemoteIdentityHistoryIterator,
	error) {
	req := &plumbing.RemoteIdentityHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newRemoteIdentityHistoryIteratorImpl(
		func() (
			[]*RemoteIdentityHistory,
			bool, error) {
			var plumbingResponse *plumbing.RemoteIdentityHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "RemoteIdentitiesHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedRemoteIdentityHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// A RemoteIdentityGroup is a named grouping of Remote Identities for Accounts.
// An Account's relationship to a RemoteIdentityGroup is defined via RemoteIdentity objects.
type RemoteIdentityGroups struct {
	client plumbing.RemoteIdentityGroupsClient
	parent *Client
}

// A SnapshotRemoteIdentityGroups exposes the read only methods of the RemoteIdentityGroups
// service for historical queries.
type SnapshotRemoteIdentityGroups interface {
	Get(
		ctx context.Context,
		id string) (
		*RemoteIdentityGroupGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		RemoteIdentityGroupIterator,
		error)
}

// Get reads one RemoteIdentityGroup by ID.
func (svc *RemoteIdentityGroups) Get(
	ctx context.Context,
	id string) (
	*RemoteIdentityGroupGetResponse,
	error) {
	req := &plumbing.RemoteIdentityGroupGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.RemoteIdentityGroupGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "RemoteIdentityGroups.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &RemoteIdentityGroupGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertRemoteIdentityGroupToPorcelain(plumbingResponse.RemoteIdentityGroup); err != nil {
		return nil, err
	} else {
		resp.RemoteIdentityGroup = v
	}
	return resp, nil
}

// List gets a list of RemoteIdentityGroups matching a given set of criteria.
func (svc *RemoteIdentityGroups) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	RemoteIdentityGroupIterator,
	error) {
	req := &plumbing.RemoteIdentityGroupListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newRemoteIdentityGroupIteratorImpl(
		func() (
			[]*RemoteIdentityGroup,
			bool, error) {
			var plumbingResponse *plumbing.RemoteIdentityGroupListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "RemoteIdentityGroups.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedRemoteIdentityGroupToPorcelain(plumbingResponse.RemoteIdentityGroups)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// RemoteIdentityGroupsHistory records all changes to the state of a RemoteIdentityGroup.
type RemoteIdentityGroupsHistory struct {
	client plumbing.RemoteIdentityGroupsHistoryClient
	parent *Client
}

// List gets a list of RemoteIdentityGroupHistory records matching a given set of criteria.
func (svc *RemoteIdentityGroupsHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	RemoteIdentityGroupHistoryIterator,
	error) {
	req := &plumbing.RemoteIdentityGroupHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newRemoteIdentityGroupHistoryIteratorImpl(
		func() (
			[]*RemoteIdentityGroupHistory,
			bool, error) {
			var plumbingResponse *plumbing.RemoteIdentityGroupHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "RemoteIdentityGroupsHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedRemoteIdentityGroupHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// A Replay captures the data transferred over a long-running SSH, RDP, or Kubernetes interactive session
// (otherwise referred to as a query). The Replays service is read-only.
type Replays struct {
	client plumbing.ReplaysClient
	parent *Client
}

// List gets a list of ReplayChunks for the Query ID specified by the filter criteria.
func (svc *Replays) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ReplayChunkIterator,
	error) {
	req := &plumbing.ReplayListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newReplayChunkIteratorImpl(
		func() (
			[]*ReplayChunk,
			bool, error) {
			var plumbingResponse *plumbing.ReplayListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "Replays.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedReplayChunkToPorcelain(plumbingResponse.Chunks)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// Resources are databases, servers, clusters, websites, or clouds that strongDM
// delegates access to.
type Resources struct {
	client plumbing.ResourcesClient
	parent *Client
}

// A SnapshotResources exposes the read only methods of the Resources
// service for historical queries.
type SnapshotResources interface {
	Get(
		ctx context.Context,
		id string) (
		*ResourceGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		ResourceIterator,
		error)
}

// EnumerateTags gets a list of the filter matching tags.
func (svc *Resources) EnumerateTags(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	TagIterator,
	error) {
	req := &plumbing.EnumerateTagsRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newTagIteratorImpl(
		func() (
			[]*Tag,
			bool, error) {
			var plumbingResponse *plumbing.EnumerateTagsResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.EnumerateTags(svc.parent.wrapContext(ctx, req, "Resources.EnumerateTags"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedTagToPorcelain(plumbingResponse.Matches)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// Create registers a new Resource.
func (svc *Resources) Create(
	ctx context.Context,
	resource Resource) (
	*ResourceCreateResponse,
	error) {
	req := &plumbing.ResourceCreateRequest{}

	req.Resource = convertResourceToPlumbing(resource)
	var plumbingResponse *plumbing.ResourceCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "Resources.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ResourceCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertResourceToPorcelain(plumbingResponse.Resource); err != nil {
		return nil, err
	} else {
		resp.Resource = v
	}
	return resp, nil
}

// Get reads one Resource by ID.
func (svc *Resources) Get(
	ctx context.Context,
	id string) (
	*ResourceGetResponse,
	error) {
	req := &plumbing.ResourceGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.ResourceGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "Resources.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ResourceGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertResourceToPorcelain(plumbingResponse.Resource); err != nil {
		return nil, err
	} else {
		resp.Resource = v
	}
	return resp, nil
}

// Update replaces all the fields of a Resource by ID.
func (svc *Resources) Update(
	ctx context.Context,
	resource Resource) (
	*ResourceUpdateResponse,
	error) {
	req := &plumbing.ResourceUpdateRequest{}

	req.Resource = convertResourceToPlumbing(resource)
	var plumbingResponse *plumbing.ResourceUpdateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Update(svc.parent.wrapContext(ctx, req, "Resources.Update"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ResourceUpdateResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertResourceToPorcelain(plumbingResponse.Resource); err != nil {
		return nil, err
	} else {
		resp.Resource = v
	}
	return resp, nil
}

// Delete removes a Resource by ID.
func (svc *Resources) Delete(
	ctx context.Context,
	id string) (
	*ResourceDeleteResponse,
	error) {
	req := &plumbing.ResourceDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.ResourceDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "Resources.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ResourceDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of Resources matching a given set of criteria.
func (svc *Resources) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ResourceIterator,
	error) {
	req := &plumbing.ResourceListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newResourceIteratorImpl(
		func() (
			[]Resource,
			bool, error) {
			var plumbingResponse *plumbing.ResourceListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "Resources.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedResourceToPorcelain(plumbingResponse.Resources)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// Healthcheck triggers a remote healthcheck. It may take minutes to propagate across a
// large network of Nodes. The call will return immediately, and the updated health of the
// Resource can be retrieved via Get or List.
func (svc *Resources) Healthcheck(
	ctx context.Context,
	id string) (
	*ResourceHealthcheckResponse,
	error) {
	req := &plumbing.ResourceHealthcheckRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.ResourceHealthcheckResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Healthcheck(svc.parent.wrapContext(ctx, req, "Resources.Healthcheck"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ResourceHealthcheckResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// ResourcesHistory records all changes to the state of a Resource.
type ResourcesHistory struct {
	client plumbing.ResourcesHistoryClient
	parent *Client
}

// List gets a list of ResourceHistory records matching a given set of criteria.
func (svc *ResourcesHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ResourceHistoryIterator,
	error) {
	req := &plumbing.ResourceHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newResourceHistoryIteratorImpl(
		func() (
			[]*ResourceHistory,
			bool, error) {
			var plumbingResponse *plumbing.ResourceHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "ResourcesHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedResourceHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// RoleResources enumerates the resources to which roles have access.
// The RoleResources service is read-only.
type RoleResources struct {
	client plumbing.RoleResourcesClient
	parent *Client
}

// A SnapshotRoleResources exposes the read only methods of the RoleResources
// service for historical queries.
type SnapshotRoleResources interface {
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		RoleResourceIterator,
		error)
}

// List gets a list of RoleResource records matching a given set of criteria.
func (svc *RoleResources) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	RoleResourceIterator,
	error) {
	req := &plumbing.RoleResourceListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newRoleResourceIteratorImpl(
		func() (
			[]*RoleResource,
			bool, error) {
			var plumbingResponse *plumbing.RoleResourceListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "RoleResources.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedRoleResourceToPorcelain(plumbingResponse.RoleResources)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// RoleResourcesHistory records all changes to the state of a RoleResource.
type RoleResourcesHistory struct {
	client plumbing.RoleResourcesHistoryClient
	parent *Client
}

// List gets a list of RoleResourceHistory records matching a given set of criteria.
func (svc *RoleResourcesHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	RoleResourceHistoryIterator,
	error) {
	req := &plumbing.RoleResourceHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newRoleResourceHistoryIteratorImpl(
		func() (
			[]*RoleResourceHistory,
			bool, error) {
			var plumbingResponse *plumbing.RoleResourceHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "RoleResourcesHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedRoleResourceHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// A Role has a list of access rules which determine which Resources the members
// of the Role have access to. An Account can be a member of multiple Roles via
// AccountAttachments.
type Roles struct {
	client plumbing.RolesClient
	parent *Client
}

// A SnapshotRoles exposes the read only methods of the Roles
// service for historical queries.
type SnapshotRoles interface {
	Get(
		ctx context.Context,
		id string) (
		*RoleGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		RoleIterator,
		error)
}

// Create registers a new Role.
func (svc *Roles) Create(
	ctx context.Context,
	role *Role) (
	*RoleCreateResponse,
	error) {
	req := &plumbing.RoleCreateRequest{}

	req.Role = convertRoleToPlumbing(role)
	var plumbingResponse *plumbing.RoleCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "Roles.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &RoleCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertRoleToPorcelain(plumbingResponse.Role); err != nil {
		return nil, err
	} else {
		resp.Role = v
	}
	return resp, nil
}

// Get reads one Role by ID.
func (svc *Roles) Get(
	ctx context.Context,
	id string) (
	*RoleGetResponse,
	error) {
	req := &plumbing.RoleGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.RoleGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "Roles.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &RoleGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertRoleToPorcelain(plumbingResponse.Role); err != nil {
		return nil, err
	} else {
		resp.Role = v
	}
	return resp, nil
}

// Update replaces all the fields of a Role by ID.
func (svc *Roles) Update(
	ctx context.Context,
	role *Role) (
	*RoleUpdateResponse,
	error) {
	req := &plumbing.RoleUpdateRequest{}

	req.Role = convertRoleToPlumbing(role)
	var plumbingResponse *plumbing.RoleUpdateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Update(svc.parent.wrapContext(ctx, req, "Roles.Update"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &RoleUpdateResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertRoleToPorcelain(plumbingResponse.Role); err != nil {
		return nil, err
	} else {
		resp.Role = v
	}
	return resp, nil
}

// Delete removes a Role by ID.
func (svc *Roles) Delete(
	ctx context.Context,
	id string) (
	*RoleDeleteResponse,
	error) {
	req := &plumbing.RoleDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.RoleDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "Roles.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &RoleDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of Roles matching a given set of criteria.
func (svc *Roles) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	RoleIterator,
	error) {
	req := &plumbing.RoleListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newRoleIteratorImpl(
		func() (
			[]*Role,
			bool, error) {
			var plumbingResponse *plumbing.RoleListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "Roles.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedRoleToPorcelain(plumbingResponse.Roles)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// RolesHistory records all changes to the state of a Role.
type RolesHistory struct {
	client plumbing.RolesHistoryClient
	parent *Client
}

// List gets a list of RoleHistory records matching a given set of criteria.
func (svc *RolesHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	RoleHistoryIterator,
	error) {
	req := &plumbing.RoleHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newRoleHistoryIteratorImpl(
		func() (
			[]*RoleHistory,
			bool, error) {
			var plumbingResponse *plumbing.RoleHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "RolesHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedRoleHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// SecretStoreHealths exposes health states for secret stores.
type SecretStoreHealths struct {
	client plumbing.SecretStoreHealthsClient
	parent *Client
}

// List reports the health status of node to secret store pairs.
func (svc *SecretStoreHealths) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	SecretStoreHealthIterator,
	error) {
	req := &plumbing.SecretStoreHealthListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newSecretStoreHealthIteratorImpl(
		func() (
			[]*SecretStoreHealth,
			bool, error) {
			var plumbingResponse *plumbing.SecretStoreHealthListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "SecretStoreHealths.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedSecretStoreHealthToPorcelain(plumbingResponse.SecretStoreHealths)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// Healthcheck triggers a remote healthcheck request for a secret store. It may take minutes
// to propagate across a large network of Nodes. The call will return immediately, and the
// updated health of the Secret Store can be retrieved via List.
func (svc *SecretStoreHealths) Healthcheck(
	ctx context.Context,
	secretStoreId string) (
	*SecretStoreHealthcheckResponse,
	error) {
	req := &plumbing.SecretStoreHealthcheckRequest{}

	req.SecretStoreId = (secretStoreId)
	var plumbingResponse *plumbing.SecretStoreHealthcheckResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Healthcheck(svc.parent.wrapContext(ctx, req, "SecretStoreHealths.Healthcheck"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &SecretStoreHealthcheckResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// SecretStores are servers where resource secrets (passwords, keys) are stored.
type SecretStores struct {
	client plumbing.SecretStoresClient
	parent *Client
}

// A SnapshotSecretStores exposes the read only methods of the SecretStores
// service for historical queries.
type SnapshotSecretStores interface {
	Get(
		ctx context.Context,
		id string) (
		*SecretStoreGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		SecretStoreIterator,
		error)
}

func (svc *SecretStores) Create(
	ctx context.Context,
	secretStore SecretStore) (
	*SecretStoreCreateResponse,
	error) {
	req := &plumbing.SecretStoreCreateRequest{}

	req.SecretStore = convertSecretStoreToPlumbing(secretStore)
	var plumbingResponse *plumbing.SecretStoreCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "SecretStores.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &SecretStoreCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertSecretStoreToPorcelain(plumbingResponse.SecretStore); err != nil {
		return nil, err
	} else {
		resp.SecretStore = v
	}
	return resp, nil
}

// Get reads one SecretStore by ID.
func (svc *SecretStores) Get(
	ctx context.Context,
	id string) (
	*SecretStoreGetResponse,
	error) {
	req := &plumbing.SecretStoreGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.SecretStoreGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "SecretStores.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &SecretStoreGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertSecretStoreToPorcelain(plumbingResponse.SecretStore); err != nil {
		return nil, err
	} else {
		resp.SecretStore = v
	}
	return resp, nil
}

// Update replaces all the fields of a SecretStore by ID.
func (svc *SecretStores) Update(
	ctx context.Context,
	secretStore SecretStore) (
	*SecretStoreUpdateResponse,
	error) {
	req := &plumbing.SecretStoreUpdateRequest{}

	req.SecretStore = convertSecretStoreToPlumbing(secretStore)
	var plumbingResponse *plumbing.SecretStoreUpdateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Update(svc.parent.wrapContext(ctx, req, "SecretStores.Update"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &SecretStoreUpdateResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertSecretStoreToPorcelain(plumbingResponse.SecretStore); err != nil {
		return nil, err
	} else {
		resp.SecretStore = v
	}
	return resp, nil
}

// Delete removes a SecretStore by ID.
func (svc *SecretStores) Delete(
	ctx context.Context,
	id string) (
	*SecretStoreDeleteResponse,
	error) {
	req := &plumbing.SecretStoreDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.SecretStoreDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "SecretStores.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &SecretStoreDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of SecretStores matching a given set of criteria.
func (svc *SecretStores) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	SecretStoreIterator,
	error) {
	req := &plumbing.SecretStoreListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newSecretStoreIteratorImpl(
		func() (
			[]SecretStore,
			bool, error) {
			var plumbingResponse *plumbing.SecretStoreListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "SecretStores.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedSecretStoreToPorcelain(plumbingResponse.SecretStores)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// SecretStoresHistory records all changes to the state of a SecretStore.
type SecretStoresHistory struct {
	client plumbing.SecretStoresHistoryClient
	parent *Client
}

// List gets a list of SecretStoreHistory records matching a given set of criteria.
func (svc *SecretStoresHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	SecretStoreHistoryIterator,
	error) {
	req := &plumbing.SecretStoreHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newSecretStoreHistoryIteratorImpl(
		func() (
			[]*SecretStoreHistory,
			bool, error) {
			var plumbingResponse *plumbing.SecretStoreHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "SecretStoresHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedSecretStoreHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// WorkflowApprovers is an account or a role with the ability to approve requests bound to a workflow.
type WorkflowApprovers struct {
	client plumbing.WorkflowApproversClient
	parent *Client
}

// A SnapshotWorkflowApprovers exposes the read only methods of the WorkflowApprovers
// service for historical queries.
type SnapshotWorkflowApprovers interface {
	Get(
		ctx context.Context,
		id string) (
		*WorkflowApproverGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		WorkflowApproverIterator,
		error)
}

// Create creates a new workflow approver
func (svc *WorkflowApprovers) Create(
	ctx context.Context,
	workflowApprover *WorkflowApprover) (
	*WorkflowApproversCreateResponse,
	error) {
	req := &plumbing.WorkflowApproversCreateRequest{}

	req.WorkflowApprover = convertWorkflowApproverToPlumbing(workflowApprover)
	var plumbingResponse *plumbing.WorkflowApproversCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "WorkflowApprovers.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &WorkflowApproversCreateResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertWorkflowApproverToPorcelain(plumbingResponse.WorkflowApprover); err != nil {
		return nil, err
	} else {
		resp.WorkflowApprover = v
	}
	return resp, nil
}

// Get reads one workflow approver by ID.
func (svc *WorkflowApprovers) Get(
	ctx context.Context,
	id string) (
	*WorkflowApproverGetResponse,
	error) {
	req := &plumbing.WorkflowApproverGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.WorkflowApproverGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "WorkflowApprovers.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &WorkflowApproverGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertWorkflowApproverToPorcelain(plumbingResponse.WorkflowApprover); err != nil {
		return nil, err
	} else {
		resp.WorkflowApprover = v
	}
	return resp, nil
}

// Delete deletes a workflow approver
func (svc *WorkflowApprovers) Delete(
	ctx context.Context,
	id string) (
	*WorkflowApproversDeleteResponse,
	error) {
	req := &plumbing.WorkflowApproversDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.WorkflowApproversDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "WorkflowApprovers.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &WorkflowApproversDeleteResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Lists existing workflow approvers.
func (svc *WorkflowApprovers) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	WorkflowApproverIterator,
	error) {
	req := &plumbing.WorkflowApproversListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newWorkflowApproverIteratorImpl(
		func() (
			[]*WorkflowApprover,
			bool, error) {
			var plumbingResponse *plumbing.WorkflowApproversListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "WorkflowApprovers.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedWorkflowApproverToPorcelain(plumbingResponse.WorkflowApprovers)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// WorkflowApproversHistory provides records of all changes to the state of a WorkflowApprover.
type WorkflowApproversHistory struct {
	client plumbing.WorkflowApproversHistoryClient
	parent *Client
}

// List gets a list of WorkflowApproversHistory records matching a given set of criteria.
func (svc *WorkflowApproversHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	WorkflowApproverHistoryIterator,
	error) {
	req := &plumbing.WorkflowApproversHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newWorkflowApproverHistoryIteratorImpl(
		func() (
			[]*WorkflowApproverHistory,
			bool, error) {
			var plumbingResponse *plumbing.WorkflowApproversHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "WorkflowApproversHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedWorkflowApproverHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// WorkflowAssignments links a Resource to a Workflow. The assigned resources are those that a user can request
// access to via the workflow.
type WorkflowAssignments struct {
	client plumbing.WorkflowAssignmentsClient
	parent *Client
}

// A SnapshotWorkflowAssignments exposes the read only methods of the WorkflowAssignments
// service for historical queries.
type SnapshotWorkflowAssignments interface {
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		WorkflowAssignmentIterator,
		error)
}

// Lists existing workflow assignments.
func (svc *WorkflowAssignments) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	WorkflowAssignmentIterator,
	error) {
	req := &plumbing.WorkflowAssignmentsListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newWorkflowAssignmentIteratorImpl(
		func() (
			[]*WorkflowAssignment,
			bool, error) {
			var plumbingResponse *plumbing.WorkflowAssignmentsListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "WorkflowAssignments.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedWorkflowAssignmentToPorcelain(plumbingResponse.WorkflowAssignments)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// WorkflowAssignmentsHistory provides records of all changes to the state of a WorkflowAssignment.
type WorkflowAssignmentsHistory struct {
	client plumbing.WorkflowAssignmentsHistoryClient
	parent *Client
}

// List gets a list of WorkflowAssignmentsHistory records matching a given set of criteria.
func (svc *WorkflowAssignmentsHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	WorkflowAssignmentHistoryIterator,
	error) {
	req := &plumbing.WorkflowAssignmentsHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newWorkflowAssignmentHistoryIteratorImpl(
		func() (
			[]*WorkflowAssignmentHistory,
			bool, error) {
			var plumbingResponse *plumbing.WorkflowAssignmentsHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "WorkflowAssignmentsHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedWorkflowAssignmentHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// WorkflowRole links a role to a workflow. The linked roles indicate which roles a user must be a part of
// to request access to a resource via the workflow.
type WorkflowRoles struct {
	client plumbing.WorkflowRolesClient
	parent *Client
}

// A SnapshotWorkflowRoles exposes the read only methods of the WorkflowRoles
// service for historical queries.
type SnapshotWorkflowRoles interface {
	Get(
		ctx context.Context,
		id string) (
		*WorkflowRoleGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		WorkflowRoleIterator,
		error)
}

// Create creates a new workflow role
func (svc *WorkflowRoles) Create(
	ctx context.Context,
	workflowRole *WorkflowRole) (
	*WorkflowRolesCreateResponse,
	error) {
	req := &plumbing.WorkflowRolesCreateRequest{}

	req.WorkflowRole = convertWorkflowRoleToPlumbing(workflowRole)
	var plumbingResponse *plumbing.WorkflowRolesCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "WorkflowRoles.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &WorkflowRolesCreateResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertWorkflowRoleToPorcelain(plumbingResponse.WorkflowRole); err != nil {
		return nil, err
	} else {
		resp.WorkflowRole = v
	}
	return resp, nil
}

// Get reads one workflow role by ID.
func (svc *WorkflowRoles) Get(
	ctx context.Context,
	id string) (
	*WorkflowRoleGetResponse,
	error) {
	req := &plumbing.WorkflowRoleGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.WorkflowRoleGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "WorkflowRoles.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &WorkflowRoleGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertWorkflowRoleToPorcelain(plumbingResponse.WorkflowRole); err != nil {
		return nil, err
	} else {
		resp.WorkflowRole = v
	}
	return resp, nil
}

// Delete deletes a workflow role
func (svc *WorkflowRoles) Delete(
	ctx context.Context,
	id string) (
	*WorkflowRolesDeleteResponse,
	error) {
	req := &plumbing.WorkflowRolesDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.WorkflowRolesDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "WorkflowRoles.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &WorkflowRolesDeleteResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Lists existing workflow roles.
func (svc *WorkflowRoles) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	WorkflowRoleIterator,
	error) {
	req := &plumbing.WorkflowRolesListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newWorkflowRoleIteratorImpl(
		func() (
			[]*WorkflowRole,
			bool, error) {
			var plumbingResponse *plumbing.WorkflowRolesListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "WorkflowRoles.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedWorkflowRoleToPorcelain(plumbingResponse.WorkflowRole)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// WorkflowRolesHistory provides records of all changes to the state of a WorkflowRole
type WorkflowRolesHistory struct {
	client plumbing.WorkflowRolesHistoryClient
	parent *Client
}

// List gets a list of WorkflowRolesHistory records matching a given set of criteria.
func (svc *WorkflowRolesHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	WorkflowRoleHistoryIterator,
	error) {
	req := &plumbing.WorkflowRolesHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newWorkflowRoleHistoryIteratorImpl(
		func() (
			[]*WorkflowRoleHistory,
			bool, error) {
			var plumbingResponse *plumbing.WorkflowRolesHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "WorkflowRolesHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedWorkflowRoleHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// Workflows are the collection of rules that define the resources to which access can be requested,
// the users that can request that access, and the mechanism for approving those requests which can either
// be automatic approval or a set of users authorized to approve the requests.
type Workflows struct {
	client plumbing.WorkflowsClient
	parent *Client
}

// A SnapshotWorkflows exposes the read only methods of the Workflows
// service for historical queries.
type SnapshotWorkflows interface {
	Get(
		ctx context.Context,
		id string) (
		*WorkflowGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		WorkflowIterator,
		error)
}

// Create creates a new workflow and requires a name for the workflow.
func (svc *Workflows) Create(
	ctx context.Context,
	workflow *Workflow) (
	*WorkflowCreateResponse,
	error) {
	req := &plumbing.WorkflowCreateRequest{}

	req.Workflow = convertWorkflowToPlumbing(workflow)
	var plumbingResponse *plumbing.WorkflowCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "Workflows.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &WorkflowCreateResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertWorkflowToPorcelain(plumbingResponse.Workflow); err != nil {
		return nil, err
	} else {
		resp.Workflow = v
	}
	return resp, nil
}

// Get reads one workflow by ID.
func (svc *Workflows) Get(
	ctx context.Context,
	id string) (
	*WorkflowGetResponse,
	error) {
	req := &plumbing.WorkflowGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.WorkflowGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "Workflows.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &WorkflowGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertWorkflowToPorcelain(plumbingResponse.Workflow); err != nil {
		return nil, err
	} else {
		resp.Workflow = v
	}
	return resp, nil
}

// Delete deletes an existing workflow.
func (svc *Workflows) Delete(
	ctx context.Context,
	id string) (
	*WorkflowDeleteResponse,
	error) {
	req := &plumbing.WorkflowDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.WorkflowDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "Workflows.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &WorkflowDeleteResponse{}
	resp.ID = (plumbingResponse.Id)
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Update updates an existing workflow.
func (svc *Workflows) Update(
	ctx context.Context,
	workflow *Workflow) (
	*WorkflowUpdateResponse,
	error) {
	req := &plumbing.WorkflowUpdateRequest{}

	req.Workflow = convertWorkflowToPlumbing(workflow)
	var plumbingResponse *plumbing.WorkflowUpdateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Update(svc.parent.wrapContext(ctx, req, "Workflows.Update"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &WorkflowUpdateResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertWorkflowToPorcelain(plumbingResponse.Workflow); err != nil {
		return nil, err
	} else {
		resp.Workflow = v
	}
	return resp, nil
}

// Lists existing workflows.
func (svc *Workflows) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	WorkflowIterator,
	error) {
	req := &plumbing.WorkflowListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newWorkflowIteratorImpl(
		func() (
			[]*Workflow,
			bool, error) {
			var plumbingResponse *plumbing.WorkflowListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "Workflows.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedWorkflowToPorcelain(plumbingResponse.Workflows)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// WorkflowsHistory provides records of all changes to the state of a Workflow.
type WorkflowsHistory struct {
	client plumbing.WorkflowsHistoryClient
	parent *Client
}

// List gets a list of WorkflowHistory records matching a given set of criteria.
func (svc *WorkflowsHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	WorkflowHistoryIterator,
	error) {
	req := &plumbing.WorkflowHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newWorkflowHistoryIteratorImpl(
		func() (
			[]*WorkflowHistory,
			bool, error) {
			var plumbingResponse *plumbing.WorkflowHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "WorkflowsHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedWorkflowHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}
