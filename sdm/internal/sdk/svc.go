// Copyright 2020 StrongDM Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package sdm

// Code generated by protogen. DO NOT EDIT.

import (
	"context"

	plumbing "github.com/strongdm/terraform-provider-sdm/sdm/internal/sdk/v1"
)

// AccountAttachments assign an account to a role.
type AccountAttachments struct {
	client plumbing.AccountAttachmentsClient
	parent *Client
}

// A SnapshotAccountAttachments exposes the read only methods of the AccountAttachments
// service for historical queries.
type SnapshotAccountAttachments interface {
	Get(
		ctx context.Context,
		id string) (
		*AccountAttachmentGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		AccountAttachmentIterator,
		error)
}

// Create registers a new AccountAttachment.
func (svc *AccountAttachments) Create(
	ctx context.Context,
	accountAttachment *AccountAttachment) (
	*AccountAttachmentCreateResponse,
	error) {
	req := &plumbing.AccountAttachmentCreateRequest{}

	req.AccountAttachment = convertAccountAttachmentToPlumbing(accountAttachment)
	var plumbingResponse *plumbing.AccountAttachmentCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "AccountAttachments.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &AccountAttachmentCreateResponse{}
	if v, err := convertAccountAttachmentToPorcelain(plumbingResponse.AccountAttachment); err != nil {
		return nil, err
	} else {
		resp.AccountAttachment = v
	}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads one AccountAttachment by ID.
func (svc *AccountAttachments) Get(
	ctx context.Context,
	id string) (
	*AccountAttachmentGetResponse,
	error) {
	req := &plumbing.AccountAttachmentGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.AccountAttachmentGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "AccountAttachments.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &AccountAttachmentGetResponse{}
	if v, err := convertAccountAttachmentToPorcelain(plumbingResponse.AccountAttachment); err != nil {
		return nil, err
	} else {
		resp.AccountAttachment = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete removes a AccountAttachment by ID.
func (svc *AccountAttachments) Delete(
	ctx context.Context,
	id string) (
	*AccountAttachmentDeleteResponse,
	error) {
	req := &plumbing.AccountAttachmentDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.AccountAttachmentDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "AccountAttachments.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &AccountAttachmentDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of AccountAttachments matching a given set of criteria.
func (svc *AccountAttachments) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountAttachmentIterator,
	error) {
	req := &plumbing.AccountAttachmentListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountAttachmentIteratorImpl(
		func() (
			[]*AccountAttachment,
			bool, error) {
			var plumbingResponse *plumbing.AccountAttachmentListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "AccountAttachments.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedAccountAttachmentToPorcelain(plumbingResponse.AccountAttachments)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccountAttachmentsHistory records all changes to the state of an AccountAttachment.
type AccountAttachmentsHistory struct {
	client plumbing.AccountAttachmentsHistoryClient
	parent *Client
}

// List gets a list of AccountAttachmentHistory records matching a given set of criteria.
func (svc *AccountAttachmentsHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountAttachmentHistoryIterator,
	error) {
	req := &plumbing.AccountAttachmentHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountAttachmentHistoryIteratorImpl(
		func() (
			[]*AccountAttachmentHistory,
			bool, error) {
			var plumbingResponse *plumbing.AccountAttachmentHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "AccountAttachmentsHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedAccountAttachmentHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccountGrants assign a resource directly to an account, giving the account the permission to connect to that resource.
type AccountGrants struct {
	client plumbing.AccountGrantsClient
	parent *Client
}

// A SnapshotAccountGrants exposes the read only methods of the AccountGrants
// service for historical queries.
type SnapshotAccountGrants interface {
	Get(
		ctx context.Context,
		id string) (
		*AccountGrantGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		AccountGrantIterator,
		error)
}

// Create registers a new AccountGrant.
func (svc *AccountGrants) Create(
	ctx context.Context,
	accountGrant *AccountGrant) (
	*AccountGrantCreateResponse,
	error) {
	req := &plumbing.AccountGrantCreateRequest{}

	req.AccountGrant = convertAccountGrantToPlumbing(accountGrant)
	var plumbingResponse *plumbing.AccountGrantCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "AccountGrants.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &AccountGrantCreateResponse{}
	if v, err := convertAccountGrantToPorcelain(plumbingResponse.AccountGrant); err != nil {
		return nil, err
	} else {
		resp.AccountGrant = v
	}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads one AccountGrant by ID.
func (svc *AccountGrants) Get(
	ctx context.Context,
	id string) (
	*AccountGrantGetResponse,
	error) {
	req := &plumbing.AccountGrantGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.AccountGrantGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "AccountGrants.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &AccountGrantGetResponse{}
	if v, err := convertAccountGrantToPorcelain(plumbingResponse.AccountGrant); err != nil {
		return nil, err
	} else {
		resp.AccountGrant = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete removes a AccountGrant by ID.
func (svc *AccountGrants) Delete(
	ctx context.Context,
	id string) (
	*AccountGrantDeleteResponse,
	error) {
	req := &plumbing.AccountGrantDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.AccountGrantDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "AccountGrants.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &AccountGrantDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of AccountGrants matching a given set of criteria.
func (svc *AccountGrants) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountGrantIterator,
	error) {
	req := &plumbing.AccountGrantListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountGrantIteratorImpl(
		func() (
			[]*AccountGrant,
			bool, error) {
			var plumbingResponse *plumbing.AccountGrantListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "AccountGrants.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedAccountGrantToPorcelain(plumbingResponse.AccountGrants)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccountGrantsHistory records all changes to the state of an AccountGrant.
type AccountGrantsHistory struct {
	client plumbing.AccountGrantsHistoryClient
	parent *Client
}

// List gets a list of AccountGrantHistory records matching a given set of criteria.
func (svc *AccountGrantsHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountGrantHistoryIterator,
	error) {
	req := &plumbing.AccountGrantHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountGrantHistoryIteratorImpl(
		func() (
			[]*AccountGrantHistory,
			bool, error) {
			var plumbingResponse *plumbing.AccountGrantHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "AccountGrantsHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedAccountGrantHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccountPermissions records the granular permissions accounts have, allowing them to execute
// relevant commands via StrongDM's APIs.
type AccountPermissions struct {
	client plumbing.AccountPermissionsClient
	parent *Client
}

// A SnapshotAccountPermissions exposes the read only methods of the AccountPermissions
// service for historical queries.
type SnapshotAccountPermissions interface {
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		AccountPermissionIterator,
		error)
}

// List gets a list of Permission records matching a given set of criteria.
func (svc *AccountPermissions) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountPermissionIterator,
	error) {
	req := &plumbing.AccountPermissionListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountPermissionIteratorImpl(
		func() (
			[]*AccountPermission,
			bool, error) {
			var plumbingResponse *plumbing.AccountPermissionListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "AccountPermissions.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedAccountPermissionToPorcelain(plumbingResponse.Permissions)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccountResources enumerates the resources to which accounts have access.
// The AccountResources service is read-only.
type AccountResources struct {
	client plumbing.AccountResourcesClient
	parent *Client
}

// A SnapshotAccountResources exposes the read only methods of the AccountResources
// service for historical queries.
type SnapshotAccountResources interface {
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		AccountResourceIterator,
		error)
}

// List gets a list of AccountResource records matching a given set of criteria.
func (svc *AccountResources) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountResourceIterator,
	error) {
	req := &plumbing.AccountResourceListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountResourceIteratorImpl(
		func() (
			[]*AccountResource,
			bool, error) {
			var plumbingResponse *plumbing.AccountResourceListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "AccountResources.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedAccountResourceToPorcelain(plumbingResponse.AccountResources)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccountResourcesHistory records all changes to the state of a AccountResource.
type AccountResourcesHistory struct {
	client plumbing.AccountResourcesHistoryClient
	parent *Client
}

// List gets a list of AccountResourceHistory records matching a given set of criteria.
func (svc *AccountResourcesHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountResourceHistoryIterator,
	error) {
	req := &plumbing.AccountResourceHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountResourceHistoryIteratorImpl(
		func() (
			[]*AccountResourceHistory,
			bool, error) {
			var plumbingResponse *plumbing.AccountResourceHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "AccountResourcesHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedAccountResourceHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// Accounts are users that have access to strongDM. There are two types of accounts:
// 1. **Users:** humans who are authenticated through username and password or SSO.
// 2. **Service Accounts:** machines that are authenticated using a service token.
type Accounts struct {
	client plumbing.AccountsClient
	parent *Client
}

// A SnapshotAccounts exposes the read only methods of the Accounts
// service for historical queries.
type SnapshotAccounts interface {
	Get(
		ctx context.Context,
		id string) (
		*AccountGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		AccountIterator,
		error)
}

// Create registers a new Account.
func (svc *Accounts) Create(
	ctx context.Context,
	account Account) (
	*AccountCreateResponse,
	error) {
	req := &plumbing.AccountCreateRequest{}

	req.Account = convertAccountToPlumbing(account)
	var plumbingResponse *plumbing.AccountCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "Accounts.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &AccountCreateResponse{}
	if v, err := convertAccountToPorcelain(plumbingResponse.Account); err != nil {
		return nil, err
	} else {
		resp.Account = v
	}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	resp.Token = (plumbingResponse.Token)
	return resp, nil
}

// Get reads one Account by ID.
func (svc *Accounts) Get(
	ctx context.Context,
	id string) (
	*AccountGetResponse,
	error) {
	req := &plumbing.AccountGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.AccountGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "Accounts.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &AccountGetResponse{}
	if v, err := convertAccountToPorcelain(plumbingResponse.Account); err != nil {
		return nil, err
	} else {
		resp.Account = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Update replaces all the fields of an Account by ID.
func (svc *Accounts) Update(
	ctx context.Context,
	account Account) (
	*AccountUpdateResponse,
	error) {
	req := &plumbing.AccountUpdateRequest{}

	req.Account = convertAccountToPlumbing(account)
	var plumbingResponse *plumbing.AccountUpdateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Update(svc.parent.wrapContext(ctx, req, "Accounts.Update"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &AccountUpdateResponse{}
	if v, err := convertAccountToPorcelain(plumbingResponse.Account); err != nil {
		return nil, err
	} else {
		resp.Account = v
	}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete removes an Account by ID.
func (svc *Accounts) Delete(
	ctx context.Context,
	id string) (
	*AccountDeleteResponse,
	error) {
	req := &plumbing.AccountDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.AccountDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "Accounts.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &AccountDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of Accounts matching a given set of criteria.
func (svc *Accounts) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountIterator,
	error) {
	req := &plumbing.AccountListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountIteratorImpl(
		func() (
			[]Account,
			bool, error) {
			var plumbingResponse *plumbing.AccountListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "Accounts.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedAccountToPorcelain(plumbingResponse.Accounts)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccountsHistory records all changes to the state of an Account.
type AccountsHistory struct {
	client plumbing.AccountsHistoryClient
	parent *Client
}

// List gets a list of AccountHistory records matching a given set of criteria.
func (svc *AccountsHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountHistoryIterator,
	error) {
	req := &plumbing.AccountHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountHistoryIteratorImpl(
		func() (
			[]*AccountHistory,
			bool, error) {
			var plumbingResponse *plumbing.AccountHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "AccountsHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedAccountHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// An Activity is a record of an action taken against a strongDM deployment, e.g.
// a user creation, resource deletion, sso configuration change, etc. The Activities
// service is read-only.
type Activities struct {
	client plumbing.ActivitiesClient
	parent *Client
}

// Get reads one Activity by ID.
func (svc *Activities) Get(
	ctx context.Context,
	id string) (
	*ActivityGetResponse,
	error) {
	req := &plumbing.ActivityGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.ActivityGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "Activities.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ActivityGetResponse{}
	if v, err := convertActivityToPorcelain(plumbingResponse.Activity); err != nil {
		return nil, err
	} else {
		resp.Activity = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of Activities matching a given set of criteria.
func (svc *Activities) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ActivityIterator,
	error) {
	req := &plumbing.ActivityListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newActivityIteratorImpl(
		func() (
			[]*Activity,
			bool, error) {
			var plumbingResponse *plumbing.ActivityListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "Activities.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedActivityToPorcelain(plumbingResponse.Activities)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// ControlPanel contains all administrative controls.
type ControlPanel struct {
	client plumbing.ControlPanelClient
	parent *Client
}

// GetSSHCAPublicKey retrieves the SSH CA public key.
func (svc *ControlPanel) GetSSHCAPublicKey(
	ctx context.Context) (
	*ControlPanelGetSSHCAPublicKeyResponse,
	error) {
	req := &plumbing.ControlPanelGetSSHCAPublicKeyRequest{}

	var plumbingResponse *plumbing.ControlPanelGetSSHCAPublicKeyResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.GetSSHCAPublicKey(svc.parent.wrapContext(ctx, req, "ControlPanel.GetSSHCAPublicKey"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ControlPanelGetSSHCAPublicKeyResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	resp.PublicKey = (plumbingResponse.PublicKey)
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// VerifyJWT reports whether the given JWT token (x-sdm-token) is valid.
func (svc *ControlPanel) VerifyJWT(
	ctx context.Context,
	token string) (
	*ControlPanelVerifyJWTResponse,
	error) {
	req := &plumbing.ControlPanelVerifyJWTRequest{}

	req.Token = (token)
	var plumbingResponse *plumbing.ControlPanelVerifyJWTResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.VerifyJWT(svc.parent.wrapContext(ctx, req, "ControlPanel.VerifyJWT"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ControlPanelVerifyJWTResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	resp.ValID = (plumbingResponse.Valid)
	return resp, nil
}

// Nodes make up the strongDM network, and allow your users to connect securely to your resources. There are two types of nodes:
// - **Gateways** are the entry points into network. They listen for connection from the strongDM client, and provide access to databases and servers.
// - **Relays** are used to extend the strongDM network into segmented subnets. They provide access to databases and servers but do not listen for incoming connections.
type Nodes struct {
	client plumbing.NodesClient
	parent *Client
}

// A SnapshotNodes exposes the read only methods of the Nodes
// service for historical queries.
type SnapshotNodes interface {
	Get(
		ctx context.Context,
		id string) (
		*NodeGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		NodeIterator,
		error)
}

// Create registers a new Node.
func (svc *Nodes) Create(
	ctx context.Context,
	node Node) (
	*NodeCreateResponse,
	error) {
	req := &plumbing.NodeCreateRequest{}

	req.Node = convertNodeToPlumbing(node)
	var plumbingResponse *plumbing.NodeCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "Nodes.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &NodeCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertNodeToPorcelain(plumbingResponse.Node); err != nil {
		return nil, err
	} else {
		resp.Node = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	resp.Token = (plumbingResponse.Token)
	return resp, nil
}

// Get reads one Node by ID.
func (svc *Nodes) Get(
	ctx context.Context,
	id string) (
	*NodeGetResponse,
	error) {
	req := &plumbing.NodeGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.NodeGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "Nodes.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &NodeGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertNodeToPorcelain(plumbingResponse.Node); err != nil {
		return nil, err
	} else {
		resp.Node = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Update replaces all the fields of a Node by ID.
func (svc *Nodes) Update(
	ctx context.Context,
	node Node) (
	*NodeUpdateResponse,
	error) {
	req := &plumbing.NodeUpdateRequest{}

	req.Node = convertNodeToPlumbing(node)
	var plumbingResponse *plumbing.NodeUpdateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Update(svc.parent.wrapContext(ctx, req, "Nodes.Update"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &NodeUpdateResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertNodeToPorcelain(plumbingResponse.Node); err != nil {
		return nil, err
	} else {
		resp.Node = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete removes a Node by ID.
func (svc *Nodes) Delete(
	ctx context.Context,
	id string) (
	*NodeDeleteResponse,
	error) {
	req := &plumbing.NodeDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.NodeDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "Nodes.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &NodeDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of Nodes matching a given set of criteria.
func (svc *Nodes) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	NodeIterator,
	error) {
	req := &plumbing.NodeListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newNodeIteratorImpl(
		func() (
			[]Node,
			bool, error) {
			var plumbingResponse *plumbing.NodeListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "Nodes.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedNodeToPorcelain(plumbingResponse.Nodes)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// NodesHistory records all changes to the state of a Node.
type NodesHistory struct {
	client plumbing.NodesHistoryClient
	parent *Client
}

// List gets a list of NodeHistory records matching a given set of criteria.
func (svc *NodesHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	NodeHistoryIterator,
	error) {
	req := &plumbing.NodeHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newNodeHistoryIteratorImpl(
		func() (
			[]*NodeHistory,
			bool, error) {
			var plumbingResponse *plumbing.NodeHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "NodesHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedNodeHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// OrganizationHistory records all changes to the state of an Organization.
type OrganizationHistory struct {
	client plumbing.OrganizationHistoryClient
	parent *Client
}

// List gets a list of OrganizationHistory records matching a given set of criteria.
func (svc *OrganizationHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	OrganizationHistoryRecordIterator,
	error) {
	req := &plumbing.OrganizationHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newOrganizationHistoryRecordIteratorImpl(
		func() (
			[]*OrganizationHistoryRecord,
			bool, error) {
			var plumbingResponse *plumbing.OrganizationHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "OrganizationHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedOrganizationHistoryRecordToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// PeeringGroupNodes provides the building blocks necessary to obtain attach a node to a peering group.
type PeeringGroupNodes struct {
	client plumbing.PeeringGroupNodesClient
	parent *Client
}

// A SnapshotPeeringGroupNodes exposes the read only methods of the PeeringGroupNodes
// service for historical queries.
type SnapshotPeeringGroupNodes interface {
	Get(
		ctx context.Context,
		id string) (
		*PeeringGroupNodeGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		PeeringGroupNodeIterator,
		error)
}

// Create attaches a Node to a PeeringGroup
func (svc *PeeringGroupNodes) Create(
	ctx context.Context,
	peeringGroupNode *PeeringGroupNode) (
	*PeeringGroupNodeCreateResponse,
	error) {
	req := &plumbing.PeeringGroupNodeCreateRequest{}

	req.PeeringGroupNode = convertPeeringGroupNodeToPlumbing(peeringGroupNode)
	var plumbingResponse *plumbing.PeeringGroupNodeCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "PeeringGroupNodes.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PeeringGroupNodeCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPeeringGroupNodeToPorcelain(plumbingResponse.PeeringGroupNode); err != nil {
		return nil, err
	} else {
		resp.PeeringGroupNode = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete detaches a Node to a PeeringGroup.
func (svc *PeeringGroupNodes) Delete(
	ctx context.Context,
	id string) (
	*PeeringGroupNodeDeleteResponse,
	error) {
	req := &plumbing.PeeringGroupNodeDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.PeeringGroupNodeDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "PeeringGroupNodes.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PeeringGroupNodeDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads the information of one peering group to node attachment.
func (svc *PeeringGroupNodes) Get(
	ctx context.Context,
	id string) (
	*PeeringGroupNodeGetResponse,
	error) {
	req := &plumbing.PeeringGroupNodeGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.PeeringGroupNodeGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "PeeringGroupNodes.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PeeringGroupNodeGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPeeringGroupNodeToPorcelain(plumbingResponse.PeeringGroupNode); err != nil {
		return nil, err
	} else {
		resp.PeeringGroupNode = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of peering group node attachments.
func (svc *PeeringGroupNodes) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	PeeringGroupNodeIterator,
	error) {
	req := &plumbing.PeeringGroupNodeListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newPeeringGroupNodeIteratorImpl(
		func() (
			[]*PeeringGroupNode,
			bool, error) {
			var plumbingResponse *plumbing.PeeringGroupNodeListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "PeeringGroupNodes.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedPeeringGroupNodeToPorcelain(plumbingResponse.PeeringGroupNodes)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// PeeringGroupPeers provides the building blocks necessary to link two peering groups.
type PeeringGroupPeers struct {
	client plumbing.PeeringGroupPeersClient
	parent *Client
}

// A SnapshotPeeringGroupPeers exposes the read only methods of the PeeringGroupPeers
// service for historical queries.
type SnapshotPeeringGroupPeers interface {
	Get(
		ctx context.Context,
		id string) (
		*PeeringGroupPeerGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		PeeringGroupPeerIterator,
		error)
}

// Create links two peering groups.
func (svc *PeeringGroupPeers) Create(
	ctx context.Context,
	peeringGroupPeer *PeeringGroupPeer) (
	*PeeringGroupPeerCreateResponse,
	error) {
	req := &plumbing.PeeringGroupPeerCreateRequest{}

	req.PeeringGroupPeer = convertPeeringGroupPeerToPlumbing(peeringGroupPeer)
	var plumbingResponse *plumbing.PeeringGroupPeerCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "PeeringGroupPeers.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PeeringGroupPeerCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPeeringGroupPeerToPorcelain(plumbingResponse.PeeringGroupPeer); err != nil {
		return nil, err
	} else {
		resp.PeeringGroupPeer = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete unlinks two peering groups.
func (svc *PeeringGroupPeers) Delete(
	ctx context.Context,
	id string) (
	*PeeringGroupPeerDeleteResponse,
	error) {
	req := &plumbing.PeeringGroupPeerDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.PeeringGroupPeerDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "PeeringGroupPeers.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PeeringGroupPeerDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads the information of one peering group link.
func (svc *PeeringGroupPeers) Get(
	ctx context.Context,
	id string) (
	*PeeringGroupPeerGetResponse,
	error) {
	req := &plumbing.PeeringGroupPeerGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.PeeringGroupPeerGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "PeeringGroupPeers.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PeeringGroupPeerGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPeeringGroupPeerToPorcelain(plumbingResponse.PeeringGroupPeer); err != nil {
		return nil, err
	} else {
		resp.PeeringGroupPeer = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of peering group links.
func (svc *PeeringGroupPeers) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	PeeringGroupPeerIterator,
	error) {
	req := &plumbing.PeeringGroupPeerListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newPeeringGroupPeerIteratorImpl(
		func() (
			[]*PeeringGroupPeer,
			bool, error) {
			var plumbingResponse *plumbing.PeeringGroupPeerListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "PeeringGroupPeers.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedPeeringGroupPeerToPorcelain(plumbingResponse.PeeringGroupPeers)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// PeeringGroupResources provides the building blocks necessary to obtain attach a resource to a peering group.
type PeeringGroupResources struct {
	client plumbing.PeeringGroupResourcesClient
	parent *Client
}

// A SnapshotPeeringGroupResources exposes the read only methods of the PeeringGroupResources
// service for historical queries.
type SnapshotPeeringGroupResources interface {
	Get(
		ctx context.Context,
		id string) (
		*PeeringGroupResourceGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		PeeringGroupResourceIterator,
		error)
}

// Create attaches a Resource to a PeeringGroup
func (svc *PeeringGroupResources) Create(
	ctx context.Context,
	peeringGroupResource *PeeringGroupResource) (
	*PeeringGroupResourceCreateResponse,
	error) {
	req := &plumbing.PeeringGroupResourceCreateRequest{}

	req.PeeringGroupResource = convertPeeringGroupResourceToPlumbing(peeringGroupResource)
	var plumbingResponse *plumbing.PeeringGroupResourceCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "PeeringGroupResources.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PeeringGroupResourceCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPeeringGroupResourceToPorcelain(plumbingResponse.PeeringGroupResource); err != nil {
		return nil, err
	} else {
		resp.PeeringGroupResource = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete detaches a Resource to a PeeringGroup
func (svc *PeeringGroupResources) Delete(
	ctx context.Context,
	id string) (
	*PeeringGroupResourceDeleteResponse,
	error) {
	req := &plumbing.PeeringGroupResourceDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.PeeringGroupResourceDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "PeeringGroupResources.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PeeringGroupResourceDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads the information of one peering group to resource attachment.
func (svc *PeeringGroupResources) Get(
	ctx context.Context,
	id string) (
	*PeeringGroupResourceGetResponse,
	error) {
	req := &plumbing.PeeringGroupResourceGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.PeeringGroupResourceGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "PeeringGroupResources.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PeeringGroupResourceGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPeeringGroupResourceToPorcelain(plumbingResponse.PeeringGroupResource); err != nil {
		return nil, err
	} else {
		resp.PeeringGroupResource = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of peering group resource attachments.
func (svc *PeeringGroupResources) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	PeeringGroupResourceIterator,
	error) {
	req := &plumbing.PeeringGroupResourceListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newPeeringGroupResourceIteratorImpl(
		func() (
			[]*PeeringGroupResource,
			bool, error) {
			var plumbingResponse *plumbing.PeeringGroupResourceListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "PeeringGroupResources.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedPeeringGroupResourceToPorcelain(plumbingResponse.PeeringGroupResources)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// PeeringGroups provides the building blocks necessary to obtain explicit network topology and routing.
type PeeringGroups struct {
	client plumbing.PeeringGroupsClient
	parent *Client
}

// A SnapshotPeeringGroups exposes the read only methods of the PeeringGroups
// service for historical queries.
type SnapshotPeeringGroups interface {
	Get(
		ctx context.Context,
		id string) (
		*PeeringGroupGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		PeeringGroupIterator,
		error)
}

// Create registers a new PeeringGroup.
func (svc *PeeringGroups) Create(
	ctx context.Context,
	peeringGroup *PeeringGroup) (
	*PeeringGroupCreateResponse,
	error) {
	req := &plumbing.PeeringGroupCreateRequest{}

	req.PeeringGroup = convertPeeringGroupToPlumbing(peeringGroup)
	var plumbingResponse *plumbing.PeeringGroupCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "PeeringGroups.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PeeringGroupCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPeeringGroupToPorcelain(plumbingResponse.PeeringGroup); err != nil {
		return nil, err
	} else {
		resp.PeeringGroup = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete removes a PeeringGroup by ID.
func (svc *PeeringGroups) Delete(
	ctx context.Context,
	id string) (
	*PeeringGroupDeleteResponse,
	error) {
	req := &plumbing.PeeringGroupDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.PeeringGroupDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "PeeringGroups.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PeeringGroupDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads one PeeringGroup by ID. It will load all its dependencies.
func (svc *PeeringGroups) Get(
	ctx context.Context,
	id string) (
	*PeeringGroupGetResponse,
	error) {
	req := &plumbing.PeeringGroupGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.PeeringGroupGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "PeeringGroups.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &PeeringGroupGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPeeringGroupToPorcelain(plumbingResponse.PeeringGroup); err != nil {
		return nil, err
	} else {
		resp.PeeringGroup = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of Peering Groups.
func (svc *PeeringGroups) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	PeeringGroupIterator,
	error) {
	req := &plumbing.PeeringGroupListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newPeeringGroupIteratorImpl(
		func() (
			[]*PeeringGroup,
			bool, error) {
			var plumbingResponse *plumbing.PeeringGroupListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "PeeringGroups.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedPeeringGroupToPorcelain(plumbingResponse.PeeringGroups)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// A Query is a record of a single client request to a resource, such as a SQL query.
// Long-running SSH, RDP, or Kubernetes interactive sessions also count as queries.
// The Queries service is read-only.
type Queries struct {
	client plumbing.QueriesClient
	parent *Client
}

// List gets a list of Queries matching a given set of criteria.
func (svc *Queries) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	QueryIterator,
	error) {
	req := &plumbing.QueryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newQueryIteratorImpl(
		func() (
			[]*Query,
			bool, error) {
			var plumbingResponse *plumbing.QueryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "Queries.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedQueryToPorcelain(plumbingResponse.Queries)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// RemoteIdentities assign a resource directly to an account, giving the account the permission to connect to that resource.
type RemoteIdentities struct {
	client plumbing.RemoteIdentitiesClient
	parent *Client
}

// A SnapshotRemoteIdentities exposes the read only methods of the RemoteIdentities
// service for historical queries.
type SnapshotRemoteIdentities interface {
	Get(
		ctx context.Context,
		id string) (
		*RemoteIdentityGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		RemoteIdentityIterator,
		error)
}

// Create registers a new RemoteIdentity.
func (svc *RemoteIdentities) Create(
	ctx context.Context,
	remoteIdentity *RemoteIdentity) (
	*RemoteIdentityCreateResponse,
	error) {
	req := &plumbing.RemoteIdentityCreateRequest{}

	req.RemoteIdentity = convertRemoteIdentityToPlumbing(remoteIdentity)
	var plumbingResponse *plumbing.RemoteIdentityCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "RemoteIdentities.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &RemoteIdentityCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertRemoteIdentityToPorcelain(plumbingResponse.RemoteIdentity); err != nil {
		return nil, err
	} else {
		resp.RemoteIdentity = v
	}
	return resp, nil
}

// Get reads one RemoteIdentity by ID.
func (svc *RemoteIdentities) Get(
	ctx context.Context,
	id string) (
	*RemoteIdentityGetResponse,
	error) {
	req := &plumbing.RemoteIdentityGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.RemoteIdentityGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "RemoteIdentities.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &RemoteIdentityGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertRemoteIdentityToPorcelain(plumbingResponse.RemoteIdentity); err != nil {
		return nil, err
	} else {
		resp.RemoteIdentity = v
	}
	return resp, nil
}

// Update replaces all the fields of a RemoteIdentity by ID.
func (svc *RemoteIdentities) Update(
	ctx context.Context,
	remoteIdentity *RemoteIdentity) (
	*RemoteIdentityUpdateResponse,
	error) {
	req := &plumbing.RemoteIdentityUpdateRequest{}

	req.RemoteIdentity = convertRemoteIdentityToPlumbing(remoteIdentity)
	var plumbingResponse *plumbing.RemoteIdentityUpdateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Update(svc.parent.wrapContext(ctx, req, "RemoteIdentities.Update"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &RemoteIdentityUpdateResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertRemoteIdentityToPorcelain(plumbingResponse.RemoteIdentity); err != nil {
		return nil, err
	} else {
		resp.RemoteIdentity = v
	}
	return resp, nil
}

// Delete removes a RemoteIdentity by ID.
func (svc *RemoteIdentities) Delete(
	ctx context.Context,
	id string) (
	*RemoteIdentityDeleteResponse,
	error) {
	req := &plumbing.RemoteIdentityDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.RemoteIdentityDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "RemoteIdentities.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &RemoteIdentityDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of RemoteIdentities matching a given set of criteria.
func (svc *RemoteIdentities) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	RemoteIdentityIterator,
	error) {
	req := &plumbing.RemoteIdentityListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newRemoteIdentityIteratorImpl(
		func() (
			[]*RemoteIdentity,
			bool, error) {
			var plumbingResponse *plumbing.RemoteIdentityListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "RemoteIdentities.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedRemoteIdentityToPorcelain(plumbingResponse.RemoteIdentities)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// RemoteIdentitiesHistory records all changes to the state of a RemoteIdentity.
type RemoteIdentitiesHistory struct {
	client plumbing.RemoteIdentitiesHistoryClient
	parent *Client
}

// List gets a list of RemoteIdentityHistory records matching a given set of criteria.
func (svc *RemoteIdentitiesHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	RemoteIdentityHistoryIterator,
	error) {
	req := &plumbing.RemoteIdentityHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newRemoteIdentityHistoryIteratorImpl(
		func() (
			[]*RemoteIdentityHistory,
			bool, error) {
			var plumbingResponse *plumbing.RemoteIdentityHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "RemoteIdentitiesHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedRemoteIdentityHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// A RemoteIdentityGroup is a named grouping of Remote Identities for Accounts.
// An Account's relationship to a RemoteIdentityGroup is defined via RemoteIdentity objects.
type RemoteIdentityGroups struct {
	client plumbing.RemoteIdentityGroupsClient
	parent *Client
}

// A SnapshotRemoteIdentityGroups exposes the read only methods of the RemoteIdentityGroups
// service for historical queries.
type SnapshotRemoteIdentityGroups interface {
	Get(
		ctx context.Context,
		id string) (
		*RemoteIdentityGroupGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		RemoteIdentityGroupIterator,
		error)
}

// Get reads one RemoteIdentityGroup by ID.
func (svc *RemoteIdentityGroups) Get(
	ctx context.Context,
	id string) (
	*RemoteIdentityGroupGetResponse,
	error) {
	req := &plumbing.RemoteIdentityGroupGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.RemoteIdentityGroupGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "RemoteIdentityGroups.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &RemoteIdentityGroupGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertRemoteIdentityGroupToPorcelain(plumbingResponse.RemoteIdentityGroup); err != nil {
		return nil, err
	} else {
		resp.RemoteIdentityGroup = v
	}
	return resp, nil
}

// List gets a list of RemoteIdentityGroups matching a given set of criteria.
func (svc *RemoteIdentityGroups) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	RemoteIdentityGroupIterator,
	error) {
	req := &plumbing.RemoteIdentityGroupListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newRemoteIdentityGroupIteratorImpl(
		func() (
			[]*RemoteIdentityGroup,
			bool, error) {
			var plumbingResponse *plumbing.RemoteIdentityGroupListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "RemoteIdentityGroups.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedRemoteIdentityGroupToPorcelain(plumbingResponse.RemoteIdentityGroups)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// RemoteIdentityGroupsHistory records all changes to the state of a RemoteIdentityGroup.
type RemoteIdentityGroupsHistory struct {
	client plumbing.RemoteIdentityGroupsHistoryClient
	parent *Client
}

// List gets a list of RemoteIdentityGroupHistory records matching a given set of criteria.
func (svc *RemoteIdentityGroupsHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	RemoteIdentityGroupHistoryIterator,
	error) {
	req := &plumbing.RemoteIdentityGroupHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newRemoteIdentityGroupHistoryIteratorImpl(
		func() (
			[]*RemoteIdentityGroupHistory,
			bool, error) {
			var plumbingResponse *plumbing.RemoteIdentityGroupHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "RemoteIdentityGroupsHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedRemoteIdentityGroupHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// A Replay captures the data transferred over a long-running SSH, RDP, or Kubernetes interactive session
// (otherwise referred to as a query). The Replays service is read-only.
type Replays struct {
	client plumbing.ReplaysClient
	parent *Client
}

// List gets a list of ReplayChunks for the Query ID specified by the filter criteria.
func (svc *Replays) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ReplayChunkIterator,
	error) {
	req := &plumbing.ReplayListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newReplayChunkIteratorImpl(
		func() (
			[]*ReplayChunk,
			bool, error) {
			var plumbingResponse *plumbing.ReplayListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "Replays.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedReplayChunkToPorcelain(plumbingResponse.Chunks)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// Resources are databases, servers, clusters, websites, or clouds that strongDM
// delegates access to.
type Resources struct {
	client plumbing.ResourcesClient
	parent *Client
}

// A SnapshotResources exposes the read only methods of the Resources
// service for historical queries.
type SnapshotResources interface {
	Get(
		ctx context.Context,
		id string) (
		*ResourceGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		ResourceIterator,
		error)
}

// EnumerateTags gets a list of the filter matching tags.
func (svc *Resources) EnumerateTags(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	TagIterator,
	error) {
	req := &plumbing.EnumerateTagsRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newTagIteratorImpl(
		func() (
			[]*Tag,
			bool, error) {
			var plumbingResponse *plumbing.EnumerateTagsResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.EnumerateTags(svc.parent.wrapContext(ctx, req, "Resources.EnumerateTags"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedTagToPorcelain(plumbingResponse.Matches)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// Create registers a new Resource.
func (svc *Resources) Create(
	ctx context.Context,
	resource Resource) (
	*ResourceCreateResponse,
	error) {
	req := &plumbing.ResourceCreateRequest{}

	req.Resource = convertResourceToPlumbing(resource)
	var plumbingResponse *plumbing.ResourceCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "Resources.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ResourceCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertResourceToPorcelain(plumbingResponse.Resource); err != nil {
		return nil, err
	} else {
		resp.Resource = v
	}
	return resp, nil
}

// Get reads one Resource by ID.
func (svc *Resources) Get(
	ctx context.Context,
	id string) (
	*ResourceGetResponse,
	error) {
	req := &plumbing.ResourceGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.ResourceGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "Resources.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ResourceGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertResourceToPorcelain(plumbingResponse.Resource); err != nil {
		return nil, err
	} else {
		resp.Resource = v
	}
	return resp, nil
}

// Update replaces all the fields of a Resource by ID.
func (svc *Resources) Update(
	ctx context.Context,
	resource Resource) (
	*ResourceUpdateResponse,
	error) {
	req := &plumbing.ResourceUpdateRequest{}

	req.Resource = convertResourceToPlumbing(resource)
	var plumbingResponse *plumbing.ResourceUpdateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Update(svc.parent.wrapContext(ctx, req, "Resources.Update"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ResourceUpdateResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertResourceToPorcelain(plumbingResponse.Resource); err != nil {
		return nil, err
	} else {
		resp.Resource = v
	}
	return resp, nil
}

// Delete removes a Resource by ID.
func (svc *Resources) Delete(
	ctx context.Context,
	id string) (
	*ResourceDeleteResponse,
	error) {
	req := &plumbing.ResourceDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.ResourceDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "Resources.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &ResourceDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of Resources matching a given set of criteria.
func (svc *Resources) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ResourceIterator,
	error) {
	req := &plumbing.ResourceListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newResourceIteratorImpl(
		func() (
			[]Resource,
			bool, error) {
			var plumbingResponse *plumbing.ResourceListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "Resources.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedResourceToPorcelain(plumbingResponse.Resources)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// ResourcesHistory records all changes to the state of a Resource.
type ResourcesHistory struct {
	client plumbing.ResourcesHistoryClient
	parent *Client
}

// List gets a list of ResourceHistory records matching a given set of criteria.
func (svc *ResourcesHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ResourceHistoryIterator,
	error) {
	req := &plumbing.ResourceHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newResourceHistoryIteratorImpl(
		func() (
			[]*ResourceHistory,
			bool, error) {
			var plumbingResponse *plumbing.ResourceHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "ResourcesHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedResourceHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// RoleResources enumerates the resources to which roles have access.
// The RoleResources service is read-only.
type RoleResources struct {
	client plumbing.RoleResourcesClient
	parent *Client
}

// A SnapshotRoleResources exposes the read only methods of the RoleResources
// service for historical queries.
type SnapshotRoleResources interface {
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		RoleResourceIterator,
		error)
}

// List gets a list of RoleResource records matching a given set of criteria.
func (svc *RoleResources) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	RoleResourceIterator,
	error) {
	req := &plumbing.RoleResourceListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newRoleResourceIteratorImpl(
		func() (
			[]*RoleResource,
			bool, error) {
			var plumbingResponse *plumbing.RoleResourceListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "RoleResources.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedRoleResourceToPorcelain(plumbingResponse.RoleResources)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// RoleResourcesHistory records all changes to the state of a RoleResource.
type RoleResourcesHistory struct {
	client plumbing.RoleResourcesHistoryClient
	parent *Client
}

// List gets a list of RoleResourceHistory records matching a given set of criteria.
func (svc *RoleResourcesHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	RoleResourceHistoryIterator,
	error) {
	req := &plumbing.RoleResourceHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newRoleResourceHistoryIteratorImpl(
		func() (
			[]*RoleResourceHistory,
			bool, error) {
			var plumbingResponse *plumbing.RoleResourceHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "RoleResourcesHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedRoleResourceHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// A Role has a list of access rules which determine which Resources the members
// of the Role have access to. An Account can be a member of multiple Roles via
// AccountAttachments.
type Roles struct {
	client plumbing.RolesClient
	parent *Client
}

// A SnapshotRoles exposes the read only methods of the Roles
// service for historical queries.
type SnapshotRoles interface {
	Get(
		ctx context.Context,
		id string) (
		*RoleGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		RoleIterator,
		error)
}

// Create registers a new Role.
func (svc *Roles) Create(
	ctx context.Context,
	role *Role) (
	*RoleCreateResponse,
	error) {
	req := &plumbing.RoleCreateRequest{}

	req.Role = convertRoleToPlumbing(role)
	var plumbingResponse *plumbing.RoleCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "Roles.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &RoleCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertRoleToPorcelain(plumbingResponse.Role); err != nil {
		return nil, err
	} else {
		resp.Role = v
	}
	return resp, nil
}

// Get reads one Role by ID.
func (svc *Roles) Get(
	ctx context.Context,
	id string) (
	*RoleGetResponse,
	error) {
	req := &plumbing.RoleGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.RoleGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "Roles.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &RoleGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertRoleToPorcelain(plumbingResponse.Role); err != nil {
		return nil, err
	} else {
		resp.Role = v
	}
	return resp, nil
}

// Update replaces all the fields of a Role by ID.
func (svc *Roles) Update(
	ctx context.Context,
	role *Role) (
	*RoleUpdateResponse,
	error) {
	req := &plumbing.RoleUpdateRequest{}

	req.Role = convertRoleToPlumbing(role)
	var plumbingResponse *plumbing.RoleUpdateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Update(svc.parent.wrapContext(ctx, req, "Roles.Update"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &RoleUpdateResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertRoleToPorcelain(plumbingResponse.Role); err != nil {
		return nil, err
	} else {
		resp.Role = v
	}
	return resp, nil
}

// Delete removes a Role by ID.
func (svc *Roles) Delete(
	ctx context.Context,
	id string) (
	*RoleDeleteResponse,
	error) {
	req := &plumbing.RoleDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.RoleDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "Roles.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &RoleDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of Roles matching a given set of criteria.
func (svc *Roles) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	RoleIterator,
	error) {
	req := &plumbing.RoleListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newRoleIteratorImpl(
		func() (
			[]*Role,
			bool, error) {
			var plumbingResponse *plumbing.RoleListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "Roles.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedRoleToPorcelain(plumbingResponse.Roles)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// RolesHistory records all changes to the state of a Role.
type RolesHistory struct {
	client plumbing.RolesHistoryClient
	parent *Client
}

// List gets a list of RoleHistory records matching a given set of criteria.
func (svc *RolesHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	RoleHistoryIterator,
	error) {
	req := &plumbing.RoleHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newRoleHistoryIteratorImpl(
		func() (
			[]*RoleHistory,
			bool, error) {
			var plumbingResponse *plumbing.RoleHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "RolesHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedRoleHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// SecretStores are servers where resource secrets (passwords, keys) are stored.
type SecretStores struct {
	client plumbing.SecretStoresClient
	parent *Client
}

// A SnapshotSecretStores exposes the read only methods of the SecretStores
// service for historical queries.
type SnapshotSecretStores interface {
	Get(
		ctx context.Context,
		id string) (
		*SecretStoreGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		SecretStoreIterator,
		error)
}

func (svc *SecretStores) Create(
	ctx context.Context,
	secretStore SecretStore) (
	*SecretStoreCreateResponse,
	error) {
	req := &plumbing.SecretStoreCreateRequest{}

	req.SecretStore = convertSecretStoreToPlumbing(secretStore)
	var plumbingResponse *plumbing.SecretStoreCreateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Create(svc.parent.wrapContext(ctx, req, "SecretStores.Create"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &SecretStoreCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertSecretStoreToPorcelain(plumbingResponse.SecretStore); err != nil {
		return nil, err
	} else {
		resp.SecretStore = v
	}
	return resp, nil
}

// Get reads one SecretStore by ID.
func (svc *SecretStores) Get(
	ctx context.Context,
	id string) (
	*SecretStoreGetResponse,
	error) {
	req := &plumbing.SecretStoreGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	var plumbingResponse *plumbing.SecretStoreGetResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Get(svc.parent.wrapContext(ctx, req, "SecretStores.Get"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &SecretStoreGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertSecretStoreToPorcelain(plumbingResponse.SecretStore); err != nil {
		return nil, err
	} else {
		resp.SecretStore = v
	}
	return resp, nil
}

// Update replaces all the fields of a SecretStore by ID.
func (svc *SecretStores) Update(
	ctx context.Context,
	secretStore SecretStore) (
	*SecretStoreUpdateResponse,
	error) {
	req := &plumbing.SecretStoreUpdateRequest{}

	req.SecretStore = convertSecretStoreToPlumbing(secretStore)
	var plumbingResponse *plumbing.SecretStoreUpdateResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Update(svc.parent.wrapContext(ctx, req, "SecretStores.Update"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &SecretStoreUpdateResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertSecretStoreToPorcelain(plumbingResponse.SecretStore); err != nil {
		return nil, err
	} else {
		resp.SecretStore = v
	}
	return resp, nil
}

// Delete removes a SecretStore by ID.
func (svc *SecretStores) Delete(
	ctx context.Context,
	id string) (
	*SecretStoreDeleteResponse,
	error) {
	req := &plumbing.SecretStoreDeleteRequest{}

	req.Id = (id)
	var plumbingResponse *plumbing.SecretStoreDeleteResponse
	var err error
	i := 0
	for {
		plumbingResponse, err = svc.client.Delete(svc.parent.wrapContext(ctx, req, "SecretStores.Delete"), req)
		if err != nil {
			if !svc.parent.shouldRetry(i, err) {
				return nil, convertErrorToPorcelain(err)
			}
			i++
			svc.parent.jitterSleep(i)
			continue
		}
		break
	}

	resp := &SecretStoreDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of SecretStores matching a given set of criteria.
func (svc *SecretStores) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	SecretStoreIterator,
	error) {
	req := &plumbing.SecretStoreListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newSecretStoreIteratorImpl(
		func() (
			[]SecretStore,
			bool, error) {
			var plumbingResponse *plumbing.SecretStoreListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "SecretStores.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedSecretStoreToPorcelain(plumbingResponse.SecretStores)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// SecretStoresHistory records all changes to the state of a SecretStore.
type SecretStoresHistory struct {
	client plumbing.SecretStoresHistoryClient
	parent *Client
}

// List gets a list of SecretStoreHistory records matching a given set of criteria.
func (svc *SecretStoresHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	SecretStoreHistoryIterator,
	error) {
	req := &plumbing.SecretStoreHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newSecretStoreHistoryIteratorImpl(
		func() (
			[]*SecretStoreHistory,
			bool, error) {
			var plumbingResponse *plumbing.SecretStoreHistoryListResponse
			var err error
			i := 0
			for {
				plumbingResponse, err = svc.client.List(svc.parent.wrapContext(ctx, req, "SecretStoresHistory.List"), req)
				if err != nil {
					if !svc.parent.shouldRetry(i, err) {
						return nil, false, convertErrorToPorcelain(err)
					}
					i++
					svc.parent.jitterSleep(i)
					continue
				}
				break
			}
			result, err := convertRepeatedSecretStoreHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}
