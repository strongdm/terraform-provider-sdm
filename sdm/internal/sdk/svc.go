// Copyright 2020 StrongDM Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package sdm

// Code generated by protogen. DO NOT EDIT.

import (
	"context"

	plumbing "github.com/strongdm/terraform-provider-sdm/sdm/internal/sdk/v1"
)

// AccessRequests are requests for access to a resource that may match a Workflow.
type AccessRequests struct {
	client plumbing.AccessRequestsClient
	parent *Client
}

// A SnapshotAccessRequests exposes the read only methods of the AccessRequests
// service for historical queries.
type SnapshotAccessRequests interface {
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		AccessRequestIterator,
		error)
}

// Lists existing access requests.
func (svc *AccessRequests) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccessRequestIterator,
	error) {
	req := plumbing.AccessRequestListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccessRequestIteratorImpl(
		func() (
			[]*AccessRequest,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.AccessRequestListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "AccessRequests.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedAccessRequestToPorcelain(plumbingResponse.AccessRequests)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccessRequestEventsHistory provides records of all changes to the state of an AccessRequest.
type AccessRequestEventsHistory struct {
	client plumbing.AccessRequestEventsHistoryClient
	parent *Client
}

// List gets a list of AccessRequestEventHistory records matching a given set of criteria.
func (svc *AccessRequestEventsHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccessRequestEventHistoryIterator,
	error) {
	req := plumbing.AccessRequestEventHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccessRequestEventHistoryIteratorImpl(
		func() (
			[]*AccessRequestEventHistory,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.AccessRequestEventHistoryListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "AccessRequestEventsHistory.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedAccessRequestEventHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccessRequestsHistory provides records of all changes to the state of an AccessRequest.
type AccessRequestsHistory struct {
	client plumbing.AccessRequestsHistoryClient
	parent *Client
}

// List gets a list of AccessRequestHistory records matching a given set of criteria.
func (svc *AccessRequestsHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccessRequestHistoryIterator,
	error) {
	req := plumbing.AccessRequestHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccessRequestHistoryIteratorImpl(
		func() (
			[]*AccessRequestHistory,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.AccessRequestHistoryListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "AccessRequestsHistory.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedAccessRequestHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccountAttachments assign an account to a role.
type AccountAttachments struct {
	client plumbing.AccountAttachmentsClient
	parent *Client
}

// A SnapshotAccountAttachments exposes the read only methods of the AccountAttachments
// service for historical queries.
type SnapshotAccountAttachments interface {
	Get(
		ctx context.Context,
		id string) (
		*AccountAttachmentGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		AccountAttachmentIterator,
		error)
}

// Create registers a new AccountAttachment.
func (svc *AccountAttachments) Create(
	ctx context.Context,
	accountAttachment *AccountAttachment) (
	*AccountAttachmentCreateResponse,
	error) {
	req := plumbing.AccountAttachmentCreateRequest{}

	req.AccountAttachment = convertAccountAttachmentToPlumbing(accountAttachment)
	req.Meta = &plumbing.CreateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.AccountAttachmentCreateResponse, error) {
			return svc.client.Create(svc.parent.wrapContext(ctx, &req, "AccountAttachments.Create"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &AccountAttachmentCreateResponse{}
	if v, err := convertAccountAttachmentToPorcelain(plumbingResponse.AccountAttachment); err != nil {
		return nil, err
	} else {
		resp.AccountAttachment = v
	}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads one AccountAttachment by ID.
func (svc *AccountAttachments) Get(
	ctx context.Context,
	id string) (
	*AccountAttachmentGetResponse,
	error) {
	req := plumbing.AccountAttachmentGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.AccountAttachmentGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "AccountAttachments.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &AccountAttachmentGetResponse{}
	if v, err := convertAccountAttachmentToPorcelain(plumbingResponse.AccountAttachment); err != nil {
		return nil, err
	} else {
		resp.AccountAttachment = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete removes a AccountAttachment by ID.
func (svc *AccountAttachments) Delete(
	ctx context.Context,
	id string) (
	*AccountAttachmentDeleteResponse,
	error) {
	req := plumbing.AccountAttachmentDeleteRequest{}

	req.Id = (id)
	req.Meta = &plumbing.DeleteRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.AccountAttachmentDeleteResponse, error) {
			return svc.client.Delete(svc.parent.wrapContext(ctx, &req, "AccountAttachments.Delete"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &AccountAttachmentDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of AccountAttachments matching a given set of criteria.
func (svc *AccountAttachments) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountAttachmentIterator,
	error) {
	req := plumbing.AccountAttachmentListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountAttachmentIteratorImpl(
		func() (
			[]*AccountAttachment,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.AccountAttachmentListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "AccountAttachments.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedAccountAttachmentToPorcelain(plumbingResponse.AccountAttachments)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccountAttachmentsHistory records all changes to the state of an AccountAttachment.
type AccountAttachmentsHistory struct {
	client plumbing.AccountAttachmentsHistoryClient
	parent *Client
}

// List gets a list of AccountAttachmentHistory records matching a given set of criteria.
func (svc *AccountAttachmentsHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountAttachmentHistoryIterator,
	error) {
	req := plumbing.AccountAttachmentHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountAttachmentHistoryIteratorImpl(
		func() (
			[]*AccountAttachmentHistory,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.AccountAttachmentHistoryListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "AccountAttachmentsHistory.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedAccountAttachmentHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccountGrants assign a resource directly to an account, giving the account the permission to connect to that resource.
type AccountGrants struct {
	client plumbing.AccountGrantsClient
	parent *Client
}

// A SnapshotAccountGrants exposes the read only methods of the AccountGrants
// service for historical queries.
type SnapshotAccountGrants interface {
	Get(
		ctx context.Context,
		id string) (
		*AccountGrantGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		AccountGrantIterator,
		error)
}

// Create registers a new AccountGrant.
func (svc *AccountGrants) Create(
	ctx context.Context,
	accountGrant *AccountGrant) (
	*AccountGrantCreateResponse,
	error) {
	req := plumbing.AccountGrantCreateRequest{}

	req.AccountGrant = convertAccountGrantToPlumbing(accountGrant)
	req.Meta = &plumbing.CreateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.AccountGrantCreateResponse, error) {
			return svc.client.Create(svc.parent.wrapContext(ctx, &req, "AccountGrants.Create"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &AccountGrantCreateResponse{}
	if v, err := convertAccountGrantToPorcelain(plumbingResponse.AccountGrant); err != nil {
		return nil, err
	} else {
		resp.AccountGrant = v
	}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads one AccountGrant by ID.
func (svc *AccountGrants) Get(
	ctx context.Context,
	id string) (
	*AccountGrantGetResponse,
	error) {
	req := plumbing.AccountGrantGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.AccountGrantGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "AccountGrants.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &AccountGrantGetResponse{}
	if v, err := convertAccountGrantToPorcelain(plumbingResponse.AccountGrant); err != nil {
		return nil, err
	} else {
		resp.AccountGrant = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete removes a AccountGrant by ID.
func (svc *AccountGrants) Delete(
	ctx context.Context,
	id string) (
	*AccountGrantDeleteResponse,
	error) {
	req := plumbing.AccountGrantDeleteRequest{}

	req.Id = (id)
	req.Meta = &plumbing.DeleteRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.AccountGrantDeleteResponse, error) {
			return svc.client.Delete(svc.parent.wrapContext(ctx, &req, "AccountGrants.Delete"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &AccountGrantDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of AccountGrants matching a given set of criteria.
func (svc *AccountGrants) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountGrantIterator,
	error) {
	req := plumbing.AccountGrantListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountGrantIteratorImpl(
		func() (
			[]*AccountGrant,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.AccountGrantListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "AccountGrants.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedAccountGrantToPorcelain(plumbingResponse.AccountGrants)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccountGrantsHistory records all changes to the state of an AccountGrant.
type AccountGrantsHistory struct {
	client plumbing.AccountGrantsHistoryClient
	parent *Client
}

// List gets a list of AccountGrantHistory records matching a given set of criteria.
func (svc *AccountGrantsHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountGrantHistoryIterator,
	error) {
	req := plumbing.AccountGrantHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountGrantHistoryIteratorImpl(
		func() (
			[]*AccountGrantHistory,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.AccountGrantHistoryListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "AccountGrantsHistory.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedAccountGrantHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccountPermissions records the granular permissions accounts have, allowing them to execute
// relevant commands via StrongDM's APIs.
type AccountPermissions struct {
	client plumbing.AccountPermissionsClient
	parent *Client
}

// A SnapshotAccountPermissions exposes the read only methods of the AccountPermissions
// service for historical queries.
type SnapshotAccountPermissions interface {
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		AccountPermissionIterator,
		error)
}

// List gets a list of Permission records matching a given set of criteria.
func (svc *AccountPermissions) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountPermissionIterator,
	error) {
	req := plumbing.AccountPermissionListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountPermissionIteratorImpl(
		func() (
			[]*AccountPermission,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.AccountPermissionListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "AccountPermissions.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedAccountPermissionToPorcelain(plumbingResponse.Permissions)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccountResources enumerates the resources to which accounts have access.
// The AccountResources service is read-only.
type AccountResources struct {
	client plumbing.AccountResourcesClient
	parent *Client
}

// A SnapshotAccountResources exposes the read only methods of the AccountResources
// service for historical queries.
type SnapshotAccountResources interface {
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		AccountResourceIterator,
		error)
}

// List gets a list of AccountResource records matching a given set of criteria.
func (svc *AccountResources) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountResourceIterator,
	error) {
	req := plumbing.AccountResourceListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountResourceIteratorImpl(
		func() (
			[]*AccountResource,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.AccountResourceListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "AccountResources.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedAccountResourceToPorcelain(plumbingResponse.AccountResources)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccountResourcesHistory records all changes to the state of a AccountResource.
type AccountResourcesHistory struct {
	client plumbing.AccountResourcesHistoryClient
	parent *Client
}

// List gets a list of AccountResourceHistory records matching a given set of criteria.
func (svc *AccountResourcesHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountResourceHistoryIterator,
	error) {
	req := plumbing.AccountResourceHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountResourceHistoryIteratorImpl(
		func() (
			[]*AccountResourceHistory,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.AccountResourceHistoryListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "AccountResourcesHistory.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedAccountResourceHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// Accounts are users that have access to strongDM. There are two types of accounts:
// 1. **Users:** humans who are authenticated through username and password or SSO.
// 2. **Service Accounts:** machines that are authenticated using a service token.
// 3. **Tokens** are access keys with permissions that can be used for authentication.
type Accounts struct {
	client plumbing.AccountsClient
	parent *Client
}

// A SnapshotAccounts exposes the read only methods of the Accounts
// service for historical queries.
type SnapshotAccounts interface {
	Get(
		ctx context.Context,
		id string) (
		*AccountGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		AccountIterator,
		error)
}

// Create registers a new Account.
func (svc *Accounts) Create(
	ctx context.Context,
	account Account) (
	*AccountCreateResponse,
	error) {
	req := plumbing.AccountCreateRequest{}

	req.Account = convertAccountToPlumbing(account)
	req.Meta = &plumbing.CreateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.AccountCreateResponse, error) {
			return svc.client.Create(svc.parent.wrapContext(ctx, &req, "Accounts.Create"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &AccountCreateResponse{}
	resp.AccessKey = (plumbingResponse.AccessKey)
	if v, err := convertAccountToPorcelain(plumbingResponse.Account); err != nil {
		return nil, err
	} else {
		resp.Account = v
	}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	resp.SecretKey = (plumbingResponse.SecretKey)
	resp.Token = (plumbingResponse.Token)
	return resp, nil
}

// Get reads one Account by ID.
func (svc *Accounts) Get(
	ctx context.Context,
	id string) (
	*AccountGetResponse,
	error) {
	req := plumbing.AccountGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.AccountGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "Accounts.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &AccountGetResponse{}
	if v, err := convertAccountToPorcelain(plumbingResponse.Account); err != nil {
		return nil, err
	} else {
		resp.Account = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Update replaces all the fields of an Account by ID.
func (svc *Accounts) Update(
	ctx context.Context,
	account Account) (
	*AccountUpdateResponse,
	error) {
	req := plumbing.AccountUpdateRequest{}

	req.Account = convertAccountToPlumbing(account)
	req.Meta = &plumbing.UpdateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.AccountUpdateResponse, error) {
			return svc.client.Update(svc.parent.wrapContext(ctx, &req, "Accounts.Update"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &AccountUpdateResponse{}
	if v, err := convertAccountToPorcelain(plumbingResponse.Account); err != nil {
		return nil, err
	} else {
		resp.Account = v
	}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete removes an Account by ID.
func (svc *Accounts) Delete(
	ctx context.Context,
	id string) (
	*AccountDeleteResponse,
	error) {
	req := plumbing.AccountDeleteRequest{}

	req.Id = (id)
	req.Meta = &plumbing.DeleteRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.AccountDeleteResponse, error) {
			return svc.client.Delete(svc.parent.wrapContext(ctx, &req, "Accounts.Delete"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &AccountDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of Accounts matching a given set of criteria.
func (svc *Accounts) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountIterator,
	error) {
	req := plumbing.AccountListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountIteratorImpl(
		func() (
			[]Account,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.AccountListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "Accounts.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedAccountToPorcelain(plumbingResponse.Accounts)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// AccountsHistory records all changes to the state of an Account.
type AccountsHistory struct {
	client plumbing.AccountsHistoryClient
	parent *Client
}

// List gets a list of AccountHistory records matching a given set of criteria.
func (svc *AccountsHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	AccountHistoryIterator,
	error) {
	req := plumbing.AccountHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newAccountHistoryIteratorImpl(
		func() (
			[]*AccountHistory,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.AccountHistoryListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "AccountsHistory.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedAccountHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// An Activity is a record of an action taken against a strongDM deployment, e.g.
// a user creation, resource deletion, sso configuration change, etc. The Activities
// service is read-only.
type Activities struct {
	client plumbing.ActivitiesClient
	parent *Client
}

// Get reads one Activity by ID.
func (svc *Activities) Get(
	ctx context.Context,
	id string) (
	*ActivityGetResponse,
	error) {
	req := plumbing.ActivityGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ActivityGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "Activities.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ActivityGetResponse{}
	if v, err := convertActivityToPorcelain(plumbingResponse.Activity); err != nil {
		return nil, err
	} else {
		resp.Activity = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of Activities matching a given set of criteria.
// The 'before' and 'after' filters can be used to control the time
// range of the output activities. If not provided, one week of back
// of activities will be returned.
func (svc *Activities) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ActivityIterator,
	error) {
	req := plumbing.ActivityListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newActivityIteratorImpl(
		func() (
			[]*Activity,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.ActivityListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "Activities.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedActivityToPorcelain(plumbingResponse.Activities)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// ApprovalWorkflowApprovers link approval workflow approvers to an ApprovalWorkflowStep
type ApprovalWorkflowApprovers struct {
	client plumbing.ApprovalWorkflowApproversClient
	parent *Client
}

// A SnapshotApprovalWorkflowApprovers exposes the read only methods of the ApprovalWorkflowApprovers
// service for historical queries.
type SnapshotApprovalWorkflowApprovers interface {
	Get(
		ctx context.Context,
		id string) (
		*ApprovalWorkflowApproverGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		ApprovalWorkflowApproverIterator,
		error)
}

// Deprecated: Create creates a new approval workflow approver.
func (svc *ApprovalWorkflowApprovers) Create(
	ctx context.Context,
	approvalWorkflowApprover *ApprovalWorkflowApprover) (
	*ApprovalWorkflowApproverCreateResponse,
	error) {
	req := plumbing.ApprovalWorkflowApproverCreateRequest{}

	req.ApprovalWorkflowApprover = convertApprovalWorkflowApproverToPlumbing(approvalWorkflowApprover)
	req.Meta = &plumbing.CreateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ApprovalWorkflowApproverCreateResponse, error) {
			return svc.client.Create(svc.parent.wrapContext(ctx, &req, "ApprovalWorkflowApprovers.Create"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ApprovalWorkflowApproverCreateResponse{}
	if v, err := convertApprovalWorkflowApproverToPorcelain(plumbingResponse.ApprovalWorkflowApprover); err != nil {
		return nil, err
	} else {
		resp.ApprovalWorkflowApprover = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Deprecated: Get reads one approval workflow approver by ID.
func (svc *ApprovalWorkflowApprovers) Get(
	ctx context.Context,
	id string) (
	*ApprovalWorkflowApproverGetResponse,
	error) {
	req := plumbing.ApprovalWorkflowApproverGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ApprovalWorkflowApproverGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "ApprovalWorkflowApprovers.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ApprovalWorkflowApproverGetResponse{}
	if v, err := convertApprovalWorkflowApproverToPorcelain(plumbingResponse.ApprovalWorkflowApprover); err != nil {
		return nil, err
	} else {
		resp.ApprovalWorkflowApprover = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Deprecated: Delete deletes an existing approval workflow approver.
func (svc *ApprovalWorkflowApprovers) Delete(
	ctx context.Context,
	id string) (
	*ApprovalWorkflowApproverDeleteResponse,
	error) {
	req := plumbing.ApprovalWorkflowApproverDeleteRequest{}

	req.Id = (id)
	req.Meta = &plumbing.DeleteRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ApprovalWorkflowApproverDeleteResponse, error) {
			return svc.client.Delete(svc.parent.wrapContext(ctx, &req, "ApprovalWorkflowApprovers.Delete"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ApprovalWorkflowApproverDeleteResponse{}
	resp.ID = (plumbingResponse.Id)
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Deprecated: Lists existing approval workflow approvers.
func (svc *ApprovalWorkflowApprovers) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ApprovalWorkflowApproverIterator,
	error) {
	req := plumbing.ApprovalWorkflowApproverListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newApprovalWorkflowApproverIteratorImpl(
		func() (
			[]*ApprovalWorkflowApprover,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.ApprovalWorkflowApproverListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "ApprovalWorkflowApprovers.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedApprovalWorkflowApproverToPorcelain(plumbingResponse.ApprovalWorkflowApprovers)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// ApprovalWorkflowApproversHistory records all changes to the state of an ApprovalWorkflowApprover.
type ApprovalWorkflowApproversHistory struct {
	client plumbing.ApprovalWorkflowApproversHistoryClient
	parent *Client
}

// List gets a list of ApprovalWorkflowApproverHistory records matching a given set of criteria.
func (svc *ApprovalWorkflowApproversHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ApprovalWorkflowApproverHistoryIterator,
	error) {
	req := plumbing.ApprovalWorkflowApproverHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newApprovalWorkflowApproverHistoryIteratorImpl(
		func() (
			[]*ApprovalWorkflowApproverHistory,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.ApprovalWorkflowApproverHistoryListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "ApprovalWorkflowApproversHistory.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedApprovalWorkflowApproverHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// ApprovalWorkflowSteps link approval workflow steps to an ApprovalWorkflow
type ApprovalWorkflowSteps struct {
	client plumbing.ApprovalWorkflowStepsClient
	parent *Client
}

// A SnapshotApprovalWorkflowSteps exposes the read only methods of the ApprovalWorkflowSteps
// service for historical queries.
type SnapshotApprovalWorkflowSteps interface {
	Get(
		ctx context.Context,
		id string) (
		*ApprovalWorkflowStepGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		ApprovalWorkflowStepIterator,
		error)
}

// Deprecated: Create creates a new approval workflow step.
func (svc *ApprovalWorkflowSteps) Create(
	ctx context.Context,
	approvalWorkflowStep *ApprovalWorkflowStep) (
	*ApprovalWorkflowStepCreateResponse,
	error) {
	req := plumbing.ApprovalWorkflowStepCreateRequest{}

	req.ApprovalWorkflowStep = convertApprovalWorkflowStepToPlumbing(approvalWorkflowStep)
	req.Meta = &plumbing.CreateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ApprovalWorkflowStepCreateResponse, error) {
			return svc.client.Create(svc.parent.wrapContext(ctx, &req, "ApprovalWorkflowSteps.Create"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ApprovalWorkflowStepCreateResponse{}
	if v, err := convertApprovalWorkflowStepToPorcelain(plumbingResponse.ApprovalWorkflowStep); err != nil {
		return nil, err
	} else {
		resp.ApprovalWorkflowStep = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Deprecated: Get reads one approval workflow step by ID.
func (svc *ApprovalWorkflowSteps) Get(
	ctx context.Context,
	id string) (
	*ApprovalWorkflowStepGetResponse,
	error) {
	req := plumbing.ApprovalWorkflowStepGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ApprovalWorkflowStepGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "ApprovalWorkflowSteps.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ApprovalWorkflowStepGetResponse{}
	if v, err := convertApprovalWorkflowStepToPorcelain(plumbingResponse.ApprovalWorkflowStep); err != nil {
		return nil, err
	} else {
		resp.ApprovalWorkflowStep = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Deprecated: Delete deletes an existing approval workflow step.
func (svc *ApprovalWorkflowSteps) Delete(
	ctx context.Context,
	id string) (
	*ApprovalWorkflowStepDeleteResponse,
	error) {
	req := plumbing.ApprovalWorkflowStepDeleteRequest{}

	req.Id = (id)
	req.Meta = &plumbing.DeleteRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ApprovalWorkflowStepDeleteResponse, error) {
			return svc.client.Delete(svc.parent.wrapContext(ctx, &req, "ApprovalWorkflowSteps.Delete"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ApprovalWorkflowStepDeleteResponse{}
	resp.ID = (plumbingResponse.Id)
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Deprecated: Lists existing approval workflow steps.
func (svc *ApprovalWorkflowSteps) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ApprovalWorkflowStepIterator,
	error) {
	req := plumbing.ApprovalWorkflowStepListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newApprovalWorkflowStepIteratorImpl(
		func() (
			[]*ApprovalWorkflowStep,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.ApprovalWorkflowStepListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "ApprovalWorkflowSteps.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedApprovalWorkflowStepToPorcelain(plumbingResponse.ApprovalWorkflowSteps)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// ApprovalWorkflowStepsHistory records all changes to the state of an ApprovalWorkflowStep.
type ApprovalWorkflowStepsHistory struct {
	client plumbing.ApprovalWorkflowStepsHistoryClient
	parent *Client
}

// List gets a list of ApprovalWorkflowStepHistory records matching a given set of criteria.
func (svc *ApprovalWorkflowStepsHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ApprovalWorkflowStepHistoryIterator,
	error) {
	req := plumbing.ApprovalWorkflowStepHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newApprovalWorkflowStepHistoryIteratorImpl(
		func() (
			[]*ApprovalWorkflowStepHistory,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.ApprovalWorkflowStepHistoryListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "ApprovalWorkflowStepsHistory.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedApprovalWorkflowStepHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// ApprovalWorkflows are the mechanism by which requests for access can be viewed by authorized
// approvers and be approved or denied.
type ApprovalWorkflows struct {
	client plumbing.ApprovalWorkflowsClient
	parent *Client
}

// A SnapshotApprovalWorkflows exposes the read only methods of the ApprovalWorkflows
// service for historical queries.
type SnapshotApprovalWorkflows interface {
	Get(
		ctx context.Context,
		id string) (
		*ApprovalWorkflowGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		ApprovalWorkflowIterator,
		error)
}

// Create creates a new approval workflow and requires a name and approval mode for the approval workflow.
func (svc *ApprovalWorkflows) Create(
	ctx context.Context,
	approvalWorkflow *ApprovalWorkflow) (
	*ApprovalWorkflowCreateResponse,
	error) {
	req := plumbing.ApprovalWorkflowCreateRequest{}

	req.ApprovalWorkflow = convertApprovalWorkflowToPlumbing(approvalWorkflow)
	req.Meta = &plumbing.CreateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ApprovalWorkflowCreateResponse, error) {
			return svc.client.Create(svc.parent.wrapContext(ctx, &req, "ApprovalWorkflows.Create"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ApprovalWorkflowCreateResponse{}
	if v, err := convertApprovalWorkflowToPorcelain(plumbingResponse.ApprovalWorkflow); err != nil {
		return nil, err
	} else {
		resp.ApprovalWorkflow = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads one approval workflow by ID.
func (svc *ApprovalWorkflows) Get(
	ctx context.Context,
	id string) (
	*ApprovalWorkflowGetResponse,
	error) {
	req := plumbing.ApprovalWorkflowGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ApprovalWorkflowGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "ApprovalWorkflows.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ApprovalWorkflowGetResponse{}
	if v, err := convertApprovalWorkflowToPorcelain(plumbingResponse.ApprovalWorkflow); err != nil {
		return nil, err
	} else {
		resp.ApprovalWorkflow = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete deletes an existing approval workflow.
func (svc *ApprovalWorkflows) Delete(
	ctx context.Context,
	id string) (
	*ApprovalWorkflowDeleteResponse,
	error) {
	req := plumbing.ApprovalWorkflowDeleteRequest{}

	req.Id = (id)
	req.Meta = &plumbing.DeleteRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ApprovalWorkflowDeleteResponse, error) {
			return svc.client.Delete(svc.parent.wrapContext(ctx, &req, "ApprovalWorkflows.Delete"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ApprovalWorkflowDeleteResponse{}
	resp.ID = (plumbingResponse.Id)
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Update updates an existing approval workflow.
func (svc *ApprovalWorkflows) Update(
	ctx context.Context,
	approvalWorkflow *ApprovalWorkflow) (
	*ApprovalWorkflowUpdateResponse,
	error) {
	req := plumbing.ApprovalWorkflowUpdateRequest{}

	req.ApprovalWorkflow = convertApprovalWorkflowToPlumbing(approvalWorkflow)
	req.Meta = &plumbing.UpdateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ApprovalWorkflowUpdateResponse, error) {
			return svc.client.Update(svc.parent.wrapContext(ctx, &req, "ApprovalWorkflows.Update"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ApprovalWorkflowUpdateResponse{}
	if v, err := convertApprovalWorkflowToPorcelain(plumbingResponse.ApprovalWorkflow); err != nil {
		return nil, err
	} else {
		resp.ApprovalWorkflow = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Lists existing approval workflows.
func (svc *ApprovalWorkflows) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ApprovalWorkflowIterator,
	error) {
	req := plumbing.ApprovalWorkflowListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newApprovalWorkflowIteratorImpl(
		func() (
			[]*ApprovalWorkflow,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.ApprovalWorkflowListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "ApprovalWorkflows.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedApprovalWorkflowToPorcelain(plumbingResponse.ApprovalWorkflows)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// ApprovalWorkflowsHistory records all changes to the state of an ApprovalWorkflow.
type ApprovalWorkflowsHistory struct {
	client plumbing.ApprovalWorkflowsHistoryClient
	parent *Client
}

// List gets a list of ApprovalWorkflowHistory records matching a given set of criteria.
func (svc *ApprovalWorkflowsHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ApprovalWorkflowHistoryIterator,
	error) {
	req := plumbing.ApprovalWorkflowHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newApprovalWorkflowHistoryIteratorImpl(
		func() (
			[]*ApprovalWorkflowHistory,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.ApprovalWorkflowHistoryListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "ApprovalWorkflowsHistory.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedApprovalWorkflowHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// ControlPanel contains all administrative controls.
type ControlPanel struct {
	client plumbing.ControlPanelClient
	parent *Client
}

// GetSSHCAPublicKey retrieves the SSH CA public key.
func (svc *ControlPanel) GetSSHCAPublicKey(
	ctx context.Context) (
	*ControlPanelGetSSHCAPublicKeyResponse,
	error) {
	req := plumbing.ControlPanelGetSSHCAPublicKeyRequest{}

	req.Meta = &plumbing.GetRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ControlPanelGetSSHCAPublicKeyResponse, error) {
			return svc.client.GetSSHCAPublicKey(svc.parent.wrapContext(ctx, &req, "ControlPanel.GetSSHCAPublicKey"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ControlPanelGetSSHCAPublicKeyResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	resp.PublicKey = (plumbingResponse.PublicKey)
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// GetRDPCAPublicKey retrieves the RDP CA public key.
func (svc *ControlPanel) GetRDPCAPublicKey(
	ctx context.Context) (
	*ControlPanelGetRDPCAPublicKeyResponse,
	error) {
	req := plumbing.ControlPanelGetRDPCAPublicKeyRequest{}

	req.Meta = &plumbing.GetRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ControlPanelGetRDPCAPublicKeyResponse, error) {
			return svc.client.GetRDPCAPublicKey(svc.parent.wrapContext(ctx, &req, "ControlPanel.GetRDPCAPublicKey"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ControlPanelGetRDPCAPublicKeyResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	resp.PublicKey = (plumbingResponse.PublicKey)
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// VerifyJWT reports whether the given JWT token (x-sdm-token) is valid.
func (svc *ControlPanel) VerifyJWT(
	ctx context.Context,
	token string) (
	*ControlPanelVerifyJWTResponse,
	error) {
	req := plumbing.ControlPanelVerifyJWTRequest{}

	req.Token = (token)
	req.Meta = &plumbing.GetRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ControlPanelVerifyJWTResponse, error) {
			return svc.client.VerifyJWT(svc.parent.wrapContext(ctx, &req, "ControlPanel.VerifyJWT"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ControlPanelVerifyJWTResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	resp.ValID = (plumbingResponse.Valid)
	return resp, nil
}

// HealthChecks lists the last healthcheck between each node and resource.
// Note the unconventional capitalization here is to prevent having a collision with GRPC
type HealthChecks struct {
	client plumbing.HealthChecksClient
	parent *Client
}

// List gets a list of Healthchecks matching a given set of criteria.
func (svc *HealthChecks) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	HealthcheckIterator,
	error) {
	req := plumbing.HealthcheckListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newHealthcheckIteratorImpl(
		func() (
			[]*Healthcheck,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.HealthcheckListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "HealthChecks.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedHealthcheckToPorcelain(plumbingResponse.Healthchecks)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// IdentityAliases assign an alias to an account within an IdentitySet.
// The alias is used as the username when connecting to a identity supported resource.
type IdentityAliases struct {
	client plumbing.IdentityAliasesClient
	parent *Client
}

// A SnapshotIdentityAliases exposes the read only methods of the IdentityAliases
// service for historical queries.
type SnapshotIdentityAliases interface {
	Get(
		ctx context.Context,
		id string) (
		*IdentityAliasGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		IdentityAliasIterator,
		error)
}

// Create registers a new IdentityAlias.
func (svc *IdentityAliases) Create(
	ctx context.Context,
	identityAlias *IdentityAlias) (
	*IdentityAliasCreateResponse,
	error) {
	req := plumbing.IdentityAliasCreateRequest{}

	req.IdentityAlias = convertIdentityAliasToPlumbing(identityAlias)
	req.Meta = &plumbing.CreateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.IdentityAliasCreateResponse, error) {
			return svc.client.Create(svc.parent.wrapContext(ctx, &req, "IdentityAliases.Create"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &IdentityAliasCreateResponse{}
	if v, err := convertIdentityAliasToPorcelain(plumbingResponse.IdentityAlias); err != nil {
		return nil, err
	} else {
		resp.IdentityAlias = v
	}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads one IdentityAlias by ID.
func (svc *IdentityAliases) Get(
	ctx context.Context,
	id string) (
	*IdentityAliasGetResponse,
	error) {
	req := plumbing.IdentityAliasGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.IdentityAliasGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "IdentityAliases.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &IdentityAliasGetResponse{}
	if v, err := convertIdentityAliasToPorcelain(plumbingResponse.IdentityAlias); err != nil {
		return nil, err
	} else {
		resp.IdentityAlias = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Update replaces all the fields of a IdentityAlias by ID.
func (svc *IdentityAliases) Update(
	ctx context.Context,
	identityAlias *IdentityAlias) (
	*IdentityAliasUpdateResponse,
	error) {
	req := plumbing.IdentityAliasUpdateRequest{}

	req.IdentityAlias = convertIdentityAliasToPlumbing(identityAlias)
	req.Meta = &plumbing.UpdateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.IdentityAliasUpdateResponse, error) {
			return svc.client.Update(svc.parent.wrapContext(ctx, &req, "IdentityAliases.Update"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &IdentityAliasUpdateResponse{}
	if v, err := convertIdentityAliasToPorcelain(plumbingResponse.IdentityAlias); err != nil {
		return nil, err
	} else {
		resp.IdentityAlias = v
	}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete removes a IdentityAlias by ID.
func (svc *IdentityAliases) Delete(
	ctx context.Context,
	id string) (
	*IdentityAliasDeleteResponse,
	error) {
	req := plumbing.IdentityAliasDeleteRequest{}

	req.Id = (id)
	req.Meta = &plumbing.DeleteRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.IdentityAliasDeleteResponse, error) {
			return svc.client.Delete(svc.parent.wrapContext(ctx, &req, "IdentityAliases.Delete"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &IdentityAliasDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of IdentityAliases matching a given set of criteria.
func (svc *IdentityAliases) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	IdentityAliasIterator,
	error) {
	req := plumbing.IdentityAliasListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newIdentityAliasIteratorImpl(
		func() (
			[]*IdentityAlias,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.IdentityAliasListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "IdentityAliases.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedIdentityAliasToPorcelain(plumbingResponse.IdentityAliases)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// IdentityAliasesHistory records all changes to the state of a IdentityAlias.
type IdentityAliasesHistory struct {
	client plumbing.IdentityAliasesHistoryClient
	parent *Client
}

// List gets a list of IdentityAliasHistory records matching a given set of criteria.
func (svc *IdentityAliasesHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	IdentityAliasHistoryIterator,
	error) {
	req := plumbing.IdentityAliasHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newIdentityAliasHistoryIteratorImpl(
		func() (
			[]*IdentityAliasHistory,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.IdentityAliasHistoryListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "IdentityAliasesHistory.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedIdentityAliasHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// A IdentitySet is a named grouping of Identity Aliases for Accounts.
// An Account's relationship to a IdentitySet is defined via IdentityAlias objects.
type IdentitySets struct {
	client plumbing.IdentitySetsClient
	parent *Client
}

// A SnapshotIdentitySets exposes the read only methods of the IdentitySets
// service for historical queries.
type SnapshotIdentitySets interface {
	Get(
		ctx context.Context,
		id string) (
		*IdentitySetGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		IdentitySetIterator,
		error)
}

// Create registers a new IdentitySet.
func (svc *IdentitySets) Create(
	ctx context.Context,
	identitySet *IdentitySet) (
	*IdentitySetCreateResponse,
	error) {
	req := plumbing.IdentitySetCreateRequest{}

	req.IdentitySet = convertIdentitySetToPlumbing(identitySet)
	req.Meta = &plumbing.CreateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.IdentitySetCreateResponse, error) {
			return svc.client.Create(svc.parent.wrapContext(ctx, &req, "IdentitySets.Create"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &IdentitySetCreateResponse{}
	if v, err := convertIdentitySetToPorcelain(plumbingResponse.IdentitySet); err != nil {
		return nil, err
	} else {
		resp.IdentitySet = v
	}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads one IdentitySet by ID.
func (svc *IdentitySets) Get(
	ctx context.Context,
	id string) (
	*IdentitySetGetResponse,
	error) {
	req := plumbing.IdentitySetGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.IdentitySetGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "IdentitySets.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &IdentitySetGetResponse{}
	if v, err := convertIdentitySetToPorcelain(plumbingResponse.IdentitySet); err != nil {
		return nil, err
	} else {
		resp.IdentitySet = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Update replaces all the fields of a IdentitySet by ID.
func (svc *IdentitySets) Update(
	ctx context.Context,
	identitySet *IdentitySet) (
	*IdentitySetUpdateResponse,
	error) {
	req := plumbing.IdentitySetUpdateRequest{}

	req.IdentitySet = convertIdentitySetToPlumbing(identitySet)
	req.Meta = &plumbing.UpdateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.IdentitySetUpdateResponse, error) {
			return svc.client.Update(svc.parent.wrapContext(ctx, &req, "IdentitySets.Update"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &IdentitySetUpdateResponse{}
	if v, err := convertIdentitySetToPorcelain(plumbingResponse.IdentitySet); err != nil {
		return nil, err
	} else {
		resp.IdentitySet = v
	}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete removes a IdentitySet by ID.
func (svc *IdentitySets) Delete(
	ctx context.Context,
	id string) (
	*IdentitySetDeleteResponse,
	error) {
	req := plumbing.IdentitySetDeleteRequest{}

	req.Id = (id)
	req.Meta = &plumbing.DeleteRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.IdentitySetDeleteResponse, error) {
			return svc.client.Delete(svc.parent.wrapContext(ctx, &req, "IdentitySets.Delete"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &IdentitySetDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of IdentitySets matching a given set of criteria.
func (svc *IdentitySets) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	IdentitySetIterator,
	error) {
	req := plumbing.IdentitySetListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newIdentitySetIteratorImpl(
		func() (
			[]*IdentitySet,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.IdentitySetListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "IdentitySets.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedIdentitySetToPorcelain(plumbingResponse.IdentitySets)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// IdentitySetsHistory records all changes to the state of a IdentitySet.
type IdentitySetsHistory struct {
	client plumbing.IdentitySetsHistoryClient
	parent *Client
}

// List gets a list of IdentitySetHistory records matching a given set of criteria.
func (svc *IdentitySetsHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	IdentitySetHistoryIterator,
	error) {
	req := plumbing.IdentitySetHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newIdentitySetHistoryIteratorImpl(
		func() (
			[]*IdentitySetHistory,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.IdentitySetHistoryListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "IdentitySetsHistory.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedIdentitySetHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// ManagedSecret is a private vertical for creating, reading, updating,
// deleting, listing and rotating the managed secrets in the secrets engines as
// an authenticated user.
type ManagedSecrets struct {
	client plumbing.ManagedSecretsClient
	parent *Client
}

// List returns Managed Secrets from a Secret Engine.
func (svc *ManagedSecrets) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ManagedSecretIterator,
	error) {
	req := plumbing.ManagedSecretListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newManagedSecretIteratorImpl(
		func() (
			[]*ManagedSecret,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.ManagedSecretListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "ManagedSecrets.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedManagedSecretToPorcelain(plumbingResponse.ManagedSecrets)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// List returns Managed Secrets for an Actor from a Secret Engine.
func (svc *ManagedSecrets) ListByActor(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ManagedSecretIterator,
	error) {
	req := plumbing.ManagedSecretListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newManagedSecretIteratorImpl(
		func() (
			[]*ManagedSecret,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.ManagedSecretListResponse, error) {
					return svc.client.ListByActor(svc.parent.wrapContext(ctx, &req, "ManagedSecrets.ListByActor"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedManagedSecretToPorcelain(plumbingResponse.ManagedSecrets)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// Create creates a Managed Secret
func (svc *ManagedSecrets) Create(
	ctx context.Context,
	managedSecret *ManagedSecret) (
	*ManagedSecretCreateResponse,
	error) {
	req := plumbing.ManagedSecretCreateRequest{}

	req.ManagedSecret = convertManagedSecretToPlumbing(managedSecret)
	req.Meta = &plumbing.CreateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ManagedSecretCreateResponse, error) {
			return svc.client.Create(svc.parent.wrapContext(ctx, &req, "ManagedSecrets.Create"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ManagedSecretCreateResponse{}
	if v, err := convertManagedSecretToPorcelain(plumbingResponse.ManagedSecret); err != nil {
		return nil, err
	} else {
		resp.ManagedSecret = v
	}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Update updates a Managed Secret
func (svc *ManagedSecrets) Update(
	ctx context.Context,
	managedSecret *ManagedSecret) (
	*ManagedSecretUpdateResponse,
	error) {
	req := plumbing.ManagedSecretUpdateRequest{}

	req.ManagedSecret = convertManagedSecretToPlumbing(managedSecret)
	req.Meta = &plumbing.UpdateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ManagedSecretUpdateResponse, error) {
			return svc.client.Update(svc.parent.wrapContext(ctx, &req, "ManagedSecrets.Update"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ManagedSecretUpdateResponse{}
	if v, err := convertManagedSecretToPorcelain(plumbingResponse.ManagedSecret); err != nil {
		return nil, err
	} else {
		resp.ManagedSecret = v
	}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Rotate forces rotation of Managed Secret
func (svc *ManagedSecrets) Rotate(
	ctx context.Context,
	id string) (
	*ManagedSecretRotateResponse,
	error) {
	req := plumbing.ManagedSecretRotateRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GenericRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ManagedSecretRotateResponse, error) {
			return svc.client.Rotate(svc.parent.wrapContext(ctx, &req, "ManagedSecrets.Rotate"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ManagedSecretRotateResponse{}
	if v, err := convertGenericResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete deletes a Managed Secret
func (svc *ManagedSecrets) Delete(
	ctx context.Context,
	id string) (
	*ManagedSecretDeleteResponse,
	error) {
	req := plumbing.ManagedSecretDeleteRequest{}

	req.Id = (id)
	req.Meta = &plumbing.UpdateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ManagedSecretDeleteResponse, error) {
			return svc.client.Delete(svc.parent.wrapContext(ctx, &req, "ManagedSecrets.Delete"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ManagedSecretDeleteResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get gets details of a Managed Secret without sensitive data
func (svc *ManagedSecrets) Get(
	ctx context.Context,
	id string) (
	*ManagedSecretGetResponse,
	error) {
	req := plumbing.ManagedSecretGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ManagedSecretGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "ManagedSecrets.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ManagedSecretGetResponse{}
	if v, err := convertManagedSecretToPorcelain(plumbingResponse.ManagedSecret); err != nil {
		return nil, err
	} else {
		resp.ManagedSecret = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Retrieve returns Managed Secret with sensitive data
func (svc *ManagedSecrets) Retrieve(
	ctx context.Context,
	id string,
	publicKey []byte) (
	*ManagedSecretRetrieveResponse,
	error) {
	req := plumbing.ManagedSecretRetrieveRequest{}

	req.Id = (id)
	req.PublicKey = (publicKey)
	req.Meta = &plumbing.GetRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ManagedSecretRetrieveResponse, error) {
			return svc.client.Retrieve(svc.parent.wrapContext(ctx, &req, "ManagedSecrets.Retrieve"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ManagedSecretRetrieveResponse{}
	if v, err := convertManagedSecretToPorcelain(plumbingResponse.ManagedSecret); err != nil {
		return nil, err
	} else {
		resp.ManagedSecret = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Validate returns the result of testing the stored credential against the
// secret engine.
func (svc *ManagedSecrets) Validate(
	ctx context.Context,
	id string) (
	*ManagedSecretValidateResponse,
	error) {
	req := plumbing.ManagedSecretValidateRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ManagedSecretValidateResponse, error) {
			return svc.client.Validate(svc.parent.wrapContext(ctx, &req, "ManagedSecrets.Validate"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ManagedSecretValidateResponse{}
	resp.InvalidInfo = (plumbingResponse.InvalidInfo)
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	resp.ValID = (plumbingResponse.Valid)
	return resp, nil
}

// Logs returns the audit records for the managed secret. This may be replaced
// in the future.
func (svc *ManagedSecrets) Logs(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ManagedSecretLogIterator,
	error) {
	req := plumbing.ManagedSecretLogsRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newManagedSecretLogIteratorImpl(
		func() (
			[]*ManagedSecretLog,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.ManagedSecretLogsResponse, error) {
					return svc.client.Logs(svc.parent.wrapContext(ctx, &req, "ManagedSecrets.Logs"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedManagedSecretLogToPorcelain(plumbingResponse.ManagedSecretLogs)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// Nodes make up the strongDM network, and allow your users to connect securely to your resources. There are two types of nodes:
// - **Gateways** are the entry points into network. They listen for connection from the strongDM client, and provide access to databases and servers.
// - **Relays** are used to extend the strongDM network into segmented subnets. They provide access to databases and servers but do not listen for incoming connections.
type Nodes struct {
	client plumbing.NodesClient
	parent *Client
}

// A SnapshotNodes exposes the read only methods of the Nodes
// service for historical queries.
type SnapshotNodes interface {
	Get(
		ctx context.Context,
		id string) (
		*NodeGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		NodeIterator,
		error)
}

// Create registers a new Node.
func (svc *Nodes) Create(
	ctx context.Context,
	node Node) (
	*NodeCreateResponse,
	error) {
	req := plumbing.NodeCreateRequest{}

	req.Node = convertNodeToPlumbing(node)
	req.Meta = &plumbing.CreateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.NodeCreateResponse, error) {
			return svc.client.Create(svc.parent.wrapContext(ctx, &req, "Nodes.Create"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &NodeCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertNodeToPorcelain(plumbingResponse.Node); err != nil {
		return nil, err
	} else {
		resp.Node = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	resp.Token = (plumbingResponse.Token)
	return resp, nil
}

// Get reads one Node by ID.
func (svc *Nodes) Get(
	ctx context.Context,
	id string) (
	*NodeGetResponse,
	error) {
	req := plumbing.NodeGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.NodeGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "Nodes.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &NodeGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertNodeToPorcelain(plumbingResponse.Node); err != nil {
		return nil, err
	} else {
		resp.Node = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Update replaces all the fields of a Node by ID.
func (svc *Nodes) Update(
	ctx context.Context,
	node Node) (
	*NodeUpdateResponse,
	error) {
	req := plumbing.NodeUpdateRequest{}

	req.Node = convertNodeToPlumbing(node)
	req.Meta = &plumbing.UpdateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.NodeUpdateResponse, error) {
			return svc.client.Update(svc.parent.wrapContext(ctx, &req, "Nodes.Update"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &NodeUpdateResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertNodeToPorcelain(plumbingResponse.Node); err != nil {
		return nil, err
	} else {
		resp.Node = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete removes a Node by ID.
func (svc *Nodes) Delete(
	ctx context.Context,
	id string) (
	*NodeDeleteResponse,
	error) {
	req := plumbing.NodeDeleteRequest{}

	req.Id = (id)
	req.Meta = &plumbing.DeleteRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.NodeDeleteResponse, error) {
			return svc.client.Delete(svc.parent.wrapContext(ctx, &req, "Nodes.Delete"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &NodeDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of Nodes matching a given set of criteria.
func (svc *Nodes) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	NodeIterator,
	error) {
	req := plumbing.NodeListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newNodeIteratorImpl(
		func() (
			[]Node,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.NodeListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "Nodes.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedNodeToPorcelain(plumbingResponse.Nodes)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// NodesHistory records all changes to the state of a Node.
type NodesHistory struct {
	client plumbing.NodesHistoryClient
	parent *Client
}

// List gets a list of NodeHistory records matching a given set of criteria.
func (svc *NodesHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	NodeHistoryIterator,
	error) {
	req := plumbing.NodeHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newNodeHistoryIteratorImpl(
		func() (
			[]*NodeHistory,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.NodeHistoryListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "NodesHistory.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedNodeHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// OrganizationHistory records all changes to the state of an Organization.
type OrganizationHistory struct {
	client plumbing.OrganizationHistoryClient
	parent *Client
}

// List gets a list of OrganizationHistory records matching a given set of criteria.
func (svc *OrganizationHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	OrganizationHistoryRecordIterator,
	error) {
	req := plumbing.OrganizationHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newOrganizationHistoryRecordIteratorImpl(
		func() (
			[]*OrganizationHistoryRecord,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.OrganizationHistoryListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "OrganizationHistory.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedOrganizationHistoryRecordToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// PeeringGroupNodes provides the building blocks necessary to obtain attach a node to a peering group.
type PeeringGroupNodes struct {
	client plumbing.PeeringGroupNodesClient
	parent *Client
}

// Create attaches a Node to a PeeringGroup
func (svc *PeeringGroupNodes) Create(
	ctx context.Context,
	peeringGroupNode *PeeringGroupNode) (
	*PeeringGroupNodeCreateResponse,
	error) {
	req := plumbing.PeeringGroupNodeCreateRequest{}

	req.PeeringGroupNode = convertPeeringGroupNodeToPlumbing(peeringGroupNode)
	req.Meta = &plumbing.CreateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.PeeringGroupNodeCreateResponse, error) {
			return svc.client.Create(svc.parent.wrapContext(ctx, &req, "PeeringGroupNodes.Create"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &PeeringGroupNodeCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPeeringGroupNodeToPorcelain(plumbingResponse.PeeringGroupNode); err != nil {
		return nil, err
	} else {
		resp.PeeringGroupNode = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete detaches a Node to a PeeringGroup.
func (svc *PeeringGroupNodes) Delete(
	ctx context.Context,
	id string) (
	*PeeringGroupNodeDeleteResponse,
	error) {
	req := plumbing.PeeringGroupNodeDeleteRequest{}

	req.Id = (id)
	req.Meta = &plumbing.DeleteRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.PeeringGroupNodeDeleteResponse, error) {
			return svc.client.Delete(svc.parent.wrapContext(ctx, &req, "PeeringGroupNodes.Delete"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &PeeringGroupNodeDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads the information of one peering group to node attachment.
func (svc *PeeringGroupNodes) Get(
	ctx context.Context,
	id string) (
	*PeeringGroupNodeGetResponse,
	error) {
	req := plumbing.PeeringGroupNodeGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.PeeringGroupNodeGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "PeeringGroupNodes.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &PeeringGroupNodeGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPeeringGroupNodeToPorcelain(plumbingResponse.PeeringGroupNode); err != nil {
		return nil, err
	} else {
		resp.PeeringGroupNode = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of peering group node attachments.
func (svc *PeeringGroupNodes) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	PeeringGroupNodeIterator,
	error) {
	req := plumbing.PeeringGroupNodeListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newPeeringGroupNodeIteratorImpl(
		func() (
			[]*PeeringGroupNode,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.PeeringGroupNodeListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "PeeringGroupNodes.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedPeeringGroupNodeToPorcelain(plumbingResponse.PeeringGroupNodes)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// PeeringGroupPeers provides the building blocks necessary to link two peering groups.
type PeeringGroupPeers struct {
	client plumbing.PeeringGroupPeersClient
	parent *Client
}

// Create links two peering groups.
func (svc *PeeringGroupPeers) Create(
	ctx context.Context,
	peeringGroupPeer *PeeringGroupPeer) (
	*PeeringGroupPeerCreateResponse,
	error) {
	req := plumbing.PeeringGroupPeerCreateRequest{}

	req.PeeringGroupPeer = convertPeeringGroupPeerToPlumbing(peeringGroupPeer)
	req.Meta = &plumbing.CreateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.PeeringGroupPeerCreateResponse, error) {
			return svc.client.Create(svc.parent.wrapContext(ctx, &req, "PeeringGroupPeers.Create"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &PeeringGroupPeerCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPeeringGroupPeerToPorcelain(plumbingResponse.PeeringGroupPeer); err != nil {
		return nil, err
	} else {
		resp.PeeringGroupPeer = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete unlinks two peering groups.
func (svc *PeeringGroupPeers) Delete(
	ctx context.Context,
	id string) (
	*PeeringGroupPeerDeleteResponse,
	error) {
	req := plumbing.PeeringGroupPeerDeleteRequest{}

	req.Id = (id)
	req.Meta = &plumbing.DeleteRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.PeeringGroupPeerDeleteResponse, error) {
			return svc.client.Delete(svc.parent.wrapContext(ctx, &req, "PeeringGroupPeers.Delete"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &PeeringGroupPeerDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads the information of one peering group link.
func (svc *PeeringGroupPeers) Get(
	ctx context.Context,
	id string) (
	*PeeringGroupPeerGetResponse,
	error) {
	req := plumbing.PeeringGroupPeerGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.PeeringGroupPeerGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "PeeringGroupPeers.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &PeeringGroupPeerGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPeeringGroupPeerToPorcelain(plumbingResponse.PeeringGroupPeer); err != nil {
		return nil, err
	} else {
		resp.PeeringGroupPeer = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of peering group links.
func (svc *PeeringGroupPeers) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	PeeringGroupPeerIterator,
	error) {
	req := plumbing.PeeringGroupPeerListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newPeeringGroupPeerIteratorImpl(
		func() (
			[]*PeeringGroupPeer,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.PeeringGroupPeerListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "PeeringGroupPeers.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedPeeringGroupPeerToPorcelain(plumbingResponse.PeeringGroupPeers)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// PeeringGroupResources provides the building blocks necessary to obtain attach a resource to a peering group.
type PeeringGroupResources struct {
	client plumbing.PeeringGroupResourcesClient
	parent *Client
}

// Create attaches a Resource to a PeeringGroup
func (svc *PeeringGroupResources) Create(
	ctx context.Context,
	peeringGroupResource *PeeringGroupResource) (
	*PeeringGroupResourceCreateResponse,
	error) {
	req := plumbing.PeeringGroupResourceCreateRequest{}

	req.PeeringGroupResource = convertPeeringGroupResourceToPlumbing(peeringGroupResource)
	req.Meta = &plumbing.CreateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.PeeringGroupResourceCreateResponse, error) {
			return svc.client.Create(svc.parent.wrapContext(ctx, &req, "PeeringGroupResources.Create"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &PeeringGroupResourceCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPeeringGroupResourceToPorcelain(plumbingResponse.PeeringGroupResource); err != nil {
		return nil, err
	} else {
		resp.PeeringGroupResource = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete detaches a Resource to a PeeringGroup
func (svc *PeeringGroupResources) Delete(
	ctx context.Context,
	id string) (
	*PeeringGroupResourceDeleteResponse,
	error) {
	req := plumbing.PeeringGroupResourceDeleteRequest{}

	req.Id = (id)
	req.Meta = &plumbing.DeleteRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.PeeringGroupResourceDeleteResponse, error) {
			return svc.client.Delete(svc.parent.wrapContext(ctx, &req, "PeeringGroupResources.Delete"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &PeeringGroupResourceDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads the information of one peering group to resource attachment.
func (svc *PeeringGroupResources) Get(
	ctx context.Context,
	id string) (
	*PeeringGroupResourceGetResponse,
	error) {
	req := plumbing.PeeringGroupResourceGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.PeeringGroupResourceGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "PeeringGroupResources.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &PeeringGroupResourceGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPeeringGroupResourceToPorcelain(plumbingResponse.PeeringGroupResource); err != nil {
		return nil, err
	} else {
		resp.PeeringGroupResource = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of peering group resource attachments.
func (svc *PeeringGroupResources) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	PeeringGroupResourceIterator,
	error) {
	req := plumbing.PeeringGroupResourceListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newPeeringGroupResourceIteratorImpl(
		func() (
			[]*PeeringGroupResource,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.PeeringGroupResourceListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "PeeringGroupResources.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedPeeringGroupResourceToPorcelain(plumbingResponse.PeeringGroupResources)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// PeeringGroups provides the building blocks necessary to obtain explicit network topology and routing.
type PeeringGroups struct {
	client plumbing.PeeringGroupsClient
	parent *Client
}

// Create registers a new PeeringGroup.
func (svc *PeeringGroups) Create(
	ctx context.Context,
	peeringGroup *PeeringGroup) (
	*PeeringGroupCreateResponse,
	error) {
	req := plumbing.PeeringGroupCreateRequest{}

	req.PeeringGroup = convertPeeringGroupToPlumbing(peeringGroup)
	req.Meta = &plumbing.CreateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.PeeringGroupCreateResponse, error) {
			return svc.client.Create(svc.parent.wrapContext(ctx, &req, "PeeringGroups.Create"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &PeeringGroupCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPeeringGroupToPorcelain(plumbingResponse.PeeringGroup); err != nil {
		return nil, err
	} else {
		resp.PeeringGroup = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete removes a PeeringGroup by ID.
func (svc *PeeringGroups) Delete(
	ctx context.Context,
	id string) (
	*PeeringGroupDeleteResponse,
	error) {
	req := plumbing.PeeringGroupDeleteRequest{}

	req.Id = (id)
	req.Meta = &plumbing.DeleteRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.PeeringGroupDeleteResponse, error) {
			return svc.client.Delete(svc.parent.wrapContext(ctx, &req, "PeeringGroups.Delete"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &PeeringGroupDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads one PeeringGroup by ID. It will load all its dependencies.
func (svc *PeeringGroups) Get(
	ctx context.Context,
	id string) (
	*PeeringGroupGetResponse,
	error) {
	req := plumbing.PeeringGroupGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.PeeringGroupGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "PeeringGroups.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &PeeringGroupGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPeeringGroupToPorcelain(plumbingResponse.PeeringGroup); err != nil {
		return nil, err
	} else {
		resp.PeeringGroup = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of Peering Groups.
func (svc *PeeringGroups) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	PeeringGroupIterator,
	error) {
	req := plumbing.PeeringGroupListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newPeeringGroupIteratorImpl(
		func() (
			[]*PeeringGroup,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.PeeringGroupListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "PeeringGroups.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedPeeringGroupToPorcelain(plumbingResponse.PeeringGroups)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// Policies are the collection of one or more statements that enforce fine-grained access
// control for the users of an organization.
type Policies struct {
	client plumbing.PoliciesClient
	parent *Client
}

// A SnapshotPolicies exposes the read only methods of the Policies
// service for historical queries.
type SnapshotPolicies interface {
	Get(
		ctx context.Context,
		id string) (
		*PolicyGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		PolicyIterator,
		error)
}

// Create creates a new Policy.
func (svc *Policies) Create(
	ctx context.Context,
	policy *Policy) (
	*PolicyCreateResponse,
	error) {
	req := plumbing.PolicyCreateRequest{}

	req.Policy = convertPolicyToPlumbing(policy)
	req.Meta = &plumbing.CreateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.PolicyCreateResponse, error) {
			return svc.client.Create(svc.parent.wrapContext(ctx, &req, "Policies.Create"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &PolicyCreateResponse{}
	if v, err := convertPolicyToPorcelain(plumbingResponse.Policy); err != nil {
		return nil, err
	} else {
		resp.Policy = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete removes a Policy by ID.
func (svc *Policies) Delete(
	ctx context.Context,
	id string) (
	*PolicyDeleteResponse,
	error) {
	req := plumbing.PolicyDeleteRequest{}

	req.Id = (id)
	req.Meta = &plumbing.DeleteRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.PolicyDeleteResponse, error) {
			return svc.client.Delete(svc.parent.wrapContext(ctx, &req, "Policies.Delete"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &PolicyDeleteResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Update replaces all the fields of a Policy by ID.
func (svc *Policies) Update(
	ctx context.Context,
	policy *Policy) (
	*PolicyUpdateResponse,
	error) {
	req := plumbing.PolicyUpdateRequest{}

	req.Policy = convertPolicyToPlumbing(policy)
	req.Meta = &plumbing.UpdateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.PolicyUpdateResponse, error) {
			return svc.client.Update(svc.parent.wrapContext(ctx, &req, "Policies.Update"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &PolicyUpdateResponse{}
	if v, err := convertPolicyToPorcelain(plumbingResponse.Policy); err != nil {
		return nil, err
	} else {
		resp.Policy = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Get reads one Policy by ID.
func (svc *Policies) Get(
	ctx context.Context,
	id string) (
	*PolicyGetResponse,
	error) {
	req := plumbing.PolicyGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.PolicyGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "Policies.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &PolicyGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertPolicyToPorcelain(plumbingResponse.Policy); err != nil {
		return nil, err
	} else {
		resp.Policy = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of Policy matching a given set of criteria
func (svc *Policies) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	PolicyIterator,
	error) {
	req := plumbing.PolicyListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newPolicyIteratorImpl(
		func() (
			[]*Policy,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.PolicyListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "Policies.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedPolicyToPorcelain(plumbingResponse.Policies)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// PoliciesHistory records all changes to the state of a Policy.
type PoliciesHistory struct {
	client plumbing.PoliciesHistoryClient
	parent *Client
}

// List gets a list of PolicyHistory records matching a given set of criteria.
func (svc *PoliciesHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	PolicyHistoryIterator,
	error) {
	req := plumbing.PoliciesHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newPolicyHistoryIteratorImpl(
		func() (
			[]*PolicyHistory,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.PoliciesHistoryListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "PoliciesHistory.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedPolicyHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// Proxy Cluster Keys are authentication keys for all proxies within a cluster.
// The proxies within a cluster share the same key. One cluster can have
// multiple keys in order to facilitate key rotation.
type ProxyClusterKeys struct {
	client plumbing.ProxyClusterKeysClient
	parent *Client
}

// A SnapshotProxyClusterKeys exposes the read only methods of the ProxyClusterKeys
// service for historical queries.
type SnapshotProxyClusterKeys interface {
	Get(
		ctx context.Context,
		id string) (
		*ProxyClusterKeyGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		ProxyClusterKeyIterator,
		error)
}

// Create registers a new ProxyClusterKey.
func (svc *ProxyClusterKeys) Create(
	ctx context.Context,
	proxyClusterKey *ProxyClusterKey) (
	*ProxyClusterKeyCreateResponse,
	error) {
	req := plumbing.ProxyClusterKeyCreateRequest{}

	req.ProxyClusterKey = convertProxyClusterKeyToPlumbing(proxyClusterKey)
	req.Meta = &plumbing.CreateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ProxyClusterKeyCreateResponse, error) {
			return svc.client.Create(svc.parent.wrapContext(ctx, &req, "ProxyClusterKeys.Create"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ProxyClusterKeyCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertProxyClusterKeyToPorcelain(plumbingResponse.ProxyClusterKey); err != nil {
		return nil, err
	} else {
		resp.ProxyClusterKey = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	resp.SecretKey = (plumbingResponse.SecretKey)
	return resp, nil
}

// Get reads one ProxyClusterKey by ID.
func (svc *ProxyClusterKeys) Get(
	ctx context.Context,
	id string) (
	*ProxyClusterKeyGetResponse,
	error) {
	req := plumbing.ProxyClusterKeyGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ProxyClusterKeyGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "ProxyClusterKeys.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ProxyClusterKeyGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertProxyClusterKeyToPorcelain(plumbingResponse.ProxyClusterKey); err != nil {
		return nil, err
	} else {
		resp.ProxyClusterKey = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Delete removes a ProxyClusterKey by ID.
func (svc *ProxyClusterKeys) Delete(
	ctx context.Context,
	id string) (
	*ProxyClusterKeyDeleteResponse,
	error) {
	req := plumbing.ProxyClusterKeyDeleteRequest{}

	req.Id = (id)
	req.Meta = &plumbing.DeleteRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ProxyClusterKeyDeleteResponse, error) {
			return svc.client.Delete(svc.parent.wrapContext(ctx, &req, "ProxyClusterKeys.Delete"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ProxyClusterKeyDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of ProxyClusterKeys matching a given set of criteria.
func (svc *ProxyClusterKeys) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ProxyClusterKeyIterator,
	error) {
	req := plumbing.ProxyClusterKeyListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newProxyClusterKeyIteratorImpl(
		func() (
			[]*ProxyClusterKey,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.ProxyClusterKeyListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "ProxyClusterKeys.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedProxyClusterKeyToPorcelain(plumbingResponse.ProxyClusterKeys)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// A Query is a record of a single client request to a resource, such as a SQL query.
// Long-running SSH, RDP, or Kubernetes interactive sessions also count as queries.
// The Queries service is read-only.
type Queries struct {
	client plumbing.QueriesClient
	parent *Client
}

// List gets a list of Queries matching a given set of criteria.
func (svc *Queries) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	QueryIterator,
	error) {
	req := plumbing.QueryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newQueryIteratorImpl(
		func() (
			[]*Query,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.QueryListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "Queries.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedQueryToPorcelain(plumbingResponse.Queries)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// RemoteIdentities assign a resource directly to an account, giving the account the permission to connect to that resource.
type RemoteIdentities struct {
	client plumbing.RemoteIdentitiesClient
	parent *Client
}

// A SnapshotRemoteIdentities exposes the read only methods of the RemoteIdentities
// service for historical queries.
type SnapshotRemoteIdentities interface {
	Get(
		ctx context.Context,
		id string) (
		*RemoteIdentityGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		RemoteIdentityIterator,
		error)
}

// Create registers a new RemoteIdentity.
func (svc *RemoteIdentities) Create(
	ctx context.Context,
	remoteIdentity *RemoteIdentity) (
	*RemoteIdentityCreateResponse,
	error) {
	req := plumbing.RemoteIdentityCreateRequest{}

	req.RemoteIdentity = convertRemoteIdentityToPlumbing(remoteIdentity)
	req.Meta = &plumbing.CreateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.RemoteIdentityCreateResponse, error) {
			return svc.client.Create(svc.parent.wrapContext(ctx, &req, "RemoteIdentities.Create"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &RemoteIdentityCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertRemoteIdentityToPorcelain(plumbingResponse.RemoteIdentity); err != nil {
		return nil, err
	} else {
		resp.RemoteIdentity = v
	}
	return resp, nil
}

// Get reads one RemoteIdentity by ID.
func (svc *RemoteIdentities) Get(
	ctx context.Context,
	id string) (
	*RemoteIdentityGetResponse,
	error) {
	req := plumbing.RemoteIdentityGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.RemoteIdentityGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "RemoteIdentities.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &RemoteIdentityGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertRemoteIdentityToPorcelain(plumbingResponse.RemoteIdentity); err != nil {
		return nil, err
	} else {
		resp.RemoteIdentity = v
	}
	return resp, nil
}

// Update replaces all the fields of a RemoteIdentity by ID.
func (svc *RemoteIdentities) Update(
	ctx context.Context,
	remoteIdentity *RemoteIdentity) (
	*RemoteIdentityUpdateResponse,
	error) {
	req := plumbing.RemoteIdentityUpdateRequest{}

	req.RemoteIdentity = convertRemoteIdentityToPlumbing(remoteIdentity)
	req.Meta = &plumbing.UpdateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.RemoteIdentityUpdateResponse, error) {
			return svc.client.Update(svc.parent.wrapContext(ctx, &req, "RemoteIdentities.Update"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &RemoteIdentityUpdateResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertRemoteIdentityToPorcelain(plumbingResponse.RemoteIdentity); err != nil {
		return nil, err
	} else {
		resp.RemoteIdentity = v
	}
	return resp, nil
}

// Delete removes a RemoteIdentity by ID.
func (svc *RemoteIdentities) Delete(
	ctx context.Context,
	id string) (
	*RemoteIdentityDeleteResponse,
	error) {
	req := plumbing.RemoteIdentityDeleteRequest{}

	req.Id = (id)
	req.Meta = &plumbing.DeleteRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.RemoteIdentityDeleteResponse, error) {
			return svc.client.Delete(svc.parent.wrapContext(ctx, &req, "RemoteIdentities.Delete"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &RemoteIdentityDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of RemoteIdentities matching a given set of criteria.
func (svc *RemoteIdentities) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	RemoteIdentityIterator,
	error) {
	req := plumbing.RemoteIdentityListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newRemoteIdentityIteratorImpl(
		func() (
			[]*RemoteIdentity,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.RemoteIdentityListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "RemoteIdentities.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedRemoteIdentityToPorcelain(plumbingResponse.RemoteIdentities)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// RemoteIdentitiesHistory records all changes to the state of a RemoteIdentity.
type RemoteIdentitiesHistory struct {
	client plumbing.RemoteIdentitiesHistoryClient
	parent *Client
}

// List gets a list of RemoteIdentityHistory records matching a given set of criteria.
func (svc *RemoteIdentitiesHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	RemoteIdentityHistoryIterator,
	error) {
	req := plumbing.RemoteIdentityHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newRemoteIdentityHistoryIteratorImpl(
		func() (
			[]*RemoteIdentityHistory,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.RemoteIdentityHistoryListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "RemoteIdentitiesHistory.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedRemoteIdentityHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// A RemoteIdentityGroup is a named grouping of Remote Identities for Accounts.
// An Account's relationship to a RemoteIdentityGroup is defined via RemoteIdentity objects.
type RemoteIdentityGroups struct {
	client plumbing.RemoteIdentityGroupsClient
	parent *Client
}

// A SnapshotRemoteIdentityGroups exposes the read only methods of the RemoteIdentityGroups
// service for historical queries.
type SnapshotRemoteIdentityGroups interface {
	Get(
		ctx context.Context,
		id string) (
		*RemoteIdentityGroupGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		RemoteIdentityGroupIterator,
		error)
}

// Get reads one RemoteIdentityGroup by ID.
func (svc *RemoteIdentityGroups) Get(
	ctx context.Context,
	id string) (
	*RemoteIdentityGroupGetResponse,
	error) {
	req := plumbing.RemoteIdentityGroupGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.RemoteIdentityGroupGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "RemoteIdentityGroups.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &RemoteIdentityGroupGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertRemoteIdentityGroupToPorcelain(plumbingResponse.RemoteIdentityGroup); err != nil {
		return nil, err
	} else {
		resp.RemoteIdentityGroup = v
	}
	return resp, nil
}

// List gets a list of RemoteIdentityGroups matching a given set of criteria.
func (svc *RemoteIdentityGroups) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	RemoteIdentityGroupIterator,
	error) {
	req := plumbing.RemoteIdentityGroupListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newRemoteIdentityGroupIteratorImpl(
		func() (
			[]*RemoteIdentityGroup,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.RemoteIdentityGroupListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "RemoteIdentityGroups.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedRemoteIdentityGroupToPorcelain(plumbingResponse.RemoteIdentityGroups)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// RemoteIdentityGroupsHistory records all changes to the state of a RemoteIdentityGroup.
type RemoteIdentityGroupsHistory struct {
	client plumbing.RemoteIdentityGroupsHistoryClient
	parent *Client
}

// List gets a list of RemoteIdentityGroupHistory records matching a given set of criteria.
func (svc *RemoteIdentityGroupsHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	RemoteIdentityGroupHistoryIterator,
	error) {
	req := plumbing.RemoteIdentityGroupHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newRemoteIdentityGroupHistoryIteratorImpl(
		func() (
			[]*RemoteIdentityGroupHistory,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.RemoteIdentityGroupHistoryListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "RemoteIdentityGroupsHistory.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedRemoteIdentityGroupHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// A Replay captures the data transferred over a long-running SSH, RDP, or Kubernetes interactive session
// (otherwise referred to as a query). The Replays service is read-only.
type Replays struct {
	client plumbing.ReplaysClient
	parent *Client
}

// List gets a list of ReplayChunks for the Query ID specified by the filter criteria.
func (svc *Replays) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ReplayChunkIterator,
	error) {
	req := plumbing.ReplayListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newReplayChunkIteratorImpl(
		func() (
			[]*ReplayChunk,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.ReplayListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "Replays.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedReplayChunkToPorcelain(plumbingResponse.Chunks)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// Resources are databases, servers, clusters, websites, or clouds that strongDM
// delegates access to.
type Resources struct {
	client plumbing.ResourcesClient
	parent *Client
}

// A SnapshotResources exposes the read only methods of the Resources
// service for historical queries.
type SnapshotResources interface {
	Get(
		ctx context.Context,
		id string) (
		*ResourceGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		ResourceIterator,
		error)
}

// EnumerateTags gets a list of the filter matching tags.
func (svc *Resources) EnumerateTags(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	TagIterator,
	error) {
	req := plumbing.EnumerateTagsRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newTagIteratorImpl(
		func() (
			[]*Tag,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.EnumerateTagsResponse, error) {
					return svc.client.EnumerateTags(svc.parent.wrapContext(ctx, &req, "Resources.EnumerateTags"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedTagToPorcelain(plumbingResponse.Matches)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// Create registers a new Resource.
func (svc *Resources) Create(
	ctx context.Context,
	resource Resource) (
	*ResourceCreateResponse,
	error) {
	req := plumbing.ResourceCreateRequest{}

	req.Resource = convertResourceToPlumbing(resource)
	req.Meta = &plumbing.CreateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ResourceCreateResponse, error) {
			return svc.client.Create(svc.parent.wrapContext(ctx, &req, "Resources.Create"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ResourceCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertResourceToPorcelain(plumbingResponse.Resource); err != nil {
		return nil, err
	} else {
		resp.Resource = v
	}
	return resp, nil
}

// Get reads one Resource by ID.
func (svc *Resources) Get(
	ctx context.Context,
	id string) (
	*ResourceGetResponse,
	error) {
	req := plumbing.ResourceGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ResourceGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "Resources.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ResourceGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertResourceToPorcelain(plumbingResponse.Resource); err != nil {
		return nil, err
	} else {
		resp.Resource = v
	}
	return resp, nil
}

// Update replaces all the fields of a Resource by ID.
func (svc *Resources) Update(
	ctx context.Context,
	resource Resource) (
	*ResourceUpdateResponse,
	error) {
	req := plumbing.ResourceUpdateRequest{}

	req.Resource = convertResourceToPlumbing(resource)
	req.Meta = &plumbing.UpdateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ResourceUpdateResponse, error) {
			return svc.client.Update(svc.parent.wrapContext(ctx, &req, "Resources.Update"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ResourceUpdateResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertResourceToPorcelain(plumbingResponse.Resource); err != nil {
		return nil, err
	} else {
		resp.Resource = v
	}
	return resp, nil
}

// Delete removes a Resource by ID.
func (svc *Resources) Delete(
	ctx context.Context,
	id string) (
	*ResourceDeleteResponse,
	error) {
	req := plumbing.ResourceDeleteRequest{}

	req.Id = (id)
	req.Meta = &plumbing.DeleteRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ResourceDeleteResponse, error) {
			return svc.client.Delete(svc.parent.wrapContext(ctx, &req, "Resources.Delete"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ResourceDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of Resources matching a given set of criteria.
func (svc *Resources) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ResourceIterator,
	error) {
	req := plumbing.ResourceListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newResourceIteratorImpl(
		func() (
			[]Resource,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.ResourceListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "Resources.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedResourceToPorcelain(plumbingResponse.Resources)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// Healthcheck triggers a remote healthcheck. It may take minutes to propagate across a
// large network of Nodes. The call will return immediately, and the updated health of the
// Resource can be retrieved via Get or List.
func (svc *Resources) Healthcheck(
	ctx context.Context,
	id string) (
	*ResourceHealthcheckResponse,
	error) {
	req := plumbing.ResourceHealthcheckRequest{}

	req.Id = (id)
	req.Meta = &plumbing.UpdateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.ResourceHealthcheckResponse, error) {
			return svc.client.Healthcheck(svc.parent.wrapContext(ctx, &req, "Resources.Healthcheck"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &ResourceHealthcheckResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// ResourcesHistory records all changes to the state of a Resource.
type ResourcesHistory struct {
	client plumbing.ResourcesHistoryClient
	parent *Client
}

// List gets a list of ResourceHistory records matching a given set of criteria.
func (svc *ResourcesHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	ResourceHistoryIterator,
	error) {
	req := plumbing.ResourceHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newResourceHistoryIteratorImpl(
		func() (
			[]*ResourceHistory,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.ResourceHistoryListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "ResourcesHistory.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedResourceHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// RoleResources enumerates the resources to which roles have access.
// The RoleResources service is read-only.
type RoleResources struct {
	client plumbing.RoleResourcesClient
	parent *Client
}

// A SnapshotRoleResources exposes the read only methods of the RoleResources
// service for historical queries.
type SnapshotRoleResources interface {
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		RoleResourceIterator,
		error)
}

// List gets a list of RoleResource records matching a given set of criteria.
func (svc *RoleResources) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	RoleResourceIterator,
	error) {
	req := plumbing.RoleResourceListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newRoleResourceIteratorImpl(
		func() (
			[]*RoleResource,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.RoleResourceListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "RoleResources.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedRoleResourceToPorcelain(plumbingResponse.RoleResources)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// RoleResourcesHistory records all changes to the state of a RoleResource.
type RoleResourcesHistory struct {
	client plumbing.RoleResourcesHistoryClient
	parent *Client
}

// List gets a list of RoleResourceHistory records matching a given set of criteria.
func (svc *RoleResourcesHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	RoleResourceHistoryIterator,
	error) {
	req := plumbing.RoleResourceHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newRoleResourceHistoryIteratorImpl(
		func() (
			[]*RoleResourceHistory,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.RoleResourceHistoryListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "RoleResourcesHistory.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedRoleResourceHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// A Role has a list of access rules which determine which Resources the members
// of the Role have access to. An Account can be a member of multiple Roles via
// AccountAttachments.
type Roles struct {
	client plumbing.RolesClient
	parent *Client
}

// A SnapshotRoles exposes the read only methods of the Roles
// service for historical queries.
type SnapshotRoles interface {
	Get(
		ctx context.Context,
		id string) (
		*RoleGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		RoleIterator,
		error)
}

// Create registers a new Role.
func (svc *Roles) Create(
	ctx context.Context,
	role *Role) (
	*RoleCreateResponse,
	error) {
	req := plumbing.RoleCreateRequest{}

	req.Role = convertRoleToPlumbing(role)
	req.Meta = &plumbing.CreateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.RoleCreateResponse, error) {
			return svc.client.Create(svc.parent.wrapContext(ctx, &req, "Roles.Create"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &RoleCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertRoleToPorcelain(plumbingResponse.Role); err != nil {
		return nil, err
	} else {
		resp.Role = v
	}
	return resp, nil
}

// Get reads one Role by ID.
func (svc *Roles) Get(
	ctx context.Context,
	id string) (
	*RoleGetResponse,
	error) {
	req := plumbing.RoleGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.RoleGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "Roles.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &RoleGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertRoleToPorcelain(plumbingResponse.Role); err != nil {
		return nil, err
	} else {
		resp.Role = v
	}
	return resp, nil
}

// Update replaces all the fields of a Role by ID.
func (svc *Roles) Update(
	ctx context.Context,
	role *Role) (
	*RoleUpdateResponse,
	error) {
	req := plumbing.RoleUpdateRequest{}

	req.Role = convertRoleToPlumbing(role)
	req.Meta = &plumbing.UpdateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.RoleUpdateResponse, error) {
			return svc.client.Update(svc.parent.wrapContext(ctx, &req, "Roles.Update"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &RoleUpdateResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertRoleToPorcelain(plumbingResponse.Role); err != nil {
		return nil, err
	} else {
		resp.Role = v
	}
	return resp, nil
}

// Delete removes a Role by ID.
func (svc *Roles) Delete(
	ctx context.Context,
	id string) (
	*RoleDeleteResponse,
	error) {
	req := plumbing.RoleDeleteRequest{}

	req.Id = (id)
	req.Meta = &plumbing.DeleteRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.RoleDeleteResponse, error) {
			return svc.client.Delete(svc.parent.wrapContext(ctx, &req, "Roles.Delete"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &RoleDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of Roles matching a given set of criteria.
func (svc *Roles) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	RoleIterator,
	error) {
	req := plumbing.RoleListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newRoleIteratorImpl(
		func() (
			[]*Role,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.RoleListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "Roles.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedRoleToPorcelain(plumbingResponse.Roles)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// RolesHistory records all changes to the state of a Role.
type RolesHistory struct {
	client plumbing.RolesHistoryClient
	parent *Client
}

// List gets a list of RoleHistory records matching a given set of criteria.
func (svc *RolesHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	RoleHistoryIterator,
	error) {
	req := plumbing.RoleHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newRoleHistoryIteratorImpl(
		func() (
			[]*RoleHistory,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.RoleHistoryListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "RolesHistory.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedRoleHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// SecretStores are servers where resource secrets (passwords, keys) are stored.
type SecretStores struct {
	client plumbing.SecretStoresClient
	parent *Client
}

// A SnapshotSecretStores exposes the read only methods of the SecretStores
// service for historical queries.
type SnapshotSecretStores interface {
	Get(
		ctx context.Context,
		id string) (
		*SecretStoreGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		SecretStoreIterator,
		error)
}

func (svc *SecretStores) Create(
	ctx context.Context,
	secretStore SecretStore) (
	*SecretStoreCreateResponse,
	error) {
	req := plumbing.SecretStoreCreateRequest{}

	req.SecretStore = convertSecretStoreToPlumbing(secretStore)
	req.Meta = &plumbing.CreateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.SecretStoreCreateResponse, error) {
			return svc.client.Create(svc.parent.wrapContext(ctx, &req, "SecretStores.Create"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &SecretStoreCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertSecretStoreToPorcelain(plumbingResponse.SecretStore); err != nil {
		return nil, err
	} else {
		resp.SecretStore = v
	}
	return resp, nil
}

// Get reads one SecretStore by ID.
func (svc *SecretStores) Get(
	ctx context.Context,
	id string) (
	*SecretStoreGetResponse,
	error) {
	req := plumbing.SecretStoreGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.SecretStoreGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "SecretStores.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &SecretStoreGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertSecretStoreToPorcelain(plumbingResponse.SecretStore); err != nil {
		return nil, err
	} else {
		resp.SecretStore = v
	}
	return resp, nil
}

// Update replaces all the fields of a SecretStore by ID.
func (svc *SecretStores) Update(
	ctx context.Context,
	secretStore SecretStore) (
	*SecretStoreUpdateResponse,
	error) {
	req := plumbing.SecretStoreUpdateRequest{}

	req.SecretStore = convertSecretStoreToPlumbing(secretStore)
	req.Meta = &plumbing.UpdateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.SecretStoreUpdateResponse, error) {
			return svc.client.Update(svc.parent.wrapContext(ctx, &req, "SecretStores.Update"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &SecretStoreUpdateResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertSecretStoreToPorcelain(plumbingResponse.SecretStore); err != nil {
		return nil, err
	} else {
		resp.SecretStore = v
	}
	return resp, nil
}

// Delete removes a SecretStore by ID.
func (svc *SecretStores) Delete(
	ctx context.Context,
	id string) (
	*SecretStoreDeleteResponse,
	error) {
	req := plumbing.SecretStoreDeleteRequest{}

	req.Id = (id)
	req.Meta = &plumbing.DeleteRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.SecretStoreDeleteResponse, error) {
			return svc.client.Delete(svc.parent.wrapContext(ctx, &req, "SecretStores.Delete"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &SecretStoreDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// List gets a list of SecretStores matching a given set of criteria.
func (svc *SecretStores) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	SecretStoreIterator,
	error) {
	req := plumbing.SecretStoreListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newSecretStoreIteratorImpl(
		func() (
			[]SecretStore,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.SecretStoreListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "SecretStores.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedSecretStoreToPorcelain(plumbingResponse.SecretStores)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

type SecretEngines struct {
	client plumbing.SecretEnginesClient
	parent *Client
}

// List returns a list of Secret Engines
func (svc *SecretEngines) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	SecretEngineIterator,
	error) {
	req := plumbing.SecretEngineListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newSecretEngineIteratorImpl(
		func() (
			[]SecretEngine,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.SecretEngineListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "SecretEngines.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedSecretEngineToPorcelain(plumbingResponse.SecretEngines)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// Get returns a secret engine details
func (svc *SecretEngines) Get(
	ctx context.Context,
	id string) (
	*SecretEngineGetResponse,
	error) {
	req := plumbing.SecretEngineGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.SecretEngineGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "SecretEngines.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &SecretEngineGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertSecretEngineToPorcelain(plumbingResponse.SecretEngine); err != nil {
		return nil, err
	} else {
		resp.SecretEngine = v
	}
	return resp, nil
}

// Create creates a secret engine
func (svc *SecretEngines) Create(
	ctx context.Context,
	secretEngine SecretEngine) (
	*SecretEngineCreateResponse,
	error) {
	req := plumbing.SecretEngineCreateRequest{}

	req.SecretEngine = convertSecretEngineToPlumbing(secretEngine)
	req.Meta = &plumbing.CreateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.SecretEngineCreateResponse, error) {
			return svc.client.Create(svc.parent.wrapContext(ctx, &req, "SecretEngines.Create"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &SecretEngineCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertSecretEngineToPorcelain(plumbingResponse.SecretEngine); err != nil {
		return nil, err
	} else {
		resp.SecretEngine = v
	}
	return resp, nil
}

// Update updates a secret engine
func (svc *SecretEngines) Update(
	ctx context.Context,
	secretEngine SecretEngine) (
	*SecretEngineUpdateResponse,
	error) {
	req := plumbing.SecretEngineUpdateRequest{}

	req.SecretEngine = convertSecretEngineToPlumbing(secretEngine)
	req.Meta = &plumbing.UpdateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.SecretEngineUpdateResponse, error) {
			return svc.client.Update(svc.parent.wrapContext(ctx, &req, "SecretEngines.Update"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &SecretEngineUpdateResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertSecretEngineToPorcelain(plumbingResponse.SecretEngine); err != nil {
		return nil, err
	} else {
		resp.SecretEngine = v
	}
	return resp, nil
}

// Delete deletes a secret engine
func (svc *SecretEngines) Delete(
	ctx context.Context,
	id string) (
	*SecretEngineDeleteResponse,
	error) {
	req := plumbing.SecretEngineDeleteRequest{}

	req.Id = (id)
	req.Meta = &plumbing.UpdateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.SecretEngineDeleteResponse, error) {
			return svc.client.Delete(svc.parent.wrapContext(ctx, &req, "SecretEngines.Delete"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &SecretEngineDeleteResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// ListSecretStores returns a list of Secret Stores that can be used as a backing store
// for Secret Engine
func (svc *SecretEngines) ListSecretStores(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	SecretStoreIterator,
	error) {
	req := plumbing.SecretStoreListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newSecretStoreIteratorImpl(
		func() (
			[]SecretStore,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.SecretStoreListResponse, error) {
					return svc.client.ListSecretStores(svc.parent.wrapContext(ctx, &req, "SecretEngines.ListSecretStores"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedSecretStoreToPorcelain(plumbingResponse.SecretStores)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// GenerateKeys generates a private key, stores it in a secret store and stores a public key in a secret engine
func (svc *SecretEngines) GenerateKeys(
	ctx context.Context,
	secretEngineId string) (
	*GenerateKeysResponse,
	error) {
	req := plumbing.GenerateKeysRequest{}

	req.SecretEngineId = (secretEngineId)
	req.Meta = &plumbing.UpdateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.GenerateKeysResponse, error) {
			return svc.client.GenerateKeys(svc.parent.wrapContext(ctx, &req, "SecretEngines.GenerateKeys"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &GenerateKeysResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Healthcheck triggers a healthcheck for all nodes serving a secret engine
func (svc *SecretEngines) Healthcheck(
	ctx context.Context,
	secretEngineId string) (
	*HealthcheckResponse,
	error) {
	req := plumbing.HealthcheckRequest{}

	req.SecretEngineId = (secretEngineId)
	req.Meta = &plumbing.GetRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.HealthcheckResponse, error) {
			return svc.client.Healthcheck(svc.parent.wrapContext(ctx, &req, "SecretEngines.Healthcheck"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &HealthcheckResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertRepeatedHealthcheckStatusToPorcelain(plumbingResponse.Status); err != nil {
		return nil, err
	} else {
		resp.Status = v
	}
	return resp, nil
}

// Rotate rotates secret engine's credentials
func (svc *SecretEngines) Rotate(
	ctx context.Context,
	id string,
	passwordPolicy *SecretEnginePasswordPolicy) (
	*SecretEngineRotateResponse,
	error) {
	req := plumbing.SecretEngineRotateRequest{}

	req.Id = (id)
	req.PasswordPolicy = convertSecretEnginePasswordPolicyToPlumbing(passwordPolicy)
	req.Meta = &plumbing.UpdateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.SecretEngineRotateResponse, error) {
			return svc.client.Rotate(svc.parent.wrapContext(ctx, &req, "SecretEngines.Rotate"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &SecretEngineRotateResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// SecretStoreHealths exposes health states for secret stores.
type SecretStoreHealths struct {
	client plumbing.SecretStoreHealthsClient
	parent *Client
}

// List reports the health status of node to secret store pairs.
func (svc *SecretStoreHealths) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	SecretStoreHealthIterator,
	error) {
	req := plumbing.SecretStoreHealthListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newSecretStoreHealthIteratorImpl(
		func() (
			[]*SecretStoreHealth,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.SecretStoreHealthListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "SecretStoreHealths.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedSecretStoreHealthToPorcelain(plumbingResponse.SecretStoreHealths)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// Healthcheck triggers a remote healthcheck request for a secret store. It may take minutes
// to propagate across a large network of Nodes. The call will return immediately, and the
// updated health of the Secret Store can be retrieved via List.
func (svc *SecretStoreHealths) Healthcheck(
	ctx context.Context,
	secretStoreId string) (
	*SecretStoreHealthcheckResponse,
	error) {
	req := plumbing.SecretStoreHealthcheckRequest{}

	req.SecretStoreId = (secretStoreId)
	req.Meta = &plumbing.CreateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.SecretStoreHealthcheckResponse, error) {
			return svc.client.Healthcheck(svc.parent.wrapContext(ctx, &req, "SecretStoreHealths.Healthcheck"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &SecretStoreHealthcheckResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// SecretStoresHistory records all changes to the state of a SecretStore.
type SecretStoresHistory struct {
	client plumbing.SecretStoresHistoryClient
	parent *Client
}

// List gets a list of SecretStoreHistory records matching a given set of criteria.
func (svc *SecretStoresHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	SecretStoreHistoryIterator,
	error) {
	req := plumbing.SecretStoreHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newSecretStoreHistoryIteratorImpl(
		func() (
			[]*SecretStoreHistory,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.SecretStoreHistoryListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "SecretStoresHistory.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedSecretStoreHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// WorkflowApprovers is an account or a role with the ability to approve requests bound to a workflow.
type WorkflowApprovers struct {
	client plumbing.WorkflowApproversClient
	parent *Client
}

// A SnapshotWorkflowApprovers exposes the read only methods of the WorkflowApprovers
// service for historical queries.
type SnapshotWorkflowApprovers interface {
	Get(
		ctx context.Context,
		id string) (
		*WorkflowApproverGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		WorkflowApproverIterator,
		error)
}

// Create creates a new workflow approver
func (svc *WorkflowApprovers) Create(
	ctx context.Context,
	workflowApprover *WorkflowApprover) (
	*WorkflowApproversCreateResponse,
	error) {
	req := plumbing.WorkflowApproversCreateRequest{}

	req.WorkflowApprover = convertWorkflowApproverToPlumbing(workflowApprover)
	req.Meta = &plumbing.CreateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.WorkflowApproversCreateResponse, error) {
			return svc.client.Create(svc.parent.wrapContext(ctx, &req, "WorkflowApprovers.Create"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &WorkflowApproversCreateResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertWorkflowApproverToPorcelain(plumbingResponse.WorkflowApprover); err != nil {
		return nil, err
	} else {
		resp.WorkflowApprover = v
	}
	return resp, nil
}

// Get reads one workflow approver by ID.
func (svc *WorkflowApprovers) Get(
	ctx context.Context,
	id string) (
	*WorkflowApproverGetResponse,
	error) {
	req := plumbing.WorkflowApproverGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.WorkflowApproverGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "WorkflowApprovers.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &WorkflowApproverGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertWorkflowApproverToPorcelain(plumbingResponse.WorkflowApprover); err != nil {
		return nil, err
	} else {
		resp.WorkflowApprover = v
	}
	return resp, nil
}

// Delete deletes a workflow approver
func (svc *WorkflowApprovers) Delete(
	ctx context.Context,
	id string) (
	*WorkflowApproversDeleteResponse,
	error) {
	req := plumbing.WorkflowApproversDeleteRequest{}

	req.Id = (id)
	req.Meta = &plumbing.DeleteRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.WorkflowApproversDeleteResponse, error) {
			return svc.client.Delete(svc.parent.wrapContext(ctx, &req, "WorkflowApprovers.Delete"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &WorkflowApproversDeleteResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Lists existing workflow approvers.
func (svc *WorkflowApprovers) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	WorkflowApproverIterator,
	error) {
	req := plumbing.WorkflowApproversListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newWorkflowApproverIteratorImpl(
		func() (
			[]*WorkflowApprover,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.WorkflowApproversListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "WorkflowApprovers.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedWorkflowApproverToPorcelain(plumbingResponse.WorkflowApprovers)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// WorkflowApproversHistory provides records of all changes to the state of a WorkflowApprover.
type WorkflowApproversHistory struct {
	client plumbing.WorkflowApproversHistoryClient
	parent *Client
}

// List gets a list of WorkflowApproversHistory records matching a given set of criteria.
func (svc *WorkflowApproversHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	WorkflowApproverHistoryIterator,
	error) {
	req := plumbing.WorkflowApproversHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newWorkflowApproverHistoryIteratorImpl(
		func() (
			[]*WorkflowApproverHistory,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.WorkflowApproversHistoryListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "WorkflowApproversHistory.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedWorkflowApproverHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// WorkflowRole links a role to a workflow. The linked roles indicate which roles a user must be a part of
// to request access to a resource via the workflow.
type WorkflowRoles struct {
	client plumbing.WorkflowRolesClient
	parent *Client
}

// A SnapshotWorkflowRoles exposes the read only methods of the WorkflowRoles
// service for historical queries.
type SnapshotWorkflowRoles interface {
	Get(
		ctx context.Context,
		id string) (
		*WorkflowRoleGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		WorkflowRoleIterator,
		error)
}

// Create creates a new workflow role
func (svc *WorkflowRoles) Create(
	ctx context.Context,
	workflowRole *WorkflowRole) (
	*WorkflowRolesCreateResponse,
	error) {
	req := plumbing.WorkflowRolesCreateRequest{}

	req.WorkflowRole = convertWorkflowRoleToPlumbing(workflowRole)
	req.Meta = &plumbing.CreateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.WorkflowRolesCreateResponse, error) {
			return svc.client.Create(svc.parent.wrapContext(ctx, &req, "WorkflowRoles.Create"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &WorkflowRolesCreateResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertWorkflowRoleToPorcelain(plumbingResponse.WorkflowRole); err != nil {
		return nil, err
	} else {
		resp.WorkflowRole = v
	}
	return resp, nil
}

// Get reads one workflow role by ID.
func (svc *WorkflowRoles) Get(
	ctx context.Context,
	id string) (
	*WorkflowRoleGetResponse,
	error) {
	req := plumbing.WorkflowRoleGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.WorkflowRoleGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "WorkflowRoles.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &WorkflowRoleGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertWorkflowRoleToPorcelain(plumbingResponse.WorkflowRole); err != nil {
		return nil, err
	} else {
		resp.WorkflowRole = v
	}
	return resp, nil
}

// Delete deletes a workflow role
func (svc *WorkflowRoles) Delete(
	ctx context.Context,
	id string) (
	*WorkflowRolesDeleteResponse,
	error) {
	req := plumbing.WorkflowRolesDeleteRequest{}

	req.Id = (id)
	req.Meta = &plumbing.DeleteRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.WorkflowRolesDeleteResponse, error) {
			return svc.client.Delete(svc.parent.wrapContext(ctx, &req, "WorkflowRoles.Delete"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &WorkflowRolesDeleteResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Lists existing workflow roles.
func (svc *WorkflowRoles) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	WorkflowRoleIterator,
	error) {
	req := plumbing.WorkflowRolesListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newWorkflowRoleIteratorImpl(
		func() (
			[]*WorkflowRole,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.WorkflowRolesListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "WorkflowRoles.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedWorkflowRoleToPorcelain(plumbingResponse.WorkflowRole)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// WorkflowRolesHistory provides records of all changes to the state of a WorkflowRole
type WorkflowRolesHistory struct {
	client plumbing.WorkflowRolesHistoryClient
	parent *Client
}

// List gets a list of WorkflowRolesHistory records matching a given set of criteria.
func (svc *WorkflowRolesHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	WorkflowRoleHistoryIterator,
	error) {
	req := plumbing.WorkflowRolesHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newWorkflowRoleHistoryIteratorImpl(
		func() (
			[]*WorkflowRoleHistory,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.WorkflowRolesHistoryListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "WorkflowRolesHistory.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedWorkflowRoleHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// Workflows are the collection of rules that define the resources to which access can be requested,
// the users that can request that access, and the mechanism for approving those requests which can either
// be automatic approval or a set of users authorized to approve the requests.
type Workflows struct {
	client plumbing.WorkflowsClient
	parent *Client
}

// A SnapshotWorkflows exposes the read only methods of the Workflows
// service for historical queries.
type SnapshotWorkflows interface {
	Get(
		ctx context.Context,
		id string) (
		*WorkflowGetResponse,
		error)
	List(
		ctx context.Context,
		filter string,
		args ...interface{}) (
		WorkflowIterator,
		error)
}

// Create creates a new workflow and requires a name for the workflow.
func (svc *Workflows) Create(
	ctx context.Context,
	workflow *Workflow) (
	*WorkflowCreateResponse,
	error) {
	req := plumbing.WorkflowCreateRequest{}

	req.Workflow = convertWorkflowToPlumbing(workflow)
	req.Meta = &plumbing.CreateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.WorkflowCreateResponse, error) {
			return svc.client.Create(svc.parent.wrapContext(ctx, &req, "Workflows.Create"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &WorkflowCreateResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertWorkflowToPorcelain(plumbingResponse.Workflow); err != nil {
		return nil, err
	} else {
		resp.Workflow = v
	}
	return resp, nil
}

// Get reads one workflow by ID.
func (svc *Workflows) Get(
	ctx context.Context,
	id string) (
	*WorkflowGetResponse,
	error) {
	req := plumbing.WorkflowGetRequest{}

	req.Id = (id)
	req.Meta = &plumbing.GetRequestMetadata{}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.WorkflowGetResponse, error) {
			return svc.client.Get(svc.parent.wrapContext(ctx, &req, "Workflows.Get"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &WorkflowGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbingResponse.Meta); err != nil {
		return nil, err
	} else {
		resp.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertWorkflowToPorcelain(plumbingResponse.Workflow); err != nil {
		return nil, err
	} else {
		resp.Workflow = v
	}
	return resp, nil
}

// Delete deletes an existing workflow.
func (svc *Workflows) Delete(
	ctx context.Context,
	id string) (
	*WorkflowDeleteResponse,
	error) {
	req := plumbing.WorkflowDeleteRequest{}

	req.Id = (id)
	req.Meta = &plumbing.DeleteRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.WorkflowDeleteResponse, error) {
			return svc.client.Delete(svc.parent.wrapContext(ctx, &req, "Workflows.Delete"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &WorkflowDeleteResponse{}
	resp.ID = (plumbingResponse.Id)
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	return resp, nil
}

// Update updates an existing workflow.
func (svc *Workflows) Update(
	ctx context.Context,
	workflow *Workflow) (
	*WorkflowUpdateResponse,
	error) {
	req := plumbing.WorkflowUpdateRequest{}

	req.Workflow = convertWorkflowToPlumbing(workflow)
	req.Meta = &plumbing.UpdateRequestMetadata{}
	plumbingResponse, err := retryWrapper(
		ctx,
		svc.parent.retryOptions,
		&req.Meta.Fulfillments,
		func() (*plumbing.WorkflowUpdateResponse, error) {
			return svc.client.Update(svc.parent.wrapContext(ctx, &req, "Workflows.Update"), &req)
		},
	)
	if err != nil {
		return nil, convertErrorToPorcelain(err)
	}

	resp := &WorkflowUpdateResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbingResponse.RateLimit); err != nil {
		return nil, err
	} else {
		resp.RateLimit = v
	}
	if v, err := convertWorkflowToPorcelain(plumbingResponse.Workflow); err != nil {
		return nil, err
	} else {
		resp.Workflow = v
	}
	return resp, nil
}

// Lists existing workflows.
func (svc *Workflows) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	WorkflowIterator,
	error) {
	req := plumbing.WorkflowListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newWorkflowIteratorImpl(
		func() (
			[]*Workflow,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.WorkflowListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "Workflows.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedWorkflowToPorcelain(plumbingResponse.Workflows)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}

// WorkflowsHistory provides records of all changes to the state of a Workflow.
type WorkflowsHistory struct {
	client plumbing.WorkflowsHistoryClient
	parent *Client
}

// List gets a list of WorkflowHistory records matching a given set of criteria.
func (svc *WorkflowsHistory) List(
	ctx context.Context,
	filter string,
	args ...interface{}) (
	WorkflowHistoryIterator,
	error) {
	req := plumbing.WorkflowHistoryListRequest{}

	var filterErr error
	req.Filter, filterErr = quoteFilterArgs(filter, args...)
	if filterErr != nil {
		return nil, filterErr
	}
	req.Meta = &plumbing.ListRequestMetadata{}
	if svc.parent.pageLimit > 0 {
		req.Meta.Limit = int32(svc.parent.pageLimit)
	}
	req.Meta.SnapshotAt = convertTimestampToPlumbing(svc.parent.snapshotAt)
	return newWorkflowHistoryIteratorImpl(
		func() (
			[]*WorkflowHistory,
			bool, error) {
			plumbingResponse, err := retryWrapper(
				ctx,
				svc.parent.retryOptions,
				&req.Meta.Fulfillments,
				func() (*plumbing.WorkflowHistoryListResponse, error) {
					return svc.client.List(svc.parent.wrapContext(ctx, &req, "WorkflowsHistory.List"), &req)
				},
			)
			if err != nil {
				return nil, false, convertErrorToPorcelain(err)
			}
			result, err := convertRepeatedWorkflowHistoryToPorcelain(plumbingResponse.History)
			if err != nil {
				return nil, false, err
			}
			req.Meta.Cursor = plumbingResponse.Meta.NextCursor
			return result, req.Meta.Cursor != "", nil
		},
	), nil
}
