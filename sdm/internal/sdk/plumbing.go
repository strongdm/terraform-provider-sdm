// Copyright 2020 StrongDM Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// This file was generated by protogen. DO NOT EDIT.

package sdm

import (
	"encoding/json"
	"fmt"
	proto "github.com/strongdm/terraform-provider-sdm/sdm/internal/sdk/internal/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/timestamppb"
	"strings"
	"time"
)

func quoteFilterArgs(filter string, args ...interface{}) (string, error) {
	parts := strings.Split(filter, "?")
	if len(parts) != len(args)+1 {
		return "", &BadRequestError{Message: "incorrect number of replacements"}
	}
	var b strings.Builder
	for i, v := range parts {
		b.WriteString(v)
		if i < len(args) {
			s := fmt.Sprint(args[i])
			j, err := json.Marshal(s)
			if err != nil {
				return "", &BadRequestError{Message: "unable to marshal string to JSON"}
			}
			b.Write(j)
		}
	}
	return b.String(), nil
}

func convertTimestampToPorcelain(t *timestamppb.Timestamp) (time.Time, error) {
	if t == nil {
		return time.Unix(0, 0).UTC(), nil
	}
	return time.Unix(t.Seconds, int64(t.Nanos)).UTC(), nil
}

func convertTimestampToPlumbing(t time.Time) *timestamppb.Timestamp {
	if t.IsZero() {
		return nil
	}
	return &timestamppb.Timestamp{
		Seconds: t.Unix(),
		Nanos:   int32(t.Nanosecond()),
	}
}

func convertTagsToPorcelain(tags *proto.Tags) (Tags, error) {
	result := Tags{}
	for _, tag := range tags.GetPairs() {
		result[tag.Name] = tag.Value
	}
	return result, nil
}

func convertTagsToPlumbing(tags Tags) *proto.Tags {
	var result []*proto.Tags_Pair
	for name, value := range tags {
		result = append(result, &proto.Tags_Pair{Name: name, Value: value})
	}
	return &proto.Tags{Pairs: result}
}

func convertAccessRulesToPorcelain(rules string) (AccessRules, error) {
	if rules == "" {
		return nil, nil
	}
	result := AccessRules{}
	decoder := json.NewDecoder(strings.NewReader(rules))
	decoder.DisallowUnknownFields()
	if err := decoder.Decode(&result); err != nil {
		return nil, err
	}
	return result, nil
}

func convertAccessRulesToPlumbing(rules AccessRules) string {
	if rules == nil {
		rules = AccessRules{}
	}
	result, _ := json.Marshal(rules)
	return string(result)
}
func convertAKSToPorcelain(plumbing *proto.AKS) (*AKS, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AKS{}
	porcelain.CertificateAuthority = plumbing.CertificateAuthority
	porcelain.ClientCertificate = plumbing.ClientCertificate
	porcelain.ClientKey = plumbing.ClientKey
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertAKSToPlumbing(porcelain *AKS) *proto.AKS {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AKS{}
	plumbing.CertificateAuthority = (porcelain.CertificateAuthority)
	plumbing.ClientCertificate = (porcelain.ClientCertificate)
	plumbing.ClientKey = (porcelain.ClientKey)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedAKSToPlumbing(
	porcelains []*AKS,
) []*proto.AKS {
	var items []*proto.AKS
	for _, porcelain := range porcelains {
		items = append(items, convertAKSToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAKSToPorcelain(plumbings []*proto.AKS) (
	[]*AKS,
	error,
) {
	var items []*AKS
	for _, plumbing := range plumbings {
		if v, err := convertAKSToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAKSBasicAuthToPorcelain(plumbing *proto.AKSBasicAuth) (*AKSBasicAuth, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AKSBasicAuth{}
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertAKSBasicAuthToPlumbing(porcelain *AKSBasicAuth) *proto.AKSBasicAuth {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AKSBasicAuth{}
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedAKSBasicAuthToPlumbing(
	porcelains []*AKSBasicAuth,
) []*proto.AKSBasicAuth {
	var items []*proto.AKSBasicAuth
	for _, porcelain := range porcelains {
		items = append(items, convertAKSBasicAuthToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAKSBasicAuthToPorcelain(plumbings []*proto.AKSBasicAuth) (
	[]*AKSBasicAuth,
	error,
) {
	var items []*AKSBasicAuth
	for _, plumbing := range plumbings {
		if v, err := convertAKSBasicAuthToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAKSServiceAccountToPorcelain(plumbing *proto.AKSServiceAccount) (*AKSServiceAccount, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AKSServiceAccount{}
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Token = plumbing.Token
	return porcelain, nil
}

func convertAKSServiceAccountToPlumbing(porcelain *AKSServiceAccount) *proto.AKSServiceAccount {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AKSServiceAccount{}
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Token = (porcelain.Token)
	return plumbing
}
func convertRepeatedAKSServiceAccountToPlumbing(
	porcelains []*AKSServiceAccount,
) []*proto.AKSServiceAccount {
	var items []*proto.AKSServiceAccount
	for _, porcelain := range porcelains {
		items = append(items, convertAKSServiceAccountToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAKSServiceAccountToPorcelain(plumbings []*proto.AKSServiceAccount) (
	[]*AKSServiceAccount,
	error,
) {
	var items []*AKSServiceAccount
	for _, plumbing := range plumbings {
		if v, err := convertAKSServiceAccountToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAKSServiceAccountUserImpersonationToPorcelain(plumbing *proto.AKSServiceAccountUserImpersonation) (*AKSServiceAccountUserImpersonation, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AKSServiceAccountUserImpersonation{}
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Token = plumbing.Token
	return porcelain, nil
}

func convertAKSServiceAccountUserImpersonationToPlumbing(porcelain *AKSServiceAccountUserImpersonation) *proto.AKSServiceAccountUserImpersonation {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AKSServiceAccountUserImpersonation{}
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Token = (porcelain.Token)
	return plumbing
}
func convertRepeatedAKSServiceAccountUserImpersonationToPlumbing(
	porcelains []*AKSServiceAccountUserImpersonation,
) []*proto.AKSServiceAccountUserImpersonation {
	var items []*proto.AKSServiceAccountUserImpersonation
	for _, porcelain := range porcelains {
		items = append(items, convertAKSServiceAccountUserImpersonationToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAKSServiceAccountUserImpersonationToPorcelain(plumbings []*proto.AKSServiceAccountUserImpersonation) (
	[]*AKSServiceAccountUserImpersonation,
	error,
) {
	var items []*AKSServiceAccountUserImpersonation
	for _, plumbing := range plumbings {
		if v, err := convertAKSServiceAccountUserImpersonationToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAKSUserImpersonationToPorcelain(plumbing *proto.AKSUserImpersonation) (*AKSUserImpersonation, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AKSUserImpersonation{}
	porcelain.CertificateAuthority = plumbing.CertificateAuthority
	porcelain.ClientCertificate = plumbing.ClientCertificate
	porcelain.ClientKey = plumbing.ClientKey
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertAKSUserImpersonationToPlumbing(porcelain *AKSUserImpersonation) *proto.AKSUserImpersonation {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AKSUserImpersonation{}
	plumbing.CertificateAuthority = (porcelain.CertificateAuthority)
	plumbing.ClientCertificate = (porcelain.ClientCertificate)
	plumbing.ClientKey = (porcelain.ClientKey)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedAKSUserImpersonationToPlumbing(
	porcelains []*AKSUserImpersonation,
) []*proto.AKSUserImpersonation {
	var items []*proto.AKSUserImpersonation
	for _, porcelain := range porcelains {
		items = append(items, convertAKSUserImpersonationToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAKSUserImpersonationToPorcelain(plumbings []*proto.AKSUserImpersonation) (
	[]*AKSUserImpersonation,
	error,
) {
	var items []*AKSUserImpersonation
	for _, plumbing := range plumbings {
		if v, err := convertAKSUserImpersonationToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAWSToPorcelain(plumbing *proto.AWS) (*AWS, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AWS{}
	porcelain.AccessKey = plumbing.AccessKey
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HealthcheckRegion = plumbing.HealthcheckRegion
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.RoleArn = plumbing.RoleArn
	porcelain.RoleExternalID = plumbing.RoleExternalId
	porcelain.SecretAccessKey = plumbing.SecretAccessKey
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertAWSToPlumbing(porcelain *AWS) *proto.AWS {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AWS{}
	plumbing.AccessKey = (porcelain.AccessKey)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HealthcheckRegion = (porcelain.HealthcheckRegion)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	plumbing.SecretAccessKey = (porcelain.SecretAccessKey)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedAWSToPlumbing(
	porcelains []*AWS,
) []*proto.AWS {
	var items []*proto.AWS
	for _, porcelain := range porcelains {
		items = append(items, convertAWSToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAWSToPorcelain(plumbings []*proto.AWS) (
	[]*AWS,
	error,
) {
	var items []*AWS
	for _, plumbing := range plumbings {
		if v, err := convertAWSToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAWSStoreToPorcelain(plumbing *proto.AWSStore) (*AWSStore, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AWSStore{}
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Region = plumbing.Region
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertAWSStoreToPlumbing(porcelain *AWSStore) *proto.AWSStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AWSStore{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Region = (porcelain.Region)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedAWSStoreToPlumbing(
	porcelains []*AWSStore,
) []*proto.AWSStore {
	var items []*proto.AWSStore
	for _, porcelain := range porcelains {
		items = append(items, convertAWSStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAWSStoreToPorcelain(plumbings []*proto.AWSStore) (
	[]*AWSStore,
	error,
) {
	var items []*AWSStore
	for _, plumbing := range plumbings {
		if v, err := convertAWSStoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountToPlumbing(porcelain Account) *proto.Account {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Account{}

	switch v := porcelain.(type) {
	case *Service:
		plumbing.Account = &proto.Account_Service{Service: convertServiceToPlumbing(v)}
	case *User:
		plumbing.Account = &proto.Account_User{User: convertUserToPlumbing(v)}
	}
	return plumbing
}

func convertAccountToPorcelain(plumbing *proto.Account) (Account, error) {
	if plumbing.GetService() != nil {
		return convertServiceToPorcelain(plumbing.GetService())
	}
	if plumbing.GetUser() != nil {
		return convertUserToPorcelain(plumbing.GetUser())
	}
	return nil, &UnknownError{Wrapped: fmt.Errorf("unknown polymorphic type, please upgrade your SDK")}
}
func convertRepeatedAccountToPlumbing(
	porcelains []Account,
) []*proto.Account {
	var items []*proto.Account
	for _, porcelain := range porcelains {
		items = append(items, convertAccountToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountToPorcelain(plumbings []*proto.Account) (
	[]Account,
	error,
) {
	var items []Account
	for _, plumbing := range plumbings {
		if v, err := convertAccountToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountAttachmentToPorcelain(plumbing *proto.AccountAttachment) (*AccountAttachment, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountAttachment{}
	porcelain.AccountID = plumbing.AccountId
	porcelain.ID = plumbing.Id
	porcelain.RoleID = plumbing.RoleId
	return porcelain, nil
}

func convertAccountAttachmentToPlumbing(porcelain *AccountAttachment) *proto.AccountAttachment {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountAttachment{}
	plumbing.AccountId = (porcelain.AccountID)
	plumbing.Id = (porcelain.ID)
	plumbing.RoleId = (porcelain.RoleID)
	return plumbing
}
func convertRepeatedAccountAttachmentToPlumbing(
	porcelains []*AccountAttachment,
) []*proto.AccountAttachment {
	var items []*proto.AccountAttachment
	for _, porcelain := range porcelains {
		items = append(items, convertAccountAttachmentToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountAttachmentToPorcelain(plumbings []*proto.AccountAttachment) (
	[]*AccountAttachment,
	error,
) {
	var items []*AccountAttachment
	for _, plumbing := range plumbings {
		if v, err := convertAccountAttachmentToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountAttachmentCreateResponseToPorcelain(plumbing *proto.AccountAttachmentCreateResponse) (*AccountAttachmentCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountAttachmentCreateResponse{}
	if v, err := convertAccountAttachmentToPorcelain(plumbing.AccountAttachment); err != nil {
		return nil, fmt.Errorf("error converting field AccountAttachment: %v", err)
	} else {
		porcelain.AccountAttachment = v
	}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertAccountAttachmentCreateResponseToPlumbing(porcelain *AccountAttachmentCreateResponse) *proto.AccountAttachmentCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountAttachmentCreateResponse{}
	plumbing.AccountAttachment = convertAccountAttachmentToPlumbing(porcelain.AccountAttachment)
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountAttachmentCreateResponseToPlumbing(
	porcelains []*AccountAttachmentCreateResponse,
) []*proto.AccountAttachmentCreateResponse {
	var items []*proto.AccountAttachmentCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountAttachmentCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountAttachmentCreateResponseToPorcelain(plumbings []*proto.AccountAttachmentCreateResponse) (
	[]*AccountAttachmentCreateResponse,
	error,
) {
	var items []*AccountAttachmentCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertAccountAttachmentCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountAttachmentDeleteResponseToPorcelain(plumbing *proto.AccountAttachmentDeleteResponse) (*AccountAttachmentDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountAttachmentDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertAccountAttachmentDeleteResponseToPlumbing(porcelain *AccountAttachmentDeleteResponse) *proto.AccountAttachmentDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountAttachmentDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountAttachmentDeleteResponseToPlumbing(
	porcelains []*AccountAttachmentDeleteResponse,
) []*proto.AccountAttachmentDeleteResponse {
	var items []*proto.AccountAttachmentDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountAttachmentDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountAttachmentDeleteResponseToPorcelain(plumbings []*proto.AccountAttachmentDeleteResponse) (
	[]*AccountAttachmentDeleteResponse,
	error,
) {
	var items []*AccountAttachmentDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertAccountAttachmentDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountAttachmentGetResponseToPorcelain(plumbing *proto.AccountAttachmentGetResponse) (*AccountAttachmentGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountAttachmentGetResponse{}
	if v, err := convertAccountAttachmentToPorcelain(plumbing.AccountAttachment); err != nil {
		return nil, fmt.Errorf("error converting field AccountAttachment: %v", err)
	} else {
		porcelain.AccountAttachment = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertAccountAttachmentGetResponseToPlumbing(porcelain *AccountAttachmentGetResponse) *proto.AccountAttachmentGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountAttachmentGetResponse{}
	plumbing.AccountAttachment = convertAccountAttachmentToPlumbing(porcelain.AccountAttachment)
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountAttachmentGetResponseToPlumbing(
	porcelains []*AccountAttachmentGetResponse,
) []*proto.AccountAttachmentGetResponse {
	var items []*proto.AccountAttachmentGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountAttachmentGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountAttachmentGetResponseToPorcelain(plumbings []*proto.AccountAttachmentGetResponse) (
	[]*AccountAttachmentGetResponse,
	error,
) {
	var items []*AccountAttachmentGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertAccountAttachmentGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountCreateResponseToPorcelain(plumbing *proto.AccountCreateResponse) (*AccountCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountCreateResponse{}
	if v, err := convertAccountToPorcelain(plumbing.Account); err != nil {
		return nil, fmt.Errorf("error converting field Account: %v", err)
	} else {
		porcelain.Account = v
	}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	porcelain.Token = plumbing.Token
	return porcelain, nil
}

func convertAccountCreateResponseToPlumbing(porcelain *AccountCreateResponse) *proto.AccountCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountCreateResponse{}
	plumbing.Account = convertAccountToPlumbing(porcelain.Account)
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.Token = (porcelain.Token)
	return plumbing
}
func convertRepeatedAccountCreateResponseToPlumbing(
	porcelains []*AccountCreateResponse,
) []*proto.AccountCreateResponse {
	var items []*proto.AccountCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountCreateResponseToPorcelain(plumbings []*proto.AccountCreateResponse) (
	[]*AccountCreateResponse,
	error,
) {
	var items []*AccountCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertAccountCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountDeleteResponseToPorcelain(plumbing *proto.AccountDeleteResponse) (*AccountDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertAccountDeleteResponseToPlumbing(porcelain *AccountDeleteResponse) *proto.AccountDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountDeleteResponseToPlumbing(
	porcelains []*AccountDeleteResponse,
) []*proto.AccountDeleteResponse {
	var items []*proto.AccountDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountDeleteResponseToPorcelain(plumbings []*proto.AccountDeleteResponse) (
	[]*AccountDeleteResponse,
	error,
) {
	var items []*AccountDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertAccountDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountGetResponseToPorcelain(plumbing *proto.AccountGetResponse) (*AccountGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountGetResponse{}
	if v, err := convertAccountToPorcelain(plumbing.Account); err != nil {
		return nil, fmt.Errorf("error converting field Account: %v", err)
	} else {
		porcelain.Account = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertAccountGetResponseToPlumbing(porcelain *AccountGetResponse) *proto.AccountGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountGetResponse{}
	plumbing.Account = convertAccountToPlumbing(porcelain.Account)
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountGetResponseToPlumbing(
	porcelains []*AccountGetResponse,
) []*proto.AccountGetResponse {
	var items []*proto.AccountGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountGetResponseToPorcelain(plumbings []*proto.AccountGetResponse) (
	[]*AccountGetResponse,
	error,
) {
	var items []*AccountGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertAccountGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountGrantToPorcelain(plumbing *proto.AccountGrant) (*AccountGrant, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountGrant{}
	porcelain.AccountID = plumbing.AccountId
	porcelain.ID = plumbing.Id
	porcelain.ResourceID = plumbing.ResourceId
	if v, err := convertTimestampToPorcelain(plumbing.StartFrom); err != nil {
		return nil, fmt.Errorf("error converting field StartFrom: %v", err)
	} else {
		porcelain.StartFrom = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.ValidUntil); err != nil {
		return nil, fmt.Errorf("error converting field ValidUntil: %v", err)
	} else {
		porcelain.ValidUntil = v
	}
	return porcelain, nil
}

func convertAccountGrantToPlumbing(porcelain *AccountGrant) *proto.AccountGrant {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountGrant{}
	plumbing.AccountId = (porcelain.AccountID)
	plumbing.Id = (porcelain.ID)
	plumbing.ResourceId = (porcelain.ResourceID)
	plumbing.StartFrom = convertTimestampToPlumbing(porcelain.StartFrom)
	plumbing.ValidUntil = convertTimestampToPlumbing(porcelain.ValidUntil)
	return plumbing
}
func convertRepeatedAccountGrantToPlumbing(
	porcelains []*AccountGrant,
) []*proto.AccountGrant {
	var items []*proto.AccountGrant
	for _, porcelain := range porcelains {
		items = append(items, convertAccountGrantToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountGrantToPorcelain(plumbings []*proto.AccountGrant) (
	[]*AccountGrant,
	error,
) {
	var items []*AccountGrant
	for _, plumbing := range plumbings {
		if v, err := convertAccountGrantToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountGrantCreateResponseToPorcelain(plumbing *proto.AccountGrantCreateResponse) (*AccountGrantCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountGrantCreateResponse{}
	if v, err := convertAccountGrantToPorcelain(plumbing.AccountGrant); err != nil {
		return nil, fmt.Errorf("error converting field AccountGrant: %v", err)
	} else {
		porcelain.AccountGrant = v
	}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertAccountGrantCreateResponseToPlumbing(porcelain *AccountGrantCreateResponse) *proto.AccountGrantCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountGrantCreateResponse{}
	plumbing.AccountGrant = convertAccountGrantToPlumbing(porcelain.AccountGrant)
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountGrantCreateResponseToPlumbing(
	porcelains []*AccountGrantCreateResponse,
) []*proto.AccountGrantCreateResponse {
	var items []*proto.AccountGrantCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountGrantCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountGrantCreateResponseToPorcelain(plumbings []*proto.AccountGrantCreateResponse) (
	[]*AccountGrantCreateResponse,
	error,
) {
	var items []*AccountGrantCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertAccountGrantCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountGrantDeleteResponseToPorcelain(plumbing *proto.AccountGrantDeleteResponse) (*AccountGrantDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountGrantDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertAccountGrantDeleteResponseToPlumbing(porcelain *AccountGrantDeleteResponse) *proto.AccountGrantDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountGrantDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountGrantDeleteResponseToPlumbing(
	porcelains []*AccountGrantDeleteResponse,
) []*proto.AccountGrantDeleteResponse {
	var items []*proto.AccountGrantDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountGrantDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountGrantDeleteResponseToPorcelain(plumbings []*proto.AccountGrantDeleteResponse) (
	[]*AccountGrantDeleteResponse,
	error,
) {
	var items []*AccountGrantDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertAccountGrantDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountGrantGetResponseToPorcelain(plumbing *proto.AccountGrantGetResponse) (*AccountGrantGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountGrantGetResponse{}
	if v, err := convertAccountGrantToPorcelain(plumbing.AccountGrant); err != nil {
		return nil, fmt.Errorf("error converting field AccountGrant: %v", err)
	} else {
		porcelain.AccountGrant = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertAccountGrantGetResponseToPlumbing(porcelain *AccountGrantGetResponse) *proto.AccountGrantGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountGrantGetResponse{}
	plumbing.AccountGrant = convertAccountGrantToPlumbing(porcelain.AccountGrant)
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountGrantGetResponseToPlumbing(
	porcelains []*AccountGrantGetResponse,
) []*proto.AccountGrantGetResponse {
	var items []*proto.AccountGrantGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountGrantGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountGrantGetResponseToPorcelain(plumbings []*proto.AccountGrantGetResponse) (
	[]*AccountGrantGetResponse,
	error,
) {
	var items []*AccountGrantGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertAccountGrantGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountUpdateResponseToPorcelain(plumbing *proto.AccountUpdateResponse) (*AccountUpdateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountUpdateResponse{}
	if v, err := convertAccountToPorcelain(plumbing.Account); err != nil {
		return nil, fmt.Errorf("error converting field Account: %v", err)
	} else {
		porcelain.Account = v
	}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertAccountUpdateResponseToPlumbing(porcelain *AccountUpdateResponse) *proto.AccountUpdateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountUpdateResponse{}
	plumbing.Account = convertAccountToPlumbing(porcelain.Account)
	plumbing.Meta = convertUpdateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountUpdateResponseToPlumbing(
	porcelains []*AccountUpdateResponse,
) []*proto.AccountUpdateResponse {
	var items []*proto.AccountUpdateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountUpdateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountUpdateResponseToPorcelain(plumbings []*proto.AccountUpdateResponse) (
	[]*AccountUpdateResponse,
	error,
) {
	var items []*AccountUpdateResponse
	for _, plumbing := range plumbings {
		if v, err := convertAccountUpdateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAmazonEKSToPorcelain(plumbing *proto.AmazonEKS) (*AmazonEKS, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AmazonEKS{}
	porcelain.AccessKey = plumbing.AccessKey
	porcelain.CertificateAuthority = plumbing.CertificateAuthority
	porcelain.ClusterName = plumbing.ClusterName
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Endpoint = plumbing.Endpoint
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Region = plumbing.Region
	porcelain.RoleArn = plumbing.RoleArn
	porcelain.RoleExternalID = plumbing.RoleExternalId
	porcelain.SecretAccessKey = plumbing.SecretAccessKey
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertAmazonEKSToPlumbing(porcelain *AmazonEKS) *proto.AmazonEKS {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AmazonEKS{}
	plumbing.AccessKey = (porcelain.AccessKey)
	plumbing.CertificateAuthority = (porcelain.CertificateAuthority)
	plumbing.ClusterName = (porcelain.ClusterName)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Region = (porcelain.Region)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	plumbing.SecretAccessKey = (porcelain.SecretAccessKey)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedAmazonEKSToPlumbing(
	porcelains []*AmazonEKS,
) []*proto.AmazonEKS {
	var items []*proto.AmazonEKS
	for _, porcelain := range porcelains {
		items = append(items, convertAmazonEKSToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAmazonEKSToPorcelain(plumbings []*proto.AmazonEKS) (
	[]*AmazonEKS,
	error,
) {
	var items []*AmazonEKS
	for _, plumbing := range plumbings {
		if v, err := convertAmazonEKSToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAmazonEKSUserImpersonationToPorcelain(plumbing *proto.AmazonEKSUserImpersonation) (*AmazonEKSUserImpersonation, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AmazonEKSUserImpersonation{}
	porcelain.AccessKey = plumbing.AccessKey
	porcelain.CertificateAuthority = plumbing.CertificateAuthority
	porcelain.ClusterName = plumbing.ClusterName
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Endpoint = plumbing.Endpoint
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Region = plumbing.Region
	porcelain.RoleArn = plumbing.RoleArn
	porcelain.RoleExternalID = plumbing.RoleExternalId
	porcelain.SecretAccessKey = plumbing.SecretAccessKey
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertAmazonEKSUserImpersonationToPlumbing(porcelain *AmazonEKSUserImpersonation) *proto.AmazonEKSUserImpersonation {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AmazonEKSUserImpersonation{}
	plumbing.AccessKey = (porcelain.AccessKey)
	plumbing.CertificateAuthority = (porcelain.CertificateAuthority)
	plumbing.ClusterName = (porcelain.ClusterName)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Region = (porcelain.Region)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	plumbing.SecretAccessKey = (porcelain.SecretAccessKey)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedAmazonEKSUserImpersonationToPlumbing(
	porcelains []*AmazonEKSUserImpersonation,
) []*proto.AmazonEKSUserImpersonation {
	var items []*proto.AmazonEKSUserImpersonation
	for _, porcelain := range porcelains {
		items = append(items, convertAmazonEKSUserImpersonationToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAmazonEKSUserImpersonationToPorcelain(plumbings []*proto.AmazonEKSUserImpersonation) (
	[]*AmazonEKSUserImpersonation,
	error,
) {
	var items []*AmazonEKSUserImpersonation
	for _, plumbing := range plumbings {
		if v, err := convertAmazonEKSUserImpersonationToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAmazonESToPorcelain(plumbing *proto.AmazonES) (*AmazonES, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AmazonES{}
	porcelain.AccessKey = plumbing.AccessKey
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Endpoint = plumbing.Endpoint
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.Region = plumbing.Region
	porcelain.RoleArn = plumbing.RoleArn
	porcelain.RoleExternalID = plumbing.RoleExternalId
	porcelain.SecretAccessKey = plumbing.SecretAccessKey
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertAmazonESToPlumbing(porcelain *AmazonES) *proto.AmazonES {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AmazonES{}
	plumbing.AccessKey = (porcelain.AccessKey)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Region = (porcelain.Region)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	plumbing.SecretAccessKey = (porcelain.SecretAccessKey)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedAmazonESToPlumbing(
	porcelains []*AmazonES,
) []*proto.AmazonES {
	var items []*proto.AmazonES
	for _, porcelain := range porcelains {
		items = append(items, convertAmazonESToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAmazonESToPorcelain(plumbings []*proto.AmazonES) (
	[]*AmazonES,
	error,
) {
	var items []*AmazonES
	for _, plumbing := range plumbings {
		if v, err := convertAmazonESToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAmazonMQAMQP091ToPorcelain(plumbing *proto.AmazonMQAMQP091) (*AmazonMQAMQP091, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AmazonMQAMQP091{}
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertAmazonMQAMQP091ToPlumbing(porcelain *AmazonMQAMQP091) *proto.AmazonMQAMQP091 {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AmazonMQAMQP091{}
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedAmazonMQAMQP091ToPlumbing(
	porcelains []*AmazonMQAMQP091,
) []*proto.AmazonMQAMQP091 {
	var items []*proto.AmazonMQAMQP091
	for _, porcelain := range porcelains {
		items = append(items, convertAmazonMQAMQP091ToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAmazonMQAMQP091ToPorcelain(plumbings []*proto.AmazonMQAMQP091) (
	[]*AmazonMQAMQP091,
	error,
) {
	var items []*AmazonMQAMQP091
	for _, plumbing := range plumbings {
		if v, err := convertAmazonMQAMQP091ToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAthenaToPorcelain(plumbing *proto.Athena) (*Athena, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Athena{}
	porcelain.AccessKey = plumbing.AccessKey
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Output = plumbing.Output
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.Region = plumbing.Region
	porcelain.RoleArn = plumbing.RoleArn
	porcelain.RoleExternalID = plumbing.RoleExternalId
	porcelain.SecretAccessKey = plumbing.SecretAccessKey
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertAthenaToPlumbing(porcelain *Athena) *proto.Athena {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Athena{}
	plumbing.AccessKey = (porcelain.AccessKey)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Output = (porcelain.Output)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Region = (porcelain.Region)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	plumbing.SecretAccessKey = (porcelain.SecretAccessKey)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedAthenaToPlumbing(
	porcelains []*Athena,
) []*proto.Athena {
	var items []*proto.Athena
	for _, porcelain := range porcelains {
		items = append(items, convertAthenaToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAthenaToPorcelain(plumbings []*proto.Athena) (
	[]*Athena,
	error,
) {
	var items []*Athena
	for _, plumbing := range plumbings {
		if v, err := convertAthenaToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAuroraMysqlToPorcelain(plumbing *proto.AuroraMysql) (*AuroraMysql, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AuroraMysql{}
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertAuroraMysqlToPlumbing(porcelain *AuroraMysql) *proto.AuroraMysql {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AuroraMysql{}
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedAuroraMysqlToPlumbing(
	porcelains []*AuroraMysql,
) []*proto.AuroraMysql {
	var items []*proto.AuroraMysql
	for _, porcelain := range porcelains {
		items = append(items, convertAuroraMysqlToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAuroraMysqlToPorcelain(plumbings []*proto.AuroraMysql) (
	[]*AuroraMysql,
	error,
) {
	var items []*AuroraMysql
	for _, plumbing := range plumbings {
		if v, err := convertAuroraMysqlToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAuroraPostgresToPorcelain(plumbing *proto.AuroraPostgres) (*AuroraPostgres, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AuroraPostgres{}
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.OverrideDatabase = plumbing.OverrideDatabase
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertAuroraPostgresToPlumbing(porcelain *AuroraPostgres) *proto.AuroraPostgres {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AuroraPostgres{}
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedAuroraPostgresToPlumbing(
	porcelains []*AuroraPostgres,
) []*proto.AuroraPostgres {
	var items []*proto.AuroraPostgres
	for _, porcelain := range porcelains {
		items = append(items, convertAuroraPostgresToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAuroraPostgresToPorcelain(plumbings []*proto.AuroraPostgres) (
	[]*AuroraPostgres,
	error,
) {
	var items []*AuroraPostgres
	for _, plumbing := range plumbings {
		if v, err := convertAuroraPostgresToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAzureToPorcelain(plumbing *proto.Azure) (*Azure, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Azure{}
	porcelain.AppID = plumbing.AppId
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TenantID = plumbing.TenantId
	return porcelain, nil
}

func convertAzureToPlumbing(porcelain *Azure) *proto.Azure {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Azure{}
	plumbing.AppId = (porcelain.AppID)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TenantId = (porcelain.TenantID)
	return plumbing
}
func convertRepeatedAzureToPlumbing(
	porcelains []*Azure,
) []*proto.Azure {
	var items []*proto.Azure
	for _, porcelain := range porcelains {
		items = append(items, convertAzureToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAzureToPorcelain(plumbings []*proto.Azure) (
	[]*Azure,
	error,
) {
	var items []*Azure
	for _, plumbing := range plumbings {
		if v, err := convertAzureToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAzureCertificateToPorcelain(plumbing *proto.AzureCertificate) (*AzureCertificate, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AzureCertificate{}
	porcelain.AppID = plumbing.AppId
	porcelain.ClientCertificate = plumbing.ClientCertificate
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TenantID = plumbing.TenantId
	return porcelain, nil
}

func convertAzureCertificateToPlumbing(porcelain *AzureCertificate) *proto.AzureCertificate {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AzureCertificate{}
	plumbing.AppId = (porcelain.AppID)
	plumbing.ClientCertificate = (porcelain.ClientCertificate)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TenantId = (porcelain.TenantID)
	return plumbing
}
func convertRepeatedAzureCertificateToPlumbing(
	porcelains []*AzureCertificate,
) []*proto.AzureCertificate {
	var items []*proto.AzureCertificate
	for _, porcelain := range porcelains {
		items = append(items, convertAzureCertificateToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAzureCertificateToPorcelain(plumbings []*proto.AzureCertificate) (
	[]*AzureCertificate,
	error,
) {
	var items []*AzureCertificate
	for _, plumbing := range plumbings {
		if v, err := convertAzureCertificateToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAzurePostgresToPorcelain(plumbing *proto.AzurePostgres) (*AzurePostgres, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AzurePostgres{}
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.OverrideDatabase = plumbing.OverrideDatabase
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertAzurePostgresToPlumbing(porcelain *AzurePostgres) *proto.AzurePostgres {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AzurePostgres{}
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedAzurePostgresToPlumbing(
	porcelains []*AzurePostgres,
) []*proto.AzurePostgres {
	var items []*proto.AzurePostgres
	for _, porcelain := range porcelains {
		items = append(items, convertAzurePostgresToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAzurePostgresToPorcelain(plumbings []*proto.AzurePostgres) (
	[]*AzurePostgres,
	error,
) {
	var items []*AzurePostgres
	for _, plumbing := range plumbings {
		if v, err := convertAzurePostgresToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAzureStoreToPorcelain(plumbing *proto.AzureStore) (*AzureStore, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AzureStore{}
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.VaultUri = plumbing.VaultUri
	return porcelain, nil
}

func convertAzureStoreToPlumbing(porcelain *AzureStore) *proto.AzureStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AzureStore{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.VaultUri = (porcelain.VaultUri)
	return plumbing
}
func convertRepeatedAzureStoreToPlumbing(
	porcelains []*AzureStore,
) []*proto.AzureStore {
	var items []*proto.AzureStore
	for _, porcelain := range porcelains {
		items = append(items, convertAzureStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAzureStoreToPorcelain(plumbings []*proto.AzureStore) (
	[]*AzureStore,
	error,
) {
	var items []*AzureStore
	for _, plumbing := range plumbings {
		if v, err := convertAzureStoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertBigQueryToPorcelain(plumbing *proto.BigQuery) (*BigQuery, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &BigQuery{}
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Endpoint = plumbing.Endpoint
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.PrivateKey = plumbing.PrivateKey
	porcelain.Project = plumbing.Project
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertBigQueryToPlumbing(porcelain *BigQuery) *proto.BigQuery {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.BigQuery{}
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.PrivateKey = (porcelain.PrivateKey)
	plumbing.Project = (porcelain.Project)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedBigQueryToPlumbing(
	porcelains []*BigQuery,
) []*proto.BigQuery {
	var items []*proto.BigQuery
	for _, porcelain := range porcelains {
		items = append(items, convertBigQueryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedBigQueryToPorcelain(plumbings []*proto.BigQuery) (
	[]*BigQuery,
	error,
) {
	var items []*BigQuery
	for _, plumbing := range plumbings {
		if v, err := convertBigQueryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertCassandraToPorcelain(plumbing *proto.Cassandra) (*Cassandra, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Cassandra{}
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertCassandraToPlumbing(porcelain *Cassandra) *proto.Cassandra {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Cassandra{}
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedCassandraToPlumbing(
	porcelains []*Cassandra,
) []*proto.Cassandra {
	var items []*proto.Cassandra
	for _, porcelain := range porcelains {
		items = append(items, convertCassandraToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedCassandraToPorcelain(plumbings []*proto.Cassandra) (
	[]*Cassandra,
	error,
) {
	var items []*Cassandra
	for _, plumbing := range plumbings {
		if v, err := convertCassandraToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertCitusToPorcelain(plumbing *proto.Citus) (*Citus, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Citus{}
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.OverrideDatabase = plumbing.OverrideDatabase
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertCitusToPlumbing(porcelain *Citus) *proto.Citus {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Citus{}
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedCitusToPlumbing(
	porcelains []*Citus,
) []*proto.Citus {
	var items []*proto.Citus
	for _, porcelain := range porcelains {
		items = append(items, convertCitusToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedCitusToPorcelain(plumbings []*proto.Citus) (
	[]*Citus,
	error,
) {
	var items []*Citus
	for _, plumbing := range plumbings {
		if v, err := convertCitusToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertClustrixToPorcelain(plumbing *proto.Clustrix) (*Clustrix, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Clustrix{}
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertClustrixToPlumbing(porcelain *Clustrix) *proto.Clustrix {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Clustrix{}
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedClustrixToPlumbing(
	porcelains []*Clustrix,
) []*proto.Clustrix {
	var items []*proto.Clustrix
	for _, porcelain := range porcelains {
		items = append(items, convertClustrixToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedClustrixToPorcelain(plumbings []*proto.Clustrix) (
	[]*Clustrix,
	error,
) {
	var items []*Clustrix
	for _, plumbing := range plumbings {
		if v, err := convertClustrixToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertCockroachToPorcelain(plumbing *proto.Cockroach) (*Cockroach, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Cockroach{}
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.OverrideDatabase = plumbing.OverrideDatabase
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertCockroachToPlumbing(porcelain *Cockroach) *proto.Cockroach {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Cockroach{}
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedCockroachToPlumbing(
	porcelains []*Cockroach,
) []*proto.Cockroach {
	var items []*proto.Cockroach
	for _, porcelain := range porcelains {
		items = append(items, convertCockroachToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedCockroachToPorcelain(plumbings []*proto.Cockroach) (
	[]*Cockroach,
	error,
) {
	var items []*Cockroach
	for _, plumbing := range plumbings {
		if v, err := convertCockroachToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertControlPanelGetSSHCAPublicKeyResponseToPorcelain(plumbing *proto.ControlPanelGetSSHCAPublicKeyResponse) (*ControlPanelGetSSHCAPublicKeyResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ControlPanelGetSSHCAPublicKeyResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	porcelain.PublicKey = plumbing.PublicKey
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertControlPanelGetSSHCAPublicKeyResponseToPlumbing(porcelain *ControlPanelGetSSHCAPublicKeyResponse) *proto.ControlPanelGetSSHCAPublicKeyResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ControlPanelGetSSHCAPublicKeyResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.PublicKey = (porcelain.PublicKey)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedControlPanelGetSSHCAPublicKeyResponseToPlumbing(
	porcelains []*ControlPanelGetSSHCAPublicKeyResponse,
) []*proto.ControlPanelGetSSHCAPublicKeyResponse {
	var items []*proto.ControlPanelGetSSHCAPublicKeyResponse
	for _, porcelain := range porcelains {
		items = append(items, convertControlPanelGetSSHCAPublicKeyResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedControlPanelGetSSHCAPublicKeyResponseToPorcelain(plumbings []*proto.ControlPanelGetSSHCAPublicKeyResponse) (
	[]*ControlPanelGetSSHCAPublicKeyResponse,
	error,
) {
	var items []*ControlPanelGetSSHCAPublicKeyResponse
	for _, plumbing := range plumbings {
		if v, err := convertControlPanelGetSSHCAPublicKeyResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertControlPanelVerifyJWTResponseToPorcelain(plumbing *proto.ControlPanelVerifyJWTResponse) (*ControlPanelVerifyJWTResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ControlPanelVerifyJWTResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	porcelain.ValID = plumbing.Valid
	return porcelain, nil
}

func convertControlPanelVerifyJWTResponseToPlumbing(porcelain *ControlPanelVerifyJWTResponse) *proto.ControlPanelVerifyJWTResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ControlPanelVerifyJWTResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.Valid = (porcelain.ValID)
	return plumbing
}
func convertRepeatedControlPanelVerifyJWTResponseToPlumbing(
	porcelains []*ControlPanelVerifyJWTResponse,
) []*proto.ControlPanelVerifyJWTResponse {
	var items []*proto.ControlPanelVerifyJWTResponse
	for _, porcelain := range porcelains {
		items = append(items, convertControlPanelVerifyJWTResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedControlPanelVerifyJWTResponseToPorcelain(plumbings []*proto.ControlPanelVerifyJWTResponse) (
	[]*ControlPanelVerifyJWTResponse,
	error,
) {
	var items []*ControlPanelVerifyJWTResponse
	for _, plumbing := range plumbings {
		if v, err := convertControlPanelVerifyJWTResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertCreateResponseMetadataToPorcelain(plumbing *proto.CreateResponseMetadata) (*CreateResponseMetadata, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &CreateResponseMetadata{}
	return porcelain, nil
}

func convertCreateResponseMetadataToPlumbing(porcelain *CreateResponseMetadata) *proto.CreateResponseMetadata {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.CreateResponseMetadata{}
	return plumbing
}
func convertRepeatedCreateResponseMetadataToPlumbing(
	porcelains []*CreateResponseMetadata,
) []*proto.CreateResponseMetadata {
	var items []*proto.CreateResponseMetadata
	for _, porcelain := range porcelains {
		items = append(items, convertCreateResponseMetadataToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedCreateResponseMetadataToPorcelain(plumbings []*proto.CreateResponseMetadata) (
	[]*CreateResponseMetadata,
	error,
) {
	var items []*CreateResponseMetadata
	for _, plumbing := range plumbings {
		if v, err := convertCreateResponseMetadataToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertDB2IToPorcelain(plumbing *proto.DB2I) (*DB2I, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &DB2I{}
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertDB2IToPlumbing(porcelain *DB2I) *proto.DB2I {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.DB2I{}
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedDB2IToPlumbing(
	porcelains []*DB2I,
) []*proto.DB2I {
	var items []*proto.DB2I
	for _, porcelain := range porcelains {
		items = append(items, convertDB2IToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedDB2IToPorcelain(plumbings []*proto.DB2I) (
	[]*DB2I,
	error,
) {
	var items []*DB2I
	for _, plumbing := range plumbings {
		if v, err := convertDB2IToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertDB2LUWToPorcelain(plumbing *proto.DB2LUW) (*DB2LUW, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &DB2LUW{}
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertDB2LUWToPlumbing(porcelain *DB2LUW) *proto.DB2LUW {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.DB2LUW{}
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedDB2LUWToPlumbing(
	porcelains []*DB2LUW,
) []*proto.DB2LUW {
	var items []*proto.DB2LUW
	for _, porcelain := range porcelains {
		items = append(items, convertDB2LUWToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedDB2LUWToPorcelain(plumbings []*proto.DB2LUW) (
	[]*DB2LUW,
	error,
) {
	var items []*DB2LUW
	for _, plumbing := range plumbings {
		if v, err := convertDB2LUWToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertDeleteResponseMetadataToPorcelain(plumbing *proto.DeleteResponseMetadata) (*DeleteResponseMetadata, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &DeleteResponseMetadata{}
	return porcelain, nil
}

func convertDeleteResponseMetadataToPlumbing(porcelain *DeleteResponseMetadata) *proto.DeleteResponseMetadata {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.DeleteResponseMetadata{}
	return plumbing
}
func convertRepeatedDeleteResponseMetadataToPlumbing(
	porcelains []*DeleteResponseMetadata,
) []*proto.DeleteResponseMetadata {
	var items []*proto.DeleteResponseMetadata
	for _, porcelain := range porcelains {
		items = append(items, convertDeleteResponseMetadataToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedDeleteResponseMetadataToPorcelain(plumbings []*proto.DeleteResponseMetadata) (
	[]*DeleteResponseMetadata,
	error,
) {
	var items []*DeleteResponseMetadata
	for _, plumbing := range plumbings {
		if v, err := convertDeleteResponseMetadataToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertDocumentDBHostToPorcelain(plumbing *proto.DocumentDBHost) (*DocumentDBHost, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &DocumentDBHost{}
	porcelain.AuthDatabase = plumbing.AuthDatabase
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertDocumentDBHostToPlumbing(porcelain *DocumentDBHost) *proto.DocumentDBHost {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.DocumentDBHost{}
	plumbing.AuthDatabase = (porcelain.AuthDatabase)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedDocumentDBHostToPlumbing(
	porcelains []*DocumentDBHost,
) []*proto.DocumentDBHost {
	var items []*proto.DocumentDBHost
	for _, porcelain := range porcelains {
		items = append(items, convertDocumentDBHostToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedDocumentDBHostToPorcelain(plumbings []*proto.DocumentDBHost) (
	[]*DocumentDBHost,
	error,
) {
	var items []*DocumentDBHost
	for _, plumbing := range plumbings {
		if v, err := convertDocumentDBHostToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertDocumentDBReplicaSetToPorcelain(plumbing *proto.DocumentDBReplicaSet) (*DocumentDBReplicaSet, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &DocumentDBReplicaSet{}
	porcelain.AuthDatabase = plumbing.AuthDatabase
	porcelain.ConnectToReplica = plumbing.ConnectToReplica
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ReplicaSet = plumbing.ReplicaSet
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertDocumentDBReplicaSetToPlumbing(porcelain *DocumentDBReplicaSet) *proto.DocumentDBReplicaSet {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.DocumentDBReplicaSet{}
	plumbing.AuthDatabase = (porcelain.AuthDatabase)
	plumbing.ConnectToReplica = (porcelain.ConnectToReplica)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ReplicaSet = (porcelain.ReplicaSet)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedDocumentDBReplicaSetToPlumbing(
	porcelains []*DocumentDBReplicaSet,
) []*proto.DocumentDBReplicaSet {
	var items []*proto.DocumentDBReplicaSet
	for _, porcelain := range porcelains {
		items = append(items, convertDocumentDBReplicaSetToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedDocumentDBReplicaSetToPorcelain(plumbings []*proto.DocumentDBReplicaSet) (
	[]*DocumentDBReplicaSet,
	error,
) {
	var items []*DocumentDBReplicaSet
	for _, plumbing := range plumbings {
		if v, err := convertDocumentDBReplicaSetToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertDruidToPorcelain(plumbing *proto.Druid) (*Druid, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Druid{}
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertDruidToPlumbing(porcelain *Druid) *proto.Druid {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Druid{}
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedDruidToPlumbing(
	porcelains []*Druid,
) []*proto.Druid {
	var items []*proto.Druid
	for _, porcelain := range porcelains {
		items = append(items, convertDruidToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedDruidToPorcelain(plumbings []*proto.Druid) (
	[]*Druid,
	error,
) {
	var items []*Druid
	for _, plumbing := range plumbings {
		if v, err := convertDruidToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertDynamoDBToPorcelain(plumbing *proto.DynamoDB) (*DynamoDB, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &DynamoDB{}
	porcelain.AccessKey = plumbing.AccessKey
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Endpoint = plumbing.Endpoint
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.Region = plumbing.Region
	porcelain.RoleArn = plumbing.RoleArn
	porcelain.RoleExternalID = plumbing.RoleExternalId
	porcelain.SecretAccessKey = plumbing.SecretAccessKey
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertDynamoDBToPlumbing(porcelain *DynamoDB) *proto.DynamoDB {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.DynamoDB{}
	plumbing.AccessKey = (porcelain.AccessKey)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Region = (porcelain.Region)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	plumbing.SecretAccessKey = (porcelain.SecretAccessKey)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedDynamoDBToPlumbing(
	porcelains []*DynamoDB,
) []*proto.DynamoDB {
	var items []*proto.DynamoDB
	for _, porcelain := range porcelains {
		items = append(items, convertDynamoDBToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedDynamoDBToPorcelain(plumbings []*proto.DynamoDB) (
	[]*DynamoDB,
	error,
) {
	var items []*DynamoDB
	for _, plumbing := range plumbings {
		if v, err := convertDynamoDBToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertElasticToPorcelain(plumbing *proto.Elastic) (*Elastic, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Elastic{}
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertElasticToPlumbing(porcelain *Elastic) *proto.Elastic {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Elastic{}
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedElasticToPlumbing(
	porcelains []*Elastic,
) []*proto.Elastic {
	var items []*proto.Elastic
	for _, porcelain := range porcelains {
		items = append(items, convertElasticToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedElasticToPorcelain(plumbings []*proto.Elastic) (
	[]*Elastic,
	error,
) {
	var items []*Elastic
	for _, plumbing := range plumbings {
		if v, err := convertElasticToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertElasticacheRedisToPorcelain(plumbing *proto.ElasticacheRedis) (*ElasticacheRedis, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ElasticacheRedis{}
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	return porcelain, nil
}

func convertElasticacheRedisToPlumbing(porcelain *ElasticacheRedis) *proto.ElasticacheRedis {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ElasticacheRedis{}
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	return plumbing
}
func convertRepeatedElasticacheRedisToPlumbing(
	porcelains []*ElasticacheRedis,
) []*proto.ElasticacheRedis {
	var items []*proto.ElasticacheRedis
	for _, porcelain := range porcelains {
		items = append(items, convertElasticacheRedisToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedElasticacheRedisToPorcelain(plumbings []*proto.ElasticacheRedis) (
	[]*ElasticacheRedis,
	error,
) {
	var items []*ElasticacheRedis
	for _, plumbing := range plumbings {
		if v, err := convertElasticacheRedisToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertGCPToPorcelain(plumbing *proto.GCP) (*GCP, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &GCP{}
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Keyfile = plumbing.Keyfile
	porcelain.Name = plumbing.Name
	porcelain.Scopes = plumbing.Scopes
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertGCPToPlumbing(porcelain *GCP) *proto.GCP {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.GCP{}
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Keyfile = (porcelain.Keyfile)
	plumbing.Name = (porcelain.Name)
	plumbing.Scopes = (porcelain.Scopes)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedGCPToPlumbing(
	porcelains []*GCP,
) []*proto.GCP {
	var items []*proto.GCP
	for _, porcelain := range porcelains {
		items = append(items, convertGCPToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedGCPToPorcelain(plumbings []*proto.GCP) (
	[]*GCP,
	error,
) {
	var items []*GCP
	for _, plumbing := range plumbings {
		if v, err := convertGCPToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertGatewayToPorcelain(plumbing *proto.Gateway) (*Gateway, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Gateway{}
	porcelain.BindAddress = plumbing.BindAddress
	porcelain.GatewayFilter = plumbing.GatewayFilter
	porcelain.ID = plumbing.Id
	porcelain.ListenAddress = plumbing.ListenAddress
	porcelain.Name = plumbing.Name
	porcelain.State = plumbing.State
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertGatewayToPlumbing(porcelain *Gateway) *proto.Gateway {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Gateway{}
	plumbing.BindAddress = (porcelain.BindAddress)
	plumbing.GatewayFilter = (porcelain.GatewayFilter)
	plumbing.Id = (porcelain.ID)
	plumbing.ListenAddress = (porcelain.ListenAddress)
	plumbing.Name = (porcelain.Name)
	plumbing.State = (porcelain.State)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedGatewayToPlumbing(
	porcelains []*Gateway,
) []*proto.Gateway {
	var items []*proto.Gateway
	for _, porcelain := range porcelains {
		items = append(items, convertGatewayToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedGatewayToPorcelain(plumbings []*proto.Gateway) (
	[]*Gateway,
	error,
) {
	var items []*Gateway
	for _, plumbing := range plumbings {
		if v, err := convertGatewayToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertGetResponseMetadataToPorcelain(plumbing *proto.GetResponseMetadata) (*GetResponseMetadata, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &GetResponseMetadata{}
	return porcelain, nil
}

func convertGetResponseMetadataToPlumbing(porcelain *GetResponseMetadata) *proto.GetResponseMetadata {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.GetResponseMetadata{}
	return plumbing
}
func convertRepeatedGetResponseMetadataToPlumbing(
	porcelains []*GetResponseMetadata,
) []*proto.GetResponseMetadata {
	var items []*proto.GetResponseMetadata
	for _, porcelain := range porcelains {
		items = append(items, convertGetResponseMetadataToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedGetResponseMetadataToPorcelain(plumbings []*proto.GetResponseMetadata) (
	[]*GetResponseMetadata,
	error,
) {
	var items []*GetResponseMetadata
	for _, plumbing := range plumbings {
		if v, err := convertGetResponseMetadataToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertGoogleGKEToPorcelain(plumbing *proto.GoogleGKE) (*GoogleGKE, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &GoogleGKE{}
	porcelain.CertificateAuthority = plumbing.CertificateAuthority
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Endpoint = plumbing.Endpoint
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.ServiceAccountKey = plumbing.ServiceAccountKey
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertGoogleGKEToPlumbing(porcelain *GoogleGKE) *proto.GoogleGKE {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.GoogleGKE{}
	plumbing.CertificateAuthority = (porcelain.CertificateAuthority)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.ServiceAccountKey = (porcelain.ServiceAccountKey)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedGoogleGKEToPlumbing(
	porcelains []*GoogleGKE,
) []*proto.GoogleGKE {
	var items []*proto.GoogleGKE
	for _, porcelain := range porcelains {
		items = append(items, convertGoogleGKEToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedGoogleGKEToPorcelain(plumbings []*proto.GoogleGKE) (
	[]*GoogleGKE,
	error,
) {
	var items []*GoogleGKE
	for _, plumbing := range plumbings {
		if v, err := convertGoogleGKEToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertGoogleGKEUserImpersonationToPorcelain(plumbing *proto.GoogleGKEUserImpersonation) (*GoogleGKEUserImpersonation, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &GoogleGKEUserImpersonation{}
	porcelain.CertificateAuthority = plumbing.CertificateAuthority
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Endpoint = plumbing.Endpoint
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.ServiceAccountKey = plumbing.ServiceAccountKey
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertGoogleGKEUserImpersonationToPlumbing(porcelain *GoogleGKEUserImpersonation) *proto.GoogleGKEUserImpersonation {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.GoogleGKEUserImpersonation{}
	plumbing.CertificateAuthority = (porcelain.CertificateAuthority)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.ServiceAccountKey = (porcelain.ServiceAccountKey)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedGoogleGKEUserImpersonationToPlumbing(
	porcelains []*GoogleGKEUserImpersonation,
) []*proto.GoogleGKEUserImpersonation {
	var items []*proto.GoogleGKEUserImpersonation
	for _, porcelain := range porcelains {
		items = append(items, convertGoogleGKEUserImpersonationToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedGoogleGKEUserImpersonationToPorcelain(plumbings []*proto.GoogleGKEUserImpersonation) (
	[]*GoogleGKEUserImpersonation,
	error,
) {
	var items []*GoogleGKEUserImpersonation
	for _, plumbing := range plumbings {
		if v, err := convertGoogleGKEUserImpersonationToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertGreenplumToPorcelain(plumbing *proto.Greenplum) (*Greenplum, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Greenplum{}
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.OverrideDatabase = plumbing.OverrideDatabase
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertGreenplumToPlumbing(porcelain *Greenplum) *proto.Greenplum {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Greenplum{}
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedGreenplumToPlumbing(
	porcelains []*Greenplum,
) []*proto.Greenplum {
	var items []*proto.Greenplum
	for _, porcelain := range porcelains {
		items = append(items, convertGreenplumToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedGreenplumToPorcelain(plumbings []*proto.Greenplum) (
	[]*Greenplum,
	error,
) {
	var items []*Greenplum
	for _, plumbing := range plumbings {
		if v, err := convertGreenplumToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertHTTPAuthToPorcelain(plumbing *proto.HTTPAuth) (*HTTPAuth, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &HTTPAuth{}
	porcelain.AuthHeader = plumbing.AuthHeader
	porcelain.DefaultPath = plumbing.DefaultPath
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HeadersBlacklist = plumbing.HeadersBlacklist
	porcelain.HealthcheckPath = plumbing.HealthcheckPath
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Url = plumbing.Url
	return porcelain, nil
}

func convertHTTPAuthToPlumbing(porcelain *HTTPAuth) *proto.HTTPAuth {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.HTTPAuth{}
	plumbing.AuthHeader = (porcelain.AuthHeader)
	plumbing.DefaultPath = (porcelain.DefaultPath)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HeadersBlacklist = (porcelain.HeadersBlacklist)
	plumbing.HealthcheckPath = (porcelain.HealthcheckPath)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Url = (porcelain.Url)
	return plumbing
}
func convertRepeatedHTTPAuthToPlumbing(
	porcelains []*HTTPAuth,
) []*proto.HTTPAuth {
	var items []*proto.HTTPAuth
	for _, porcelain := range porcelains {
		items = append(items, convertHTTPAuthToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedHTTPAuthToPorcelain(plumbings []*proto.HTTPAuth) (
	[]*HTTPAuth,
	error,
) {
	var items []*HTTPAuth
	for _, plumbing := range plumbings {
		if v, err := convertHTTPAuthToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertHTTPBasicAuthToPorcelain(plumbing *proto.HTTPBasicAuth) (*HTTPBasicAuth, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &HTTPBasicAuth{}
	porcelain.DefaultPath = plumbing.DefaultPath
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HeadersBlacklist = plumbing.HeadersBlacklist
	porcelain.HealthcheckPath = plumbing.HealthcheckPath
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Url = plumbing.Url
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertHTTPBasicAuthToPlumbing(porcelain *HTTPBasicAuth) *proto.HTTPBasicAuth {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.HTTPBasicAuth{}
	plumbing.DefaultPath = (porcelain.DefaultPath)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HeadersBlacklist = (porcelain.HeadersBlacklist)
	plumbing.HealthcheckPath = (porcelain.HealthcheckPath)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Url = (porcelain.Url)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedHTTPBasicAuthToPlumbing(
	porcelains []*HTTPBasicAuth,
) []*proto.HTTPBasicAuth {
	var items []*proto.HTTPBasicAuth
	for _, porcelain := range porcelains {
		items = append(items, convertHTTPBasicAuthToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedHTTPBasicAuthToPorcelain(plumbings []*proto.HTTPBasicAuth) (
	[]*HTTPBasicAuth,
	error,
) {
	var items []*HTTPBasicAuth
	for _, plumbing := range plumbings {
		if v, err := convertHTTPBasicAuthToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertHTTPNoAuthToPorcelain(plumbing *proto.HTTPNoAuth) (*HTTPNoAuth, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &HTTPNoAuth{}
	porcelain.DefaultPath = plumbing.DefaultPath
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HeadersBlacklist = plumbing.HeadersBlacklist
	porcelain.HealthcheckPath = plumbing.HealthcheckPath
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Url = plumbing.Url
	return porcelain, nil
}

func convertHTTPNoAuthToPlumbing(porcelain *HTTPNoAuth) *proto.HTTPNoAuth {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.HTTPNoAuth{}
	plumbing.DefaultPath = (porcelain.DefaultPath)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HeadersBlacklist = (porcelain.HeadersBlacklist)
	plumbing.HealthcheckPath = (porcelain.HealthcheckPath)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Url = (porcelain.Url)
	return plumbing
}
func convertRepeatedHTTPNoAuthToPlumbing(
	porcelains []*HTTPNoAuth,
) []*proto.HTTPNoAuth {
	var items []*proto.HTTPNoAuth
	for _, porcelain := range porcelains {
		items = append(items, convertHTTPNoAuthToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedHTTPNoAuthToPorcelain(plumbings []*proto.HTTPNoAuth) (
	[]*HTTPNoAuth,
	error,
) {
	var items []*HTTPNoAuth
	for _, plumbing := range plumbings {
		if v, err := convertHTTPNoAuthToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertKubernetesToPorcelain(plumbing *proto.Kubernetes) (*Kubernetes, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Kubernetes{}
	porcelain.CertificateAuthority = plumbing.CertificateAuthority
	porcelain.ClientCertificate = plumbing.ClientCertificate
	porcelain.ClientKey = plumbing.ClientKey
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertKubernetesToPlumbing(porcelain *Kubernetes) *proto.Kubernetes {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Kubernetes{}
	plumbing.CertificateAuthority = (porcelain.CertificateAuthority)
	plumbing.ClientCertificate = (porcelain.ClientCertificate)
	plumbing.ClientKey = (porcelain.ClientKey)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedKubernetesToPlumbing(
	porcelains []*Kubernetes,
) []*proto.Kubernetes {
	var items []*proto.Kubernetes
	for _, porcelain := range porcelains {
		items = append(items, convertKubernetesToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedKubernetesToPorcelain(plumbings []*proto.Kubernetes) (
	[]*Kubernetes,
	error,
) {
	var items []*Kubernetes
	for _, plumbing := range plumbings {
		if v, err := convertKubernetesToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertKubernetesBasicAuthToPorcelain(plumbing *proto.KubernetesBasicAuth) (*KubernetesBasicAuth, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &KubernetesBasicAuth{}
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertKubernetesBasicAuthToPlumbing(porcelain *KubernetesBasicAuth) *proto.KubernetesBasicAuth {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.KubernetesBasicAuth{}
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedKubernetesBasicAuthToPlumbing(
	porcelains []*KubernetesBasicAuth,
) []*proto.KubernetesBasicAuth {
	var items []*proto.KubernetesBasicAuth
	for _, porcelain := range porcelains {
		items = append(items, convertKubernetesBasicAuthToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedKubernetesBasicAuthToPorcelain(plumbings []*proto.KubernetesBasicAuth) (
	[]*KubernetesBasicAuth,
	error,
) {
	var items []*KubernetesBasicAuth
	for _, plumbing := range plumbings {
		if v, err := convertKubernetesBasicAuthToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertKubernetesServiceAccountToPorcelain(plumbing *proto.KubernetesServiceAccount) (*KubernetesServiceAccount, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &KubernetesServiceAccount{}
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Token = plumbing.Token
	return porcelain, nil
}

func convertKubernetesServiceAccountToPlumbing(porcelain *KubernetesServiceAccount) *proto.KubernetesServiceAccount {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.KubernetesServiceAccount{}
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Token = (porcelain.Token)
	return plumbing
}
func convertRepeatedKubernetesServiceAccountToPlumbing(
	porcelains []*KubernetesServiceAccount,
) []*proto.KubernetesServiceAccount {
	var items []*proto.KubernetesServiceAccount
	for _, porcelain := range porcelains {
		items = append(items, convertKubernetesServiceAccountToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedKubernetesServiceAccountToPorcelain(plumbings []*proto.KubernetesServiceAccount) (
	[]*KubernetesServiceAccount,
	error,
) {
	var items []*KubernetesServiceAccount
	for _, plumbing := range plumbings {
		if v, err := convertKubernetesServiceAccountToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertKubernetesServiceAccountUserImpersonationToPorcelain(plumbing *proto.KubernetesServiceAccountUserImpersonation) (*KubernetesServiceAccountUserImpersonation, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &KubernetesServiceAccountUserImpersonation{}
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Token = plumbing.Token
	return porcelain, nil
}

func convertKubernetesServiceAccountUserImpersonationToPlumbing(porcelain *KubernetesServiceAccountUserImpersonation) *proto.KubernetesServiceAccountUserImpersonation {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.KubernetesServiceAccountUserImpersonation{}
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Token = (porcelain.Token)
	return plumbing
}
func convertRepeatedKubernetesServiceAccountUserImpersonationToPlumbing(
	porcelains []*KubernetesServiceAccountUserImpersonation,
) []*proto.KubernetesServiceAccountUserImpersonation {
	var items []*proto.KubernetesServiceAccountUserImpersonation
	for _, porcelain := range porcelains {
		items = append(items, convertKubernetesServiceAccountUserImpersonationToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedKubernetesServiceAccountUserImpersonationToPorcelain(plumbings []*proto.KubernetesServiceAccountUserImpersonation) (
	[]*KubernetesServiceAccountUserImpersonation,
	error,
) {
	var items []*KubernetesServiceAccountUserImpersonation
	for _, plumbing := range plumbings {
		if v, err := convertKubernetesServiceAccountUserImpersonationToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertKubernetesUserImpersonationToPorcelain(plumbing *proto.KubernetesUserImpersonation) (*KubernetesUserImpersonation, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &KubernetesUserImpersonation{}
	porcelain.CertificateAuthority = plumbing.CertificateAuthority
	porcelain.ClientCertificate = plumbing.ClientCertificate
	porcelain.ClientKey = plumbing.ClientKey
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertKubernetesUserImpersonationToPlumbing(porcelain *KubernetesUserImpersonation) *proto.KubernetesUserImpersonation {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.KubernetesUserImpersonation{}
	plumbing.CertificateAuthority = (porcelain.CertificateAuthority)
	plumbing.ClientCertificate = (porcelain.ClientCertificate)
	plumbing.ClientKey = (porcelain.ClientKey)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedKubernetesUserImpersonationToPlumbing(
	porcelains []*KubernetesUserImpersonation,
) []*proto.KubernetesUserImpersonation {
	var items []*proto.KubernetesUserImpersonation
	for _, porcelain := range porcelains {
		items = append(items, convertKubernetesUserImpersonationToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedKubernetesUserImpersonationToPorcelain(plumbings []*proto.KubernetesUserImpersonation) (
	[]*KubernetesUserImpersonation,
	error,
) {
	var items []*KubernetesUserImpersonation
	for _, plumbing := range plumbings {
		if v, err := convertKubernetesUserImpersonationToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertMTLSPostgresToPorcelain(plumbing *proto.MTLSPostgres) (*MTLSPostgres, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &MTLSPostgres{}
	porcelain.CertificateAuthority = plumbing.CertificateAuthority
	porcelain.ClientCertificate = plumbing.ClientCertificate
	porcelain.ClientKey = plumbing.ClientKey
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.OverrideDatabase = plumbing.OverrideDatabase
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.ServerName = plumbing.ServerName
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertMTLSPostgresToPlumbing(porcelain *MTLSPostgres) *proto.MTLSPostgres {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.MTLSPostgres{}
	plumbing.CertificateAuthority = (porcelain.CertificateAuthority)
	plumbing.ClientCertificate = (porcelain.ClientCertificate)
	plumbing.ClientKey = (porcelain.ClientKey)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.ServerName = (porcelain.ServerName)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedMTLSPostgresToPlumbing(
	porcelains []*MTLSPostgres,
) []*proto.MTLSPostgres {
	var items []*proto.MTLSPostgres
	for _, porcelain := range porcelains {
		items = append(items, convertMTLSPostgresToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMTLSPostgresToPorcelain(plumbings []*proto.MTLSPostgres) (
	[]*MTLSPostgres,
	error,
) {
	var items []*MTLSPostgres
	for _, plumbing := range plumbings {
		if v, err := convertMTLSPostgresToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertMariaToPorcelain(plumbing *proto.Maria) (*Maria, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Maria{}
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertMariaToPlumbing(porcelain *Maria) *proto.Maria {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Maria{}
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedMariaToPlumbing(
	porcelains []*Maria,
) []*proto.Maria {
	var items []*proto.Maria
	for _, porcelain := range porcelains {
		items = append(items, convertMariaToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMariaToPorcelain(plumbings []*proto.Maria) (
	[]*Maria,
	error,
) {
	var items []*Maria
	for _, plumbing := range plumbings {
		if v, err := convertMariaToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertMemcachedToPorcelain(plumbing *proto.Memcached) (*Memcached, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Memcached{}
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertMemcachedToPlumbing(porcelain *Memcached) *proto.Memcached {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Memcached{}
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedMemcachedToPlumbing(
	porcelains []*Memcached,
) []*proto.Memcached {
	var items []*proto.Memcached
	for _, porcelain := range porcelains {
		items = append(items, convertMemcachedToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMemcachedToPorcelain(plumbings []*proto.Memcached) (
	[]*Memcached,
	error,
) {
	var items []*Memcached
	for _, plumbing := range plumbings {
		if v, err := convertMemcachedToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertMemsqlToPorcelain(plumbing *proto.Memsql) (*Memsql, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Memsql{}
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertMemsqlToPlumbing(porcelain *Memsql) *proto.Memsql {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Memsql{}
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedMemsqlToPlumbing(
	porcelains []*Memsql,
) []*proto.Memsql {
	var items []*proto.Memsql
	for _, porcelain := range porcelains {
		items = append(items, convertMemsqlToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMemsqlToPorcelain(plumbings []*proto.Memsql) (
	[]*Memsql,
	error,
) {
	var items []*Memsql
	for _, plumbing := range plumbings {
		if v, err := convertMemsqlToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertMongoHostToPorcelain(plumbing *proto.MongoHost) (*MongoHost, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &MongoHost{}
	porcelain.AuthDatabase = plumbing.AuthDatabase
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertMongoHostToPlumbing(porcelain *MongoHost) *proto.MongoHost {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.MongoHost{}
	plumbing.AuthDatabase = (porcelain.AuthDatabase)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedMongoHostToPlumbing(
	porcelains []*MongoHost,
) []*proto.MongoHost {
	var items []*proto.MongoHost
	for _, porcelain := range porcelains {
		items = append(items, convertMongoHostToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMongoHostToPorcelain(plumbings []*proto.MongoHost) (
	[]*MongoHost,
	error,
) {
	var items []*MongoHost
	for _, plumbing := range plumbings {
		if v, err := convertMongoHostToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertMongoLegacyHostToPorcelain(plumbing *proto.MongoLegacyHost) (*MongoLegacyHost, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &MongoLegacyHost{}
	porcelain.AuthDatabase = plumbing.AuthDatabase
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ReplicaSet = plumbing.ReplicaSet
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertMongoLegacyHostToPlumbing(porcelain *MongoLegacyHost) *proto.MongoLegacyHost {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.MongoLegacyHost{}
	plumbing.AuthDatabase = (porcelain.AuthDatabase)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ReplicaSet = (porcelain.ReplicaSet)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedMongoLegacyHostToPlumbing(
	porcelains []*MongoLegacyHost,
) []*proto.MongoLegacyHost {
	var items []*proto.MongoLegacyHost
	for _, porcelain := range porcelains {
		items = append(items, convertMongoLegacyHostToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMongoLegacyHostToPorcelain(plumbings []*proto.MongoLegacyHost) (
	[]*MongoLegacyHost,
	error,
) {
	var items []*MongoLegacyHost
	for _, plumbing := range plumbings {
		if v, err := convertMongoLegacyHostToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertMongoLegacyReplicasetToPorcelain(plumbing *proto.MongoLegacyReplicaset) (*MongoLegacyReplicaset, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &MongoLegacyReplicaset{}
	porcelain.AuthDatabase = plumbing.AuthDatabase
	porcelain.ConnectToReplica = plumbing.ConnectToReplica
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ReplicaSet = plumbing.ReplicaSet
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertMongoLegacyReplicasetToPlumbing(porcelain *MongoLegacyReplicaset) *proto.MongoLegacyReplicaset {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.MongoLegacyReplicaset{}
	plumbing.AuthDatabase = (porcelain.AuthDatabase)
	plumbing.ConnectToReplica = (porcelain.ConnectToReplica)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ReplicaSet = (porcelain.ReplicaSet)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedMongoLegacyReplicasetToPlumbing(
	porcelains []*MongoLegacyReplicaset,
) []*proto.MongoLegacyReplicaset {
	var items []*proto.MongoLegacyReplicaset
	for _, porcelain := range porcelains {
		items = append(items, convertMongoLegacyReplicasetToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMongoLegacyReplicasetToPorcelain(plumbings []*proto.MongoLegacyReplicaset) (
	[]*MongoLegacyReplicaset,
	error,
) {
	var items []*MongoLegacyReplicaset
	for _, plumbing := range plumbings {
		if v, err := convertMongoLegacyReplicasetToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertMongoReplicaSetToPorcelain(plumbing *proto.MongoReplicaSet) (*MongoReplicaSet, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &MongoReplicaSet{}
	porcelain.AuthDatabase = plumbing.AuthDatabase
	porcelain.ConnectToReplica = plumbing.ConnectToReplica
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ReplicaSet = plumbing.ReplicaSet
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertMongoReplicaSetToPlumbing(porcelain *MongoReplicaSet) *proto.MongoReplicaSet {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.MongoReplicaSet{}
	plumbing.AuthDatabase = (porcelain.AuthDatabase)
	plumbing.ConnectToReplica = (porcelain.ConnectToReplica)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ReplicaSet = (porcelain.ReplicaSet)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedMongoReplicaSetToPlumbing(
	porcelains []*MongoReplicaSet,
) []*proto.MongoReplicaSet {
	var items []*proto.MongoReplicaSet
	for _, porcelain := range porcelains {
		items = append(items, convertMongoReplicaSetToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMongoReplicaSetToPorcelain(plumbings []*proto.MongoReplicaSet) (
	[]*MongoReplicaSet,
	error,
) {
	var items []*MongoReplicaSet
	for _, plumbing := range plumbings {
		if v, err := convertMongoReplicaSetToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertMongoShardedClusterToPorcelain(plumbing *proto.MongoShardedCluster) (*MongoShardedCluster, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &MongoShardedCluster{}
	porcelain.AuthDatabase = plumbing.AuthDatabase
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertMongoShardedClusterToPlumbing(porcelain *MongoShardedCluster) *proto.MongoShardedCluster {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.MongoShardedCluster{}
	plumbing.AuthDatabase = (porcelain.AuthDatabase)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedMongoShardedClusterToPlumbing(
	porcelains []*MongoShardedCluster,
) []*proto.MongoShardedCluster {
	var items []*proto.MongoShardedCluster
	for _, porcelain := range porcelains {
		items = append(items, convertMongoShardedClusterToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMongoShardedClusterToPorcelain(plumbings []*proto.MongoShardedCluster) (
	[]*MongoShardedCluster,
	error,
) {
	var items []*MongoShardedCluster
	for _, plumbing := range plumbings {
		if v, err := convertMongoShardedClusterToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertMysqlToPorcelain(plumbing *proto.Mysql) (*Mysql, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Mysql{}
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertMysqlToPlumbing(porcelain *Mysql) *proto.Mysql {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Mysql{}
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedMysqlToPlumbing(
	porcelains []*Mysql,
) []*proto.Mysql {
	var items []*proto.Mysql
	for _, porcelain := range porcelains {
		items = append(items, convertMysqlToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMysqlToPorcelain(plumbings []*proto.Mysql) (
	[]*Mysql,
	error,
) {
	var items []*Mysql
	for _, plumbing := range plumbings {
		if v, err := convertMysqlToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertNeptuneToPorcelain(plumbing *proto.Neptune) (*Neptune, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Neptune{}
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Endpoint = plumbing.Endpoint
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertNeptuneToPlumbing(porcelain *Neptune) *proto.Neptune {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Neptune{}
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedNeptuneToPlumbing(
	porcelains []*Neptune,
) []*proto.Neptune {
	var items []*proto.Neptune
	for _, porcelain := range porcelains {
		items = append(items, convertNeptuneToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedNeptuneToPorcelain(plumbings []*proto.Neptune) (
	[]*Neptune,
	error,
) {
	var items []*Neptune
	for _, plumbing := range plumbings {
		if v, err := convertNeptuneToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertNeptuneIAMToPorcelain(plumbing *proto.NeptuneIAM) (*NeptuneIAM, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &NeptuneIAM{}
	porcelain.AccessKey = plumbing.AccessKey
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Endpoint = plumbing.Endpoint
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.Region = plumbing.Region
	porcelain.RoleArn = plumbing.RoleArn
	porcelain.RoleExternalID = plumbing.RoleExternalId
	porcelain.SecretAccessKey = plumbing.SecretAccessKey
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertNeptuneIAMToPlumbing(porcelain *NeptuneIAM) *proto.NeptuneIAM {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.NeptuneIAM{}
	plumbing.AccessKey = (porcelain.AccessKey)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Region = (porcelain.Region)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	plumbing.SecretAccessKey = (porcelain.SecretAccessKey)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedNeptuneIAMToPlumbing(
	porcelains []*NeptuneIAM,
) []*proto.NeptuneIAM {
	var items []*proto.NeptuneIAM
	for _, porcelain := range porcelains {
		items = append(items, convertNeptuneIAMToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedNeptuneIAMToPorcelain(plumbings []*proto.NeptuneIAM) (
	[]*NeptuneIAM,
	error,
) {
	var items []*NeptuneIAM
	for _, plumbing := range plumbings {
		if v, err := convertNeptuneIAMToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertNodeToPlumbing(porcelain Node) *proto.Node {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Node{}

	switch v := porcelain.(type) {
	case *Gateway:
		plumbing.Node = &proto.Node_Gateway{Gateway: convertGatewayToPlumbing(v)}
	case *Relay:
		plumbing.Node = &proto.Node_Relay{Relay: convertRelayToPlumbing(v)}
	}
	return plumbing
}

func convertNodeToPorcelain(plumbing *proto.Node) (Node, error) {
	if plumbing.GetGateway() != nil {
		return convertGatewayToPorcelain(plumbing.GetGateway())
	}
	if plumbing.GetRelay() != nil {
		return convertRelayToPorcelain(plumbing.GetRelay())
	}
	return nil, &UnknownError{Wrapped: fmt.Errorf("unknown polymorphic type, please upgrade your SDK")}
}
func convertRepeatedNodeToPlumbing(
	porcelains []Node,
) []*proto.Node {
	var items []*proto.Node
	for _, porcelain := range porcelains {
		items = append(items, convertNodeToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedNodeToPorcelain(plumbings []*proto.Node) (
	[]Node,
	error,
) {
	var items []Node
	for _, plumbing := range plumbings {
		if v, err := convertNodeToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertNodeCreateResponseToPorcelain(plumbing *proto.NodeCreateResponse) (*NodeCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &NodeCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertNodeToPorcelain(plumbing.Node); err != nil {
		return nil, fmt.Errorf("error converting field Node: %v", err)
	} else {
		porcelain.Node = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	porcelain.Token = plumbing.Token
	return porcelain, nil
}

func convertNodeCreateResponseToPlumbing(porcelain *NodeCreateResponse) *proto.NodeCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.NodeCreateResponse{}
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.Node = convertNodeToPlumbing(porcelain.Node)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.Token = (porcelain.Token)
	return plumbing
}
func convertRepeatedNodeCreateResponseToPlumbing(
	porcelains []*NodeCreateResponse,
) []*proto.NodeCreateResponse {
	var items []*proto.NodeCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertNodeCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedNodeCreateResponseToPorcelain(plumbings []*proto.NodeCreateResponse) (
	[]*NodeCreateResponse,
	error,
) {
	var items []*NodeCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertNodeCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertNodeDeleteResponseToPorcelain(plumbing *proto.NodeDeleteResponse) (*NodeDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &NodeDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertNodeDeleteResponseToPlumbing(porcelain *NodeDeleteResponse) *proto.NodeDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.NodeDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedNodeDeleteResponseToPlumbing(
	porcelains []*NodeDeleteResponse,
) []*proto.NodeDeleteResponse {
	var items []*proto.NodeDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertNodeDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedNodeDeleteResponseToPorcelain(plumbings []*proto.NodeDeleteResponse) (
	[]*NodeDeleteResponse,
	error,
) {
	var items []*NodeDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertNodeDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertNodeGetResponseToPorcelain(plumbing *proto.NodeGetResponse) (*NodeGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &NodeGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertNodeToPorcelain(plumbing.Node); err != nil {
		return nil, fmt.Errorf("error converting field Node: %v", err)
	} else {
		porcelain.Node = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertNodeGetResponseToPlumbing(porcelain *NodeGetResponse) *proto.NodeGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.NodeGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.Node = convertNodeToPlumbing(porcelain.Node)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedNodeGetResponseToPlumbing(
	porcelains []*NodeGetResponse,
) []*proto.NodeGetResponse {
	var items []*proto.NodeGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertNodeGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedNodeGetResponseToPorcelain(plumbings []*proto.NodeGetResponse) (
	[]*NodeGetResponse,
	error,
) {
	var items []*NodeGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertNodeGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertNodeUpdateResponseToPorcelain(plumbing *proto.NodeUpdateResponse) (*NodeUpdateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &NodeUpdateResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertNodeToPorcelain(plumbing.Node); err != nil {
		return nil, fmt.Errorf("error converting field Node: %v", err)
	} else {
		porcelain.Node = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertNodeUpdateResponseToPlumbing(porcelain *NodeUpdateResponse) *proto.NodeUpdateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.NodeUpdateResponse{}
	plumbing.Meta = convertUpdateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.Node = convertNodeToPlumbing(porcelain.Node)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedNodeUpdateResponseToPlumbing(
	porcelains []*NodeUpdateResponse,
) []*proto.NodeUpdateResponse {
	var items []*proto.NodeUpdateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertNodeUpdateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedNodeUpdateResponseToPorcelain(plumbings []*proto.NodeUpdateResponse) (
	[]*NodeUpdateResponse,
	error,
) {
	var items []*NodeUpdateResponse
	for _, plumbing := range plumbings {
		if v, err := convertNodeUpdateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertOracleToPorcelain(plumbing *proto.Oracle) (*Oracle, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Oracle{}
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertOracleToPlumbing(porcelain *Oracle) *proto.Oracle {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Oracle{}
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedOracleToPlumbing(
	porcelains []*Oracle,
) []*proto.Oracle {
	var items []*proto.Oracle
	for _, porcelain := range porcelains {
		items = append(items, convertOracleToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedOracleToPorcelain(plumbings []*proto.Oracle) (
	[]*Oracle,
	error,
) {
	var items []*Oracle
	for _, plumbing := range plumbings {
		if v, err := convertOracleToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPostgresToPorcelain(plumbing *proto.Postgres) (*Postgres, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Postgres{}
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.OverrideDatabase = plumbing.OverrideDatabase
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertPostgresToPlumbing(porcelain *Postgres) *proto.Postgres {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Postgres{}
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedPostgresToPlumbing(
	porcelains []*Postgres,
) []*proto.Postgres {
	var items []*proto.Postgres
	for _, porcelain := range porcelains {
		items = append(items, convertPostgresToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPostgresToPorcelain(plumbings []*proto.Postgres) (
	[]*Postgres,
	error,
) {
	var items []*Postgres
	for _, plumbing := range plumbings {
		if v, err := convertPostgresToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPrestoToPorcelain(plumbing *proto.Presto) (*Presto, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Presto{}
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertPrestoToPlumbing(porcelain *Presto) *proto.Presto {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Presto{}
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedPrestoToPlumbing(
	porcelains []*Presto,
) []*proto.Presto {
	var items []*proto.Presto
	for _, porcelain := range porcelains {
		items = append(items, convertPrestoToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPrestoToPorcelain(plumbings []*proto.Presto) (
	[]*Presto,
	error,
) {
	var items []*Presto
	for _, plumbing := range plumbings {
		if v, err := convertPrestoToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRDPToPorcelain(plumbing *proto.RDP) (*RDP, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RDP{}
	porcelain.DowngradeNlaConnections = plumbing.DowngradeNlaConnections
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertRDPToPlumbing(porcelain *RDP) *proto.RDP {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RDP{}
	plumbing.DowngradeNlaConnections = (porcelain.DowngradeNlaConnections)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedRDPToPlumbing(
	porcelains []*RDP,
) []*proto.RDP {
	var items []*proto.RDP
	for _, porcelain := range porcelains {
		items = append(items, convertRDPToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRDPToPorcelain(plumbings []*proto.RDP) (
	[]*RDP,
	error,
) {
	var items []*RDP
	for _, plumbing := range plumbings {
		if v, err := convertRDPToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRabbitMQAMQP091ToPorcelain(plumbing *proto.RabbitMQAMQP091) (*RabbitMQAMQP091, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RabbitMQAMQP091{}
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertRabbitMQAMQP091ToPlumbing(porcelain *RabbitMQAMQP091) *proto.RabbitMQAMQP091 {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RabbitMQAMQP091{}
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedRabbitMQAMQP091ToPlumbing(
	porcelains []*RabbitMQAMQP091,
) []*proto.RabbitMQAMQP091 {
	var items []*proto.RabbitMQAMQP091
	for _, porcelain := range porcelains {
		items = append(items, convertRabbitMQAMQP091ToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRabbitMQAMQP091ToPorcelain(plumbings []*proto.RabbitMQAMQP091) (
	[]*RabbitMQAMQP091,
	error,
) {
	var items []*RabbitMQAMQP091
	for _, plumbing := range plumbings {
		if v, err := convertRabbitMQAMQP091ToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRateLimitMetadataToPorcelain(plumbing *proto.RateLimitMetadata) (*RateLimitMetadata, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RateLimitMetadata{}
	porcelain.Bucket = plumbing.Bucket
	porcelain.Limit = plumbing.Limit
	porcelain.Remaining = plumbing.Remaining
	if v, err := convertTimestampToPorcelain(plumbing.ResetAt); err != nil {
		return nil, fmt.Errorf("error converting field ResetAt: %v", err)
	} else {
		porcelain.ResetAt = v
	}
	return porcelain, nil
}

func convertRateLimitMetadataToPlumbing(porcelain *RateLimitMetadata) *proto.RateLimitMetadata {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RateLimitMetadata{}
	plumbing.Bucket = (porcelain.Bucket)
	plumbing.Limit = (porcelain.Limit)
	plumbing.Remaining = (porcelain.Remaining)
	plumbing.ResetAt = convertTimestampToPlumbing(porcelain.ResetAt)
	return plumbing
}
func convertRepeatedRateLimitMetadataToPlumbing(
	porcelains []*RateLimitMetadata,
) []*proto.RateLimitMetadata {
	var items []*proto.RateLimitMetadata
	for _, porcelain := range porcelains {
		items = append(items, convertRateLimitMetadataToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRateLimitMetadataToPorcelain(plumbings []*proto.RateLimitMetadata) (
	[]*RateLimitMetadata,
	error,
) {
	var items []*RateLimitMetadata
	for _, plumbing := range plumbings {
		if v, err := convertRateLimitMetadataToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRawTCPToPorcelain(plumbing *proto.RawTCP) (*RawTCP, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RawTCP{}
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertRawTCPToPlumbing(porcelain *RawTCP) *proto.RawTCP {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RawTCP{}
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedRawTCPToPlumbing(
	porcelains []*RawTCP,
) []*proto.RawTCP {
	var items []*proto.RawTCP
	for _, porcelain := range porcelains {
		items = append(items, convertRawTCPToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRawTCPToPorcelain(plumbings []*proto.RawTCP) (
	[]*RawTCP,
	error,
) {
	var items []*RawTCP
	for _, plumbing := range plumbings {
		if v, err := convertRawTCPToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRedisToPorcelain(plumbing *proto.Redis) (*Redis, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Redis{}
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertRedisToPlumbing(porcelain *Redis) *proto.Redis {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Redis{}
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedRedisToPlumbing(
	porcelains []*Redis,
) []*proto.Redis {
	var items []*proto.Redis
	for _, porcelain := range porcelains {
		items = append(items, convertRedisToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRedisToPorcelain(plumbings []*proto.Redis) (
	[]*Redis,
	error,
) {
	var items []*Redis
	for _, plumbing := range plumbings {
		if v, err := convertRedisToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRedshiftToPorcelain(plumbing *proto.Redshift) (*Redshift, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Redshift{}
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.OverrideDatabase = plumbing.OverrideDatabase
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertRedshiftToPlumbing(porcelain *Redshift) *proto.Redshift {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Redshift{}
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedRedshiftToPlumbing(
	porcelains []*Redshift,
) []*proto.Redshift {
	var items []*proto.Redshift
	for _, porcelain := range porcelains {
		items = append(items, convertRedshiftToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRedshiftToPorcelain(plumbings []*proto.Redshift) (
	[]*Redshift,
	error,
) {
	var items []*Redshift
	for _, plumbing := range plumbings {
		if v, err := convertRedshiftToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRelayToPorcelain(plumbing *proto.Relay) (*Relay, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Relay{}
	porcelain.GatewayFilter = plumbing.GatewayFilter
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.State = plumbing.State
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertRelayToPlumbing(porcelain *Relay) *proto.Relay {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Relay{}
	plumbing.GatewayFilter = (porcelain.GatewayFilter)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.State = (porcelain.State)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedRelayToPlumbing(
	porcelains []*Relay,
) []*proto.Relay {
	var items []*proto.Relay
	for _, porcelain := range porcelains {
		items = append(items, convertRelayToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRelayToPorcelain(plumbings []*proto.Relay) (
	[]*Relay,
	error,
) {
	var items []*Relay
	for _, plumbing := range plumbings {
		if v, err := convertRelayToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertResourceToPlumbing(porcelain Resource) *proto.Resource {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Resource{}

	switch v := porcelain.(type) {
	case *AKS:
		plumbing.Resource = &proto.Resource_Aks{Aks: convertAKSToPlumbing(v)}
	case *AKSBasicAuth:
		plumbing.Resource = &proto.Resource_AksBasicAuth{AksBasicAuth: convertAKSBasicAuthToPlumbing(v)}
	case *AKSServiceAccount:
		plumbing.Resource = &proto.Resource_AksServiceAccount{AksServiceAccount: convertAKSServiceAccountToPlumbing(v)}
	case *AKSServiceAccountUserImpersonation:
		plumbing.Resource = &proto.Resource_AksServiceAccountUserImpersonation{AksServiceAccountUserImpersonation: convertAKSServiceAccountUserImpersonationToPlumbing(v)}
	case *AKSUserImpersonation:
		plumbing.Resource = &proto.Resource_AksUserImpersonation{AksUserImpersonation: convertAKSUserImpersonationToPlumbing(v)}
	case *AmazonEKS:
		plumbing.Resource = &proto.Resource_AmazonEks{AmazonEks: convertAmazonEKSToPlumbing(v)}
	case *AmazonEKSUserImpersonation:
		plumbing.Resource = &proto.Resource_AmazonEksUserImpersonation{AmazonEksUserImpersonation: convertAmazonEKSUserImpersonationToPlumbing(v)}
	case *AmazonES:
		plumbing.Resource = &proto.Resource_AmazonEs{AmazonEs: convertAmazonESToPlumbing(v)}
	case *AmazonMQAMQP091:
		plumbing.Resource = &proto.Resource_AmazonMqamqp_091{AmazonMqamqp_091: convertAmazonMQAMQP091ToPlumbing(v)}
	case *Athena:
		plumbing.Resource = &proto.Resource_Athena{Athena: convertAthenaToPlumbing(v)}
	case *AuroraMysql:
		plumbing.Resource = &proto.Resource_AuroraMysql{AuroraMysql: convertAuroraMysqlToPlumbing(v)}
	case *AuroraPostgres:
		plumbing.Resource = &proto.Resource_AuroraPostgres{AuroraPostgres: convertAuroraPostgresToPlumbing(v)}
	case *AWS:
		plumbing.Resource = &proto.Resource_Aws{Aws: convertAWSToPlumbing(v)}
	case *Azure:
		plumbing.Resource = &proto.Resource_Azure{Azure: convertAzureToPlumbing(v)}
	case *AzureCertificate:
		plumbing.Resource = &proto.Resource_AzureCertificate{AzureCertificate: convertAzureCertificateToPlumbing(v)}
	case *AzurePostgres:
		plumbing.Resource = &proto.Resource_AzurePostgres{AzurePostgres: convertAzurePostgresToPlumbing(v)}
	case *BigQuery:
		plumbing.Resource = &proto.Resource_BigQuery{BigQuery: convertBigQueryToPlumbing(v)}
	case *Cassandra:
		plumbing.Resource = &proto.Resource_Cassandra{Cassandra: convertCassandraToPlumbing(v)}
	case *Citus:
		plumbing.Resource = &proto.Resource_Citus{Citus: convertCitusToPlumbing(v)}
	case *Clustrix:
		plumbing.Resource = &proto.Resource_Clustrix{Clustrix: convertClustrixToPlumbing(v)}
	case *Cockroach:
		plumbing.Resource = &proto.Resource_Cockroach{Cockroach: convertCockroachToPlumbing(v)}
	case *DB2I:
		plumbing.Resource = &proto.Resource_Db_2I{Db_2I: convertDB2IToPlumbing(v)}
	case *DB2LUW:
		plumbing.Resource = &proto.Resource_Db_2Luw{Db_2Luw: convertDB2LUWToPlumbing(v)}
	case *DocumentDBHost:
		plumbing.Resource = &proto.Resource_DocumentDbHost{DocumentDbHost: convertDocumentDBHostToPlumbing(v)}
	case *DocumentDBReplicaSet:
		plumbing.Resource = &proto.Resource_DocumentDbReplicaSet{DocumentDbReplicaSet: convertDocumentDBReplicaSetToPlumbing(v)}
	case *Druid:
		plumbing.Resource = &proto.Resource_Druid{Druid: convertDruidToPlumbing(v)}
	case *DynamoDB:
		plumbing.Resource = &proto.Resource_DynamoDb{DynamoDb: convertDynamoDBToPlumbing(v)}
	case *Elastic:
		plumbing.Resource = &proto.Resource_Elastic{Elastic: convertElasticToPlumbing(v)}
	case *ElasticacheRedis:
		plumbing.Resource = &proto.Resource_ElasticacheRedis{ElasticacheRedis: convertElasticacheRedisToPlumbing(v)}
	case *GCP:
		plumbing.Resource = &proto.Resource_Gcp{Gcp: convertGCPToPlumbing(v)}
	case *GoogleGKE:
		plumbing.Resource = &proto.Resource_GoogleGke{GoogleGke: convertGoogleGKEToPlumbing(v)}
	case *GoogleGKEUserImpersonation:
		plumbing.Resource = &proto.Resource_GoogleGkeUserImpersonation{GoogleGkeUserImpersonation: convertGoogleGKEUserImpersonationToPlumbing(v)}
	case *Greenplum:
		plumbing.Resource = &proto.Resource_Greenplum{Greenplum: convertGreenplumToPlumbing(v)}
	case *HTTPAuth:
		plumbing.Resource = &proto.Resource_HttpAuth{HttpAuth: convertHTTPAuthToPlumbing(v)}
	case *HTTPBasicAuth:
		plumbing.Resource = &proto.Resource_HttpBasicAuth{HttpBasicAuth: convertHTTPBasicAuthToPlumbing(v)}
	case *HTTPNoAuth:
		plumbing.Resource = &proto.Resource_HttpNoAuth{HttpNoAuth: convertHTTPNoAuthToPlumbing(v)}
	case *Kubernetes:
		plumbing.Resource = &proto.Resource_Kubernetes{Kubernetes: convertKubernetesToPlumbing(v)}
	case *KubernetesBasicAuth:
		plumbing.Resource = &proto.Resource_KubernetesBasicAuth{KubernetesBasicAuth: convertKubernetesBasicAuthToPlumbing(v)}
	case *KubernetesServiceAccount:
		plumbing.Resource = &proto.Resource_KubernetesServiceAccount{KubernetesServiceAccount: convertKubernetesServiceAccountToPlumbing(v)}
	case *KubernetesServiceAccountUserImpersonation:
		plumbing.Resource = &proto.Resource_KubernetesServiceAccountUserImpersonation{KubernetesServiceAccountUserImpersonation: convertKubernetesServiceAccountUserImpersonationToPlumbing(v)}
	case *KubernetesUserImpersonation:
		plumbing.Resource = &proto.Resource_KubernetesUserImpersonation{KubernetesUserImpersonation: convertKubernetesUserImpersonationToPlumbing(v)}
	case *Maria:
		plumbing.Resource = &proto.Resource_Maria{Maria: convertMariaToPlumbing(v)}
	case *Memcached:
		plumbing.Resource = &proto.Resource_Memcached{Memcached: convertMemcachedToPlumbing(v)}
	case *Memsql:
		plumbing.Resource = &proto.Resource_Memsql{Memsql: convertMemsqlToPlumbing(v)}
	case *MongoHost:
		plumbing.Resource = &proto.Resource_MongoHost{MongoHost: convertMongoHostToPlumbing(v)}
	case *MongoLegacyHost:
		plumbing.Resource = &proto.Resource_MongoLegacyHost{MongoLegacyHost: convertMongoLegacyHostToPlumbing(v)}
	case *MongoLegacyReplicaset:
		plumbing.Resource = &proto.Resource_MongoLegacyReplicaset{MongoLegacyReplicaset: convertMongoLegacyReplicasetToPlumbing(v)}
	case *MongoReplicaSet:
		plumbing.Resource = &proto.Resource_MongoReplicaSet{MongoReplicaSet: convertMongoReplicaSetToPlumbing(v)}
	case *MongoShardedCluster:
		plumbing.Resource = &proto.Resource_MongoShardedCluster{MongoShardedCluster: convertMongoShardedClusterToPlumbing(v)}
	case *MTLSPostgres:
		plumbing.Resource = &proto.Resource_MtlsPostgres{MtlsPostgres: convertMTLSPostgresToPlumbing(v)}
	case *Mysql:
		plumbing.Resource = &proto.Resource_Mysql{Mysql: convertMysqlToPlumbing(v)}
	case *Neptune:
		plumbing.Resource = &proto.Resource_Neptune{Neptune: convertNeptuneToPlumbing(v)}
	case *NeptuneIAM:
		plumbing.Resource = &proto.Resource_NeptuneIam{NeptuneIam: convertNeptuneIAMToPlumbing(v)}
	case *Oracle:
		plumbing.Resource = &proto.Resource_Oracle{Oracle: convertOracleToPlumbing(v)}
	case *Postgres:
		plumbing.Resource = &proto.Resource_Postgres{Postgres: convertPostgresToPlumbing(v)}
	case *Presto:
		plumbing.Resource = &proto.Resource_Presto{Presto: convertPrestoToPlumbing(v)}
	case *RabbitMQAMQP091:
		plumbing.Resource = &proto.Resource_RabbitMqamqp_091{RabbitMqamqp_091: convertRabbitMQAMQP091ToPlumbing(v)}
	case *RawTCP:
		plumbing.Resource = &proto.Resource_RawTcp{RawTcp: convertRawTCPToPlumbing(v)}
	case *RDP:
		plumbing.Resource = &proto.Resource_Rdp{Rdp: convertRDPToPlumbing(v)}
	case *Redis:
		plumbing.Resource = &proto.Resource_Redis{Redis: convertRedisToPlumbing(v)}
	case *Redshift:
		plumbing.Resource = &proto.Resource_Redshift{Redshift: convertRedshiftToPlumbing(v)}
	case *SingleStore:
		plumbing.Resource = &proto.Resource_SingleStore{SingleStore: convertSingleStoreToPlumbing(v)}
	case *Snowflake:
		plumbing.Resource = &proto.Resource_Snowflake{Snowflake: convertSnowflakeToPlumbing(v)}
	case *SQLServer:
		plumbing.Resource = &proto.Resource_SqlServer{SqlServer: convertSQLServerToPlumbing(v)}
	case *SSH:
		plumbing.Resource = &proto.Resource_Ssh{Ssh: convertSSHToPlumbing(v)}
	case *SSHCert:
		plumbing.Resource = &proto.Resource_SshCert{SshCert: convertSSHCertToPlumbing(v)}
	case *SSHCustomerKey:
		plumbing.Resource = &proto.Resource_SshCustomerKey{SshCustomerKey: convertSSHCustomerKeyToPlumbing(v)}
	case *Sybase:
		plumbing.Resource = &proto.Resource_Sybase{Sybase: convertSybaseToPlumbing(v)}
	case *SybaseIQ:
		plumbing.Resource = &proto.Resource_SybaseIq{SybaseIq: convertSybaseIQToPlumbing(v)}
	case *Teradata:
		plumbing.Resource = &proto.Resource_Teradata{Teradata: convertTeradataToPlumbing(v)}
	}
	return plumbing
}

func convertResourceToPorcelain(plumbing *proto.Resource) (Resource, error) {
	if plumbing.GetAks() != nil {
		return convertAKSToPorcelain(plumbing.GetAks())
	}
	if plumbing.GetAksBasicAuth() != nil {
		return convertAKSBasicAuthToPorcelain(plumbing.GetAksBasicAuth())
	}
	if plumbing.GetAksServiceAccount() != nil {
		return convertAKSServiceAccountToPorcelain(plumbing.GetAksServiceAccount())
	}
	if plumbing.GetAksServiceAccountUserImpersonation() != nil {
		return convertAKSServiceAccountUserImpersonationToPorcelain(plumbing.GetAksServiceAccountUserImpersonation())
	}
	if plumbing.GetAksUserImpersonation() != nil {
		return convertAKSUserImpersonationToPorcelain(plumbing.GetAksUserImpersonation())
	}
	if plumbing.GetAmazonEks() != nil {
		return convertAmazonEKSToPorcelain(plumbing.GetAmazonEks())
	}
	if plumbing.GetAmazonEksUserImpersonation() != nil {
		return convertAmazonEKSUserImpersonationToPorcelain(plumbing.GetAmazonEksUserImpersonation())
	}
	if plumbing.GetAmazonEs() != nil {
		return convertAmazonESToPorcelain(plumbing.GetAmazonEs())
	}
	if plumbing.GetAmazonMqamqp_091() != nil {
		return convertAmazonMQAMQP091ToPorcelain(plumbing.GetAmazonMqamqp_091())
	}
	if plumbing.GetAthena() != nil {
		return convertAthenaToPorcelain(plumbing.GetAthena())
	}
	if plumbing.GetAuroraMysql() != nil {
		return convertAuroraMysqlToPorcelain(plumbing.GetAuroraMysql())
	}
	if plumbing.GetAuroraPostgres() != nil {
		return convertAuroraPostgresToPorcelain(plumbing.GetAuroraPostgres())
	}
	if plumbing.GetAws() != nil {
		return convertAWSToPorcelain(plumbing.GetAws())
	}
	if plumbing.GetAzure() != nil {
		return convertAzureToPorcelain(plumbing.GetAzure())
	}
	if plumbing.GetAzureCertificate() != nil {
		return convertAzureCertificateToPorcelain(plumbing.GetAzureCertificate())
	}
	if plumbing.GetAzurePostgres() != nil {
		return convertAzurePostgresToPorcelain(plumbing.GetAzurePostgres())
	}
	if plumbing.GetBigQuery() != nil {
		return convertBigQueryToPorcelain(plumbing.GetBigQuery())
	}
	if plumbing.GetCassandra() != nil {
		return convertCassandraToPorcelain(plumbing.GetCassandra())
	}
	if plumbing.GetCitus() != nil {
		return convertCitusToPorcelain(plumbing.GetCitus())
	}
	if plumbing.GetClustrix() != nil {
		return convertClustrixToPorcelain(plumbing.GetClustrix())
	}
	if plumbing.GetCockroach() != nil {
		return convertCockroachToPorcelain(plumbing.GetCockroach())
	}
	if plumbing.GetDb_2I() != nil {
		return convertDB2IToPorcelain(plumbing.GetDb_2I())
	}
	if plumbing.GetDb_2Luw() != nil {
		return convertDB2LUWToPorcelain(plumbing.GetDb_2Luw())
	}
	if plumbing.GetDocumentDbHost() != nil {
		return convertDocumentDBHostToPorcelain(plumbing.GetDocumentDbHost())
	}
	if plumbing.GetDocumentDbReplicaSet() != nil {
		return convertDocumentDBReplicaSetToPorcelain(plumbing.GetDocumentDbReplicaSet())
	}
	if plumbing.GetDruid() != nil {
		return convertDruidToPorcelain(plumbing.GetDruid())
	}
	if plumbing.GetDynamoDb() != nil {
		return convertDynamoDBToPorcelain(plumbing.GetDynamoDb())
	}
	if plumbing.GetElastic() != nil {
		return convertElasticToPorcelain(plumbing.GetElastic())
	}
	if plumbing.GetElasticacheRedis() != nil {
		return convertElasticacheRedisToPorcelain(plumbing.GetElasticacheRedis())
	}
	if plumbing.GetGcp() != nil {
		return convertGCPToPorcelain(plumbing.GetGcp())
	}
	if plumbing.GetGoogleGke() != nil {
		return convertGoogleGKEToPorcelain(plumbing.GetGoogleGke())
	}
	if plumbing.GetGoogleGkeUserImpersonation() != nil {
		return convertGoogleGKEUserImpersonationToPorcelain(plumbing.GetGoogleGkeUserImpersonation())
	}
	if plumbing.GetGreenplum() != nil {
		return convertGreenplumToPorcelain(plumbing.GetGreenplum())
	}
	if plumbing.GetHttpAuth() != nil {
		return convertHTTPAuthToPorcelain(plumbing.GetHttpAuth())
	}
	if plumbing.GetHttpBasicAuth() != nil {
		return convertHTTPBasicAuthToPorcelain(plumbing.GetHttpBasicAuth())
	}
	if plumbing.GetHttpNoAuth() != nil {
		return convertHTTPNoAuthToPorcelain(plumbing.GetHttpNoAuth())
	}
	if plumbing.GetKubernetes() != nil {
		return convertKubernetesToPorcelain(plumbing.GetKubernetes())
	}
	if plumbing.GetKubernetesBasicAuth() != nil {
		return convertKubernetesBasicAuthToPorcelain(plumbing.GetKubernetesBasicAuth())
	}
	if plumbing.GetKubernetesServiceAccount() != nil {
		return convertKubernetesServiceAccountToPorcelain(plumbing.GetKubernetesServiceAccount())
	}
	if plumbing.GetKubernetesServiceAccountUserImpersonation() != nil {
		return convertKubernetesServiceAccountUserImpersonationToPorcelain(plumbing.GetKubernetesServiceAccountUserImpersonation())
	}
	if plumbing.GetKubernetesUserImpersonation() != nil {
		return convertKubernetesUserImpersonationToPorcelain(plumbing.GetKubernetesUserImpersonation())
	}
	if plumbing.GetMaria() != nil {
		return convertMariaToPorcelain(plumbing.GetMaria())
	}
	if plumbing.GetMemcached() != nil {
		return convertMemcachedToPorcelain(plumbing.GetMemcached())
	}
	if plumbing.GetMemsql() != nil {
		return convertMemsqlToPorcelain(plumbing.GetMemsql())
	}
	if plumbing.GetMongoHost() != nil {
		return convertMongoHostToPorcelain(plumbing.GetMongoHost())
	}
	if plumbing.GetMongoLegacyHost() != nil {
		return convertMongoLegacyHostToPorcelain(plumbing.GetMongoLegacyHost())
	}
	if plumbing.GetMongoLegacyReplicaset() != nil {
		return convertMongoLegacyReplicasetToPorcelain(plumbing.GetMongoLegacyReplicaset())
	}
	if plumbing.GetMongoReplicaSet() != nil {
		return convertMongoReplicaSetToPorcelain(plumbing.GetMongoReplicaSet())
	}
	if plumbing.GetMongoShardedCluster() != nil {
		return convertMongoShardedClusterToPorcelain(plumbing.GetMongoShardedCluster())
	}
	if plumbing.GetMtlsPostgres() != nil {
		return convertMTLSPostgresToPorcelain(plumbing.GetMtlsPostgres())
	}
	if plumbing.GetMysql() != nil {
		return convertMysqlToPorcelain(plumbing.GetMysql())
	}
	if plumbing.GetNeptune() != nil {
		return convertNeptuneToPorcelain(plumbing.GetNeptune())
	}
	if plumbing.GetNeptuneIam() != nil {
		return convertNeptuneIAMToPorcelain(plumbing.GetNeptuneIam())
	}
	if plumbing.GetOracle() != nil {
		return convertOracleToPorcelain(plumbing.GetOracle())
	}
	if plumbing.GetPostgres() != nil {
		return convertPostgresToPorcelain(plumbing.GetPostgres())
	}
	if plumbing.GetPresto() != nil {
		return convertPrestoToPorcelain(plumbing.GetPresto())
	}
	if plumbing.GetRabbitMqamqp_091() != nil {
		return convertRabbitMQAMQP091ToPorcelain(plumbing.GetRabbitMqamqp_091())
	}
	if plumbing.GetRawTcp() != nil {
		return convertRawTCPToPorcelain(plumbing.GetRawTcp())
	}
	if plumbing.GetRdp() != nil {
		return convertRDPToPorcelain(plumbing.GetRdp())
	}
	if plumbing.GetRedis() != nil {
		return convertRedisToPorcelain(plumbing.GetRedis())
	}
	if plumbing.GetRedshift() != nil {
		return convertRedshiftToPorcelain(plumbing.GetRedshift())
	}
	if plumbing.GetSingleStore() != nil {
		return convertSingleStoreToPorcelain(plumbing.GetSingleStore())
	}
	if plumbing.GetSnowflake() != nil {
		return convertSnowflakeToPorcelain(plumbing.GetSnowflake())
	}
	if plumbing.GetSqlServer() != nil {
		return convertSQLServerToPorcelain(plumbing.GetSqlServer())
	}
	if plumbing.GetSsh() != nil {
		return convertSSHToPorcelain(plumbing.GetSsh())
	}
	if plumbing.GetSshCert() != nil {
		return convertSSHCertToPorcelain(plumbing.GetSshCert())
	}
	if plumbing.GetSshCustomerKey() != nil {
		return convertSSHCustomerKeyToPorcelain(plumbing.GetSshCustomerKey())
	}
	if plumbing.GetSybase() != nil {
		return convertSybaseToPorcelain(plumbing.GetSybase())
	}
	if plumbing.GetSybaseIq() != nil {
		return convertSybaseIQToPorcelain(plumbing.GetSybaseIq())
	}
	if plumbing.GetTeradata() != nil {
		return convertTeradataToPorcelain(plumbing.GetTeradata())
	}
	return nil, &UnknownError{Wrapped: fmt.Errorf("unknown polymorphic type, please upgrade your SDK")}
}
func convertRepeatedResourceToPlumbing(
	porcelains []Resource,
) []*proto.Resource {
	var items []*proto.Resource
	for _, porcelain := range porcelains {
		items = append(items, convertResourceToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedResourceToPorcelain(plumbings []*proto.Resource) (
	[]Resource,
	error,
) {
	var items []Resource
	for _, plumbing := range plumbings {
		if v, err := convertResourceToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertResourceCreateResponseToPorcelain(plumbing *proto.ResourceCreateResponse) (*ResourceCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ResourceCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertResourceToPorcelain(plumbing.Resource); err != nil {
		return nil, fmt.Errorf("error converting field Resource: %v", err)
	} else {
		porcelain.Resource = v
	}
	return porcelain, nil
}

func convertResourceCreateResponseToPlumbing(porcelain *ResourceCreateResponse) *proto.ResourceCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ResourceCreateResponse{}
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.Resource = convertResourceToPlumbing(porcelain.Resource)
	return plumbing
}
func convertRepeatedResourceCreateResponseToPlumbing(
	porcelains []*ResourceCreateResponse,
) []*proto.ResourceCreateResponse {
	var items []*proto.ResourceCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertResourceCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedResourceCreateResponseToPorcelain(plumbings []*proto.ResourceCreateResponse) (
	[]*ResourceCreateResponse,
	error,
) {
	var items []*ResourceCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertResourceCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertResourceDeleteResponseToPorcelain(plumbing *proto.ResourceDeleteResponse) (*ResourceDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ResourceDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertResourceDeleteResponseToPlumbing(porcelain *ResourceDeleteResponse) *proto.ResourceDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ResourceDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedResourceDeleteResponseToPlumbing(
	porcelains []*ResourceDeleteResponse,
) []*proto.ResourceDeleteResponse {
	var items []*proto.ResourceDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertResourceDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedResourceDeleteResponseToPorcelain(plumbings []*proto.ResourceDeleteResponse) (
	[]*ResourceDeleteResponse,
	error,
) {
	var items []*ResourceDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertResourceDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertResourceGetResponseToPorcelain(plumbing *proto.ResourceGetResponse) (*ResourceGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ResourceGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertResourceToPorcelain(plumbing.Resource); err != nil {
		return nil, fmt.Errorf("error converting field Resource: %v", err)
	} else {
		porcelain.Resource = v
	}
	return porcelain, nil
}

func convertResourceGetResponseToPlumbing(porcelain *ResourceGetResponse) *proto.ResourceGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ResourceGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.Resource = convertResourceToPlumbing(porcelain.Resource)
	return plumbing
}
func convertRepeatedResourceGetResponseToPlumbing(
	porcelains []*ResourceGetResponse,
) []*proto.ResourceGetResponse {
	var items []*proto.ResourceGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertResourceGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedResourceGetResponseToPorcelain(plumbings []*proto.ResourceGetResponse) (
	[]*ResourceGetResponse,
	error,
) {
	var items []*ResourceGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertResourceGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertResourceUpdateResponseToPorcelain(plumbing *proto.ResourceUpdateResponse) (*ResourceUpdateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ResourceUpdateResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertResourceToPorcelain(plumbing.Resource); err != nil {
		return nil, fmt.Errorf("error converting field Resource: %v", err)
	} else {
		porcelain.Resource = v
	}
	return porcelain, nil
}

func convertResourceUpdateResponseToPlumbing(porcelain *ResourceUpdateResponse) *proto.ResourceUpdateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ResourceUpdateResponse{}
	plumbing.Meta = convertUpdateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.Resource = convertResourceToPlumbing(porcelain.Resource)
	return plumbing
}
func convertRepeatedResourceUpdateResponseToPlumbing(
	porcelains []*ResourceUpdateResponse,
) []*proto.ResourceUpdateResponse {
	var items []*proto.ResourceUpdateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertResourceUpdateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedResourceUpdateResponseToPorcelain(plumbings []*proto.ResourceUpdateResponse) (
	[]*ResourceUpdateResponse,
	error,
) {
	var items []*ResourceUpdateResponse
	for _, plumbing := range plumbings {
		if v, err := convertResourceUpdateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRoleToPorcelain(plumbing *proto.Role) (*Role, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Role{}
	if v, err := convertAccessRulesToPorcelain(plumbing.AccessRules); err != nil {
		return nil, fmt.Errorf("error converting field AccessRules: %v", err)
	} else {
		porcelain.AccessRules = v
	}
	porcelain.Composite = plumbing.Composite
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertRoleToPlumbing(porcelain *Role) *proto.Role {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Role{}
	plumbing.AccessRules = convertAccessRulesToPlumbing(porcelain.AccessRules)
	plumbing.Composite = (porcelain.Composite)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedRoleToPlumbing(
	porcelains []*Role,
) []*proto.Role {
	var items []*proto.Role
	for _, porcelain := range porcelains {
		items = append(items, convertRoleToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleToPorcelain(plumbings []*proto.Role) (
	[]*Role,
	error,
) {
	var items []*Role
	for _, plumbing := range plumbings {
		if v, err := convertRoleToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRoleAttachmentToPorcelain(plumbing *proto.RoleAttachment) (*RoleAttachment, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RoleAttachment{}
	porcelain.AttachedRoleID = plumbing.AttachedRoleId
	porcelain.CompositeRoleID = plumbing.CompositeRoleId
	porcelain.ID = plumbing.Id
	return porcelain, nil
}

func convertRoleAttachmentToPlumbing(porcelain *RoleAttachment) *proto.RoleAttachment {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleAttachment{}
	plumbing.AttachedRoleId = (porcelain.AttachedRoleID)
	plumbing.CompositeRoleId = (porcelain.CompositeRoleID)
	plumbing.Id = (porcelain.ID)
	return plumbing
}
func convertRepeatedRoleAttachmentToPlumbing(
	porcelains []*RoleAttachment,
) []*proto.RoleAttachment {
	var items []*proto.RoleAttachment
	for _, porcelain := range porcelains {
		items = append(items, convertRoleAttachmentToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleAttachmentToPorcelain(plumbings []*proto.RoleAttachment) (
	[]*RoleAttachment,
	error,
) {
	var items []*RoleAttachment
	for _, plumbing := range plumbings {
		if v, err := convertRoleAttachmentToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRoleAttachmentCreateResponseToPorcelain(plumbing *proto.RoleAttachmentCreateResponse) (*RoleAttachmentCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RoleAttachmentCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertRoleAttachmentToPorcelain(plumbing.RoleAttachment); err != nil {
		return nil, fmt.Errorf("error converting field RoleAttachment: %v", err)
	} else {
		porcelain.RoleAttachment = v
	}
	return porcelain, nil
}

func convertRoleAttachmentCreateResponseToPlumbing(porcelain *RoleAttachmentCreateResponse) *proto.RoleAttachmentCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleAttachmentCreateResponse{}
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.RoleAttachment = convertRoleAttachmentToPlumbing(porcelain.RoleAttachment)
	return plumbing
}
func convertRepeatedRoleAttachmentCreateResponseToPlumbing(
	porcelains []*RoleAttachmentCreateResponse,
) []*proto.RoleAttachmentCreateResponse {
	var items []*proto.RoleAttachmentCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRoleAttachmentCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleAttachmentCreateResponseToPorcelain(plumbings []*proto.RoleAttachmentCreateResponse) (
	[]*RoleAttachmentCreateResponse,
	error,
) {
	var items []*RoleAttachmentCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertRoleAttachmentCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRoleAttachmentDeleteResponseToPorcelain(plumbing *proto.RoleAttachmentDeleteResponse) (*RoleAttachmentDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RoleAttachmentDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertRoleAttachmentDeleteResponseToPlumbing(porcelain *RoleAttachmentDeleteResponse) *proto.RoleAttachmentDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleAttachmentDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedRoleAttachmentDeleteResponseToPlumbing(
	porcelains []*RoleAttachmentDeleteResponse,
) []*proto.RoleAttachmentDeleteResponse {
	var items []*proto.RoleAttachmentDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRoleAttachmentDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleAttachmentDeleteResponseToPorcelain(plumbings []*proto.RoleAttachmentDeleteResponse) (
	[]*RoleAttachmentDeleteResponse,
	error,
) {
	var items []*RoleAttachmentDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertRoleAttachmentDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRoleAttachmentGetResponseToPorcelain(plumbing *proto.RoleAttachmentGetResponse) (*RoleAttachmentGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RoleAttachmentGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertRoleAttachmentToPorcelain(plumbing.RoleAttachment); err != nil {
		return nil, fmt.Errorf("error converting field RoleAttachment: %v", err)
	} else {
		porcelain.RoleAttachment = v
	}
	return porcelain, nil
}

func convertRoleAttachmentGetResponseToPlumbing(porcelain *RoleAttachmentGetResponse) *proto.RoleAttachmentGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleAttachmentGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.RoleAttachment = convertRoleAttachmentToPlumbing(porcelain.RoleAttachment)
	return plumbing
}
func convertRepeatedRoleAttachmentGetResponseToPlumbing(
	porcelains []*RoleAttachmentGetResponse,
) []*proto.RoleAttachmentGetResponse {
	var items []*proto.RoleAttachmentGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRoleAttachmentGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleAttachmentGetResponseToPorcelain(plumbings []*proto.RoleAttachmentGetResponse) (
	[]*RoleAttachmentGetResponse,
	error,
) {
	var items []*RoleAttachmentGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertRoleAttachmentGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRoleCreateResponseToPorcelain(plumbing *proto.RoleCreateResponse) (*RoleCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RoleCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertRoleToPorcelain(plumbing.Role); err != nil {
		return nil, fmt.Errorf("error converting field Role: %v", err)
	} else {
		porcelain.Role = v
	}
	return porcelain, nil
}

func convertRoleCreateResponseToPlumbing(porcelain *RoleCreateResponse) *proto.RoleCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleCreateResponse{}
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.Role = convertRoleToPlumbing(porcelain.Role)
	return plumbing
}
func convertRepeatedRoleCreateResponseToPlumbing(
	porcelains []*RoleCreateResponse,
) []*proto.RoleCreateResponse {
	var items []*proto.RoleCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRoleCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleCreateResponseToPorcelain(plumbings []*proto.RoleCreateResponse) (
	[]*RoleCreateResponse,
	error,
) {
	var items []*RoleCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertRoleCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRoleDeleteResponseToPorcelain(plumbing *proto.RoleDeleteResponse) (*RoleDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RoleDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertRoleDeleteResponseToPlumbing(porcelain *RoleDeleteResponse) *proto.RoleDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedRoleDeleteResponseToPlumbing(
	porcelains []*RoleDeleteResponse,
) []*proto.RoleDeleteResponse {
	var items []*proto.RoleDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRoleDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleDeleteResponseToPorcelain(plumbings []*proto.RoleDeleteResponse) (
	[]*RoleDeleteResponse,
	error,
) {
	var items []*RoleDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertRoleDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRoleGetResponseToPorcelain(plumbing *proto.RoleGetResponse) (*RoleGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RoleGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertRoleToPorcelain(plumbing.Role); err != nil {
		return nil, fmt.Errorf("error converting field Role: %v", err)
	} else {
		porcelain.Role = v
	}
	return porcelain, nil
}

func convertRoleGetResponseToPlumbing(porcelain *RoleGetResponse) *proto.RoleGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.Role = convertRoleToPlumbing(porcelain.Role)
	return plumbing
}
func convertRepeatedRoleGetResponseToPlumbing(
	porcelains []*RoleGetResponse,
) []*proto.RoleGetResponse {
	var items []*proto.RoleGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRoleGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleGetResponseToPorcelain(plumbings []*proto.RoleGetResponse) (
	[]*RoleGetResponse,
	error,
) {
	var items []*RoleGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertRoleGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRoleGrantToPorcelain(plumbing *proto.RoleGrant) (*RoleGrant, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RoleGrant{}
	porcelain.ID = plumbing.Id
	porcelain.ResourceID = plumbing.ResourceId
	porcelain.RoleID = plumbing.RoleId
	return porcelain, nil
}

func convertRoleGrantToPlumbing(porcelain *RoleGrant) *proto.RoleGrant {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleGrant{}
	plumbing.Id = (porcelain.ID)
	plumbing.ResourceId = (porcelain.ResourceID)
	plumbing.RoleId = (porcelain.RoleID)
	return plumbing
}
func convertRepeatedRoleGrantToPlumbing(
	porcelains []*RoleGrant,
) []*proto.RoleGrant {
	var items []*proto.RoleGrant
	for _, porcelain := range porcelains {
		items = append(items, convertRoleGrantToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleGrantToPorcelain(plumbings []*proto.RoleGrant) (
	[]*RoleGrant,
	error,
) {
	var items []*RoleGrant
	for _, plumbing := range plumbings {
		if v, err := convertRoleGrantToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRoleGrantCreateResponseToPorcelain(plumbing *proto.RoleGrantCreateResponse) (*RoleGrantCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RoleGrantCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertRoleGrantToPorcelain(plumbing.RoleGrant); err != nil {
		return nil, fmt.Errorf("error converting field RoleGrant: %v", err)
	} else {
		porcelain.RoleGrant = v
	}
	return porcelain, nil
}

func convertRoleGrantCreateResponseToPlumbing(porcelain *RoleGrantCreateResponse) *proto.RoleGrantCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleGrantCreateResponse{}
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.RoleGrant = convertRoleGrantToPlumbing(porcelain.RoleGrant)
	return plumbing
}
func convertRepeatedRoleGrantCreateResponseToPlumbing(
	porcelains []*RoleGrantCreateResponse,
) []*proto.RoleGrantCreateResponse {
	var items []*proto.RoleGrantCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRoleGrantCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleGrantCreateResponseToPorcelain(plumbings []*proto.RoleGrantCreateResponse) (
	[]*RoleGrantCreateResponse,
	error,
) {
	var items []*RoleGrantCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertRoleGrantCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRoleGrantDeleteResponseToPorcelain(plumbing *proto.RoleGrantDeleteResponse) (*RoleGrantDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RoleGrantDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertRoleGrantDeleteResponseToPlumbing(porcelain *RoleGrantDeleteResponse) *proto.RoleGrantDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleGrantDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedRoleGrantDeleteResponseToPlumbing(
	porcelains []*RoleGrantDeleteResponse,
) []*proto.RoleGrantDeleteResponse {
	var items []*proto.RoleGrantDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRoleGrantDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleGrantDeleteResponseToPorcelain(plumbings []*proto.RoleGrantDeleteResponse) (
	[]*RoleGrantDeleteResponse,
	error,
) {
	var items []*RoleGrantDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertRoleGrantDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRoleGrantGetResponseToPorcelain(plumbing *proto.RoleGrantGetResponse) (*RoleGrantGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RoleGrantGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertRoleGrantToPorcelain(plumbing.RoleGrant); err != nil {
		return nil, fmt.Errorf("error converting field RoleGrant: %v", err)
	} else {
		porcelain.RoleGrant = v
	}
	return porcelain, nil
}

func convertRoleGrantGetResponseToPlumbing(porcelain *RoleGrantGetResponse) *proto.RoleGrantGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleGrantGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.RoleGrant = convertRoleGrantToPlumbing(porcelain.RoleGrant)
	return plumbing
}
func convertRepeatedRoleGrantGetResponseToPlumbing(
	porcelains []*RoleGrantGetResponse,
) []*proto.RoleGrantGetResponse {
	var items []*proto.RoleGrantGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRoleGrantGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleGrantGetResponseToPorcelain(plumbings []*proto.RoleGrantGetResponse) (
	[]*RoleGrantGetResponse,
	error,
) {
	var items []*RoleGrantGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertRoleGrantGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRoleUpdateResponseToPorcelain(plumbing *proto.RoleUpdateResponse) (*RoleUpdateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RoleUpdateResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertRoleToPorcelain(plumbing.Role); err != nil {
		return nil, fmt.Errorf("error converting field Role: %v", err)
	} else {
		porcelain.Role = v
	}
	return porcelain, nil
}

func convertRoleUpdateResponseToPlumbing(porcelain *RoleUpdateResponse) *proto.RoleUpdateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleUpdateResponse{}
	plumbing.Meta = convertUpdateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.Role = convertRoleToPlumbing(porcelain.Role)
	return plumbing
}
func convertRepeatedRoleUpdateResponseToPlumbing(
	porcelains []*RoleUpdateResponse,
) []*proto.RoleUpdateResponse {
	var items []*proto.RoleUpdateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRoleUpdateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleUpdateResponseToPorcelain(plumbings []*proto.RoleUpdateResponse) (
	[]*RoleUpdateResponse,
	error,
) {
	var items []*RoleUpdateResponse
	for _, plumbing := range plumbings {
		if v, err := convertRoleUpdateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSQLServerToPorcelain(plumbing *proto.SQLServer) (*SQLServer, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SQLServer{}
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.OverrideDatabase = plumbing.OverrideDatabase
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.Schema = plumbing.Schema
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertSQLServerToPlumbing(porcelain *SQLServer) *proto.SQLServer {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SQLServer{}
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Schema = (porcelain.Schema)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedSQLServerToPlumbing(
	porcelains []*SQLServer,
) []*proto.SQLServer {
	var items []*proto.SQLServer
	for _, porcelain := range porcelains {
		items = append(items, convertSQLServerToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSQLServerToPorcelain(plumbings []*proto.SQLServer) (
	[]*SQLServer,
	error,
) {
	var items []*SQLServer
	for _, plumbing := range plumbings {
		if v, err := convertSQLServerToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSSHToPorcelain(plumbing *proto.SSH) (*SSH, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SSH{}
	porcelain.AllowDeprecatedKeyExchanges = plumbing.AllowDeprecatedKeyExchanges
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.PortForwarding = plumbing.PortForwarding
	porcelain.PublicKey = plumbing.PublicKey
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertSSHToPlumbing(porcelain *SSH) *proto.SSH {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SSH{}
	plumbing.AllowDeprecatedKeyExchanges = (porcelain.AllowDeprecatedKeyExchanges)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.PortForwarding = (porcelain.PortForwarding)
	plumbing.PublicKey = (porcelain.PublicKey)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedSSHToPlumbing(
	porcelains []*SSH,
) []*proto.SSH {
	var items []*proto.SSH
	for _, porcelain := range porcelains {
		items = append(items, convertSSHToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSSHToPorcelain(plumbings []*proto.SSH) (
	[]*SSH,
	error,
) {
	var items []*SSH
	for _, plumbing := range plumbings {
		if v, err := convertSSHToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSSHCertToPorcelain(plumbing *proto.SSHCert) (*SSHCert, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SSHCert{}
	porcelain.AllowDeprecatedKeyExchanges = plumbing.AllowDeprecatedKeyExchanges
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.PortForwarding = plumbing.PortForwarding
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertSSHCertToPlumbing(porcelain *SSHCert) *proto.SSHCert {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SSHCert{}
	plumbing.AllowDeprecatedKeyExchanges = (porcelain.AllowDeprecatedKeyExchanges)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.PortForwarding = (porcelain.PortForwarding)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedSSHCertToPlumbing(
	porcelains []*SSHCert,
) []*proto.SSHCert {
	var items []*proto.SSHCert
	for _, porcelain := range porcelains {
		items = append(items, convertSSHCertToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSSHCertToPorcelain(plumbings []*proto.SSHCert) (
	[]*SSHCert,
	error,
) {
	var items []*SSHCert
	for _, plumbing := range plumbings {
		if v, err := convertSSHCertToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSSHCustomerKeyToPorcelain(plumbing *proto.SSHCustomerKey) (*SSHCustomerKey, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SSHCustomerKey{}
	porcelain.AllowDeprecatedKeyExchanges = plumbing.AllowDeprecatedKeyExchanges
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.PortForwarding = plumbing.PortForwarding
	porcelain.PrivateKey = plumbing.PrivateKey
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertSSHCustomerKeyToPlumbing(porcelain *SSHCustomerKey) *proto.SSHCustomerKey {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SSHCustomerKey{}
	plumbing.AllowDeprecatedKeyExchanges = (porcelain.AllowDeprecatedKeyExchanges)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.PortForwarding = (porcelain.PortForwarding)
	plumbing.PrivateKey = (porcelain.PrivateKey)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedSSHCustomerKeyToPlumbing(
	porcelains []*SSHCustomerKey,
) []*proto.SSHCustomerKey {
	var items []*proto.SSHCustomerKey
	for _, porcelain := range porcelains {
		items = append(items, convertSSHCustomerKeyToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSSHCustomerKeyToPorcelain(plumbings []*proto.SSHCustomerKey) (
	[]*SSHCustomerKey,
	error,
) {
	var items []*SSHCustomerKey
	for _, plumbing := range plumbings {
		if v, err := convertSSHCustomerKeyToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSecretStoreToPlumbing(porcelain SecretStore) *proto.SecretStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SecretStore{}

	switch v := porcelain.(type) {
	case *AWSStore:
		plumbing.SecretStore = &proto.SecretStore_Aws{Aws: convertAWSStoreToPlumbing(v)}
	case *AzureStore:
		plumbing.SecretStore = &proto.SecretStore_Azure{Azure: convertAzureStoreToPlumbing(v)}
	case *VaultTLSStore:
		plumbing.SecretStore = &proto.SecretStore_VaultTls{VaultTls: convertVaultTLSStoreToPlumbing(v)}
	case *VaultTokenStore:
		plumbing.SecretStore = &proto.SecretStore_VaultToken{VaultToken: convertVaultTokenStoreToPlumbing(v)}
	}
	return plumbing
}

func convertSecretStoreToPorcelain(plumbing *proto.SecretStore) (SecretStore, error) {
	if plumbing.GetAws() != nil {
		return convertAWSStoreToPorcelain(plumbing.GetAws())
	}
	if plumbing.GetAzure() != nil {
		return convertAzureStoreToPorcelain(plumbing.GetAzure())
	}
	if plumbing.GetVaultTls() != nil {
		return convertVaultTLSStoreToPorcelain(plumbing.GetVaultTls())
	}
	if plumbing.GetVaultToken() != nil {
		return convertVaultTokenStoreToPorcelain(plumbing.GetVaultToken())
	}
	return nil, &UnknownError{Wrapped: fmt.Errorf("unknown polymorphic type, please upgrade your SDK")}
}
func convertRepeatedSecretStoreToPlumbing(
	porcelains []SecretStore,
) []*proto.SecretStore {
	var items []*proto.SecretStore
	for _, porcelain := range porcelains {
		items = append(items, convertSecretStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSecretStoreToPorcelain(plumbings []*proto.SecretStore) (
	[]SecretStore,
	error,
) {
	var items []SecretStore
	for _, plumbing := range plumbings {
		if v, err := convertSecretStoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSecretStoreCreateResponseToPorcelain(plumbing *proto.SecretStoreCreateResponse) (*SecretStoreCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SecretStoreCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertSecretStoreToPorcelain(plumbing.SecretStore); err != nil {
		return nil, fmt.Errorf("error converting field SecretStore: %v", err)
	} else {
		porcelain.SecretStore = v
	}
	return porcelain, nil
}

func convertSecretStoreCreateResponseToPlumbing(porcelain *SecretStoreCreateResponse) *proto.SecretStoreCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SecretStoreCreateResponse{}
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.SecretStore = convertSecretStoreToPlumbing(porcelain.SecretStore)
	return plumbing
}
func convertRepeatedSecretStoreCreateResponseToPlumbing(
	porcelains []*SecretStoreCreateResponse,
) []*proto.SecretStoreCreateResponse {
	var items []*proto.SecretStoreCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertSecretStoreCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSecretStoreCreateResponseToPorcelain(plumbings []*proto.SecretStoreCreateResponse) (
	[]*SecretStoreCreateResponse,
	error,
) {
	var items []*SecretStoreCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertSecretStoreCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSecretStoreDeleteResponseToPorcelain(plumbing *proto.SecretStoreDeleteResponse) (*SecretStoreDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SecretStoreDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertSecretStoreDeleteResponseToPlumbing(porcelain *SecretStoreDeleteResponse) *proto.SecretStoreDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SecretStoreDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedSecretStoreDeleteResponseToPlumbing(
	porcelains []*SecretStoreDeleteResponse,
) []*proto.SecretStoreDeleteResponse {
	var items []*proto.SecretStoreDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertSecretStoreDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSecretStoreDeleteResponseToPorcelain(plumbings []*proto.SecretStoreDeleteResponse) (
	[]*SecretStoreDeleteResponse,
	error,
) {
	var items []*SecretStoreDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertSecretStoreDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSecretStoreGetResponseToPorcelain(plumbing *proto.SecretStoreGetResponse) (*SecretStoreGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SecretStoreGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertSecretStoreToPorcelain(plumbing.SecretStore); err != nil {
		return nil, fmt.Errorf("error converting field SecretStore: %v", err)
	} else {
		porcelain.SecretStore = v
	}
	return porcelain, nil
}

func convertSecretStoreGetResponseToPlumbing(porcelain *SecretStoreGetResponse) *proto.SecretStoreGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SecretStoreGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.SecretStore = convertSecretStoreToPlumbing(porcelain.SecretStore)
	return plumbing
}
func convertRepeatedSecretStoreGetResponseToPlumbing(
	porcelains []*SecretStoreGetResponse,
) []*proto.SecretStoreGetResponse {
	var items []*proto.SecretStoreGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertSecretStoreGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSecretStoreGetResponseToPorcelain(plumbings []*proto.SecretStoreGetResponse) (
	[]*SecretStoreGetResponse,
	error,
) {
	var items []*SecretStoreGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertSecretStoreGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSecretStoreUpdateResponseToPorcelain(plumbing *proto.SecretStoreUpdateResponse) (*SecretStoreUpdateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SecretStoreUpdateResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertSecretStoreToPorcelain(plumbing.SecretStore); err != nil {
		return nil, fmt.Errorf("error converting field SecretStore: %v", err)
	} else {
		porcelain.SecretStore = v
	}
	return porcelain, nil
}

func convertSecretStoreUpdateResponseToPlumbing(porcelain *SecretStoreUpdateResponse) *proto.SecretStoreUpdateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SecretStoreUpdateResponse{}
	plumbing.Meta = convertUpdateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.SecretStore = convertSecretStoreToPlumbing(porcelain.SecretStore)
	return plumbing
}
func convertRepeatedSecretStoreUpdateResponseToPlumbing(
	porcelains []*SecretStoreUpdateResponse,
) []*proto.SecretStoreUpdateResponse {
	var items []*proto.SecretStoreUpdateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertSecretStoreUpdateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSecretStoreUpdateResponseToPorcelain(plumbings []*proto.SecretStoreUpdateResponse) (
	[]*SecretStoreUpdateResponse,
	error,
) {
	var items []*SecretStoreUpdateResponse
	for _, plumbing := range plumbings {
		if v, err := convertSecretStoreUpdateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertServiceToPorcelain(plumbing *proto.Service) (*Service, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Service{}
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Suspended = plumbing.Suspended
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertServiceToPlumbing(porcelain *Service) *proto.Service {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Service{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Suspended = (porcelain.Suspended)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedServiceToPlumbing(
	porcelains []*Service,
) []*proto.Service {
	var items []*proto.Service
	for _, porcelain := range porcelains {
		items = append(items, convertServiceToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedServiceToPorcelain(plumbings []*proto.Service) (
	[]*Service,
	error,
) {
	var items []*Service
	for _, plumbing := range plumbings {
		if v, err := convertServiceToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSingleStoreToPorcelain(plumbing *proto.SingleStore) (*SingleStore, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SingleStore{}
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertSingleStoreToPlumbing(porcelain *SingleStore) *proto.SingleStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SingleStore{}
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedSingleStoreToPlumbing(
	porcelains []*SingleStore,
) []*proto.SingleStore {
	var items []*proto.SingleStore
	for _, porcelain := range porcelains {
		items = append(items, convertSingleStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSingleStoreToPorcelain(plumbings []*proto.SingleStore) (
	[]*SingleStore,
	error,
) {
	var items []*SingleStore
	for _, plumbing := range plumbings {
		if v, err := convertSingleStoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSnowflakeToPorcelain(plumbing *proto.Snowflake) (*Snowflake, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Snowflake{}
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.Schema = plumbing.Schema
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertSnowflakeToPlumbing(porcelain *Snowflake) *proto.Snowflake {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Snowflake{}
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.Schema = (porcelain.Schema)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedSnowflakeToPlumbing(
	porcelains []*Snowflake,
) []*proto.Snowflake {
	var items []*proto.Snowflake
	for _, porcelain := range porcelains {
		items = append(items, convertSnowflakeToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSnowflakeToPorcelain(plumbings []*proto.Snowflake) (
	[]*Snowflake,
	error,
) {
	var items []*Snowflake
	for _, plumbing := range plumbings {
		if v, err := convertSnowflakeToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSybaseToPorcelain(plumbing *proto.Sybase) (*Sybase, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Sybase{}
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertSybaseToPlumbing(porcelain *Sybase) *proto.Sybase {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Sybase{}
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedSybaseToPlumbing(
	porcelains []*Sybase,
) []*proto.Sybase {
	var items []*proto.Sybase
	for _, porcelain := range porcelains {
		items = append(items, convertSybaseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSybaseToPorcelain(plumbings []*proto.Sybase) (
	[]*Sybase,
	error,
) {
	var items []*Sybase
	for _, plumbing := range plumbings {
		if v, err := convertSybaseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSybaseIQToPorcelain(plumbing *proto.SybaseIQ) (*SybaseIQ, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SybaseIQ{}
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertSybaseIQToPlumbing(porcelain *SybaseIQ) *proto.SybaseIQ {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SybaseIQ{}
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedSybaseIQToPlumbing(
	porcelains []*SybaseIQ,
) []*proto.SybaseIQ {
	var items []*proto.SybaseIQ
	for _, porcelain := range porcelains {
		items = append(items, convertSybaseIQToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSybaseIQToPorcelain(plumbings []*proto.SybaseIQ) (
	[]*SybaseIQ,
	error,
) {
	var items []*SybaseIQ
	for _, plumbing := range plumbings {
		if v, err := convertSybaseIQToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertTagToPorcelain(plumbing *proto.Tag) (*Tag, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Tag{}
	porcelain.Name = plumbing.Name
	porcelain.Value = plumbing.Value
	return porcelain, nil
}

func convertTagToPlumbing(porcelain *Tag) *proto.Tag {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Tag{}
	plumbing.Name = (porcelain.Name)
	plumbing.Value = (porcelain.Value)
	return plumbing
}
func convertRepeatedTagToPlumbing(
	porcelains []*Tag,
) []*proto.Tag {
	var items []*proto.Tag
	for _, porcelain := range porcelains {
		items = append(items, convertTagToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedTagToPorcelain(plumbings []*proto.Tag) (
	[]*Tag,
	error,
) {
	var items []*Tag
	for _, plumbing := range plumbings {
		if v, err := convertTagToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertTeradataToPorcelain(plumbing *proto.Teradata) (*Teradata, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Teradata{}
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertTeradataToPlumbing(porcelain *Teradata) *proto.Teradata {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Teradata{}
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedTeradataToPlumbing(
	porcelains []*Teradata,
) []*proto.Teradata {
	var items []*proto.Teradata
	for _, porcelain := range porcelains {
		items = append(items, convertTeradataToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedTeradataToPorcelain(plumbings []*proto.Teradata) (
	[]*Teradata,
	error,
) {
	var items []*Teradata
	for _, plumbing := range plumbings {
		if v, err := convertTeradataToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertUpdateResponseMetadataToPorcelain(plumbing *proto.UpdateResponseMetadata) (*UpdateResponseMetadata, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &UpdateResponseMetadata{}
	return porcelain, nil
}

func convertUpdateResponseMetadataToPlumbing(porcelain *UpdateResponseMetadata) *proto.UpdateResponseMetadata {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.UpdateResponseMetadata{}
	return plumbing
}
func convertRepeatedUpdateResponseMetadataToPlumbing(
	porcelains []*UpdateResponseMetadata,
) []*proto.UpdateResponseMetadata {
	var items []*proto.UpdateResponseMetadata
	for _, porcelain := range porcelains {
		items = append(items, convertUpdateResponseMetadataToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedUpdateResponseMetadataToPorcelain(plumbings []*proto.UpdateResponseMetadata) (
	[]*UpdateResponseMetadata,
	error,
) {
	var items []*UpdateResponseMetadata
	for _, plumbing := range plumbings {
		if v, err := convertUpdateResponseMetadataToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertUserToPorcelain(plumbing *proto.User) (*User, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &User{}
	porcelain.Email = plumbing.Email
	porcelain.FirstName = plumbing.FirstName
	porcelain.ID = plumbing.Id
	porcelain.LastName = plumbing.LastName
	porcelain.Suspended = plumbing.Suspended
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertUserToPlumbing(porcelain *User) *proto.User {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.User{}
	plumbing.Email = (porcelain.Email)
	plumbing.FirstName = (porcelain.FirstName)
	plumbing.Id = (porcelain.ID)
	plumbing.LastName = (porcelain.LastName)
	plumbing.Suspended = (porcelain.Suspended)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedUserToPlumbing(
	porcelains []*User,
) []*proto.User {
	var items []*proto.User
	for _, porcelain := range porcelains {
		items = append(items, convertUserToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedUserToPorcelain(plumbings []*proto.User) (
	[]*User,
	error,
) {
	var items []*User
	for _, plumbing := range plumbings {
		if v, err := convertUserToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertVaultTLSStoreToPorcelain(plumbing *proto.VaultTLSStore) (*VaultTLSStore, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &VaultTLSStore{}
	porcelain.CACertPath = plumbing.CACertPath
	porcelain.ClientCertPath = plumbing.ClientCertPath
	porcelain.ClientKeyPath = plumbing.ClientKeyPath
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Namespace = plumbing.Namespace
	porcelain.ServerAddress = plumbing.ServerAddress
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertVaultTLSStoreToPlumbing(porcelain *VaultTLSStore) *proto.VaultTLSStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.VaultTLSStore{}
	plumbing.CACertPath = (porcelain.CACertPath)
	plumbing.ClientCertPath = (porcelain.ClientCertPath)
	plumbing.ClientKeyPath = (porcelain.ClientKeyPath)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Namespace = (porcelain.Namespace)
	plumbing.ServerAddress = (porcelain.ServerAddress)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedVaultTLSStoreToPlumbing(
	porcelains []*VaultTLSStore,
) []*proto.VaultTLSStore {
	var items []*proto.VaultTLSStore
	for _, porcelain := range porcelains {
		items = append(items, convertVaultTLSStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedVaultTLSStoreToPorcelain(plumbings []*proto.VaultTLSStore) (
	[]*VaultTLSStore,
	error,
) {
	var items []*VaultTLSStore
	for _, plumbing := range plumbings {
		if v, err := convertVaultTLSStoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertVaultTokenStoreToPorcelain(plumbing *proto.VaultTokenStore) (*VaultTokenStore, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &VaultTokenStore{}
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Namespace = plumbing.Namespace
	porcelain.ServerAddress = plumbing.ServerAddress
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertVaultTokenStoreToPlumbing(porcelain *VaultTokenStore) *proto.VaultTokenStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.VaultTokenStore{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Namespace = (porcelain.Namespace)
	plumbing.ServerAddress = (porcelain.ServerAddress)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedVaultTokenStoreToPlumbing(
	porcelains []*VaultTokenStore,
) []*proto.VaultTokenStore {
	var items []*proto.VaultTokenStore
	for _, porcelain := range porcelains {
		items = append(items, convertVaultTokenStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedVaultTokenStoreToPorcelain(plumbings []*proto.VaultTokenStore) (
	[]*VaultTokenStore,
	error,
) {
	var items []*VaultTokenStore
	for _, plumbing := range plumbings {
		if v, err := convertVaultTokenStoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}

type rpcError struct {
	wrapped error
	code    int
}

func (e *rpcError) Error() string {
	return e.wrapped.Error()
}

func (e *rpcError) Unwrap() error {
	return e.wrapped
}

func (e *rpcError) Code() int {
	return e.code
}

func convertErrorToPorcelain(err error) error {
	if s, ok := status.FromError(err); ok {
		switch s.Code() {
		case codes.Canceled:
			return &ContextCanceledError{Wrapped: err}
		case codes.DeadlineExceeded:
			return &DeadlineExceededError{Wrapped: err}
		case codes.AlreadyExists:
			return &AlreadyExistsError{Message: s.Message()}
		case codes.NotFound:
			return &NotFoundError{Message: s.Message()}
		case codes.InvalidArgument:
			return &BadRequestError{Message: s.Message()}
		case codes.Unauthenticated:
			return &AuthenticationError{Message: s.Message()}
		case codes.PermissionDenied:
			return &PermissionError{Message: s.Message()}
		case codes.Internal:
			return &InternalError{Message: s.Message()}
		case codes.ResourceExhausted:
			for _, d := range s.Details() {
				if d, ok := d.(*proto.RateLimitMetadata); ok {
					rateLimit, _ := convertRateLimitMetadataToPorcelain(d)
					return &RateLimitError{Message: s.Message(), RateLimit: rateLimit}
				}
			}
		}
		return &rpcError{wrapped: err, code: int(s.Code())}
	}
	return &UnknownError{Wrapped: err}
}

type accountAttachmentIteratorImplFetchFunc func() (
	[]*AccountAttachment,
	bool, error)
type accountAttachmentIteratorImpl struct {
	buffer      []*AccountAttachment
	index       int
	hasNextPage bool
	err         error
	fetch       accountAttachmentIteratorImplFetchFunc
}

func newAccountAttachmentIteratorImpl(f accountAttachmentIteratorImplFetchFunc) *accountAttachmentIteratorImpl {
	return &accountAttachmentIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (a *accountAttachmentIteratorImpl) Next() bool {
	if a.index < len(a.buffer)-1 {
		a.index++
		return true
	}

	// reached end of buffer
	if !a.hasNextPage {
		return false
	}

	a.index = 0
	a.buffer, a.hasNextPage, a.err = a.fetch()
	return len(a.buffer) > 0
}

func (a *accountAttachmentIteratorImpl) Value() *AccountAttachment {
	if a.index >= len(a.buffer) {
		return nil
	}
	return a.buffer[a.index]
}

func (a *accountAttachmentIteratorImpl) Err() error {
	return a.err
}

type accountGrantIteratorImplFetchFunc func() (
	[]*AccountGrant,
	bool, error)
type accountGrantIteratorImpl struct {
	buffer      []*AccountGrant
	index       int
	hasNextPage bool
	err         error
	fetch       accountGrantIteratorImplFetchFunc
}

func newAccountGrantIteratorImpl(f accountGrantIteratorImplFetchFunc) *accountGrantIteratorImpl {
	return &accountGrantIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (a *accountGrantIteratorImpl) Next() bool {
	if a.index < len(a.buffer)-1 {
		a.index++
		return true
	}

	// reached end of buffer
	if !a.hasNextPage {
		return false
	}

	a.index = 0
	a.buffer, a.hasNextPage, a.err = a.fetch()
	return len(a.buffer) > 0
}

func (a *accountGrantIteratorImpl) Value() *AccountGrant {
	if a.index >= len(a.buffer) {
		return nil
	}
	return a.buffer[a.index]
}

func (a *accountGrantIteratorImpl) Err() error {
	return a.err
}

type accountIteratorImplFetchFunc func() (
	[]Account,
	bool, error)
type accountIteratorImpl struct {
	buffer      []Account
	index       int
	hasNextPage bool
	err         error
	fetch       accountIteratorImplFetchFunc
}

func newAccountIteratorImpl(f accountIteratorImplFetchFunc) *accountIteratorImpl {
	return &accountIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (a *accountIteratorImpl) Next() bool {
	if a.index < len(a.buffer)-1 {
		a.index++
		return true
	}

	// reached end of buffer
	if !a.hasNextPage {
		return false
	}

	a.index = 0
	a.buffer, a.hasNextPage, a.err = a.fetch()
	return len(a.buffer) > 0
}

func (a *accountIteratorImpl) Value() Account {
	if a.index >= len(a.buffer) {
		return nil
	}
	return a.buffer[a.index]
}

func (a *accountIteratorImpl) Err() error {
	return a.err
}

type nodeIteratorImplFetchFunc func() (
	[]Node,
	bool, error)
type nodeIteratorImpl struct {
	buffer      []Node
	index       int
	hasNextPage bool
	err         error
	fetch       nodeIteratorImplFetchFunc
}

func newNodeIteratorImpl(f nodeIteratorImplFetchFunc) *nodeIteratorImpl {
	return &nodeIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (n *nodeIteratorImpl) Next() bool {
	if n.index < len(n.buffer)-1 {
		n.index++
		return true
	}

	// reached end of buffer
	if !n.hasNextPage {
		return false
	}

	n.index = 0
	n.buffer, n.hasNextPage, n.err = n.fetch()
	return len(n.buffer) > 0
}

func (n *nodeIteratorImpl) Value() Node {
	if n.index >= len(n.buffer) {
		return nil
	}
	return n.buffer[n.index]
}

func (n *nodeIteratorImpl) Err() error {
	return n.err
}

type tagIteratorImplFetchFunc func() (
	[]*Tag,
	bool, error)
type tagIteratorImpl struct {
	buffer      []*Tag
	index       int
	hasNextPage bool
	err         error
	fetch       tagIteratorImplFetchFunc
}

func newTagIteratorImpl(f tagIteratorImplFetchFunc) *tagIteratorImpl {
	return &tagIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (t *tagIteratorImpl) Next() bool {
	if t.index < len(t.buffer)-1 {
		t.index++
		return true
	}

	// reached end of buffer
	if !t.hasNextPage {
		return false
	}

	t.index = 0
	t.buffer, t.hasNextPage, t.err = t.fetch()
	return len(t.buffer) > 0
}

func (t *tagIteratorImpl) Value() *Tag {
	if t.index >= len(t.buffer) {
		return nil
	}
	return t.buffer[t.index]
}

func (t *tagIteratorImpl) Err() error {
	return t.err
}

type resourceIteratorImplFetchFunc func() (
	[]Resource,
	bool, error)
type resourceIteratorImpl struct {
	buffer      []Resource
	index       int
	hasNextPage bool
	err         error
	fetch       resourceIteratorImplFetchFunc
}

func newResourceIteratorImpl(f resourceIteratorImplFetchFunc) *resourceIteratorImpl {
	return &resourceIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (r *resourceIteratorImpl) Next() bool {
	if r.index < len(r.buffer)-1 {
		r.index++
		return true
	}

	// reached end of buffer
	if !r.hasNextPage {
		return false
	}

	r.index = 0
	r.buffer, r.hasNextPage, r.err = r.fetch()
	return len(r.buffer) > 0
}

func (r *resourceIteratorImpl) Value() Resource {
	if r.index >= len(r.buffer) {
		return nil
	}
	return r.buffer[r.index]
}

func (r *resourceIteratorImpl) Err() error {
	return r.err
}

type roleAttachmentIteratorImplFetchFunc func() (
	[]*RoleAttachment,
	bool, error)
type roleAttachmentIteratorImpl struct {
	buffer      []*RoleAttachment
	index       int
	hasNextPage bool
	err         error
	fetch       roleAttachmentIteratorImplFetchFunc
}

func newRoleAttachmentIteratorImpl(f roleAttachmentIteratorImplFetchFunc) *roleAttachmentIteratorImpl {
	return &roleAttachmentIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (r *roleAttachmentIteratorImpl) Next() bool {
	if r.index < len(r.buffer)-1 {
		r.index++
		return true
	}

	// reached end of buffer
	if !r.hasNextPage {
		return false
	}

	r.index = 0
	r.buffer, r.hasNextPage, r.err = r.fetch()
	return len(r.buffer) > 0
}

func (r *roleAttachmentIteratorImpl) Value() *RoleAttachment {
	if r.index >= len(r.buffer) {
		return nil
	}
	return r.buffer[r.index]
}

func (r *roleAttachmentIteratorImpl) Err() error {
	return r.err
}

type roleGrantIteratorImplFetchFunc func() (
	[]*RoleGrant,
	bool, error)
type roleGrantIteratorImpl struct {
	buffer      []*RoleGrant
	index       int
	hasNextPage bool
	err         error
	fetch       roleGrantIteratorImplFetchFunc
}

func newRoleGrantIteratorImpl(f roleGrantIteratorImplFetchFunc) *roleGrantIteratorImpl {
	return &roleGrantIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (r *roleGrantIteratorImpl) Next() bool {
	if r.index < len(r.buffer)-1 {
		r.index++
		return true
	}

	// reached end of buffer
	if !r.hasNextPage {
		return false
	}

	r.index = 0
	r.buffer, r.hasNextPage, r.err = r.fetch()
	return len(r.buffer) > 0
}

func (r *roleGrantIteratorImpl) Value() *RoleGrant {
	if r.index >= len(r.buffer) {
		return nil
	}
	return r.buffer[r.index]
}

func (r *roleGrantIteratorImpl) Err() error {
	return r.err
}

type roleIteratorImplFetchFunc func() (
	[]*Role,
	bool, error)
type roleIteratorImpl struct {
	buffer      []*Role
	index       int
	hasNextPage bool
	err         error
	fetch       roleIteratorImplFetchFunc
}

func newRoleIteratorImpl(f roleIteratorImplFetchFunc) *roleIteratorImpl {
	return &roleIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (r *roleIteratorImpl) Next() bool {
	if r.index < len(r.buffer)-1 {
		r.index++
		return true
	}

	// reached end of buffer
	if !r.hasNextPage {
		return false
	}

	r.index = 0
	r.buffer, r.hasNextPage, r.err = r.fetch()
	return len(r.buffer) > 0
}

func (r *roleIteratorImpl) Value() *Role {
	if r.index >= len(r.buffer) {
		return nil
	}
	return r.buffer[r.index]
}

func (r *roleIteratorImpl) Err() error {
	return r.err
}

type secretStoreIteratorImplFetchFunc func() (
	[]SecretStore,
	bool, error)
type secretStoreIteratorImpl struct {
	buffer      []SecretStore
	index       int
	hasNextPage bool
	err         error
	fetch       secretStoreIteratorImplFetchFunc
}

func newSecretStoreIteratorImpl(f secretStoreIteratorImplFetchFunc) *secretStoreIteratorImpl {
	return &secretStoreIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (s *secretStoreIteratorImpl) Next() bool {
	if s.index < len(s.buffer)-1 {
		s.index++
		return true
	}

	// reached end of buffer
	if !s.hasNextPage {
		return false
	}

	s.index = 0
	s.buffer, s.hasNextPage, s.err = s.fetch()
	return len(s.buffer) > 0
}

func (s *secretStoreIteratorImpl) Value() SecretStore {
	if s.index >= len(s.buffer) {
		return nil
	}
	return s.buffer[s.index]
}

func (s *secretStoreIteratorImpl) Err() error {
	return s.err
}
