// Copyright 2020 StrongDM Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package sdm

// Code generated by protogen. DO NOT EDIT.

import (
	"encoding/json"
	"fmt"
	proto "github.com/strongdm/terraform-provider-sdm/sdm/internal/sdk/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/durationpb"
	"google.golang.org/protobuf/types/known/timestamppb"
	"strings"
	"time"
)

func quoteFilterArgs(filter string, args ...interface{}) (string, error) {
	parts := strings.Split(filter, "?")
	if len(parts) != len(args)+1 {
		return "", &BadRequestError{Message: "incorrect number of replacements"}
	}
	var b strings.Builder
	for i, v := range parts {
		b.WriteString(v)
		if i < len(args) {
			s := fmt.Sprint(args[i])
			j, err := json.Marshal(s)
			if err != nil {
				return "", &BadRequestError{Message: "unable to marshal string to JSON"}
			}
			b.Write(j)
		}
	}
	return b.String(), nil
}

func convertTimestampToPorcelain(t *timestamppb.Timestamp) (time.Time, error) {
	if t == nil {
		return time.Unix(0, 0).UTC(), nil
	}
	return time.Unix(t.Seconds, int64(t.Nanos)).UTC(), nil
}

func convertTimestampToPlumbing(t time.Time) *timestamppb.Timestamp {
	if t.IsZero() {
		return nil
	}
	return &timestamppb.Timestamp{
		Seconds: t.Unix(),
		Nanos:   int32(t.Nanosecond()),
	}
}

func convertDurationToPorcelain(d *durationpb.Duration) (time.Duration, error) {
	if d == nil {
		return 0, nil
	}
	return d.AsDuration(), nil
}

func convertDurationToPlumbing(d time.Duration) *durationpb.Duration {
	return durationpb.New(d)
}

func convertTagsToPorcelain(tags *proto.Tags) (Tags, error) {
	result := Tags{}
	for _, tag := range tags.GetPairs() {
		result[tag.Name] = tag.Value
	}
	return result, nil
}

func convertTagsToPlumbing(tags Tags) *proto.Tags {
	var result []*proto.Tags_Pair
	for name, value := range tags {
		result = append(result, &proto.Tags_Pair{Name: name, Value: value})
	}
	return &proto.Tags{Pairs: result}
}
func convertAKSToPorcelain(plumbing *proto.AKS) (*AKS, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AKS{}
	porcelain.AllowResourceRoleBypass = plumbing.AllowResourceRoleBypass
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.CertificateAuthority = plumbing.CertificateAuthority
	porcelain.ClientCertificate = plumbing.ClientCertificate
	porcelain.ClientKey = plumbing.ClientKey
	porcelain.DiscoveryEnabled = plumbing.DiscoveryEnabled
	porcelain.DiscoveryUsername = plumbing.DiscoveryUsername
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.IdentityAliasHealthcheckUsername = plumbing.IdentityAliasHealthcheckUsername
	porcelain.IdentitySetID = plumbing.IdentitySetId
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertAKSToPlumbing(porcelain *AKS) *proto.AKS {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AKS{}
	plumbing.AllowResourceRoleBypass = (porcelain.AllowResourceRoleBypass)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.CertificateAuthority = (porcelain.CertificateAuthority)
	plumbing.ClientCertificate = (porcelain.ClientCertificate)
	plumbing.ClientKey = (porcelain.ClientKey)
	plumbing.DiscoveryEnabled = (porcelain.DiscoveryEnabled)
	plumbing.DiscoveryUsername = (porcelain.DiscoveryUsername)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.IdentityAliasHealthcheckUsername = (porcelain.IdentityAliasHealthcheckUsername)
	plumbing.IdentitySetId = (porcelain.IdentitySetID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedAKSToPlumbing(
	porcelains []*AKS,
) []*proto.AKS {
	var items []*proto.AKS
	for _, porcelain := range porcelains {
		items = append(items, convertAKSToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAKSToPorcelain(plumbings []*proto.AKS) (
	[]*AKS,
	error,
) {
	var items []*AKS
	for _, plumbing := range plumbings {
		if v, err := convertAKSToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAKSBasicAuthToPorcelain(plumbing *proto.AKSBasicAuth) (*AKSBasicAuth, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AKSBasicAuth{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertAKSBasicAuthToPlumbing(porcelain *AKSBasicAuth) *proto.AKSBasicAuth {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AKSBasicAuth{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedAKSBasicAuthToPlumbing(
	porcelains []*AKSBasicAuth,
) []*proto.AKSBasicAuth {
	var items []*proto.AKSBasicAuth
	for _, porcelain := range porcelains {
		items = append(items, convertAKSBasicAuthToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAKSBasicAuthToPorcelain(plumbings []*proto.AKSBasicAuth) (
	[]*AKSBasicAuth,
	error,
) {
	var items []*AKSBasicAuth
	for _, plumbing := range plumbings {
		if v, err := convertAKSBasicAuthToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAKSServiceAccountToPorcelain(plumbing *proto.AKSServiceAccount) (*AKSServiceAccount, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AKSServiceAccount{}
	porcelain.AllowResourceRoleBypass = plumbing.AllowResourceRoleBypass
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.DiscoveryEnabled = plumbing.DiscoveryEnabled
	porcelain.DiscoveryUsername = plumbing.DiscoveryUsername
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.IdentityAliasHealthcheckUsername = plumbing.IdentityAliasHealthcheckUsername
	porcelain.IdentitySetID = plumbing.IdentitySetId
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Token = plumbing.Token
	return porcelain, nil
}

func convertAKSServiceAccountToPlumbing(porcelain *AKSServiceAccount) *proto.AKSServiceAccount {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AKSServiceAccount{}
	plumbing.AllowResourceRoleBypass = (porcelain.AllowResourceRoleBypass)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.DiscoveryEnabled = (porcelain.DiscoveryEnabled)
	plumbing.DiscoveryUsername = (porcelain.DiscoveryUsername)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.IdentityAliasHealthcheckUsername = (porcelain.IdentityAliasHealthcheckUsername)
	plumbing.IdentitySetId = (porcelain.IdentitySetID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Token = (porcelain.Token)
	return plumbing
}
func convertRepeatedAKSServiceAccountToPlumbing(
	porcelains []*AKSServiceAccount,
) []*proto.AKSServiceAccount {
	var items []*proto.AKSServiceAccount
	for _, porcelain := range porcelains {
		items = append(items, convertAKSServiceAccountToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAKSServiceAccountToPorcelain(plumbings []*proto.AKSServiceAccount) (
	[]*AKSServiceAccount,
	error,
) {
	var items []*AKSServiceAccount
	for _, plumbing := range plumbings {
		if v, err := convertAKSServiceAccountToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAKSServiceAccountUserImpersonationToPorcelain(plumbing *proto.AKSServiceAccountUserImpersonation) (*AKSServiceAccountUserImpersonation, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AKSServiceAccountUserImpersonation{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Token = plumbing.Token
	return porcelain, nil
}

func convertAKSServiceAccountUserImpersonationToPlumbing(porcelain *AKSServiceAccountUserImpersonation) *proto.AKSServiceAccountUserImpersonation {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AKSServiceAccountUserImpersonation{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Token = (porcelain.Token)
	return plumbing
}
func convertRepeatedAKSServiceAccountUserImpersonationToPlumbing(
	porcelains []*AKSServiceAccountUserImpersonation,
) []*proto.AKSServiceAccountUserImpersonation {
	var items []*proto.AKSServiceAccountUserImpersonation
	for _, porcelain := range porcelains {
		items = append(items, convertAKSServiceAccountUserImpersonationToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAKSServiceAccountUserImpersonationToPorcelain(plumbings []*proto.AKSServiceAccountUserImpersonation) (
	[]*AKSServiceAccountUserImpersonation,
	error,
) {
	var items []*AKSServiceAccountUserImpersonation
	for _, plumbing := range plumbings {
		if v, err := convertAKSServiceAccountUserImpersonationToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAKSUserImpersonationToPorcelain(plumbing *proto.AKSUserImpersonation) (*AKSUserImpersonation, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AKSUserImpersonation{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.CertificateAuthority = plumbing.CertificateAuthority
	porcelain.ClientCertificate = plumbing.ClientCertificate
	porcelain.ClientKey = plumbing.ClientKey
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertAKSUserImpersonationToPlumbing(porcelain *AKSUserImpersonation) *proto.AKSUserImpersonation {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AKSUserImpersonation{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.CertificateAuthority = (porcelain.CertificateAuthority)
	plumbing.ClientCertificate = (porcelain.ClientCertificate)
	plumbing.ClientKey = (porcelain.ClientKey)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedAKSUserImpersonationToPlumbing(
	porcelains []*AKSUserImpersonation,
) []*proto.AKSUserImpersonation {
	var items []*proto.AKSUserImpersonation
	for _, porcelain := range porcelains {
		items = append(items, convertAKSUserImpersonationToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAKSUserImpersonationToPorcelain(plumbings []*proto.AKSUserImpersonation) (
	[]*AKSUserImpersonation,
	error,
) {
	var items []*AKSUserImpersonation
	for _, plumbing := range plumbings {
		if v, err := convertAKSUserImpersonationToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAWSToPorcelain(plumbing *proto.AWS) (*AWS, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AWS{}
	porcelain.AccessKey = plumbing.AccessKey
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HealthcheckRegion = plumbing.HealthcheckRegion
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.RoleArn = plumbing.RoleArn
	porcelain.RoleExternalID = plumbing.RoleExternalId
	porcelain.SecretAccessKey = plumbing.SecretAccessKey
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertAWSToPlumbing(porcelain *AWS) *proto.AWS {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AWS{}
	plumbing.AccessKey = (porcelain.AccessKey)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HealthcheckRegion = (porcelain.HealthcheckRegion)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	plumbing.SecretAccessKey = (porcelain.SecretAccessKey)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedAWSToPlumbing(
	porcelains []*AWS,
) []*proto.AWS {
	var items []*proto.AWS
	for _, porcelain := range porcelains {
		items = append(items, convertAWSToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAWSToPorcelain(plumbings []*proto.AWS) (
	[]*AWS,
	error,
) {
	var items []*AWS
	for _, plumbing := range plumbings {
		if v, err := convertAWSToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAWSCertX509StoreToPorcelain(plumbing *proto.AWSCertX509Store) (*AWSCertX509Store, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AWSCertX509Store{}
	porcelain.CaArn = plumbing.CaArn
	porcelain.CertificateTemplateArn = plumbing.CertificateTemplateArn
	porcelain.ID = plumbing.Id
	porcelain.IssuedCertTTLMinutes = plumbing.IssuedCertTTLMinutes
	porcelain.Name = plumbing.Name
	porcelain.Region = plumbing.Region
	porcelain.SigningAlgo = plumbing.SigningAlgo
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertAWSCertX509StoreToPlumbing(porcelain *AWSCertX509Store) *proto.AWSCertX509Store {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AWSCertX509Store{}
	plumbing.CaArn = (porcelain.CaArn)
	plumbing.CertificateTemplateArn = (porcelain.CertificateTemplateArn)
	plumbing.Id = (porcelain.ID)
	plumbing.IssuedCertTTLMinutes = (porcelain.IssuedCertTTLMinutes)
	plumbing.Name = (porcelain.Name)
	plumbing.Region = (porcelain.Region)
	plumbing.SigningAlgo = (porcelain.SigningAlgo)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedAWSCertX509StoreToPlumbing(
	porcelains []*AWSCertX509Store,
) []*proto.AWSCertX509Store {
	var items []*proto.AWSCertX509Store
	for _, porcelain := range porcelains {
		items = append(items, convertAWSCertX509StoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAWSCertX509StoreToPorcelain(plumbings []*proto.AWSCertX509Store) (
	[]*AWSCertX509Store,
	error,
) {
	var items []*AWSCertX509Store
	for _, plumbing := range plumbings {
		if v, err := convertAWSCertX509StoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAWSConsoleToPorcelain(plumbing *proto.AWSConsole) (*AWSConsole, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AWSConsole{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.EnableEnvVariables = plumbing.EnableEnvVariables
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.IdentityAliasHealthcheckUsername = plumbing.IdentityAliasHealthcheckUsername
	porcelain.IdentitySetID = plumbing.IdentitySetId
	porcelain.Name = plumbing.Name
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.Region = plumbing.Region
	porcelain.RoleArn = plumbing.RoleArn
	porcelain.RoleExternalID = plumbing.RoleExternalId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.SessionExpiry = plumbing.SessionExpiry
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertAWSConsoleToPlumbing(porcelain *AWSConsole) *proto.AWSConsole {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AWSConsole{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.EnableEnvVariables = (porcelain.EnableEnvVariables)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.IdentityAliasHealthcheckUsername = (porcelain.IdentityAliasHealthcheckUsername)
	plumbing.IdentitySetId = (porcelain.IdentitySetID)
	plumbing.Name = (porcelain.Name)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.Region = (porcelain.Region)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.SessionExpiry = (porcelain.SessionExpiry)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedAWSConsoleToPlumbing(
	porcelains []*AWSConsole,
) []*proto.AWSConsole {
	var items []*proto.AWSConsole
	for _, porcelain := range porcelains {
		items = append(items, convertAWSConsoleToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAWSConsoleToPorcelain(plumbings []*proto.AWSConsole) (
	[]*AWSConsole,
	error,
) {
	var items []*AWSConsole
	for _, plumbing := range plumbings {
		if v, err := convertAWSConsoleToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAWSConsoleStaticKeyPairToPorcelain(plumbing *proto.AWSConsoleStaticKeyPair) (*AWSConsoleStaticKeyPair, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AWSConsoleStaticKeyPair{}
	porcelain.AccessKey = plumbing.AccessKey
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.IdentityAliasHealthcheckUsername = plumbing.IdentityAliasHealthcheckUsername
	porcelain.IdentitySetID = plumbing.IdentitySetId
	porcelain.Name = plumbing.Name
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.Region = plumbing.Region
	porcelain.RoleArn = plumbing.RoleArn
	porcelain.RoleExternalID = plumbing.RoleExternalId
	porcelain.SecretAccessKey = plumbing.SecretAccessKey
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.SessionExpiry = plumbing.SessionExpiry
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertAWSConsoleStaticKeyPairToPlumbing(porcelain *AWSConsoleStaticKeyPair) *proto.AWSConsoleStaticKeyPair {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AWSConsoleStaticKeyPair{}
	plumbing.AccessKey = (porcelain.AccessKey)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.IdentityAliasHealthcheckUsername = (porcelain.IdentityAliasHealthcheckUsername)
	plumbing.IdentitySetId = (porcelain.IdentitySetID)
	plumbing.Name = (porcelain.Name)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.Region = (porcelain.Region)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	plumbing.SecretAccessKey = (porcelain.SecretAccessKey)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.SessionExpiry = (porcelain.SessionExpiry)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedAWSConsoleStaticKeyPairToPlumbing(
	porcelains []*AWSConsoleStaticKeyPair,
) []*proto.AWSConsoleStaticKeyPair {
	var items []*proto.AWSConsoleStaticKeyPair
	for _, porcelain := range porcelains {
		items = append(items, convertAWSConsoleStaticKeyPairToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAWSConsoleStaticKeyPairToPorcelain(plumbings []*proto.AWSConsoleStaticKeyPair) (
	[]*AWSConsoleStaticKeyPair,
	error,
) {
	var items []*AWSConsoleStaticKeyPair
	for _, plumbing := range plumbings {
		if v, err := convertAWSConsoleStaticKeyPairToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAWSInstanceProfileToPorcelain(plumbing *proto.AWSInstanceProfile) (*AWSInstanceProfile, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AWSInstanceProfile{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.EnableEnvVariables = plumbing.EnableEnvVariables
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.Region = plumbing.Region
	porcelain.RoleArn = plumbing.RoleArn
	porcelain.RoleExternalID = plumbing.RoleExternalId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertAWSInstanceProfileToPlumbing(porcelain *AWSInstanceProfile) *proto.AWSInstanceProfile {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AWSInstanceProfile{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.EnableEnvVariables = (porcelain.EnableEnvVariables)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.Region = (porcelain.Region)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedAWSInstanceProfileToPlumbing(
	porcelains []*AWSInstanceProfile,
) []*proto.AWSInstanceProfile {
	var items []*proto.AWSInstanceProfile
	for _, porcelain := range porcelains {
		items = append(items, convertAWSInstanceProfileToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAWSInstanceProfileToPorcelain(plumbings []*proto.AWSInstanceProfile) (
	[]*AWSInstanceProfile,
	error,
) {
	var items []*AWSInstanceProfile
	for _, plumbing := range plumbings {
		if v, err := convertAWSInstanceProfileToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAWSStoreToPorcelain(plumbing *proto.AWSStore) (*AWSStore, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AWSStore{}
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Region = plumbing.Region
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertAWSStoreToPlumbing(porcelain *AWSStore) *proto.AWSStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AWSStore{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Region = (porcelain.Region)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedAWSStoreToPlumbing(
	porcelains []*AWSStore,
) []*proto.AWSStore {
	var items []*proto.AWSStore
	for _, porcelain := range porcelains {
		items = append(items, convertAWSStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAWSStoreToPorcelain(plumbings []*proto.AWSStore) (
	[]*AWSStore,
	error,
) {
	var items []*AWSStore
	for _, plumbing := range plumbings {
		if v, err := convertAWSStoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccessRequestToPorcelain(plumbing *proto.AccessRequest) (*AccessRequest, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccessRequest{}
	porcelain.AccountID = plumbing.AccountId
	porcelain.Duration = plumbing.Duration
	porcelain.GrantID = plumbing.GrantId
	porcelain.ID = plumbing.Id
	porcelain.Reason = plumbing.Reason
	if v, err := convertDurationToPorcelain(plumbing.RequestedDuration); err != nil {
		return nil, fmt.Errorf("error converting field RequestedDuration: %v", err)
	} else {
		porcelain.RequestedDuration = v
	}
	porcelain.ResourceID = plumbing.ResourceId
	if v, err := convertDurationToPorcelain(plumbing.ResultDuration); err != nil {
		return nil, fmt.Errorf("error converting field ResultDuration: %v", err)
	} else {
		porcelain.ResultDuration = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.StartFrom); err != nil {
		return nil, fmt.Errorf("error converting field StartFrom: %v", err)
	} else {
		porcelain.StartFrom = v
	}
	porcelain.Status = plumbing.Status
	if v, err := convertTimestampToPorcelain(plumbing.StatusAt); err != nil {
		return nil, fmt.Errorf("error converting field StatusAt: %v", err)
	} else {
		porcelain.StatusAt = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.ValidUntil); err != nil {
		return nil, fmt.Errorf("error converting field ValidUntil: %v", err)
	} else {
		porcelain.ValidUntil = v
	}
	porcelain.WorkflowID = plumbing.WorkflowId
	return porcelain, nil
}

func convertAccessRequestToPlumbing(porcelain *AccessRequest) *proto.AccessRequest {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccessRequest{}
	plumbing.AccountId = (porcelain.AccountID)
	plumbing.Duration = (porcelain.Duration)
	plumbing.GrantId = (porcelain.GrantID)
	plumbing.Id = (porcelain.ID)
	plumbing.Reason = (porcelain.Reason)
	plumbing.RequestedDuration = convertDurationToPlumbing(porcelain.RequestedDuration)
	plumbing.ResourceId = (porcelain.ResourceID)
	plumbing.ResultDuration = convertDurationToPlumbing(porcelain.ResultDuration)
	plumbing.StartFrom = convertTimestampToPlumbing(porcelain.StartFrom)
	plumbing.Status = (porcelain.Status)
	plumbing.StatusAt = convertTimestampToPlumbing(porcelain.StatusAt)
	plumbing.ValidUntil = convertTimestampToPlumbing(porcelain.ValidUntil)
	plumbing.WorkflowId = (porcelain.WorkflowID)
	return plumbing
}
func convertRepeatedAccessRequestToPlumbing(
	porcelains []*AccessRequest,
) []*proto.AccessRequest {
	var items []*proto.AccessRequest
	for _, porcelain := range porcelains {
		items = append(items, convertAccessRequestToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccessRequestToPorcelain(plumbings []*proto.AccessRequest) (
	[]*AccessRequest,
	error,
) {
	var items []*AccessRequest
	for _, plumbing := range plumbings {
		if v, err := convertAccessRequestToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccessRequestConfigToPorcelain(plumbing *proto.AccessRequestConfig) (*AccessRequestConfig, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccessRequestConfig{}
	porcelain.Duration = plumbing.Duration
	porcelain.Reason = plumbing.Reason
	porcelain.ResourceID = plumbing.ResourceId
	if v, err := convertTimestampToPorcelain(plumbing.StartFrom); err != nil {
		return nil, fmt.Errorf("error converting field StartFrom: %v", err)
	} else {
		porcelain.StartFrom = v
	}
	return porcelain, nil
}

func convertAccessRequestConfigToPlumbing(porcelain *AccessRequestConfig) *proto.AccessRequestConfig {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccessRequestConfig{}
	plumbing.Duration = (porcelain.Duration)
	plumbing.Reason = (porcelain.Reason)
	plumbing.ResourceId = (porcelain.ResourceID)
	plumbing.StartFrom = convertTimestampToPlumbing(porcelain.StartFrom)
	return plumbing
}
func convertRepeatedAccessRequestConfigToPlumbing(
	porcelains []*AccessRequestConfig,
) []*proto.AccessRequestConfig {
	var items []*proto.AccessRequestConfig
	for _, porcelain := range porcelains {
		items = append(items, convertAccessRequestConfigToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccessRequestConfigToPorcelain(plumbings []*proto.AccessRequestConfig) (
	[]*AccessRequestConfig,
	error,
) {
	var items []*AccessRequestConfig
	for _, plumbing := range plumbings {
		if v, err := convertAccessRequestConfigToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccessRequestEventToPorcelain(plumbing *proto.AccessRequestEvent) (*AccessRequestEvent, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccessRequestEvent{}
	porcelain.ActorID = plumbing.ActorId
	porcelain.ID = plumbing.Id
	porcelain.Metadata = plumbing.Metadata
	porcelain.RequestID = plumbing.RequestId
	porcelain.Type = plumbing.Type
	return porcelain, nil
}

func convertAccessRequestEventToPlumbing(porcelain *AccessRequestEvent) *proto.AccessRequestEvent {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccessRequestEvent{}
	plumbing.ActorId = (porcelain.ActorID)
	plumbing.Id = (porcelain.ID)
	plumbing.Metadata = (porcelain.Metadata)
	plumbing.RequestId = (porcelain.RequestID)
	plumbing.Type = (porcelain.Type)
	return plumbing
}
func convertRepeatedAccessRequestEventToPlumbing(
	porcelains []*AccessRequestEvent,
) []*proto.AccessRequestEvent {
	var items []*proto.AccessRequestEvent
	for _, porcelain := range porcelains {
		items = append(items, convertAccessRequestEventToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccessRequestEventToPorcelain(plumbings []*proto.AccessRequestEvent) (
	[]*AccessRequestEvent,
	error,
) {
	var items []*AccessRequestEvent
	for _, plumbing := range plumbings {
		if v, err := convertAccessRequestEventToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccessRequestEventHistoryToPorcelain(plumbing *proto.AccessRequestEventHistory) (*AccessRequestEventHistory, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccessRequestEventHistory{}
	if v, err := convertAccessRequestEventToPorcelain(plumbing.AccessRequestEvent); err != nil {
		return nil, fmt.Errorf("error converting field AccessRequestEvent: %v", err)
	} else {
		porcelain.AccessRequestEvent = v
	}
	porcelain.ActivityID = plumbing.ActivityId
	if v, err := convertTimestampToPorcelain(plumbing.DeletedAt); err != nil {
		return nil, fmt.Errorf("error converting field DeletedAt: %v", err)
	} else {
		porcelain.DeletedAt = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	return porcelain, nil
}

func convertAccessRequestEventHistoryToPlumbing(porcelain *AccessRequestEventHistory) *proto.AccessRequestEventHistory {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccessRequestEventHistory{}
	plumbing.AccessRequestEvent = convertAccessRequestEventToPlumbing(porcelain.AccessRequestEvent)
	plumbing.ActivityId = (porcelain.ActivityID)
	plumbing.DeletedAt = convertTimestampToPlumbing(porcelain.DeletedAt)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	return plumbing
}
func convertRepeatedAccessRequestEventHistoryToPlumbing(
	porcelains []*AccessRequestEventHistory,
) []*proto.AccessRequestEventHistory {
	var items []*proto.AccessRequestEventHistory
	for _, porcelain := range porcelains {
		items = append(items, convertAccessRequestEventHistoryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccessRequestEventHistoryToPorcelain(plumbings []*proto.AccessRequestEventHistory) (
	[]*AccessRequestEventHistory,
	error,
) {
	var items []*AccessRequestEventHistory
	for _, plumbing := range plumbings {
		if v, err := convertAccessRequestEventHistoryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccessRequestHistoryToPorcelain(plumbing *proto.AccessRequestHistory) (*AccessRequestHistory, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccessRequestHistory{}
	if v, err := convertAccessRequestToPorcelain(plumbing.AccessRequest); err != nil {
		return nil, fmt.Errorf("error converting field AccessRequest: %v", err)
	} else {
		porcelain.AccessRequest = v
	}
	porcelain.ActivityID = plumbing.ActivityId
	if v, err := convertTimestampToPorcelain(plumbing.DeletedAt); err != nil {
		return nil, fmt.Errorf("error converting field DeletedAt: %v", err)
	} else {
		porcelain.DeletedAt = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	return porcelain, nil
}

func convertAccessRequestHistoryToPlumbing(porcelain *AccessRequestHistory) *proto.AccessRequestHistory {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccessRequestHistory{}
	plumbing.AccessRequest = convertAccessRequestToPlumbing(porcelain.AccessRequest)
	plumbing.ActivityId = (porcelain.ActivityID)
	plumbing.DeletedAt = convertTimestampToPlumbing(porcelain.DeletedAt)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	return plumbing
}
func convertRepeatedAccessRequestHistoryToPlumbing(
	porcelains []*AccessRequestHistory,
) []*proto.AccessRequestHistory {
	var items []*proto.AccessRequestHistory
	for _, porcelain := range porcelains {
		items = append(items, convertAccessRequestHistoryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccessRequestHistoryToPorcelain(plumbings []*proto.AccessRequestHistory) (
	[]*AccessRequestHistory,
	error,
) {
	var items []*AccessRequestHistory
	for _, plumbing := range plumbings {
		if v, err := convertAccessRequestHistoryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccessRequestListRequestToPorcelain(plumbing *proto.AccessRequestListRequest) (*AccessRequestListRequest, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccessRequestListRequest{}
	porcelain.Filter = plumbing.Filter
	return porcelain, nil
}

func convertAccessRequestListRequestToPlumbing(porcelain *AccessRequestListRequest) *proto.AccessRequestListRequest {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccessRequestListRequest{}
	plumbing.Filter = (porcelain.Filter)
	return plumbing
}
func convertRepeatedAccessRequestListRequestToPlumbing(
	porcelains []*AccessRequestListRequest,
) []*proto.AccessRequestListRequest {
	var items []*proto.AccessRequestListRequest
	for _, porcelain := range porcelains {
		items = append(items, convertAccessRequestListRequestToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccessRequestListRequestToPorcelain(plumbings []*proto.AccessRequestListRequest) (
	[]*AccessRequestListRequest,
	error,
) {
	var items []*AccessRequestListRequest
	for _, plumbing := range plumbings {
		if v, err := convertAccessRequestListRequestToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccessRequestListResponseToPorcelain(plumbing *proto.AccessRequestListResponse) (*AccessRequestListResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccessRequestListResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertAccessRequestListResponseToPlumbing(porcelain *AccessRequestListResponse) *proto.AccessRequestListResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccessRequestListResponse{}
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccessRequestListResponseToPlumbing(
	porcelains []*AccessRequestListResponse,
) []*proto.AccessRequestListResponse {
	var items []*proto.AccessRequestListResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccessRequestListResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccessRequestListResponseToPorcelain(plumbings []*proto.AccessRequestListResponse) (
	[]*AccessRequestListResponse,
	error,
) {
	var items []*AccessRequestListResponse
	for _, plumbing := range plumbings {
		if v, err := convertAccessRequestListResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountToPlumbing(porcelain Account) *proto.Account {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Account{}

	switch v := porcelain.(type) {
	case *Service:
		plumbing.Account = &proto.Account_Service{Service: convertServiceToPlumbing(v)}
	case *Token:
		plumbing.Account = &proto.Account_Token{Token: convertTokenToPlumbing(v)}
	case *User:
		plumbing.Account = &proto.Account_User{User: convertUserToPlumbing(v)}
	}
	return plumbing
}

func convertAccountToPorcelain(plumbing *proto.Account) (Account, error) {
	if plumbing.GetService() != nil {
		return convertServiceToPorcelain(plumbing.GetService())
	}
	if plumbing.GetToken() != nil {
		return convertTokenToPorcelain(plumbing.GetToken())
	}
	if plumbing.GetUser() != nil {
		return convertUserToPorcelain(plumbing.GetUser())
	}
	return nil, &UnknownError{Wrapped: fmt.Errorf("unknown polymorphic type, please upgrade your SDK")}
}
func convertRepeatedAccountToPlumbing(
	porcelains []Account,
) []*proto.Account {
	var items []*proto.Account
	for _, porcelain := range porcelains {
		items = append(items, convertAccountToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountToPorcelain(plumbings []*proto.Account) (
	[]Account,
	error,
) {
	var items []Account
	for _, plumbing := range plumbings {
		if v, err := convertAccountToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountAttachmentToPorcelain(plumbing *proto.AccountAttachment) (*AccountAttachment, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountAttachment{}
	porcelain.AccountID = plumbing.AccountId
	porcelain.ID = plumbing.Id
	porcelain.RoleID = plumbing.RoleId
	return porcelain, nil
}

func convertAccountAttachmentToPlumbing(porcelain *AccountAttachment) *proto.AccountAttachment {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountAttachment{}
	plumbing.AccountId = (porcelain.AccountID)
	plumbing.Id = (porcelain.ID)
	plumbing.RoleId = (porcelain.RoleID)
	return plumbing
}
func convertRepeatedAccountAttachmentToPlumbing(
	porcelains []*AccountAttachment,
) []*proto.AccountAttachment {
	var items []*proto.AccountAttachment
	for _, porcelain := range porcelains {
		items = append(items, convertAccountAttachmentToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountAttachmentToPorcelain(plumbings []*proto.AccountAttachment) (
	[]*AccountAttachment,
	error,
) {
	var items []*AccountAttachment
	for _, plumbing := range plumbings {
		if v, err := convertAccountAttachmentToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountAttachmentCreateResponseToPorcelain(plumbing *proto.AccountAttachmentCreateResponse) (*AccountAttachmentCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountAttachmentCreateResponse{}
	if v, err := convertAccountAttachmentToPorcelain(plumbing.AccountAttachment); err != nil {
		return nil, fmt.Errorf("error converting field AccountAttachment: %v", err)
	} else {
		porcelain.AccountAttachment = v
	}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertAccountAttachmentCreateResponseToPlumbing(porcelain *AccountAttachmentCreateResponse) *proto.AccountAttachmentCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountAttachmentCreateResponse{}
	plumbing.AccountAttachment = convertAccountAttachmentToPlumbing(porcelain.AccountAttachment)
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountAttachmentCreateResponseToPlumbing(
	porcelains []*AccountAttachmentCreateResponse,
) []*proto.AccountAttachmentCreateResponse {
	var items []*proto.AccountAttachmentCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountAttachmentCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountAttachmentCreateResponseToPorcelain(plumbings []*proto.AccountAttachmentCreateResponse) (
	[]*AccountAttachmentCreateResponse,
	error,
) {
	var items []*AccountAttachmentCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertAccountAttachmentCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountAttachmentDeleteResponseToPorcelain(plumbing *proto.AccountAttachmentDeleteResponse) (*AccountAttachmentDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountAttachmentDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertAccountAttachmentDeleteResponseToPlumbing(porcelain *AccountAttachmentDeleteResponse) *proto.AccountAttachmentDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountAttachmentDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountAttachmentDeleteResponseToPlumbing(
	porcelains []*AccountAttachmentDeleteResponse,
) []*proto.AccountAttachmentDeleteResponse {
	var items []*proto.AccountAttachmentDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountAttachmentDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountAttachmentDeleteResponseToPorcelain(plumbings []*proto.AccountAttachmentDeleteResponse) (
	[]*AccountAttachmentDeleteResponse,
	error,
) {
	var items []*AccountAttachmentDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertAccountAttachmentDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountAttachmentGetResponseToPorcelain(plumbing *proto.AccountAttachmentGetResponse) (*AccountAttachmentGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountAttachmentGetResponse{}
	if v, err := convertAccountAttachmentToPorcelain(plumbing.AccountAttachment); err != nil {
		return nil, fmt.Errorf("error converting field AccountAttachment: %v", err)
	} else {
		porcelain.AccountAttachment = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertAccountAttachmentGetResponseToPlumbing(porcelain *AccountAttachmentGetResponse) *proto.AccountAttachmentGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountAttachmentGetResponse{}
	plumbing.AccountAttachment = convertAccountAttachmentToPlumbing(porcelain.AccountAttachment)
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountAttachmentGetResponseToPlumbing(
	porcelains []*AccountAttachmentGetResponse,
) []*proto.AccountAttachmentGetResponse {
	var items []*proto.AccountAttachmentGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountAttachmentGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountAttachmentGetResponseToPorcelain(plumbings []*proto.AccountAttachmentGetResponse) (
	[]*AccountAttachmentGetResponse,
	error,
) {
	var items []*AccountAttachmentGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertAccountAttachmentGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountAttachmentHistoryToPorcelain(plumbing *proto.AccountAttachmentHistory) (*AccountAttachmentHistory, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountAttachmentHistory{}
	if v, err := convertAccountAttachmentToPorcelain(plumbing.AccountAttachment); err != nil {
		return nil, fmt.Errorf("error converting field AccountAttachment: %v", err)
	} else {
		porcelain.AccountAttachment = v
	}
	porcelain.ActivityID = plumbing.ActivityId
	if v, err := convertTimestampToPorcelain(plumbing.DeletedAt); err != nil {
		return nil, fmt.Errorf("error converting field DeletedAt: %v", err)
	} else {
		porcelain.DeletedAt = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	return porcelain, nil
}

func convertAccountAttachmentHistoryToPlumbing(porcelain *AccountAttachmentHistory) *proto.AccountAttachmentHistory {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountAttachmentHistory{}
	plumbing.AccountAttachment = convertAccountAttachmentToPlumbing(porcelain.AccountAttachment)
	plumbing.ActivityId = (porcelain.ActivityID)
	plumbing.DeletedAt = convertTimestampToPlumbing(porcelain.DeletedAt)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	return plumbing
}
func convertRepeatedAccountAttachmentHistoryToPlumbing(
	porcelains []*AccountAttachmentHistory,
) []*proto.AccountAttachmentHistory {
	var items []*proto.AccountAttachmentHistory
	for _, porcelain := range porcelains {
		items = append(items, convertAccountAttachmentHistoryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountAttachmentHistoryToPorcelain(plumbings []*proto.AccountAttachmentHistory) (
	[]*AccountAttachmentHistory,
	error,
) {
	var items []*AccountAttachmentHistory
	for _, plumbing := range plumbings {
		if v, err := convertAccountAttachmentHistoryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountCreateResponseToPorcelain(plumbing *proto.AccountCreateResponse) (*AccountCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountCreateResponse{}
	porcelain.AccessKey = plumbing.AccessKey
	if v, err := convertAccountToPorcelain(plumbing.Account); err != nil {
		return nil, fmt.Errorf("error converting field Account: %v", err)
	} else {
		porcelain.Account = v
	}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	porcelain.SecretKey = plumbing.SecretKey
	porcelain.Token = plumbing.Token
	return porcelain, nil
}

func convertAccountCreateResponseToPlumbing(porcelain *AccountCreateResponse) *proto.AccountCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountCreateResponse{}
	plumbing.AccessKey = (porcelain.AccessKey)
	plumbing.Account = convertAccountToPlumbing(porcelain.Account)
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.SecretKey = (porcelain.SecretKey)
	plumbing.Token = (porcelain.Token)
	return plumbing
}
func convertRepeatedAccountCreateResponseToPlumbing(
	porcelains []*AccountCreateResponse,
) []*proto.AccountCreateResponse {
	var items []*proto.AccountCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountCreateResponseToPorcelain(plumbings []*proto.AccountCreateResponse) (
	[]*AccountCreateResponse,
	error,
) {
	var items []*AccountCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertAccountCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountDeleteResponseToPorcelain(plumbing *proto.AccountDeleteResponse) (*AccountDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertAccountDeleteResponseToPlumbing(porcelain *AccountDeleteResponse) *proto.AccountDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountDeleteResponseToPlumbing(
	porcelains []*AccountDeleteResponse,
) []*proto.AccountDeleteResponse {
	var items []*proto.AccountDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountDeleteResponseToPorcelain(plumbings []*proto.AccountDeleteResponse) (
	[]*AccountDeleteResponse,
	error,
) {
	var items []*AccountDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertAccountDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountGetResponseToPorcelain(plumbing *proto.AccountGetResponse) (*AccountGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountGetResponse{}
	if v, err := convertAccountToPorcelain(plumbing.Account); err != nil {
		return nil, fmt.Errorf("error converting field Account: %v", err)
	} else {
		porcelain.Account = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertAccountGetResponseToPlumbing(porcelain *AccountGetResponse) *proto.AccountGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountGetResponse{}
	plumbing.Account = convertAccountToPlumbing(porcelain.Account)
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountGetResponseToPlumbing(
	porcelains []*AccountGetResponse,
) []*proto.AccountGetResponse {
	var items []*proto.AccountGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountGetResponseToPorcelain(plumbings []*proto.AccountGetResponse) (
	[]*AccountGetResponse,
	error,
) {
	var items []*AccountGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertAccountGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountGrantToPorcelain(plumbing *proto.AccountGrant) (*AccountGrant, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountGrant{}
	porcelain.AccountID = plumbing.AccountId
	porcelain.ID = plumbing.Id
	porcelain.ResourceID = plumbing.ResourceId
	if v, err := convertTimestampToPorcelain(plumbing.StartFrom); err != nil {
		return nil, fmt.Errorf("error converting field StartFrom: %v", err)
	} else {
		porcelain.StartFrom = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.ValidUntil); err != nil {
		return nil, fmt.Errorf("error converting field ValidUntil: %v", err)
	} else {
		porcelain.ValidUntil = v
	}
	return porcelain, nil
}

func convertAccountGrantToPlumbing(porcelain *AccountGrant) *proto.AccountGrant {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountGrant{}
	plumbing.AccountId = (porcelain.AccountID)
	plumbing.Id = (porcelain.ID)
	plumbing.ResourceId = (porcelain.ResourceID)
	plumbing.StartFrom = convertTimestampToPlumbing(porcelain.StartFrom)
	plumbing.ValidUntil = convertTimestampToPlumbing(porcelain.ValidUntil)
	return plumbing
}
func convertRepeatedAccountGrantToPlumbing(
	porcelains []*AccountGrant,
) []*proto.AccountGrant {
	var items []*proto.AccountGrant
	for _, porcelain := range porcelains {
		items = append(items, convertAccountGrantToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountGrantToPorcelain(plumbings []*proto.AccountGrant) (
	[]*AccountGrant,
	error,
) {
	var items []*AccountGrant
	for _, plumbing := range plumbings {
		if v, err := convertAccountGrantToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountGrantCreateResponseToPorcelain(plumbing *proto.AccountGrantCreateResponse) (*AccountGrantCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountGrantCreateResponse{}
	if v, err := convertAccountGrantToPorcelain(plumbing.AccountGrant); err != nil {
		return nil, fmt.Errorf("error converting field AccountGrant: %v", err)
	} else {
		porcelain.AccountGrant = v
	}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertAccountGrantCreateResponseToPlumbing(porcelain *AccountGrantCreateResponse) *proto.AccountGrantCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountGrantCreateResponse{}
	plumbing.AccountGrant = convertAccountGrantToPlumbing(porcelain.AccountGrant)
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountGrantCreateResponseToPlumbing(
	porcelains []*AccountGrantCreateResponse,
) []*proto.AccountGrantCreateResponse {
	var items []*proto.AccountGrantCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountGrantCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountGrantCreateResponseToPorcelain(plumbings []*proto.AccountGrantCreateResponse) (
	[]*AccountGrantCreateResponse,
	error,
) {
	var items []*AccountGrantCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertAccountGrantCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountGrantDeleteResponseToPorcelain(plumbing *proto.AccountGrantDeleteResponse) (*AccountGrantDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountGrantDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertAccountGrantDeleteResponseToPlumbing(porcelain *AccountGrantDeleteResponse) *proto.AccountGrantDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountGrantDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountGrantDeleteResponseToPlumbing(
	porcelains []*AccountGrantDeleteResponse,
) []*proto.AccountGrantDeleteResponse {
	var items []*proto.AccountGrantDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountGrantDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountGrantDeleteResponseToPorcelain(plumbings []*proto.AccountGrantDeleteResponse) (
	[]*AccountGrantDeleteResponse,
	error,
) {
	var items []*AccountGrantDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertAccountGrantDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountGrantGetResponseToPorcelain(plumbing *proto.AccountGrantGetResponse) (*AccountGrantGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountGrantGetResponse{}
	if v, err := convertAccountGrantToPorcelain(plumbing.AccountGrant); err != nil {
		return nil, fmt.Errorf("error converting field AccountGrant: %v", err)
	} else {
		porcelain.AccountGrant = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertAccountGrantGetResponseToPlumbing(porcelain *AccountGrantGetResponse) *proto.AccountGrantGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountGrantGetResponse{}
	plumbing.AccountGrant = convertAccountGrantToPlumbing(porcelain.AccountGrant)
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountGrantGetResponseToPlumbing(
	porcelains []*AccountGrantGetResponse,
) []*proto.AccountGrantGetResponse {
	var items []*proto.AccountGrantGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountGrantGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountGrantGetResponseToPorcelain(plumbings []*proto.AccountGrantGetResponse) (
	[]*AccountGrantGetResponse,
	error,
) {
	var items []*AccountGrantGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertAccountGrantGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountGrantHistoryToPorcelain(plumbing *proto.AccountGrantHistory) (*AccountGrantHistory, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountGrantHistory{}
	if v, err := convertAccountGrantToPorcelain(plumbing.AccountGrant); err != nil {
		return nil, fmt.Errorf("error converting field AccountGrant: %v", err)
	} else {
		porcelain.AccountGrant = v
	}
	porcelain.ActivityID = plumbing.ActivityId
	if v, err := convertTimestampToPorcelain(plumbing.DeletedAt); err != nil {
		return nil, fmt.Errorf("error converting field DeletedAt: %v", err)
	} else {
		porcelain.DeletedAt = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	return porcelain, nil
}

func convertAccountGrantHistoryToPlumbing(porcelain *AccountGrantHistory) *proto.AccountGrantHistory {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountGrantHistory{}
	plumbing.AccountGrant = convertAccountGrantToPlumbing(porcelain.AccountGrant)
	plumbing.ActivityId = (porcelain.ActivityID)
	plumbing.DeletedAt = convertTimestampToPlumbing(porcelain.DeletedAt)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	return plumbing
}
func convertRepeatedAccountGrantHistoryToPlumbing(
	porcelains []*AccountGrantHistory,
) []*proto.AccountGrantHistory {
	var items []*proto.AccountGrantHistory
	for _, porcelain := range porcelains {
		items = append(items, convertAccountGrantHistoryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountGrantHistoryToPorcelain(plumbings []*proto.AccountGrantHistory) (
	[]*AccountGrantHistory,
	error,
) {
	var items []*AccountGrantHistory
	for _, plumbing := range plumbings {
		if v, err := convertAccountGrantHistoryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountHistoryToPorcelain(plumbing *proto.AccountHistory) (*AccountHistory, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountHistory{}
	if v, err := convertAccountToPorcelain(plumbing.Account); err != nil {
		return nil, fmt.Errorf("error converting field Account: %v", err)
	} else {
		porcelain.Account = v
	}
	porcelain.ActivityID = plumbing.ActivityId
	if v, err := convertTimestampToPorcelain(plumbing.DeletedAt); err != nil {
		return nil, fmt.Errorf("error converting field DeletedAt: %v", err)
	} else {
		porcelain.DeletedAt = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	return porcelain, nil
}

func convertAccountHistoryToPlumbing(porcelain *AccountHistory) *proto.AccountHistory {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountHistory{}
	plumbing.Account = convertAccountToPlumbing(porcelain.Account)
	plumbing.ActivityId = (porcelain.ActivityID)
	plumbing.DeletedAt = convertTimestampToPlumbing(porcelain.DeletedAt)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	return plumbing
}
func convertRepeatedAccountHistoryToPlumbing(
	porcelains []*AccountHistory,
) []*proto.AccountHistory {
	var items []*proto.AccountHistory
	for _, porcelain := range porcelains {
		items = append(items, convertAccountHistoryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountHistoryToPorcelain(plumbings []*proto.AccountHistory) (
	[]*AccountHistory,
	error,
) {
	var items []*AccountHistory
	for _, plumbing := range plumbings {
		if v, err := convertAccountHistoryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountPermissionToPorcelain(plumbing *proto.AccountPermission) (*AccountPermission, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountPermission{}
	porcelain.AccountID = plumbing.AccountId
	if v, err := convertTimestampToPorcelain(plumbing.GrantedAt); err != nil {
		return nil, fmt.Errorf("error converting field GrantedAt: %v", err)
	} else {
		porcelain.GrantedAt = v
	}
	porcelain.Permission = plumbing.Permission
	porcelain.Scope = plumbing.Scope
	porcelain.ScopedID = plumbing.ScopedId
	return porcelain, nil
}

func convertAccountPermissionToPlumbing(porcelain *AccountPermission) *proto.AccountPermission {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountPermission{}
	plumbing.AccountId = (porcelain.AccountID)
	plumbing.GrantedAt = convertTimestampToPlumbing(porcelain.GrantedAt)
	plumbing.Permission = (porcelain.Permission)
	plumbing.Scope = (porcelain.Scope)
	plumbing.ScopedId = (porcelain.ScopedID)
	return plumbing
}
func convertRepeatedAccountPermissionToPlumbing(
	porcelains []*AccountPermission,
) []*proto.AccountPermission {
	var items []*proto.AccountPermission
	for _, porcelain := range porcelains {
		items = append(items, convertAccountPermissionToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountPermissionToPorcelain(plumbings []*proto.AccountPermission) (
	[]*AccountPermission,
	error,
) {
	var items []*AccountPermission
	for _, plumbing := range plumbings {
		if v, err := convertAccountPermissionToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountResourceToPorcelain(plumbing *proto.AccountResource) (*AccountResource, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountResource{}
	porcelain.AccountGrantID = plumbing.AccountGrantId
	porcelain.AccountID = plumbing.AccountId
	if v, err := convertTimestampToPorcelain(plumbing.CreatedAt); err != nil {
		return nil, fmt.Errorf("error converting field CreatedAt: %v", err)
	} else {
		porcelain.CreatedAt = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.ExpiresAt); err != nil {
		return nil, fmt.Errorf("error converting field ExpiresAt: %v", err)
	} else {
		porcelain.ExpiresAt = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.GrantedAt); err != nil {
		return nil, fmt.Errorf("error converting field GrantedAt: %v", err)
	} else {
		porcelain.GrantedAt = v
	}
	porcelain.ResourceID = plumbing.ResourceId
	porcelain.RoleID = plumbing.RoleId
	return porcelain, nil
}

func convertAccountResourceToPlumbing(porcelain *AccountResource) *proto.AccountResource {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountResource{}
	plumbing.AccountGrantId = (porcelain.AccountGrantID)
	plumbing.AccountId = (porcelain.AccountID)
	plumbing.CreatedAt = convertTimestampToPlumbing(porcelain.CreatedAt)
	plumbing.ExpiresAt = convertTimestampToPlumbing(porcelain.ExpiresAt)
	plumbing.GrantedAt = convertTimestampToPlumbing(porcelain.GrantedAt)
	plumbing.ResourceId = (porcelain.ResourceID)
	plumbing.RoleId = (porcelain.RoleID)
	return plumbing
}
func convertRepeatedAccountResourceToPlumbing(
	porcelains []*AccountResource,
) []*proto.AccountResource {
	var items []*proto.AccountResource
	for _, porcelain := range porcelains {
		items = append(items, convertAccountResourceToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountResourceToPorcelain(plumbings []*proto.AccountResource) (
	[]*AccountResource,
	error,
) {
	var items []*AccountResource
	for _, plumbing := range plumbings {
		if v, err := convertAccountResourceToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountResourceHistoryToPorcelain(plumbing *proto.AccountResourceHistory) (*AccountResourceHistory, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountResourceHistory{}
	if v, err := convertAccountResourceToPorcelain(plumbing.AccountResource); err != nil {
		return nil, fmt.Errorf("error converting field AccountResource: %v", err)
	} else {
		porcelain.AccountResource = v
	}
	porcelain.ActivityID = plumbing.ActivityId
	if v, err := convertTimestampToPorcelain(plumbing.DeletedAt); err != nil {
		return nil, fmt.Errorf("error converting field DeletedAt: %v", err)
	} else {
		porcelain.DeletedAt = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	return porcelain, nil
}

func convertAccountResourceHistoryToPlumbing(porcelain *AccountResourceHistory) *proto.AccountResourceHistory {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountResourceHistory{}
	plumbing.AccountResource = convertAccountResourceToPlumbing(porcelain.AccountResource)
	plumbing.ActivityId = (porcelain.ActivityID)
	plumbing.DeletedAt = convertTimestampToPlumbing(porcelain.DeletedAt)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	return plumbing
}
func convertRepeatedAccountResourceHistoryToPlumbing(
	porcelains []*AccountResourceHistory,
) []*proto.AccountResourceHistory {
	var items []*proto.AccountResourceHistory
	for _, porcelain := range porcelains {
		items = append(items, convertAccountResourceHistoryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountResourceHistoryToPorcelain(plumbings []*proto.AccountResourceHistory) (
	[]*AccountResourceHistory,
	error,
) {
	var items []*AccountResourceHistory
	for _, plumbing := range plumbings {
		if v, err := convertAccountResourceHistoryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAccountUpdateResponseToPorcelain(plumbing *proto.AccountUpdateResponse) (*AccountUpdateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AccountUpdateResponse{}
	if v, err := convertAccountToPorcelain(plumbing.Account); err != nil {
		return nil, fmt.Errorf("error converting field Account: %v", err)
	} else {
		porcelain.Account = v
	}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertAccountUpdateResponseToPlumbing(porcelain *AccountUpdateResponse) *proto.AccountUpdateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AccountUpdateResponse{}
	plumbing.Account = convertAccountToPlumbing(porcelain.Account)
	plumbing.Meta = convertUpdateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedAccountUpdateResponseToPlumbing(
	porcelains []*AccountUpdateResponse,
) []*proto.AccountUpdateResponse {
	var items []*proto.AccountUpdateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertAccountUpdateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAccountUpdateResponseToPorcelain(plumbings []*proto.AccountUpdateResponse) (
	[]*AccountUpdateResponse,
	error,
) {
	var items []*AccountUpdateResponse
	for _, plumbing := range plumbings {
		if v, err := convertAccountUpdateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertActiveDirectoryStoreToPorcelain(plumbing *proto.ActiveDirectoryStore) (*ActiveDirectoryStore, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ActiveDirectoryStore{}
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.ServerAddress = plumbing.ServerAddress
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertActiveDirectoryStoreToPlumbing(porcelain *ActiveDirectoryStore) *proto.ActiveDirectoryStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ActiveDirectoryStore{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.ServerAddress = (porcelain.ServerAddress)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedActiveDirectoryStoreToPlumbing(
	porcelains []*ActiveDirectoryStore,
) []*proto.ActiveDirectoryStore {
	var items []*proto.ActiveDirectoryStore
	for _, porcelain := range porcelains {
		items = append(items, convertActiveDirectoryStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedActiveDirectoryStoreToPorcelain(plumbings []*proto.ActiveDirectoryStore) (
	[]*ActiveDirectoryStore,
	error,
) {
	var items []*ActiveDirectoryStore
	for _, plumbing := range plumbings {
		if v, err := convertActiveDirectoryStoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertActivityToPorcelain(plumbing *proto.Activity) (*Activity, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Activity{}
	if v, err := convertActivityActorToPorcelain(plumbing.Actor); err != nil {
		return nil, fmt.Errorf("error converting field Actor: %v", err)
	} else {
		porcelain.Actor = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.CompletedAt); err != nil {
		return nil, fmt.Errorf("error converting field CompletedAt: %v", err)
	} else {
		porcelain.CompletedAt = v
	}
	porcelain.Description = plumbing.Description
	if v, err := convertRepeatedActivityEntityToPorcelain(plumbing.Entities); err != nil {
		return nil, fmt.Errorf("error converting field Entities: %v", err)
	} else {
		porcelain.Entities = v
	}
	porcelain.ID = plumbing.Id
	porcelain.IPAddress = plumbing.IpAddress
	porcelain.UserAgent = plumbing.UserAgent
	porcelain.Verb = plumbing.Verb
	return porcelain, nil
}

func convertActivityToPlumbing(porcelain *Activity) *proto.Activity {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Activity{}
	plumbing.Actor = convertActivityActorToPlumbing(porcelain.Actor)
	plumbing.CompletedAt = convertTimestampToPlumbing(porcelain.CompletedAt)
	plumbing.Description = (porcelain.Description)
	plumbing.Entities = convertRepeatedActivityEntityToPlumbing(porcelain.Entities)
	plumbing.Id = (porcelain.ID)
	plumbing.IpAddress = (porcelain.IPAddress)
	plumbing.UserAgent = (porcelain.UserAgent)
	plumbing.Verb = (porcelain.Verb)
	return plumbing
}
func convertRepeatedActivityToPlumbing(
	porcelains []*Activity,
) []*proto.Activity {
	var items []*proto.Activity
	for _, porcelain := range porcelains {
		items = append(items, convertActivityToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedActivityToPorcelain(plumbings []*proto.Activity) (
	[]*Activity,
	error,
) {
	var items []*Activity
	for _, plumbing := range plumbings {
		if v, err := convertActivityToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertActivityActorToPorcelain(plumbing *proto.ActivityActor) (*ActivityActor, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ActivityActor{}
	porcelain.ActivityExternalID = plumbing.ActivityExternalId
	porcelain.Email = plumbing.Email
	porcelain.FirstName = plumbing.FirstName
	porcelain.ID = plumbing.Id
	porcelain.LastName = plumbing.LastName
	return porcelain, nil
}

func convertActivityActorToPlumbing(porcelain *ActivityActor) *proto.ActivityActor {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ActivityActor{}
	plumbing.ActivityExternalId = (porcelain.ActivityExternalID)
	plumbing.Email = (porcelain.Email)
	plumbing.FirstName = (porcelain.FirstName)
	plumbing.Id = (porcelain.ID)
	plumbing.LastName = (porcelain.LastName)
	return plumbing
}
func convertRepeatedActivityActorToPlumbing(
	porcelains []*ActivityActor,
) []*proto.ActivityActor {
	var items []*proto.ActivityActor
	for _, porcelain := range porcelains {
		items = append(items, convertActivityActorToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedActivityActorToPorcelain(plumbings []*proto.ActivityActor) (
	[]*ActivityActor,
	error,
) {
	var items []*ActivityActor
	for _, plumbing := range plumbings {
		if v, err := convertActivityActorToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertActivityEntityToPorcelain(plumbing *proto.ActivityEntity) (*ActivityEntity, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ActivityEntity{}
	porcelain.Email = plumbing.Email
	porcelain.ExternalID = plumbing.ExternalId
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Type = plumbing.Type
	return porcelain, nil
}

func convertActivityEntityToPlumbing(porcelain *ActivityEntity) *proto.ActivityEntity {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ActivityEntity{}
	plumbing.Email = (porcelain.Email)
	plumbing.ExternalId = (porcelain.ExternalID)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Type = (porcelain.Type)
	return plumbing
}
func convertRepeatedActivityEntityToPlumbing(
	porcelains []*ActivityEntity,
) []*proto.ActivityEntity {
	var items []*proto.ActivityEntity
	for _, porcelain := range porcelains {
		items = append(items, convertActivityEntityToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedActivityEntityToPorcelain(plumbings []*proto.ActivityEntity) (
	[]*ActivityEntity,
	error,
) {
	var items []*ActivityEntity
	for _, plumbing := range plumbings {
		if v, err := convertActivityEntityToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertActivityGetResponseToPorcelain(plumbing *proto.ActivityGetResponse) (*ActivityGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ActivityGetResponse{}
	if v, err := convertActivityToPorcelain(plumbing.Activity); err != nil {
		return nil, fmt.Errorf("error converting field Activity: %v", err)
	} else {
		porcelain.Activity = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertActivityGetResponseToPlumbing(porcelain *ActivityGetResponse) *proto.ActivityGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ActivityGetResponse{}
	plumbing.Activity = convertActivityToPlumbing(porcelain.Activity)
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedActivityGetResponseToPlumbing(
	porcelains []*ActivityGetResponse,
) []*proto.ActivityGetResponse {
	var items []*proto.ActivityGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertActivityGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedActivityGetResponseToPorcelain(plumbings []*proto.ActivityGetResponse) (
	[]*ActivityGetResponse,
	error,
) {
	var items []*ActivityGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertActivityGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAmazonEKSToPorcelain(plumbing *proto.AmazonEKS) (*AmazonEKS, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AmazonEKS{}
	porcelain.AccessKey = plumbing.AccessKey
	porcelain.AllowResourceRoleBypass = plumbing.AllowResourceRoleBypass
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.CertificateAuthority = plumbing.CertificateAuthority
	porcelain.ClusterName = plumbing.ClusterName
	porcelain.DiscoveryEnabled = plumbing.DiscoveryEnabled
	porcelain.DiscoveryUsername = plumbing.DiscoveryUsername
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Endpoint = plumbing.Endpoint
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.IdentityAliasHealthcheckUsername = plumbing.IdentityAliasHealthcheckUsername
	porcelain.IdentitySetID = plumbing.IdentitySetId
	porcelain.Name = plumbing.Name
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.Region = plumbing.Region
	porcelain.RoleArn = plumbing.RoleArn
	porcelain.RoleExternalID = plumbing.RoleExternalId
	porcelain.SecretAccessKey = plumbing.SecretAccessKey
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertAmazonEKSToPlumbing(porcelain *AmazonEKS) *proto.AmazonEKS {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AmazonEKS{}
	plumbing.AccessKey = (porcelain.AccessKey)
	plumbing.AllowResourceRoleBypass = (porcelain.AllowResourceRoleBypass)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.CertificateAuthority = (porcelain.CertificateAuthority)
	plumbing.ClusterName = (porcelain.ClusterName)
	plumbing.DiscoveryEnabled = (porcelain.DiscoveryEnabled)
	plumbing.DiscoveryUsername = (porcelain.DiscoveryUsername)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.IdentityAliasHealthcheckUsername = (porcelain.IdentityAliasHealthcheckUsername)
	plumbing.IdentitySetId = (porcelain.IdentitySetID)
	plumbing.Name = (porcelain.Name)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.Region = (porcelain.Region)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	plumbing.SecretAccessKey = (porcelain.SecretAccessKey)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedAmazonEKSToPlumbing(
	porcelains []*AmazonEKS,
) []*proto.AmazonEKS {
	var items []*proto.AmazonEKS
	for _, porcelain := range porcelains {
		items = append(items, convertAmazonEKSToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAmazonEKSToPorcelain(plumbings []*proto.AmazonEKS) (
	[]*AmazonEKS,
	error,
) {
	var items []*AmazonEKS
	for _, plumbing := range plumbings {
		if v, err := convertAmazonEKSToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAmazonEKSInstanceProfileToPorcelain(plumbing *proto.AmazonEKSInstanceProfile) (*AmazonEKSInstanceProfile, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AmazonEKSInstanceProfile{}
	porcelain.AllowResourceRoleBypass = plumbing.AllowResourceRoleBypass
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.CertificateAuthority = plumbing.CertificateAuthority
	porcelain.ClusterName = plumbing.ClusterName
	porcelain.DiscoveryEnabled = plumbing.DiscoveryEnabled
	porcelain.DiscoveryUsername = plumbing.DiscoveryUsername
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Endpoint = plumbing.Endpoint
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.IdentityAliasHealthcheckUsername = plumbing.IdentityAliasHealthcheckUsername
	porcelain.IdentitySetID = plumbing.IdentitySetId
	porcelain.Name = plumbing.Name
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.Region = plumbing.Region
	porcelain.RoleArn = plumbing.RoleArn
	porcelain.RoleExternalID = plumbing.RoleExternalId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertAmazonEKSInstanceProfileToPlumbing(porcelain *AmazonEKSInstanceProfile) *proto.AmazonEKSInstanceProfile {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AmazonEKSInstanceProfile{}
	plumbing.AllowResourceRoleBypass = (porcelain.AllowResourceRoleBypass)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.CertificateAuthority = (porcelain.CertificateAuthority)
	plumbing.ClusterName = (porcelain.ClusterName)
	plumbing.DiscoveryEnabled = (porcelain.DiscoveryEnabled)
	plumbing.DiscoveryUsername = (porcelain.DiscoveryUsername)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.IdentityAliasHealthcheckUsername = (porcelain.IdentityAliasHealthcheckUsername)
	plumbing.IdentitySetId = (porcelain.IdentitySetID)
	plumbing.Name = (porcelain.Name)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.Region = (porcelain.Region)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedAmazonEKSInstanceProfileToPlumbing(
	porcelains []*AmazonEKSInstanceProfile,
) []*proto.AmazonEKSInstanceProfile {
	var items []*proto.AmazonEKSInstanceProfile
	for _, porcelain := range porcelains {
		items = append(items, convertAmazonEKSInstanceProfileToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAmazonEKSInstanceProfileToPorcelain(plumbings []*proto.AmazonEKSInstanceProfile) (
	[]*AmazonEKSInstanceProfile,
	error,
) {
	var items []*AmazonEKSInstanceProfile
	for _, plumbing := range plumbings {
		if v, err := convertAmazonEKSInstanceProfileToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAmazonEKSInstanceProfileUserImpersonationToPorcelain(plumbing *proto.AmazonEKSInstanceProfileUserImpersonation) (*AmazonEKSInstanceProfileUserImpersonation, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AmazonEKSInstanceProfileUserImpersonation{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.CertificateAuthority = plumbing.CertificateAuthority
	porcelain.ClusterName = plumbing.ClusterName
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Endpoint = plumbing.Endpoint
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.Region = plumbing.Region
	porcelain.RoleArn = plumbing.RoleArn
	porcelain.RoleExternalID = plumbing.RoleExternalId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertAmazonEKSInstanceProfileUserImpersonationToPlumbing(porcelain *AmazonEKSInstanceProfileUserImpersonation) *proto.AmazonEKSInstanceProfileUserImpersonation {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AmazonEKSInstanceProfileUserImpersonation{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.CertificateAuthority = (porcelain.CertificateAuthority)
	plumbing.ClusterName = (porcelain.ClusterName)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.Region = (porcelain.Region)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedAmazonEKSInstanceProfileUserImpersonationToPlumbing(
	porcelains []*AmazonEKSInstanceProfileUserImpersonation,
) []*proto.AmazonEKSInstanceProfileUserImpersonation {
	var items []*proto.AmazonEKSInstanceProfileUserImpersonation
	for _, porcelain := range porcelains {
		items = append(items, convertAmazonEKSInstanceProfileUserImpersonationToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAmazonEKSInstanceProfileUserImpersonationToPorcelain(plumbings []*proto.AmazonEKSInstanceProfileUserImpersonation) (
	[]*AmazonEKSInstanceProfileUserImpersonation,
	error,
) {
	var items []*AmazonEKSInstanceProfileUserImpersonation
	for _, plumbing := range plumbings {
		if v, err := convertAmazonEKSInstanceProfileUserImpersonationToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAmazonEKSUserImpersonationToPorcelain(plumbing *proto.AmazonEKSUserImpersonation) (*AmazonEKSUserImpersonation, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AmazonEKSUserImpersonation{}
	porcelain.AccessKey = plumbing.AccessKey
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.CertificateAuthority = plumbing.CertificateAuthority
	porcelain.ClusterName = plumbing.ClusterName
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Endpoint = plumbing.Endpoint
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.Region = plumbing.Region
	porcelain.RoleArn = plumbing.RoleArn
	porcelain.RoleExternalID = plumbing.RoleExternalId
	porcelain.SecretAccessKey = plumbing.SecretAccessKey
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertAmazonEKSUserImpersonationToPlumbing(porcelain *AmazonEKSUserImpersonation) *proto.AmazonEKSUserImpersonation {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AmazonEKSUserImpersonation{}
	plumbing.AccessKey = (porcelain.AccessKey)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.CertificateAuthority = (porcelain.CertificateAuthority)
	plumbing.ClusterName = (porcelain.ClusterName)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.Region = (porcelain.Region)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	plumbing.SecretAccessKey = (porcelain.SecretAccessKey)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedAmazonEKSUserImpersonationToPlumbing(
	porcelains []*AmazonEKSUserImpersonation,
) []*proto.AmazonEKSUserImpersonation {
	var items []*proto.AmazonEKSUserImpersonation
	for _, porcelain := range porcelains {
		items = append(items, convertAmazonEKSUserImpersonationToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAmazonEKSUserImpersonationToPorcelain(plumbings []*proto.AmazonEKSUserImpersonation) (
	[]*AmazonEKSUserImpersonation,
	error,
) {
	var items []*AmazonEKSUserImpersonation
	for _, plumbing := range plumbings {
		if v, err := convertAmazonEKSUserImpersonationToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAmazonESToPorcelain(plumbing *proto.AmazonES) (*AmazonES, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AmazonES{}
	porcelain.AccessKey = plumbing.AccessKey
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Endpoint = plumbing.Endpoint
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.Region = plumbing.Region
	porcelain.RoleArn = plumbing.RoleArn
	porcelain.RoleExternalID = plumbing.RoleExternalId
	porcelain.SecretAccessKey = plumbing.SecretAccessKey
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertAmazonESToPlumbing(porcelain *AmazonES) *proto.AmazonES {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AmazonES{}
	plumbing.AccessKey = (porcelain.AccessKey)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.Region = (porcelain.Region)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	plumbing.SecretAccessKey = (porcelain.SecretAccessKey)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedAmazonESToPlumbing(
	porcelains []*AmazonES,
) []*proto.AmazonES {
	var items []*proto.AmazonES
	for _, porcelain := range porcelains {
		items = append(items, convertAmazonESToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAmazonESToPorcelain(plumbings []*proto.AmazonES) (
	[]*AmazonES,
	error,
) {
	var items []*AmazonES
	for _, plumbing := range plumbings {
		if v, err := convertAmazonESToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAmazonESIAMToPorcelain(plumbing *proto.AmazonESIAM) (*AmazonESIAM, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AmazonESIAM{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Endpoint = plumbing.Endpoint
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.Region = plumbing.Region
	porcelain.RoleArn = plumbing.RoleArn
	porcelain.RoleExternalID = plumbing.RoleExternalId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	return porcelain, nil
}

func convertAmazonESIAMToPlumbing(porcelain *AmazonESIAM) *proto.AmazonESIAM {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AmazonESIAM{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.Region = (porcelain.Region)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	return plumbing
}
func convertRepeatedAmazonESIAMToPlumbing(
	porcelains []*AmazonESIAM,
) []*proto.AmazonESIAM {
	var items []*proto.AmazonESIAM
	for _, porcelain := range porcelains {
		items = append(items, convertAmazonESIAMToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAmazonESIAMToPorcelain(plumbings []*proto.AmazonESIAM) (
	[]*AmazonESIAM,
	error,
) {
	var items []*AmazonESIAM
	for _, plumbing := range plumbings {
		if v, err := convertAmazonESIAMToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAmazonMQAMQP091ToPorcelain(plumbing *proto.AmazonMQAMQP091) (*AmazonMQAMQP091, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AmazonMQAMQP091{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertAmazonMQAMQP091ToPlumbing(porcelain *AmazonMQAMQP091) *proto.AmazonMQAMQP091 {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AmazonMQAMQP091{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedAmazonMQAMQP091ToPlumbing(
	porcelains []*AmazonMQAMQP091,
) []*proto.AmazonMQAMQP091 {
	var items []*proto.AmazonMQAMQP091
	for _, porcelain := range porcelains {
		items = append(items, convertAmazonMQAMQP091ToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAmazonMQAMQP091ToPorcelain(plumbings []*proto.AmazonMQAMQP091) (
	[]*AmazonMQAMQP091,
	error,
) {
	var items []*AmazonMQAMQP091
	for _, plumbing := range plumbings {
		if v, err := convertAmazonMQAMQP091ToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertApprovalWorkflowToPorcelain(plumbing *proto.ApprovalWorkflow) (*ApprovalWorkflow, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ApprovalWorkflow{}
	porcelain.ApprovalMode = plumbing.ApprovalMode
	porcelain.Description = plumbing.Description
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	return porcelain, nil
}

func convertApprovalWorkflowToPlumbing(porcelain *ApprovalWorkflow) *proto.ApprovalWorkflow {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ApprovalWorkflow{}
	plumbing.ApprovalMode = (porcelain.ApprovalMode)
	plumbing.Description = (porcelain.Description)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	return plumbing
}
func convertRepeatedApprovalWorkflowToPlumbing(
	porcelains []*ApprovalWorkflow,
) []*proto.ApprovalWorkflow {
	var items []*proto.ApprovalWorkflow
	for _, porcelain := range porcelains {
		items = append(items, convertApprovalWorkflowToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedApprovalWorkflowToPorcelain(plumbings []*proto.ApprovalWorkflow) (
	[]*ApprovalWorkflow,
	error,
) {
	var items []*ApprovalWorkflow
	for _, plumbing := range plumbings {
		if v, err := convertApprovalWorkflowToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertApprovalWorkflowApproverToPorcelain(plumbing *proto.ApprovalWorkflowApprover) (*ApprovalWorkflowApprover, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ApprovalWorkflowApprover{}
	porcelain.AccountID = plumbing.AccountId
	porcelain.ApprovalFlowID = plumbing.ApprovalFlowId
	porcelain.ApprovalStepID = plumbing.ApprovalStepId
	porcelain.ID = plumbing.Id
	porcelain.RoleID = plumbing.RoleId
	return porcelain, nil
}

func convertApprovalWorkflowApproverToPlumbing(porcelain *ApprovalWorkflowApprover) *proto.ApprovalWorkflowApprover {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ApprovalWorkflowApprover{}
	plumbing.AccountId = (porcelain.AccountID)
	plumbing.ApprovalFlowId = (porcelain.ApprovalFlowID)
	plumbing.ApprovalStepId = (porcelain.ApprovalStepID)
	plumbing.Id = (porcelain.ID)
	plumbing.RoleId = (porcelain.RoleID)
	return plumbing
}
func convertRepeatedApprovalWorkflowApproverToPlumbing(
	porcelains []*ApprovalWorkflowApprover,
) []*proto.ApprovalWorkflowApprover {
	var items []*proto.ApprovalWorkflowApprover
	for _, porcelain := range porcelains {
		items = append(items, convertApprovalWorkflowApproverToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedApprovalWorkflowApproverToPorcelain(plumbings []*proto.ApprovalWorkflowApprover) (
	[]*ApprovalWorkflowApprover,
	error,
) {
	var items []*ApprovalWorkflowApprover
	for _, plumbing := range plumbings {
		if v, err := convertApprovalWorkflowApproverToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertApprovalWorkflowApproverCreateResponseToPorcelain(plumbing *proto.ApprovalWorkflowApproverCreateResponse) (*ApprovalWorkflowApproverCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ApprovalWorkflowApproverCreateResponse{}
	if v, err := convertApprovalWorkflowApproverToPorcelain(plumbing.ApprovalWorkflowApprover); err != nil {
		return nil, fmt.Errorf("error converting field ApprovalWorkflowApprover: %v", err)
	} else {
		porcelain.ApprovalWorkflowApprover = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertApprovalWorkflowApproverCreateResponseToPlumbing(porcelain *ApprovalWorkflowApproverCreateResponse) *proto.ApprovalWorkflowApproverCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ApprovalWorkflowApproverCreateResponse{}
	plumbing.ApprovalWorkflowApprover = convertApprovalWorkflowApproverToPlumbing(porcelain.ApprovalWorkflowApprover)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedApprovalWorkflowApproverCreateResponseToPlumbing(
	porcelains []*ApprovalWorkflowApproverCreateResponse,
) []*proto.ApprovalWorkflowApproverCreateResponse {
	var items []*proto.ApprovalWorkflowApproverCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertApprovalWorkflowApproverCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedApprovalWorkflowApproverCreateResponseToPorcelain(plumbings []*proto.ApprovalWorkflowApproverCreateResponse) (
	[]*ApprovalWorkflowApproverCreateResponse,
	error,
) {
	var items []*ApprovalWorkflowApproverCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertApprovalWorkflowApproverCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertApprovalWorkflowApproverDeleteResponseToPorcelain(plumbing *proto.ApprovalWorkflowApproverDeleteResponse) (*ApprovalWorkflowApproverDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ApprovalWorkflowApproverDeleteResponse{}
	porcelain.ID = plumbing.Id
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertApprovalWorkflowApproverDeleteResponseToPlumbing(porcelain *ApprovalWorkflowApproverDeleteResponse) *proto.ApprovalWorkflowApproverDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ApprovalWorkflowApproverDeleteResponse{}
	plumbing.Id = (porcelain.ID)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedApprovalWorkflowApproverDeleteResponseToPlumbing(
	porcelains []*ApprovalWorkflowApproverDeleteResponse,
) []*proto.ApprovalWorkflowApproverDeleteResponse {
	var items []*proto.ApprovalWorkflowApproverDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertApprovalWorkflowApproverDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedApprovalWorkflowApproverDeleteResponseToPorcelain(plumbings []*proto.ApprovalWorkflowApproverDeleteResponse) (
	[]*ApprovalWorkflowApproverDeleteResponse,
	error,
) {
	var items []*ApprovalWorkflowApproverDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertApprovalWorkflowApproverDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertApprovalWorkflowApproverGetResponseToPorcelain(plumbing *proto.ApprovalWorkflowApproverGetResponse) (*ApprovalWorkflowApproverGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ApprovalWorkflowApproverGetResponse{}
	if v, err := convertApprovalWorkflowApproverToPorcelain(plumbing.ApprovalWorkflowApprover); err != nil {
		return nil, fmt.Errorf("error converting field ApprovalWorkflowApprover: %v", err)
	} else {
		porcelain.ApprovalWorkflowApprover = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertApprovalWorkflowApproverGetResponseToPlumbing(porcelain *ApprovalWorkflowApproverGetResponse) *proto.ApprovalWorkflowApproverGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ApprovalWorkflowApproverGetResponse{}
	plumbing.ApprovalWorkflowApprover = convertApprovalWorkflowApproverToPlumbing(porcelain.ApprovalWorkflowApprover)
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedApprovalWorkflowApproverGetResponseToPlumbing(
	porcelains []*ApprovalWorkflowApproverGetResponse,
) []*proto.ApprovalWorkflowApproverGetResponse {
	var items []*proto.ApprovalWorkflowApproverGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertApprovalWorkflowApproverGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedApprovalWorkflowApproverGetResponseToPorcelain(plumbings []*proto.ApprovalWorkflowApproverGetResponse) (
	[]*ApprovalWorkflowApproverGetResponse,
	error,
) {
	var items []*ApprovalWorkflowApproverGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertApprovalWorkflowApproverGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertApprovalWorkflowApproverHistoryToPorcelain(plumbing *proto.ApprovalWorkflowApproverHistory) (*ApprovalWorkflowApproverHistory, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ApprovalWorkflowApproverHistory{}
	porcelain.ActivityID = plumbing.ActivityId
	if v, err := convertApprovalWorkflowApproverToPorcelain(plumbing.ApprovalWorkflowApprover); err != nil {
		return nil, fmt.Errorf("error converting field ApprovalWorkflowApprover: %v", err)
	} else {
		porcelain.ApprovalWorkflowApprover = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.DeletedAt); err != nil {
		return nil, fmt.Errorf("error converting field DeletedAt: %v", err)
	} else {
		porcelain.DeletedAt = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	return porcelain, nil
}

func convertApprovalWorkflowApproverHistoryToPlumbing(porcelain *ApprovalWorkflowApproverHistory) *proto.ApprovalWorkflowApproverHistory {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ApprovalWorkflowApproverHistory{}
	plumbing.ActivityId = (porcelain.ActivityID)
	plumbing.ApprovalWorkflowApprover = convertApprovalWorkflowApproverToPlumbing(porcelain.ApprovalWorkflowApprover)
	plumbing.DeletedAt = convertTimestampToPlumbing(porcelain.DeletedAt)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	return plumbing
}
func convertRepeatedApprovalWorkflowApproverHistoryToPlumbing(
	porcelains []*ApprovalWorkflowApproverHistory,
) []*proto.ApprovalWorkflowApproverHistory {
	var items []*proto.ApprovalWorkflowApproverHistory
	for _, porcelain := range porcelains {
		items = append(items, convertApprovalWorkflowApproverHistoryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedApprovalWorkflowApproverHistoryToPorcelain(plumbings []*proto.ApprovalWorkflowApproverHistory) (
	[]*ApprovalWorkflowApproverHistory,
	error,
) {
	var items []*ApprovalWorkflowApproverHistory
	for _, plumbing := range plumbings {
		if v, err := convertApprovalWorkflowApproverHistoryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertApprovalWorkflowApproverListResponseToPorcelain(plumbing *proto.ApprovalWorkflowApproverListResponse) (*ApprovalWorkflowApproverListResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ApprovalWorkflowApproverListResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertApprovalWorkflowApproverListResponseToPlumbing(porcelain *ApprovalWorkflowApproverListResponse) *proto.ApprovalWorkflowApproverListResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ApprovalWorkflowApproverListResponse{}
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedApprovalWorkflowApproverListResponseToPlumbing(
	porcelains []*ApprovalWorkflowApproverListResponse,
) []*proto.ApprovalWorkflowApproverListResponse {
	var items []*proto.ApprovalWorkflowApproverListResponse
	for _, porcelain := range porcelains {
		items = append(items, convertApprovalWorkflowApproverListResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedApprovalWorkflowApproverListResponseToPorcelain(plumbings []*proto.ApprovalWorkflowApproverListResponse) (
	[]*ApprovalWorkflowApproverListResponse,
	error,
) {
	var items []*ApprovalWorkflowApproverListResponse
	for _, plumbing := range plumbings {
		if v, err := convertApprovalWorkflowApproverListResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertApprovalWorkflowCreateResponseToPorcelain(plumbing *proto.ApprovalWorkflowCreateResponse) (*ApprovalWorkflowCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ApprovalWorkflowCreateResponse{}
	if v, err := convertApprovalWorkflowToPorcelain(plumbing.ApprovalWorkflow); err != nil {
		return nil, fmt.Errorf("error converting field ApprovalWorkflow: %v", err)
	} else {
		porcelain.ApprovalWorkflow = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertApprovalWorkflowCreateResponseToPlumbing(porcelain *ApprovalWorkflowCreateResponse) *proto.ApprovalWorkflowCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ApprovalWorkflowCreateResponse{}
	plumbing.ApprovalWorkflow = convertApprovalWorkflowToPlumbing(porcelain.ApprovalWorkflow)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedApprovalWorkflowCreateResponseToPlumbing(
	porcelains []*ApprovalWorkflowCreateResponse,
) []*proto.ApprovalWorkflowCreateResponse {
	var items []*proto.ApprovalWorkflowCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertApprovalWorkflowCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedApprovalWorkflowCreateResponseToPorcelain(plumbings []*proto.ApprovalWorkflowCreateResponse) (
	[]*ApprovalWorkflowCreateResponse,
	error,
) {
	var items []*ApprovalWorkflowCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertApprovalWorkflowCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertApprovalWorkflowDeleteResponseToPorcelain(plumbing *proto.ApprovalWorkflowDeleteResponse) (*ApprovalWorkflowDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ApprovalWorkflowDeleteResponse{}
	porcelain.ID = plumbing.Id
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertApprovalWorkflowDeleteResponseToPlumbing(porcelain *ApprovalWorkflowDeleteResponse) *proto.ApprovalWorkflowDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ApprovalWorkflowDeleteResponse{}
	plumbing.Id = (porcelain.ID)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedApprovalWorkflowDeleteResponseToPlumbing(
	porcelains []*ApprovalWorkflowDeleteResponse,
) []*proto.ApprovalWorkflowDeleteResponse {
	var items []*proto.ApprovalWorkflowDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertApprovalWorkflowDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedApprovalWorkflowDeleteResponseToPorcelain(plumbings []*proto.ApprovalWorkflowDeleteResponse) (
	[]*ApprovalWorkflowDeleteResponse,
	error,
) {
	var items []*ApprovalWorkflowDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertApprovalWorkflowDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertApprovalWorkflowGetResponseToPorcelain(plumbing *proto.ApprovalWorkflowGetResponse) (*ApprovalWorkflowGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ApprovalWorkflowGetResponse{}
	if v, err := convertApprovalWorkflowToPorcelain(plumbing.ApprovalWorkflow); err != nil {
		return nil, fmt.Errorf("error converting field ApprovalWorkflow: %v", err)
	} else {
		porcelain.ApprovalWorkflow = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertApprovalWorkflowGetResponseToPlumbing(porcelain *ApprovalWorkflowGetResponse) *proto.ApprovalWorkflowGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ApprovalWorkflowGetResponse{}
	plumbing.ApprovalWorkflow = convertApprovalWorkflowToPlumbing(porcelain.ApprovalWorkflow)
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedApprovalWorkflowGetResponseToPlumbing(
	porcelains []*ApprovalWorkflowGetResponse,
) []*proto.ApprovalWorkflowGetResponse {
	var items []*proto.ApprovalWorkflowGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertApprovalWorkflowGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedApprovalWorkflowGetResponseToPorcelain(plumbings []*proto.ApprovalWorkflowGetResponse) (
	[]*ApprovalWorkflowGetResponse,
	error,
) {
	var items []*ApprovalWorkflowGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertApprovalWorkflowGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertApprovalWorkflowHistoryToPorcelain(plumbing *proto.ApprovalWorkflowHistory) (*ApprovalWorkflowHistory, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ApprovalWorkflowHistory{}
	porcelain.ActivityID = plumbing.ActivityId
	if v, err := convertApprovalWorkflowToPorcelain(plumbing.ApprovalWorkflow); err != nil {
		return nil, fmt.Errorf("error converting field ApprovalWorkflow: %v", err)
	} else {
		porcelain.ApprovalWorkflow = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.DeletedAt); err != nil {
		return nil, fmt.Errorf("error converting field DeletedAt: %v", err)
	} else {
		porcelain.DeletedAt = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	return porcelain, nil
}

func convertApprovalWorkflowHistoryToPlumbing(porcelain *ApprovalWorkflowHistory) *proto.ApprovalWorkflowHistory {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ApprovalWorkflowHistory{}
	plumbing.ActivityId = (porcelain.ActivityID)
	plumbing.ApprovalWorkflow = convertApprovalWorkflowToPlumbing(porcelain.ApprovalWorkflow)
	plumbing.DeletedAt = convertTimestampToPlumbing(porcelain.DeletedAt)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	return plumbing
}
func convertRepeatedApprovalWorkflowHistoryToPlumbing(
	porcelains []*ApprovalWorkflowHistory,
) []*proto.ApprovalWorkflowHistory {
	var items []*proto.ApprovalWorkflowHistory
	for _, porcelain := range porcelains {
		items = append(items, convertApprovalWorkflowHistoryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedApprovalWorkflowHistoryToPorcelain(plumbings []*proto.ApprovalWorkflowHistory) (
	[]*ApprovalWorkflowHistory,
	error,
) {
	var items []*ApprovalWorkflowHistory
	for _, plumbing := range plumbings {
		if v, err := convertApprovalWorkflowHistoryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertApprovalWorkflowListResponseToPorcelain(plumbing *proto.ApprovalWorkflowListResponse) (*ApprovalWorkflowListResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ApprovalWorkflowListResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertApprovalWorkflowListResponseToPlumbing(porcelain *ApprovalWorkflowListResponse) *proto.ApprovalWorkflowListResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ApprovalWorkflowListResponse{}
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedApprovalWorkflowListResponseToPlumbing(
	porcelains []*ApprovalWorkflowListResponse,
) []*proto.ApprovalWorkflowListResponse {
	var items []*proto.ApprovalWorkflowListResponse
	for _, porcelain := range porcelains {
		items = append(items, convertApprovalWorkflowListResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedApprovalWorkflowListResponseToPorcelain(plumbings []*proto.ApprovalWorkflowListResponse) (
	[]*ApprovalWorkflowListResponse,
	error,
) {
	var items []*ApprovalWorkflowListResponse
	for _, plumbing := range plumbings {
		if v, err := convertApprovalWorkflowListResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertApprovalWorkflowStepToPorcelain(plumbing *proto.ApprovalWorkflowStep) (*ApprovalWorkflowStep, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ApprovalWorkflowStep{}
	porcelain.ApprovalFlowID = plumbing.ApprovalFlowId
	porcelain.ID = plumbing.Id
	return porcelain, nil
}

func convertApprovalWorkflowStepToPlumbing(porcelain *ApprovalWorkflowStep) *proto.ApprovalWorkflowStep {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ApprovalWorkflowStep{}
	plumbing.ApprovalFlowId = (porcelain.ApprovalFlowID)
	plumbing.Id = (porcelain.ID)
	return plumbing
}
func convertRepeatedApprovalWorkflowStepToPlumbing(
	porcelains []*ApprovalWorkflowStep,
) []*proto.ApprovalWorkflowStep {
	var items []*proto.ApprovalWorkflowStep
	for _, porcelain := range porcelains {
		items = append(items, convertApprovalWorkflowStepToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedApprovalWorkflowStepToPorcelain(plumbings []*proto.ApprovalWorkflowStep) (
	[]*ApprovalWorkflowStep,
	error,
) {
	var items []*ApprovalWorkflowStep
	for _, plumbing := range plumbings {
		if v, err := convertApprovalWorkflowStepToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertApprovalWorkflowStepCreateResponseToPorcelain(plumbing *proto.ApprovalWorkflowStepCreateResponse) (*ApprovalWorkflowStepCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ApprovalWorkflowStepCreateResponse{}
	if v, err := convertApprovalWorkflowStepToPorcelain(plumbing.ApprovalWorkflowStep); err != nil {
		return nil, fmt.Errorf("error converting field ApprovalWorkflowStep: %v", err)
	} else {
		porcelain.ApprovalWorkflowStep = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertApprovalWorkflowStepCreateResponseToPlumbing(porcelain *ApprovalWorkflowStepCreateResponse) *proto.ApprovalWorkflowStepCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ApprovalWorkflowStepCreateResponse{}
	plumbing.ApprovalWorkflowStep = convertApprovalWorkflowStepToPlumbing(porcelain.ApprovalWorkflowStep)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedApprovalWorkflowStepCreateResponseToPlumbing(
	porcelains []*ApprovalWorkflowStepCreateResponse,
) []*proto.ApprovalWorkflowStepCreateResponse {
	var items []*proto.ApprovalWorkflowStepCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertApprovalWorkflowStepCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedApprovalWorkflowStepCreateResponseToPorcelain(plumbings []*proto.ApprovalWorkflowStepCreateResponse) (
	[]*ApprovalWorkflowStepCreateResponse,
	error,
) {
	var items []*ApprovalWorkflowStepCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertApprovalWorkflowStepCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertApprovalWorkflowStepDeleteResponseToPorcelain(plumbing *proto.ApprovalWorkflowStepDeleteResponse) (*ApprovalWorkflowStepDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ApprovalWorkflowStepDeleteResponse{}
	porcelain.ID = plumbing.Id
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertApprovalWorkflowStepDeleteResponseToPlumbing(porcelain *ApprovalWorkflowStepDeleteResponse) *proto.ApprovalWorkflowStepDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ApprovalWorkflowStepDeleteResponse{}
	plumbing.Id = (porcelain.ID)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedApprovalWorkflowStepDeleteResponseToPlumbing(
	porcelains []*ApprovalWorkflowStepDeleteResponse,
) []*proto.ApprovalWorkflowStepDeleteResponse {
	var items []*proto.ApprovalWorkflowStepDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertApprovalWorkflowStepDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedApprovalWorkflowStepDeleteResponseToPorcelain(plumbings []*proto.ApprovalWorkflowStepDeleteResponse) (
	[]*ApprovalWorkflowStepDeleteResponse,
	error,
) {
	var items []*ApprovalWorkflowStepDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertApprovalWorkflowStepDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertApprovalWorkflowStepGetResponseToPorcelain(plumbing *proto.ApprovalWorkflowStepGetResponse) (*ApprovalWorkflowStepGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ApprovalWorkflowStepGetResponse{}
	if v, err := convertApprovalWorkflowStepToPorcelain(plumbing.ApprovalWorkflowStep); err != nil {
		return nil, fmt.Errorf("error converting field ApprovalWorkflowStep: %v", err)
	} else {
		porcelain.ApprovalWorkflowStep = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertApprovalWorkflowStepGetResponseToPlumbing(porcelain *ApprovalWorkflowStepGetResponse) *proto.ApprovalWorkflowStepGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ApprovalWorkflowStepGetResponse{}
	plumbing.ApprovalWorkflowStep = convertApprovalWorkflowStepToPlumbing(porcelain.ApprovalWorkflowStep)
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedApprovalWorkflowStepGetResponseToPlumbing(
	porcelains []*ApprovalWorkflowStepGetResponse,
) []*proto.ApprovalWorkflowStepGetResponse {
	var items []*proto.ApprovalWorkflowStepGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertApprovalWorkflowStepGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedApprovalWorkflowStepGetResponseToPorcelain(plumbings []*proto.ApprovalWorkflowStepGetResponse) (
	[]*ApprovalWorkflowStepGetResponse,
	error,
) {
	var items []*ApprovalWorkflowStepGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertApprovalWorkflowStepGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertApprovalWorkflowStepHistoryToPorcelain(plumbing *proto.ApprovalWorkflowStepHistory) (*ApprovalWorkflowStepHistory, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ApprovalWorkflowStepHistory{}
	porcelain.ActivityID = plumbing.ActivityId
	if v, err := convertApprovalWorkflowStepToPorcelain(plumbing.ApprovalWorkflowStep); err != nil {
		return nil, fmt.Errorf("error converting field ApprovalWorkflowStep: %v", err)
	} else {
		porcelain.ApprovalWorkflowStep = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.DeletedAt); err != nil {
		return nil, fmt.Errorf("error converting field DeletedAt: %v", err)
	} else {
		porcelain.DeletedAt = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	return porcelain, nil
}

func convertApprovalWorkflowStepHistoryToPlumbing(porcelain *ApprovalWorkflowStepHistory) *proto.ApprovalWorkflowStepHistory {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ApprovalWorkflowStepHistory{}
	plumbing.ActivityId = (porcelain.ActivityID)
	plumbing.ApprovalWorkflowStep = convertApprovalWorkflowStepToPlumbing(porcelain.ApprovalWorkflowStep)
	plumbing.DeletedAt = convertTimestampToPlumbing(porcelain.DeletedAt)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	return plumbing
}
func convertRepeatedApprovalWorkflowStepHistoryToPlumbing(
	porcelains []*ApprovalWorkflowStepHistory,
) []*proto.ApprovalWorkflowStepHistory {
	var items []*proto.ApprovalWorkflowStepHistory
	for _, porcelain := range porcelains {
		items = append(items, convertApprovalWorkflowStepHistoryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedApprovalWorkflowStepHistoryToPorcelain(plumbings []*proto.ApprovalWorkflowStepHistory) (
	[]*ApprovalWorkflowStepHistory,
	error,
) {
	var items []*ApprovalWorkflowStepHistory
	for _, plumbing := range plumbings {
		if v, err := convertApprovalWorkflowStepHistoryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertApprovalWorkflowStepListResponseToPorcelain(plumbing *proto.ApprovalWorkflowStepListResponse) (*ApprovalWorkflowStepListResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ApprovalWorkflowStepListResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertApprovalWorkflowStepListResponseToPlumbing(porcelain *ApprovalWorkflowStepListResponse) *proto.ApprovalWorkflowStepListResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ApprovalWorkflowStepListResponse{}
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedApprovalWorkflowStepListResponseToPlumbing(
	porcelains []*ApprovalWorkflowStepListResponse,
) []*proto.ApprovalWorkflowStepListResponse {
	var items []*proto.ApprovalWorkflowStepListResponse
	for _, porcelain := range porcelains {
		items = append(items, convertApprovalWorkflowStepListResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedApprovalWorkflowStepListResponseToPorcelain(plumbings []*proto.ApprovalWorkflowStepListResponse) (
	[]*ApprovalWorkflowStepListResponse,
	error,
) {
	var items []*ApprovalWorkflowStepListResponse
	for _, plumbing := range plumbings {
		if v, err := convertApprovalWorkflowStepListResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertApprovalWorkflowUpdateResponseToPorcelain(plumbing *proto.ApprovalWorkflowUpdateResponse) (*ApprovalWorkflowUpdateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ApprovalWorkflowUpdateResponse{}
	if v, err := convertApprovalWorkflowToPorcelain(plumbing.ApprovalWorkflow); err != nil {
		return nil, fmt.Errorf("error converting field ApprovalWorkflow: %v", err)
	} else {
		porcelain.ApprovalWorkflow = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertApprovalWorkflowUpdateResponseToPlumbing(porcelain *ApprovalWorkflowUpdateResponse) *proto.ApprovalWorkflowUpdateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ApprovalWorkflowUpdateResponse{}
	plumbing.ApprovalWorkflow = convertApprovalWorkflowToPlumbing(porcelain.ApprovalWorkflow)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedApprovalWorkflowUpdateResponseToPlumbing(
	porcelains []*ApprovalWorkflowUpdateResponse,
) []*proto.ApprovalWorkflowUpdateResponse {
	var items []*proto.ApprovalWorkflowUpdateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertApprovalWorkflowUpdateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedApprovalWorkflowUpdateResponseToPorcelain(plumbings []*proto.ApprovalWorkflowUpdateResponse) (
	[]*ApprovalWorkflowUpdateResponse,
	error,
) {
	var items []*ApprovalWorkflowUpdateResponse
	for _, plumbing := range plumbings {
		if v, err := convertApprovalWorkflowUpdateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAthenaToPorcelain(plumbing *proto.Athena) (*Athena, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Athena{}
	porcelain.AccessKey = plumbing.AccessKey
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Output = plumbing.Output
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.Region = plumbing.Region
	porcelain.RoleArn = plumbing.RoleArn
	porcelain.RoleExternalID = plumbing.RoleExternalId
	porcelain.SecretAccessKey = plumbing.SecretAccessKey
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertAthenaToPlumbing(porcelain *Athena) *proto.Athena {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Athena{}
	plumbing.AccessKey = (porcelain.AccessKey)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Output = (porcelain.Output)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.Region = (porcelain.Region)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	plumbing.SecretAccessKey = (porcelain.SecretAccessKey)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedAthenaToPlumbing(
	porcelains []*Athena,
) []*proto.Athena {
	var items []*proto.Athena
	for _, porcelain := range porcelains {
		items = append(items, convertAthenaToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAthenaToPorcelain(plumbings []*proto.Athena) (
	[]*Athena,
	error,
) {
	var items []*Athena
	for _, plumbing := range plumbings {
		if v, err := convertAthenaToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAthenaIAMToPorcelain(plumbing *proto.AthenaIAM) (*AthenaIAM, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AthenaIAM{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Output = plumbing.Output
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.Region = plumbing.Region
	porcelain.RoleArn = plumbing.RoleArn
	porcelain.RoleExternalID = plumbing.RoleExternalId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertAthenaIAMToPlumbing(porcelain *AthenaIAM) *proto.AthenaIAM {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AthenaIAM{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Output = (porcelain.Output)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.Region = (porcelain.Region)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedAthenaIAMToPlumbing(
	porcelains []*AthenaIAM,
) []*proto.AthenaIAM {
	var items []*proto.AthenaIAM
	for _, porcelain := range porcelains {
		items = append(items, convertAthenaIAMToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAthenaIAMToPorcelain(plumbings []*proto.AthenaIAM) (
	[]*AthenaIAM,
	error,
) {
	var items []*AthenaIAM
	for _, plumbing := range plumbings {
		if v, err := convertAthenaIAMToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAuroraMysqlToPorcelain(plumbing *proto.AuroraMysql) (*AuroraMysql, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AuroraMysql{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.RequireNativeAuth = plumbing.RequireNativeAuth
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.UseAzureSingleServerUsernames = plumbing.UseAzureSingleServerUsernames
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertAuroraMysqlToPlumbing(porcelain *AuroraMysql) *proto.AuroraMysql {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AuroraMysql{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.RequireNativeAuth = (porcelain.RequireNativeAuth)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.UseAzureSingleServerUsernames = (porcelain.UseAzureSingleServerUsernames)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedAuroraMysqlToPlumbing(
	porcelains []*AuroraMysql,
) []*proto.AuroraMysql {
	var items []*proto.AuroraMysql
	for _, porcelain := range porcelains {
		items = append(items, convertAuroraMysqlToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAuroraMysqlToPorcelain(plumbings []*proto.AuroraMysql) (
	[]*AuroraMysql,
	error,
) {
	var items []*AuroraMysql
	for _, plumbing := range plumbings {
		if v, err := convertAuroraMysqlToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAuroraMysqlIAMToPorcelain(plumbing *proto.AuroraMysqlIAM) (*AuroraMysqlIAM, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AuroraMysqlIAM{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.Region = plumbing.Region
	porcelain.RoleAssumptionArn = plumbing.RoleAssumptionArn
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertAuroraMysqlIAMToPlumbing(porcelain *AuroraMysqlIAM) *proto.AuroraMysqlIAM {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AuroraMysqlIAM{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.Region = (porcelain.Region)
	plumbing.RoleAssumptionArn = (porcelain.RoleAssumptionArn)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedAuroraMysqlIAMToPlumbing(
	porcelains []*AuroraMysqlIAM,
) []*proto.AuroraMysqlIAM {
	var items []*proto.AuroraMysqlIAM
	for _, porcelain := range porcelains {
		items = append(items, convertAuroraMysqlIAMToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAuroraMysqlIAMToPorcelain(plumbings []*proto.AuroraMysqlIAM) (
	[]*AuroraMysqlIAM,
	error,
) {
	var items []*AuroraMysqlIAM
	for _, plumbing := range plumbings {
		if v, err := convertAuroraMysqlIAMToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAuroraPostgresToPorcelain(plumbing *proto.AuroraPostgres) (*AuroraPostgres, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AuroraPostgres{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.OverrideDatabase = plumbing.OverrideDatabase
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertAuroraPostgresToPlumbing(porcelain *AuroraPostgres) *proto.AuroraPostgres {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AuroraPostgres{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedAuroraPostgresToPlumbing(
	porcelains []*AuroraPostgres,
) []*proto.AuroraPostgres {
	var items []*proto.AuroraPostgres
	for _, porcelain := range porcelains {
		items = append(items, convertAuroraPostgresToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAuroraPostgresToPorcelain(plumbings []*proto.AuroraPostgres) (
	[]*AuroraPostgres,
	error,
) {
	var items []*AuroraPostgres
	for _, plumbing := range plumbings {
		if v, err := convertAuroraPostgresToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAuroraPostgresIAMToPorcelain(plumbing *proto.AuroraPostgresIAM) (*AuroraPostgresIAM, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AuroraPostgresIAM{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.OverrideDatabase = plumbing.OverrideDatabase
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.Region = plumbing.Region
	porcelain.RoleAssumptionArn = plumbing.RoleAssumptionArn
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertAuroraPostgresIAMToPlumbing(porcelain *AuroraPostgresIAM) *proto.AuroraPostgresIAM {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AuroraPostgresIAM{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.Region = (porcelain.Region)
	plumbing.RoleAssumptionArn = (porcelain.RoleAssumptionArn)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedAuroraPostgresIAMToPlumbing(
	porcelains []*AuroraPostgresIAM,
) []*proto.AuroraPostgresIAM {
	var items []*proto.AuroraPostgresIAM
	for _, porcelain := range porcelains {
		items = append(items, convertAuroraPostgresIAMToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAuroraPostgresIAMToPorcelain(plumbings []*proto.AuroraPostgresIAM) (
	[]*AuroraPostgresIAM,
	error,
) {
	var items []*AuroraPostgresIAM
	for _, plumbing := range plumbings {
		if v, err := convertAuroraPostgresIAMToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAzureToPorcelain(plumbing *proto.Azure) (*Azure, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Azure{}
	porcelain.AppID = plumbing.AppId
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TenantID = plumbing.TenantId
	return porcelain, nil
}

func convertAzureToPlumbing(porcelain *Azure) *proto.Azure {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Azure{}
	plumbing.AppId = (porcelain.AppID)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TenantId = (porcelain.TenantID)
	return plumbing
}
func convertRepeatedAzureToPlumbing(
	porcelains []*Azure,
) []*proto.Azure {
	var items []*proto.Azure
	for _, porcelain := range porcelains {
		items = append(items, convertAzureToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAzureToPorcelain(plumbings []*proto.Azure) (
	[]*Azure,
	error,
) {
	var items []*Azure
	for _, plumbing := range plumbings {
		if v, err := convertAzureToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAzureCertificateToPorcelain(plumbing *proto.AzureCertificate) (*AzureCertificate, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AzureCertificate{}
	porcelain.AppID = plumbing.AppId
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.ClientCertificate = plumbing.ClientCertificate
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TenantID = plumbing.TenantId
	return porcelain, nil
}

func convertAzureCertificateToPlumbing(porcelain *AzureCertificate) *proto.AzureCertificate {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AzureCertificate{}
	plumbing.AppId = (porcelain.AppID)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.ClientCertificate = (porcelain.ClientCertificate)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TenantId = (porcelain.TenantID)
	return plumbing
}
func convertRepeatedAzureCertificateToPlumbing(
	porcelains []*AzureCertificate,
) []*proto.AzureCertificate {
	var items []*proto.AzureCertificate
	for _, porcelain := range porcelains {
		items = append(items, convertAzureCertificateToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAzureCertificateToPorcelain(plumbings []*proto.AzureCertificate) (
	[]*AzureCertificate,
	error,
) {
	var items []*AzureCertificate
	for _, plumbing := range plumbings {
		if v, err := convertAzureCertificateToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAzureMysqlToPorcelain(plumbing *proto.AzureMysql) (*AzureMysql, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AzureMysql{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.RequireNativeAuth = plumbing.RequireNativeAuth
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.UseAzureSingleServerUsernames = plumbing.UseAzureSingleServerUsernames
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertAzureMysqlToPlumbing(porcelain *AzureMysql) *proto.AzureMysql {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AzureMysql{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.RequireNativeAuth = (porcelain.RequireNativeAuth)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.UseAzureSingleServerUsernames = (porcelain.UseAzureSingleServerUsernames)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedAzureMysqlToPlumbing(
	porcelains []*AzureMysql,
) []*proto.AzureMysql {
	var items []*proto.AzureMysql
	for _, porcelain := range porcelains {
		items = append(items, convertAzureMysqlToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAzureMysqlToPorcelain(plumbings []*proto.AzureMysql) (
	[]*AzureMysql,
	error,
) {
	var items []*AzureMysql
	for _, plumbing := range plumbings {
		if v, err := convertAzureMysqlToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAzurePostgresToPorcelain(plumbing *proto.AzurePostgres) (*AzurePostgres, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AzurePostgres{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.OverrideDatabase = plumbing.OverrideDatabase
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertAzurePostgresToPlumbing(porcelain *AzurePostgres) *proto.AzurePostgres {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AzurePostgres{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedAzurePostgresToPlumbing(
	porcelains []*AzurePostgres,
) []*proto.AzurePostgres {
	var items []*proto.AzurePostgres
	for _, porcelain := range porcelains {
		items = append(items, convertAzurePostgresToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAzurePostgresToPorcelain(plumbings []*proto.AzurePostgres) (
	[]*AzurePostgres,
	error,
) {
	var items []*AzurePostgres
	for _, plumbing := range plumbings {
		if v, err := convertAzurePostgresToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAzurePostgresManagedIdentityToPorcelain(plumbing *proto.AzurePostgresManagedIdentity) (*AzurePostgresManagedIdentity, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AzurePostgresManagedIdentity{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.OverrideDatabase = plumbing.OverrideDatabase
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.UseAzureSingleServerUsernames = plumbing.UseAzureSingleServerUsernames
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertAzurePostgresManagedIdentityToPlumbing(porcelain *AzurePostgresManagedIdentity) *proto.AzurePostgresManagedIdentity {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AzurePostgresManagedIdentity{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.UseAzureSingleServerUsernames = (porcelain.UseAzureSingleServerUsernames)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedAzurePostgresManagedIdentityToPlumbing(
	porcelains []*AzurePostgresManagedIdentity,
) []*proto.AzurePostgresManagedIdentity {
	var items []*proto.AzurePostgresManagedIdentity
	for _, porcelain := range porcelains {
		items = append(items, convertAzurePostgresManagedIdentityToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAzurePostgresManagedIdentityToPorcelain(plumbings []*proto.AzurePostgresManagedIdentity) (
	[]*AzurePostgresManagedIdentity,
	error,
) {
	var items []*AzurePostgresManagedIdentity
	for _, plumbing := range plumbings {
		if v, err := convertAzurePostgresManagedIdentityToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertAzureStoreToPorcelain(plumbing *proto.AzureStore) (*AzureStore, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &AzureStore{}
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.VaultUri = plumbing.VaultUri
	return porcelain, nil
}

func convertAzureStoreToPlumbing(porcelain *AzureStore) *proto.AzureStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.AzureStore{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.VaultUri = (porcelain.VaultUri)
	return plumbing
}
func convertRepeatedAzureStoreToPlumbing(
	porcelains []*AzureStore,
) []*proto.AzureStore {
	var items []*proto.AzureStore
	for _, porcelain := range porcelains {
		items = append(items, convertAzureStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedAzureStoreToPorcelain(plumbings []*proto.AzureStore) (
	[]*AzureStore,
	error,
) {
	var items []*AzureStore
	for _, plumbing := range plumbings {
		if v, err := convertAzureStoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertBigQueryToPorcelain(plumbing *proto.BigQuery) (*BigQuery, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &BigQuery{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Endpoint = plumbing.Endpoint
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.PrivateKey = plumbing.PrivateKey
	porcelain.Project = plumbing.Project
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertBigQueryToPlumbing(porcelain *BigQuery) *proto.BigQuery {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.BigQuery{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.PrivateKey = (porcelain.PrivateKey)
	plumbing.Project = (porcelain.Project)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedBigQueryToPlumbing(
	porcelains []*BigQuery,
) []*proto.BigQuery {
	var items []*proto.BigQuery
	for _, porcelain := range porcelains {
		items = append(items, convertBigQueryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedBigQueryToPorcelain(plumbings []*proto.BigQuery) (
	[]*BigQuery,
	error,
) {
	var items []*BigQuery
	for _, plumbing := range plumbings {
		if v, err := convertBigQueryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertCassandraToPorcelain(plumbing *proto.Cassandra) (*Cassandra, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Cassandra{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertCassandraToPlumbing(porcelain *Cassandra) *proto.Cassandra {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Cassandra{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedCassandraToPlumbing(
	porcelains []*Cassandra,
) []*proto.Cassandra {
	var items []*proto.Cassandra
	for _, porcelain := range porcelains {
		items = append(items, convertCassandraToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedCassandraToPorcelain(plumbings []*proto.Cassandra) (
	[]*Cassandra,
	error,
) {
	var items []*Cassandra
	for _, plumbing := range plumbings {
		if v, err := convertCassandraToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertCitusToPorcelain(plumbing *proto.Citus) (*Citus, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Citus{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.OverrideDatabase = plumbing.OverrideDatabase
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertCitusToPlumbing(porcelain *Citus) *proto.Citus {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Citus{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedCitusToPlumbing(
	porcelains []*Citus,
) []*proto.Citus {
	var items []*proto.Citus
	for _, porcelain := range porcelains {
		items = append(items, convertCitusToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedCitusToPorcelain(plumbings []*proto.Citus) (
	[]*Citus,
	error,
) {
	var items []*Citus
	for _, plumbing := range plumbings {
		if v, err := convertCitusToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertClickHouseHTTPToPorcelain(plumbing *proto.ClickHouseHTTP) (*ClickHouseHTTP, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ClickHouseHTTP{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Url = plumbing.Url
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertClickHouseHTTPToPlumbing(porcelain *ClickHouseHTTP) *proto.ClickHouseHTTP {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ClickHouseHTTP{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Url = (porcelain.Url)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedClickHouseHTTPToPlumbing(
	porcelains []*ClickHouseHTTP,
) []*proto.ClickHouseHTTP {
	var items []*proto.ClickHouseHTTP
	for _, porcelain := range porcelains {
		items = append(items, convertClickHouseHTTPToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedClickHouseHTTPToPorcelain(plumbings []*proto.ClickHouseHTTP) (
	[]*ClickHouseHTTP,
	error,
) {
	var items []*ClickHouseHTTP
	for _, plumbing := range plumbings {
		if v, err := convertClickHouseHTTPToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertClickHouseMySQLToPorcelain(plumbing *proto.ClickHouseMySQL) (*ClickHouseMySQL, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ClickHouseMySQL{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.RequireNativeAuth = plumbing.RequireNativeAuth
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertClickHouseMySQLToPlumbing(porcelain *ClickHouseMySQL) *proto.ClickHouseMySQL {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ClickHouseMySQL{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.RequireNativeAuth = (porcelain.RequireNativeAuth)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedClickHouseMySQLToPlumbing(
	porcelains []*ClickHouseMySQL,
) []*proto.ClickHouseMySQL {
	var items []*proto.ClickHouseMySQL
	for _, porcelain := range porcelains {
		items = append(items, convertClickHouseMySQLToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedClickHouseMySQLToPorcelain(plumbings []*proto.ClickHouseMySQL) (
	[]*ClickHouseMySQL,
	error,
) {
	var items []*ClickHouseMySQL
	for _, plumbing := range plumbings {
		if v, err := convertClickHouseMySQLToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertClickHouseTCPToPorcelain(plumbing *proto.ClickHouseTCP) (*ClickHouseTCP, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ClickHouseTCP{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertClickHouseTCPToPlumbing(porcelain *ClickHouseTCP) *proto.ClickHouseTCP {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ClickHouseTCP{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedClickHouseTCPToPlumbing(
	porcelains []*ClickHouseTCP,
) []*proto.ClickHouseTCP {
	var items []*proto.ClickHouseTCP
	for _, porcelain := range porcelains {
		items = append(items, convertClickHouseTCPToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedClickHouseTCPToPorcelain(plumbings []*proto.ClickHouseTCP) (
	[]*ClickHouseTCP,
	error,
) {
	var items []*ClickHouseTCP
	for _, plumbing := range plumbings {
		if v, err := convertClickHouseTCPToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertClustrixToPorcelain(plumbing *proto.Clustrix) (*Clustrix, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Clustrix{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.RequireNativeAuth = plumbing.RequireNativeAuth
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.UseAzureSingleServerUsernames = plumbing.UseAzureSingleServerUsernames
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertClustrixToPlumbing(porcelain *Clustrix) *proto.Clustrix {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Clustrix{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.RequireNativeAuth = (porcelain.RequireNativeAuth)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.UseAzureSingleServerUsernames = (porcelain.UseAzureSingleServerUsernames)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedClustrixToPlumbing(
	porcelains []*Clustrix,
) []*proto.Clustrix {
	var items []*proto.Clustrix
	for _, porcelain := range porcelains {
		items = append(items, convertClustrixToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedClustrixToPorcelain(plumbings []*proto.Clustrix) (
	[]*Clustrix,
	error,
) {
	var items []*Clustrix
	for _, plumbing := range plumbings {
		if v, err := convertClustrixToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertCockroachToPorcelain(plumbing *proto.Cockroach) (*Cockroach, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Cockroach{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.OverrideDatabase = plumbing.OverrideDatabase
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertCockroachToPlumbing(porcelain *Cockroach) *proto.Cockroach {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Cockroach{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedCockroachToPlumbing(
	porcelains []*Cockroach,
) []*proto.Cockroach {
	var items []*proto.Cockroach
	for _, porcelain := range porcelains {
		items = append(items, convertCockroachToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedCockroachToPorcelain(plumbings []*proto.Cockroach) (
	[]*Cockroach,
	error,
) {
	var items []*Cockroach
	for _, plumbing := range plumbings {
		if v, err := convertCockroachToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertControlPanelGetRDPCAPublicKeyResponseToPorcelain(plumbing *proto.ControlPanelGetRDPCAPublicKeyResponse) (*ControlPanelGetRDPCAPublicKeyResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ControlPanelGetRDPCAPublicKeyResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	porcelain.PublicKey = plumbing.PublicKey
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertControlPanelGetRDPCAPublicKeyResponseToPlumbing(porcelain *ControlPanelGetRDPCAPublicKeyResponse) *proto.ControlPanelGetRDPCAPublicKeyResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ControlPanelGetRDPCAPublicKeyResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.PublicKey = (porcelain.PublicKey)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedControlPanelGetRDPCAPublicKeyResponseToPlumbing(
	porcelains []*ControlPanelGetRDPCAPublicKeyResponse,
) []*proto.ControlPanelGetRDPCAPublicKeyResponse {
	var items []*proto.ControlPanelGetRDPCAPublicKeyResponse
	for _, porcelain := range porcelains {
		items = append(items, convertControlPanelGetRDPCAPublicKeyResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedControlPanelGetRDPCAPublicKeyResponseToPorcelain(plumbings []*proto.ControlPanelGetRDPCAPublicKeyResponse) (
	[]*ControlPanelGetRDPCAPublicKeyResponse,
	error,
) {
	var items []*ControlPanelGetRDPCAPublicKeyResponse
	for _, plumbing := range plumbings {
		if v, err := convertControlPanelGetRDPCAPublicKeyResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertControlPanelGetSSHCAPublicKeyResponseToPorcelain(plumbing *proto.ControlPanelGetSSHCAPublicKeyResponse) (*ControlPanelGetSSHCAPublicKeyResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ControlPanelGetSSHCAPublicKeyResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	porcelain.PublicKey = plumbing.PublicKey
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertControlPanelGetSSHCAPublicKeyResponseToPlumbing(porcelain *ControlPanelGetSSHCAPublicKeyResponse) *proto.ControlPanelGetSSHCAPublicKeyResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ControlPanelGetSSHCAPublicKeyResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.PublicKey = (porcelain.PublicKey)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedControlPanelGetSSHCAPublicKeyResponseToPlumbing(
	porcelains []*ControlPanelGetSSHCAPublicKeyResponse,
) []*proto.ControlPanelGetSSHCAPublicKeyResponse {
	var items []*proto.ControlPanelGetSSHCAPublicKeyResponse
	for _, porcelain := range porcelains {
		items = append(items, convertControlPanelGetSSHCAPublicKeyResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedControlPanelGetSSHCAPublicKeyResponseToPorcelain(plumbings []*proto.ControlPanelGetSSHCAPublicKeyResponse) (
	[]*ControlPanelGetSSHCAPublicKeyResponse,
	error,
) {
	var items []*ControlPanelGetSSHCAPublicKeyResponse
	for _, plumbing := range plumbings {
		if v, err := convertControlPanelGetSSHCAPublicKeyResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertControlPanelVerifyJWTResponseToPorcelain(plumbing *proto.ControlPanelVerifyJWTResponse) (*ControlPanelVerifyJWTResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ControlPanelVerifyJWTResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	porcelain.ValID = plumbing.Valid
	return porcelain, nil
}

func convertControlPanelVerifyJWTResponseToPlumbing(porcelain *ControlPanelVerifyJWTResponse) *proto.ControlPanelVerifyJWTResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ControlPanelVerifyJWTResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.Valid = (porcelain.ValID)
	return plumbing
}
func convertRepeatedControlPanelVerifyJWTResponseToPlumbing(
	porcelains []*ControlPanelVerifyJWTResponse,
) []*proto.ControlPanelVerifyJWTResponse {
	var items []*proto.ControlPanelVerifyJWTResponse
	for _, porcelain := range porcelains {
		items = append(items, convertControlPanelVerifyJWTResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedControlPanelVerifyJWTResponseToPorcelain(plumbings []*proto.ControlPanelVerifyJWTResponse) (
	[]*ControlPanelVerifyJWTResponse,
	error,
) {
	var items []*ControlPanelVerifyJWTResponse
	for _, plumbing := range plumbings {
		if v, err := convertControlPanelVerifyJWTResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertCouchbaseDatabaseToPorcelain(plumbing *proto.CouchbaseDatabase) (*CouchbaseDatabase, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &CouchbaseDatabase{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.N1QlPort = plumbing.N1QlPort
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertCouchbaseDatabaseToPlumbing(porcelain *CouchbaseDatabase) *proto.CouchbaseDatabase {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.CouchbaseDatabase{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.N1QlPort = (porcelain.N1QlPort)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedCouchbaseDatabaseToPlumbing(
	porcelains []*CouchbaseDatabase,
) []*proto.CouchbaseDatabase {
	var items []*proto.CouchbaseDatabase
	for _, porcelain := range porcelains {
		items = append(items, convertCouchbaseDatabaseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedCouchbaseDatabaseToPorcelain(plumbings []*proto.CouchbaseDatabase) (
	[]*CouchbaseDatabase,
	error,
) {
	var items []*CouchbaseDatabase
	for _, plumbing := range plumbings {
		if v, err := convertCouchbaseDatabaseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertCouchbaseWebUIToPorcelain(plumbing *proto.CouchbaseWebUI) (*CouchbaseWebUI, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &CouchbaseWebUI{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Url = plumbing.Url
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertCouchbaseWebUIToPlumbing(porcelain *CouchbaseWebUI) *proto.CouchbaseWebUI {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.CouchbaseWebUI{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Url = (porcelain.Url)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedCouchbaseWebUIToPlumbing(
	porcelains []*CouchbaseWebUI,
) []*proto.CouchbaseWebUI {
	var items []*proto.CouchbaseWebUI
	for _, porcelain := range porcelains {
		items = append(items, convertCouchbaseWebUIToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedCouchbaseWebUIToPorcelain(plumbings []*proto.CouchbaseWebUI) (
	[]*CouchbaseWebUI,
	error,
) {
	var items []*CouchbaseWebUI
	for _, plumbing := range plumbings {
		if v, err := convertCouchbaseWebUIToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertCreateResponseMetadataToPorcelain(plumbing *proto.CreateResponseMetadata) (*CreateResponseMetadata, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &CreateResponseMetadata{}
	return porcelain, nil
}

func convertCreateResponseMetadataToPlumbing(porcelain *CreateResponseMetadata) *proto.CreateResponseMetadata {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.CreateResponseMetadata{}
	return plumbing
}
func convertRepeatedCreateResponseMetadataToPlumbing(
	porcelains []*CreateResponseMetadata,
) []*proto.CreateResponseMetadata {
	var items []*proto.CreateResponseMetadata
	for _, porcelain := range porcelains {
		items = append(items, convertCreateResponseMetadataToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedCreateResponseMetadataToPorcelain(plumbings []*proto.CreateResponseMetadata) (
	[]*CreateResponseMetadata,
	error,
) {
	var items []*CreateResponseMetadata
	for _, plumbing := range plumbings {
		if v, err := convertCreateResponseMetadataToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertCyberarkConjurStoreToPorcelain(plumbing *proto.CyberarkConjurStore) (*CyberarkConjurStore, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &CyberarkConjurStore{}
	porcelain.AppURL = plumbing.AppURL
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertCyberarkConjurStoreToPlumbing(porcelain *CyberarkConjurStore) *proto.CyberarkConjurStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.CyberarkConjurStore{}
	plumbing.AppURL = (porcelain.AppURL)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedCyberarkConjurStoreToPlumbing(
	porcelains []*CyberarkConjurStore,
) []*proto.CyberarkConjurStore {
	var items []*proto.CyberarkConjurStore
	for _, porcelain := range porcelains {
		items = append(items, convertCyberarkConjurStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedCyberarkConjurStoreToPorcelain(plumbings []*proto.CyberarkConjurStore) (
	[]*CyberarkConjurStore,
	error,
) {
	var items []*CyberarkConjurStore
	for _, plumbing := range plumbings {
		if v, err := convertCyberarkConjurStoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertCyberarkPAMExperimentalStoreToPorcelain(plumbing *proto.CyberarkPAMExperimentalStore) (*CyberarkPAMExperimentalStore, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &CyberarkPAMExperimentalStore{}
	porcelain.AppURL = plumbing.AppURL
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertCyberarkPAMExperimentalStoreToPlumbing(porcelain *CyberarkPAMExperimentalStore) *proto.CyberarkPAMExperimentalStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.CyberarkPAMExperimentalStore{}
	plumbing.AppURL = (porcelain.AppURL)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedCyberarkPAMExperimentalStoreToPlumbing(
	porcelains []*CyberarkPAMExperimentalStore,
) []*proto.CyberarkPAMExperimentalStore {
	var items []*proto.CyberarkPAMExperimentalStore
	for _, porcelain := range porcelains {
		items = append(items, convertCyberarkPAMExperimentalStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedCyberarkPAMExperimentalStoreToPorcelain(plumbings []*proto.CyberarkPAMExperimentalStore) (
	[]*CyberarkPAMExperimentalStore,
	error,
) {
	var items []*CyberarkPAMExperimentalStore
	for _, plumbing := range plumbings {
		if v, err := convertCyberarkPAMExperimentalStoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertCyberarkPAMStoreToPorcelain(plumbing *proto.CyberarkPAMStore) (*CyberarkPAMStore, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &CyberarkPAMStore{}
	porcelain.AppURL = plumbing.AppURL
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertCyberarkPAMStoreToPlumbing(porcelain *CyberarkPAMStore) *proto.CyberarkPAMStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.CyberarkPAMStore{}
	plumbing.AppURL = (porcelain.AppURL)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedCyberarkPAMStoreToPlumbing(
	porcelains []*CyberarkPAMStore,
) []*proto.CyberarkPAMStore {
	var items []*proto.CyberarkPAMStore
	for _, porcelain := range porcelains {
		items = append(items, convertCyberarkPAMStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedCyberarkPAMStoreToPorcelain(plumbings []*proto.CyberarkPAMStore) (
	[]*CyberarkPAMStore,
	error,
) {
	var items []*CyberarkPAMStore
	for _, plumbing := range plumbings {
		if v, err := convertCyberarkPAMStoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertDB2IToPorcelain(plumbing *proto.DB2I) (*DB2I, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &DB2I{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertDB2IToPlumbing(porcelain *DB2I) *proto.DB2I {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.DB2I{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedDB2IToPlumbing(
	porcelains []*DB2I,
) []*proto.DB2I {
	var items []*proto.DB2I
	for _, porcelain := range porcelains {
		items = append(items, convertDB2IToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedDB2IToPorcelain(plumbings []*proto.DB2I) (
	[]*DB2I,
	error,
) {
	var items []*DB2I
	for _, plumbing := range plumbings {
		if v, err := convertDB2IToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertDB2LUWToPorcelain(plumbing *proto.DB2LUW) (*DB2LUW, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &DB2LUW{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertDB2LUWToPlumbing(porcelain *DB2LUW) *proto.DB2LUW {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.DB2LUW{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedDB2LUWToPlumbing(
	porcelains []*DB2LUW,
) []*proto.DB2LUW {
	var items []*proto.DB2LUW
	for _, porcelain := range porcelains {
		items = append(items, convertDB2LUWToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedDB2LUWToPorcelain(plumbings []*proto.DB2LUW) (
	[]*DB2LUW,
	error,
) {
	var items []*DB2LUW
	for _, plumbing := range plumbings {
		if v, err := convertDB2LUWToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertDeleteResponseMetadataToPorcelain(plumbing *proto.DeleteResponseMetadata) (*DeleteResponseMetadata, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &DeleteResponseMetadata{}
	return porcelain, nil
}

func convertDeleteResponseMetadataToPlumbing(porcelain *DeleteResponseMetadata) *proto.DeleteResponseMetadata {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.DeleteResponseMetadata{}
	return plumbing
}
func convertRepeatedDeleteResponseMetadataToPlumbing(
	porcelains []*DeleteResponseMetadata,
) []*proto.DeleteResponseMetadata {
	var items []*proto.DeleteResponseMetadata
	for _, porcelain := range porcelains {
		items = append(items, convertDeleteResponseMetadataToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedDeleteResponseMetadataToPorcelain(plumbings []*proto.DeleteResponseMetadata) (
	[]*DeleteResponseMetadata,
	error,
) {
	var items []*DeleteResponseMetadata
	for _, plumbing := range plumbings {
		if v, err := convertDeleteResponseMetadataToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertDelineaStoreToPorcelain(plumbing *proto.DelineaStore) (*DelineaStore, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &DelineaStore{}
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.ServerUrl = plumbing.ServerUrl
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TenantName = plumbing.TenantName
	return porcelain, nil
}

func convertDelineaStoreToPlumbing(porcelain *DelineaStore) *proto.DelineaStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.DelineaStore{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.ServerUrl = (porcelain.ServerUrl)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TenantName = (porcelain.TenantName)
	return plumbing
}
func convertRepeatedDelineaStoreToPlumbing(
	porcelains []*DelineaStore,
) []*proto.DelineaStore {
	var items []*proto.DelineaStore
	for _, porcelain := range porcelains {
		items = append(items, convertDelineaStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedDelineaStoreToPorcelain(plumbings []*proto.DelineaStore) (
	[]*DelineaStore,
	error,
) {
	var items []*DelineaStore
	for _, plumbing := range plumbings {
		if v, err := convertDelineaStoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertDocumentDBHostToPorcelain(plumbing *proto.DocumentDBHost) (*DocumentDBHost, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &DocumentDBHost{}
	porcelain.AuthDatabase = plumbing.AuthDatabase
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertDocumentDBHostToPlumbing(porcelain *DocumentDBHost) *proto.DocumentDBHost {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.DocumentDBHost{}
	plumbing.AuthDatabase = (porcelain.AuthDatabase)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedDocumentDBHostToPlumbing(
	porcelains []*DocumentDBHost,
) []*proto.DocumentDBHost {
	var items []*proto.DocumentDBHost
	for _, porcelain := range porcelains {
		items = append(items, convertDocumentDBHostToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedDocumentDBHostToPorcelain(plumbings []*proto.DocumentDBHost) (
	[]*DocumentDBHost,
	error,
) {
	var items []*DocumentDBHost
	for _, plumbing := range plumbings {
		if v, err := convertDocumentDBHostToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertDocumentDBHostIAMToPorcelain(plumbing *proto.DocumentDBHostIAM) (*DocumentDBHostIAM, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &DocumentDBHostIAM{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.Region = plumbing.Region
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertDocumentDBHostIAMToPlumbing(porcelain *DocumentDBHostIAM) *proto.DocumentDBHostIAM {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.DocumentDBHostIAM{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.Region = (porcelain.Region)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedDocumentDBHostIAMToPlumbing(
	porcelains []*DocumentDBHostIAM,
) []*proto.DocumentDBHostIAM {
	var items []*proto.DocumentDBHostIAM
	for _, porcelain := range porcelains {
		items = append(items, convertDocumentDBHostIAMToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedDocumentDBHostIAMToPorcelain(plumbings []*proto.DocumentDBHostIAM) (
	[]*DocumentDBHostIAM,
	error,
) {
	var items []*DocumentDBHostIAM
	for _, plumbing := range plumbings {
		if v, err := convertDocumentDBHostIAMToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertDocumentDBReplicaSetToPorcelain(plumbing *proto.DocumentDBReplicaSet) (*DocumentDBReplicaSet, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &DocumentDBReplicaSet{}
	porcelain.AuthDatabase = plumbing.AuthDatabase
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.ConnectToReplica = plumbing.ConnectToReplica
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.ReplicaSet = plumbing.ReplicaSet
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertDocumentDBReplicaSetToPlumbing(porcelain *DocumentDBReplicaSet) *proto.DocumentDBReplicaSet {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.DocumentDBReplicaSet{}
	plumbing.AuthDatabase = (porcelain.AuthDatabase)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.ConnectToReplica = (porcelain.ConnectToReplica)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.ReplicaSet = (porcelain.ReplicaSet)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedDocumentDBReplicaSetToPlumbing(
	porcelains []*DocumentDBReplicaSet,
) []*proto.DocumentDBReplicaSet {
	var items []*proto.DocumentDBReplicaSet
	for _, porcelain := range porcelains {
		items = append(items, convertDocumentDBReplicaSetToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedDocumentDBReplicaSetToPorcelain(plumbings []*proto.DocumentDBReplicaSet) (
	[]*DocumentDBReplicaSet,
	error,
) {
	var items []*DocumentDBReplicaSet
	for _, plumbing := range plumbings {
		if v, err := convertDocumentDBReplicaSetToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertDruidToPorcelain(plumbing *proto.Druid) (*Druid, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Druid{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertDruidToPlumbing(porcelain *Druid) *proto.Druid {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Druid{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedDruidToPlumbing(
	porcelains []*Druid,
) []*proto.Druid {
	var items []*proto.Druid
	for _, porcelain := range porcelains {
		items = append(items, convertDruidToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedDruidToPorcelain(plumbings []*proto.Druid) (
	[]*Druid,
	error,
) {
	var items []*Druid
	for _, plumbing := range plumbings {
		if v, err := convertDruidToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertDynamoDBToPorcelain(plumbing *proto.DynamoDB) (*DynamoDB, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &DynamoDB{}
	porcelain.AccessKey = plumbing.AccessKey
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Endpoint = plumbing.Endpoint
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.Region = plumbing.Region
	porcelain.RoleArn = plumbing.RoleArn
	porcelain.RoleExternalID = plumbing.RoleExternalId
	porcelain.SecretAccessKey = plumbing.SecretAccessKey
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertDynamoDBToPlumbing(porcelain *DynamoDB) *proto.DynamoDB {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.DynamoDB{}
	plumbing.AccessKey = (porcelain.AccessKey)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.Region = (porcelain.Region)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	plumbing.SecretAccessKey = (porcelain.SecretAccessKey)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedDynamoDBToPlumbing(
	porcelains []*DynamoDB,
) []*proto.DynamoDB {
	var items []*proto.DynamoDB
	for _, porcelain := range porcelains {
		items = append(items, convertDynamoDBToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedDynamoDBToPorcelain(plumbings []*proto.DynamoDB) (
	[]*DynamoDB,
	error,
) {
	var items []*DynamoDB
	for _, plumbing := range plumbings {
		if v, err := convertDynamoDBToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertDynamoDBIAMToPorcelain(plumbing *proto.DynamoDBIAM) (*DynamoDBIAM, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &DynamoDBIAM{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Endpoint = plumbing.Endpoint
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.Region = plumbing.Region
	porcelain.RoleArn = plumbing.RoleArn
	porcelain.RoleExternalID = plumbing.RoleExternalId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertDynamoDBIAMToPlumbing(porcelain *DynamoDBIAM) *proto.DynamoDBIAM {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.DynamoDBIAM{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.Region = (porcelain.Region)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedDynamoDBIAMToPlumbing(
	porcelains []*DynamoDBIAM,
) []*proto.DynamoDBIAM {
	var items []*proto.DynamoDBIAM
	for _, porcelain := range porcelains {
		items = append(items, convertDynamoDBIAMToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedDynamoDBIAMToPorcelain(plumbings []*proto.DynamoDBIAM) (
	[]*DynamoDBIAM,
	error,
) {
	var items []*DynamoDBIAM
	for _, plumbing := range plumbings {
		if v, err := convertDynamoDBIAMToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertElasticToPorcelain(plumbing *proto.Elastic) (*Elastic, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Elastic{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertElasticToPlumbing(porcelain *Elastic) *proto.Elastic {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Elastic{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedElasticToPlumbing(
	porcelains []*Elastic,
) []*proto.Elastic {
	var items []*proto.Elastic
	for _, porcelain := range porcelains {
		items = append(items, convertElasticToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedElasticToPorcelain(plumbings []*proto.Elastic) (
	[]*Elastic,
	error,
) {
	var items []*Elastic
	for _, plumbing := range plumbings {
		if v, err := convertElasticToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertElasticacheRedisToPorcelain(plumbing *proto.ElasticacheRedis) (*ElasticacheRedis, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ElasticacheRedis{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertElasticacheRedisToPlumbing(porcelain *ElasticacheRedis) *proto.ElasticacheRedis {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ElasticacheRedis{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedElasticacheRedisToPlumbing(
	porcelains []*ElasticacheRedis,
) []*proto.ElasticacheRedis {
	var items []*proto.ElasticacheRedis
	for _, porcelain := range porcelains {
		items = append(items, convertElasticacheRedisToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedElasticacheRedisToPorcelain(plumbings []*proto.ElasticacheRedis) (
	[]*ElasticacheRedis,
	error,
) {
	var items []*ElasticacheRedis
	for _, plumbing := range plumbings {
		if v, err := convertElasticacheRedisToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertGCPToPorcelain(plumbing *proto.GCP) (*GCP, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &GCP{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Keyfile = plumbing.Keyfile
	porcelain.Name = plumbing.Name
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.Scopes = plumbing.Scopes
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertGCPToPlumbing(porcelain *GCP) *proto.GCP {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.GCP{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Keyfile = (porcelain.Keyfile)
	plumbing.Name = (porcelain.Name)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.Scopes = (porcelain.Scopes)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedGCPToPlumbing(
	porcelains []*GCP,
) []*proto.GCP {
	var items []*proto.GCP
	for _, porcelain := range porcelains {
		items = append(items, convertGCPToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedGCPToPorcelain(plumbings []*proto.GCP) (
	[]*GCP,
	error,
) {
	var items []*GCP
	for _, plumbing := range plumbings {
		if v, err := convertGCPToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertGCPCertX509StoreToPorcelain(plumbing *proto.GCPCertX509Store) (*GCPCertX509Store, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &GCPCertX509Store{}
	porcelain.CaID = plumbing.CaID
	porcelain.CaPoolID = plumbing.CaPoolID
	porcelain.ID = plumbing.Id
	porcelain.IssuedCertTTLMinutes = plumbing.IssuedCertTTLMinutes
	porcelain.Location = plumbing.Location
	porcelain.Name = plumbing.Name
	porcelain.ProjectID = plumbing.ProjectID
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertGCPCertX509StoreToPlumbing(porcelain *GCPCertX509Store) *proto.GCPCertX509Store {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.GCPCertX509Store{}
	plumbing.CaID = (porcelain.CaID)
	plumbing.CaPoolID = (porcelain.CaPoolID)
	plumbing.Id = (porcelain.ID)
	plumbing.IssuedCertTTLMinutes = (porcelain.IssuedCertTTLMinutes)
	plumbing.Location = (porcelain.Location)
	plumbing.Name = (porcelain.Name)
	plumbing.ProjectID = (porcelain.ProjectID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedGCPCertX509StoreToPlumbing(
	porcelains []*GCPCertX509Store,
) []*proto.GCPCertX509Store {
	var items []*proto.GCPCertX509Store
	for _, porcelain := range porcelains {
		items = append(items, convertGCPCertX509StoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedGCPCertX509StoreToPorcelain(plumbings []*proto.GCPCertX509Store) (
	[]*GCPCertX509Store,
	error,
) {
	var items []*GCPCertX509Store
	for _, plumbing := range plumbings {
		if v, err := convertGCPCertX509StoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertGCPConsoleToPorcelain(plumbing *proto.GCPConsole) (*GCPConsole, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &GCPConsole{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.IdentityAliasHealthcheckUsername = plumbing.IdentityAliasHealthcheckUsername
	porcelain.IdentitySetID = plumbing.IdentitySetId
	porcelain.Name = plumbing.Name
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.SessionExpiry = plumbing.SessionExpiry
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.WorkforcePoolID = plumbing.WorkforcePoolId
	porcelain.WorkforceProviderID = plumbing.WorkforceProviderId
	return porcelain, nil
}

func convertGCPConsoleToPlumbing(porcelain *GCPConsole) *proto.GCPConsole {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.GCPConsole{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.IdentityAliasHealthcheckUsername = (porcelain.IdentityAliasHealthcheckUsername)
	plumbing.IdentitySetId = (porcelain.IdentitySetID)
	plumbing.Name = (porcelain.Name)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.SessionExpiry = (porcelain.SessionExpiry)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.WorkforcePoolId = (porcelain.WorkforcePoolID)
	plumbing.WorkforceProviderId = (porcelain.WorkforceProviderID)
	return plumbing
}
func convertRepeatedGCPConsoleToPlumbing(
	porcelains []*GCPConsole,
) []*proto.GCPConsole {
	var items []*proto.GCPConsole
	for _, porcelain := range porcelains {
		items = append(items, convertGCPConsoleToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedGCPConsoleToPorcelain(plumbings []*proto.GCPConsole) (
	[]*GCPConsole,
	error,
) {
	var items []*GCPConsole
	for _, plumbing := range plumbings {
		if v, err := convertGCPConsoleToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertGCPStoreToPorcelain(plumbing *proto.GCPStore) (*GCPStore, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &GCPStore{}
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.ProjectID = plumbing.ProjectID
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertGCPStoreToPlumbing(porcelain *GCPStore) *proto.GCPStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.GCPStore{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.ProjectID = (porcelain.ProjectID)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedGCPStoreToPlumbing(
	porcelains []*GCPStore,
) []*proto.GCPStore {
	var items []*proto.GCPStore
	for _, porcelain := range porcelains {
		items = append(items, convertGCPStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedGCPStoreToPorcelain(plumbings []*proto.GCPStore) (
	[]*GCPStore,
	error,
) {
	var items []*GCPStore
	for _, plumbing := range plumbings {
		if v, err := convertGCPStoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertGCPWIFToPorcelain(plumbing *proto.GCPWIF) (*GCPWIF, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &GCPWIF{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.IdentityAliasHealthcheckUsername = plumbing.IdentityAliasHealthcheckUsername
	porcelain.IdentitySetID = plumbing.IdentitySetId
	porcelain.Name = plumbing.Name
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProjectID = plumbing.ProjectId
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.Scopes = plumbing.Scopes
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.SessionExpiry = plumbing.SessionExpiry
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.WorkforcePoolID = plumbing.WorkforcePoolId
	porcelain.WorkforceProviderID = plumbing.WorkforceProviderId
	return porcelain, nil
}

func convertGCPWIFToPlumbing(porcelain *GCPWIF) *proto.GCPWIF {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.GCPWIF{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.IdentityAliasHealthcheckUsername = (porcelain.IdentityAliasHealthcheckUsername)
	plumbing.IdentitySetId = (porcelain.IdentitySetID)
	plumbing.Name = (porcelain.Name)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProjectId = (porcelain.ProjectID)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.Scopes = (porcelain.Scopes)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.SessionExpiry = (porcelain.SessionExpiry)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.WorkforcePoolId = (porcelain.WorkforcePoolID)
	plumbing.WorkforceProviderId = (porcelain.WorkforceProviderID)
	return plumbing
}
func convertRepeatedGCPWIFToPlumbing(
	porcelains []*GCPWIF,
) []*proto.GCPWIF {
	var items []*proto.GCPWIF
	for _, porcelain := range porcelains {
		items = append(items, convertGCPWIFToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedGCPWIFToPorcelain(plumbings []*proto.GCPWIF) (
	[]*GCPWIF,
	error,
) {
	var items []*GCPWIF
	for _, plumbing := range plumbings {
		if v, err := convertGCPWIFToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertGatewayToPorcelain(plumbing *proto.Gateway) (*Gateway, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Gateway{}
	porcelain.BindAddress = plumbing.BindAddress
	porcelain.Device = plumbing.Device
	porcelain.GatewayFilter = plumbing.GatewayFilter
	porcelain.ID = plumbing.Id
	porcelain.ListenAddress = plumbing.ListenAddress
	porcelain.Location = plumbing.Location
	if v, err := convertRepeatedNodeMaintenanceWindowToPorcelain(plumbing.MaintenanceWindows); err != nil {
		return nil, fmt.Errorf("error converting field MaintenanceWindows: %v", err)
	} else {
		porcelain.MaintenanceWindows = v
	}
	porcelain.Name = plumbing.Name
	porcelain.State = plumbing.State
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Version = plumbing.Version
	return porcelain, nil
}

func convertGatewayToPlumbing(porcelain *Gateway) *proto.Gateway {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Gateway{}
	plumbing.BindAddress = (porcelain.BindAddress)
	plumbing.Device = (porcelain.Device)
	plumbing.GatewayFilter = (porcelain.GatewayFilter)
	plumbing.Id = (porcelain.ID)
	plumbing.ListenAddress = (porcelain.ListenAddress)
	plumbing.Location = (porcelain.Location)
	plumbing.MaintenanceWindows = convertRepeatedNodeMaintenanceWindowToPlumbing(porcelain.MaintenanceWindows)
	plumbing.Name = (porcelain.Name)
	plumbing.State = (porcelain.State)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Version = (porcelain.Version)
	return plumbing
}
func convertRepeatedGatewayToPlumbing(
	porcelains []*Gateway,
) []*proto.Gateway {
	var items []*proto.Gateway
	for _, porcelain := range porcelains {
		items = append(items, convertGatewayToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedGatewayToPorcelain(plumbings []*proto.Gateway) (
	[]*Gateway,
	error,
) {
	var items []*Gateway
	for _, plumbing := range plumbings {
		if v, err := convertGatewayToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertGenericResponseMetadataToPorcelain(plumbing *proto.GenericResponseMetadata) (*GenericResponseMetadata, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &GenericResponseMetadata{}
	return porcelain, nil
}

func convertGenericResponseMetadataToPlumbing(porcelain *GenericResponseMetadata) *proto.GenericResponseMetadata {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.GenericResponseMetadata{}
	return plumbing
}
func convertRepeatedGenericResponseMetadataToPlumbing(
	porcelains []*GenericResponseMetadata,
) []*proto.GenericResponseMetadata {
	var items []*proto.GenericResponseMetadata
	for _, porcelain := range porcelains {
		items = append(items, convertGenericResponseMetadataToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedGenericResponseMetadataToPorcelain(plumbings []*proto.GenericResponseMetadata) (
	[]*GenericResponseMetadata,
	error,
) {
	var items []*GenericResponseMetadata
	for _, plumbing := range plumbings {
		if v, err := convertGenericResponseMetadataToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertGetResponseMetadataToPorcelain(plumbing *proto.GetResponseMetadata) (*GetResponseMetadata, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &GetResponseMetadata{}
	return porcelain, nil
}

func convertGetResponseMetadataToPlumbing(porcelain *GetResponseMetadata) *proto.GetResponseMetadata {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.GetResponseMetadata{}
	return plumbing
}
func convertRepeatedGetResponseMetadataToPlumbing(
	porcelains []*GetResponseMetadata,
) []*proto.GetResponseMetadata {
	var items []*proto.GetResponseMetadata
	for _, porcelain := range porcelains {
		items = append(items, convertGetResponseMetadataToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedGetResponseMetadataToPorcelain(plumbings []*proto.GetResponseMetadata) (
	[]*GetResponseMetadata,
	error,
) {
	var items []*GetResponseMetadata
	for _, plumbing := range plumbings {
		if v, err := convertGetResponseMetadataToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertGoogleGKEToPorcelain(plumbing *proto.GoogleGKE) (*GoogleGKE, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &GoogleGKE{}
	porcelain.AllowResourceRoleBypass = plumbing.AllowResourceRoleBypass
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.CertificateAuthority = plumbing.CertificateAuthority
	porcelain.DiscoveryEnabled = plumbing.DiscoveryEnabled
	porcelain.DiscoveryUsername = plumbing.DiscoveryUsername
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Endpoint = plumbing.Endpoint
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.IdentityAliasHealthcheckUsername = plumbing.IdentityAliasHealthcheckUsername
	porcelain.IdentitySetID = plumbing.IdentitySetId
	porcelain.Name = plumbing.Name
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.ServiceAccountKey = plumbing.ServiceAccountKey
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertGoogleGKEToPlumbing(porcelain *GoogleGKE) *proto.GoogleGKE {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.GoogleGKE{}
	plumbing.AllowResourceRoleBypass = (porcelain.AllowResourceRoleBypass)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.CertificateAuthority = (porcelain.CertificateAuthority)
	plumbing.DiscoveryEnabled = (porcelain.DiscoveryEnabled)
	plumbing.DiscoveryUsername = (porcelain.DiscoveryUsername)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.IdentityAliasHealthcheckUsername = (porcelain.IdentityAliasHealthcheckUsername)
	plumbing.IdentitySetId = (porcelain.IdentitySetID)
	plumbing.Name = (porcelain.Name)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.ServiceAccountKey = (porcelain.ServiceAccountKey)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedGoogleGKEToPlumbing(
	porcelains []*GoogleGKE,
) []*proto.GoogleGKE {
	var items []*proto.GoogleGKE
	for _, porcelain := range porcelains {
		items = append(items, convertGoogleGKEToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedGoogleGKEToPorcelain(plumbings []*proto.GoogleGKE) (
	[]*GoogleGKE,
	error,
) {
	var items []*GoogleGKE
	for _, plumbing := range plumbings {
		if v, err := convertGoogleGKEToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertGoogleGKEUserImpersonationToPorcelain(plumbing *proto.GoogleGKEUserImpersonation) (*GoogleGKEUserImpersonation, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &GoogleGKEUserImpersonation{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.CertificateAuthority = plumbing.CertificateAuthority
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Endpoint = plumbing.Endpoint
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.ServiceAccountKey = plumbing.ServiceAccountKey
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertGoogleGKEUserImpersonationToPlumbing(porcelain *GoogleGKEUserImpersonation) *proto.GoogleGKEUserImpersonation {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.GoogleGKEUserImpersonation{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.CertificateAuthority = (porcelain.CertificateAuthority)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.ServiceAccountKey = (porcelain.ServiceAccountKey)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedGoogleGKEUserImpersonationToPlumbing(
	porcelains []*GoogleGKEUserImpersonation,
) []*proto.GoogleGKEUserImpersonation {
	var items []*proto.GoogleGKEUserImpersonation
	for _, porcelain := range porcelains {
		items = append(items, convertGoogleGKEUserImpersonationToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedGoogleGKEUserImpersonationToPorcelain(plumbings []*proto.GoogleGKEUserImpersonation) (
	[]*GoogleGKEUserImpersonation,
	error,
) {
	var items []*GoogleGKEUserImpersonation
	for _, plumbing := range plumbings {
		if v, err := convertGoogleGKEUserImpersonationToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertGreenplumToPorcelain(plumbing *proto.Greenplum) (*Greenplum, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Greenplum{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.OverrideDatabase = plumbing.OverrideDatabase
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertGreenplumToPlumbing(porcelain *Greenplum) *proto.Greenplum {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Greenplum{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedGreenplumToPlumbing(
	porcelains []*Greenplum,
) []*proto.Greenplum {
	var items []*proto.Greenplum
	for _, porcelain := range porcelains {
		items = append(items, convertGreenplumToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedGreenplumToPorcelain(plumbings []*proto.Greenplum) (
	[]*Greenplum,
	error,
) {
	var items []*Greenplum
	for _, plumbing := range plumbings {
		if v, err := convertGreenplumToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertHTTPAuthToPorcelain(plumbing *proto.HTTPAuth) (*HTTPAuth, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &HTTPAuth{}
	porcelain.AuthHeader = plumbing.AuthHeader
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.DefaultPath = plumbing.DefaultPath
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HeadersBlacklist = plumbing.HeadersBlacklist
	porcelain.HealthcheckPath = plumbing.HealthcheckPath
	porcelain.Healthy = plumbing.Healthy
	porcelain.HostOverride = plumbing.HostOverride
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Url = plumbing.Url
	return porcelain, nil
}

func convertHTTPAuthToPlumbing(porcelain *HTTPAuth) *proto.HTTPAuth {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.HTTPAuth{}
	plumbing.AuthHeader = (porcelain.AuthHeader)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.DefaultPath = (porcelain.DefaultPath)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HeadersBlacklist = (porcelain.HeadersBlacklist)
	plumbing.HealthcheckPath = (porcelain.HealthcheckPath)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.HostOverride = (porcelain.HostOverride)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Url = (porcelain.Url)
	return plumbing
}
func convertRepeatedHTTPAuthToPlumbing(
	porcelains []*HTTPAuth,
) []*proto.HTTPAuth {
	var items []*proto.HTTPAuth
	for _, porcelain := range porcelains {
		items = append(items, convertHTTPAuthToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedHTTPAuthToPorcelain(plumbings []*proto.HTTPAuth) (
	[]*HTTPAuth,
	error,
) {
	var items []*HTTPAuth
	for _, plumbing := range plumbings {
		if v, err := convertHTTPAuthToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertHTTPBasicAuthToPorcelain(plumbing *proto.HTTPBasicAuth) (*HTTPBasicAuth, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &HTTPBasicAuth{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.DefaultPath = plumbing.DefaultPath
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HeadersBlacklist = plumbing.HeadersBlacklist
	porcelain.HealthcheckPath = plumbing.HealthcheckPath
	porcelain.Healthy = plumbing.Healthy
	porcelain.HostOverride = plumbing.HostOverride
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Url = plumbing.Url
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertHTTPBasicAuthToPlumbing(porcelain *HTTPBasicAuth) *proto.HTTPBasicAuth {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.HTTPBasicAuth{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.DefaultPath = (porcelain.DefaultPath)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HeadersBlacklist = (porcelain.HeadersBlacklist)
	plumbing.HealthcheckPath = (porcelain.HealthcheckPath)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.HostOverride = (porcelain.HostOverride)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Url = (porcelain.Url)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedHTTPBasicAuthToPlumbing(
	porcelains []*HTTPBasicAuth,
) []*proto.HTTPBasicAuth {
	var items []*proto.HTTPBasicAuth
	for _, porcelain := range porcelains {
		items = append(items, convertHTTPBasicAuthToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedHTTPBasicAuthToPorcelain(plumbings []*proto.HTTPBasicAuth) (
	[]*HTTPBasicAuth,
	error,
) {
	var items []*HTTPBasicAuth
	for _, plumbing := range plumbings {
		if v, err := convertHTTPBasicAuthToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertHTTPNoAuthToPorcelain(plumbing *proto.HTTPNoAuth) (*HTTPNoAuth, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &HTTPNoAuth{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.DefaultPath = plumbing.DefaultPath
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HeadersBlacklist = plumbing.HeadersBlacklist
	porcelain.HealthcheckPath = plumbing.HealthcheckPath
	porcelain.Healthy = plumbing.Healthy
	porcelain.HostOverride = plumbing.HostOverride
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Url = plumbing.Url
	return porcelain, nil
}

func convertHTTPNoAuthToPlumbing(porcelain *HTTPNoAuth) *proto.HTTPNoAuth {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.HTTPNoAuth{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.DefaultPath = (porcelain.DefaultPath)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HeadersBlacklist = (porcelain.HeadersBlacklist)
	plumbing.HealthcheckPath = (porcelain.HealthcheckPath)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.HostOverride = (porcelain.HostOverride)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Url = (porcelain.Url)
	return plumbing
}
func convertRepeatedHTTPNoAuthToPlumbing(
	porcelains []*HTTPNoAuth,
) []*proto.HTTPNoAuth {
	var items []*proto.HTTPNoAuth
	for _, porcelain := range porcelains {
		items = append(items, convertHTTPNoAuthToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedHTTPNoAuthToPorcelain(plumbings []*proto.HTTPNoAuth) (
	[]*HTTPNoAuth,
	error,
) {
	var items []*HTTPNoAuth
	for _, plumbing := range plumbings {
		if v, err := convertHTTPNoAuthToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertHealthcheckToPorcelain(plumbing *proto.Healthcheck) (*Healthcheck, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Healthcheck{}
	porcelain.ErrorMsg = plumbing.ErrorMsg
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.NodeID = plumbing.NodeId
	porcelain.NodeName = plumbing.NodeName
	porcelain.ResourceID = plumbing.ResourceId
	porcelain.ResourceName = plumbing.ResourceName
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	return porcelain, nil
}

func convertHealthcheckToPlumbing(porcelain *Healthcheck) *proto.Healthcheck {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Healthcheck{}
	plumbing.ErrorMsg = (porcelain.ErrorMsg)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.NodeId = (porcelain.NodeID)
	plumbing.NodeName = (porcelain.NodeName)
	plumbing.ResourceId = (porcelain.ResourceID)
	plumbing.ResourceName = (porcelain.ResourceName)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	return plumbing
}
func convertRepeatedHealthcheckToPlumbing(
	porcelains []*Healthcheck,
) []*proto.Healthcheck {
	var items []*proto.Healthcheck
	for _, porcelain := range porcelains {
		items = append(items, convertHealthcheckToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedHealthcheckToPorcelain(plumbings []*proto.Healthcheck) (
	[]*Healthcheck,
	error,
) {
	var items []*Healthcheck
	for _, plumbing := range plumbings {
		if v, err := convertHealthcheckToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertHealthcheckListResponseToPorcelain(plumbing *proto.HealthcheckListResponse) (*HealthcheckListResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &HealthcheckListResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertHealthcheckListResponseToPlumbing(porcelain *HealthcheckListResponse) *proto.HealthcheckListResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.HealthcheckListResponse{}
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedHealthcheckListResponseToPlumbing(
	porcelains []*HealthcheckListResponse,
) []*proto.HealthcheckListResponse {
	var items []*proto.HealthcheckListResponse
	for _, porcelain := range porcelains {
		items = append(items, convertHealthcheckListResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedHealthcheckListResponseToPorcelain(plumbings []*proto.HealthcheckListResponse) (
	[]*HealthcheckListResponse,
	error,
) {
	var items []*HealthcheckListResponse
	for _, plumbing := range plumbings {
		if v, err := convertHealthcheckListResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertIdentityAliasToPorcelain(plumbing *proto.IdentityAlias) (*IdentityAlias, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &IdentityAlias{}
	porcelain.AccountID = plumbing.AccountId
	porcelain.ID = plumbing.Id
	porcelain.IdentitySetID = plumbing.IdentitySetId
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertIdentityAliasToPlumbing(porcelain *IdentityAlias) *proto.IdentityAlias {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.IdentityAlias{}
	plumbing.AccountId = (porcelain.AccountID)
	plumbing.Id = (porcelain.ID)
	plumbing.IdentitySetId = (porcelain.IdentitySetID)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedIdentityAliasToPlumbing(
	porcelains []*IdentityAlias,
) []*proto.IdentityAlias {
	var items []*proto.IdentityAlias
	for _, porcelain := range porcelains {
		items = append(items, convertIdentityAliasToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedIdentityAliasToPorcelain(plumbings []*proto.IdentityAlias) (
	[]*IdentityAlias,
	error,
) {
	var items []*IdentityAlias
	for _, plumbing := range plumbings {
		if v, err := convertIdentityAliasToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertIdentityAliasCreateResponseToPorcelain(plumbing *proto.IdentityAliasCreateResponse) (*IdentityAliasCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &IdentityAliasCreateResponse{}
	if v, err := convertIdentityAliasToPorcelain(plumbing.IdentityAlias); err != nil {
		return nil, fmt.Errorf("error converting field IdentityAlias: %v", err)
	} else {
		porcelain.IdentityAlias = v
	}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertIdentityAliasCreateResponseToPlumbing(porcelain *IdentityAliasCreateResponse) *proto.IdentityAliasCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.IdentityAliasCreateResponse{}
	plumbing.IdentityAlias = convertIdentityAliasToPlumbing(porcelain.IdentityAlias)
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedIdentityAliasCreateResponseToPlumbing(
	porcelains []*IdentityAliasCreateResponse,
) []*proto.IdentityAliasCreateResponse {
	var items []*proto.IdentityAliasCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertIdentityAliasCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedIdentityAliasCreateResponseToPorcelain(plumbings []*proto.IdentityAliasCreateResponse) (
	[]*IdentityAliasCreateResponse,
	error,
) {
	var items []*IdentityAliasCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertIdentityAliasCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertIdentityAliasDeleteResponseToPorcelain(plumbing *proto.IdentityAliasDeleteResponse) (*IdentityAliasDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &IdentityAliasDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertIdentityAliasDeleteResponseToPlumbing(porcelain *IdentityAliasDeleteResponse) *proto.IdentityAliasDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.IdentityAliasDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedIdentityAliasDeleteResponseToPlumbing(
	porcelains []*IdentityAliasDeleteResponse,
) []*proto.IdentityAliasDeleteResponse {
	var items []*proto.IdentityAliasDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertIdentityAliasDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedIdentityAliasDeleteResponseToPorcelain(plumbings []*proto.IdentityAliasDeleteResponse) (
	[]*IdentityAliasDeleteResponse,
	error,
) {
	var items []*IdentityAliasDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertIdentityAliasDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertIdentityAliasGetResponseToPorcelain(plumbing *proto.IdentityAliasGetResponse) (*IdentityAliasGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &IdentityAliasGetResponse{}
	if v, err := convertIdentityAliasToPorcelain(plumbing.IdentityAlias); err != nil {
		return nil, fmt.Errorf("error converting field IdentityAlias: %v", err)
	} else {
		porcelain.IdentityAlias = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertIdentityAliasGetResponseToPlumbing(porcelain *IdentityAliasGetResponse) *proto.IdentityAliasGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.IdentityAliasGetResponse{}
	plumbing.IdentityAlias = convertIdentityAliasToPlumbing(porcelain.IdentityAlias)
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedIdentityAliasGetResponseToPlumbing(
	porcelains []*IdentityAliasGetResponse,
) []*proto.IdentityAliasGetResponse {
	var items []*proto.IdentityAliasGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertIdentityAliasGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedIdentityAliasGetResponseToPorcelain(plumbings []*proto.IdentityAliasGetResponse) (
	[]*IdentityAliasGetResponse,
	error,
) {
	var items []*IdentityAliasGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertIdentityAliasGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertIdentityAliasHistoryToPorcelain(plumbing *proto.IdentityAliasHistory) (*IdentityAliasHistory, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &IdentityAliasHistory{}
	porcelain.ActivityID = plumbing.ActivityId
	if v, err := convertTimestampToPorcelain(plumbing.DeletedAt); err != nil {
		return nil, fmt.Errorf("error converting field DeletedAt: %v", err)
	} else {
		porcelain.DeletedAt = v
	}
	if v, err := convertIdentityAliasToPorcelain(plumbing.IdentityAlias); err != nil {
		return nil, fmt.Errorf("error converting field IdentityAlias: %v", err)
	} else {
		porcelain.IdentityAlias = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	return porcelain, nil
}

func convertIdentityAliasHistoryToPlumbing(porcelain *IdentityAliasHistory) *proto.IdentityAliasHistory {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.IdentityAliasHistory{}
	plumbing.ActivityId = (porcelain.ActivityID)
	plumbing.DeletedAt = convertTimestampToPlumbing(porcelain.DeletedAt)
	plumbing.IdentityAlias = convertIdentityAliasToPlumbing(porcelain.IdentityAlias)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	return plumbing
}
func convertRepeatedIdentityAliasHistoryToPlumbing(
	porcelains []*IdentityAliasHistory,
) []*proto.IdentityAliasHistory {
	var items []*proto.IdentityAliasHistory
	for _, porcelain := range porcelains {
		items = append(items, convertIdentityAliasHistoryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedIdentityAliasHistoryToPorcelain(plumbings []*proto.IdentityAliasHistory) (
	[]*IdentityAliasHistory,
	error,
) {
	var items []*IdentityAliasHistory
	for _, plumbing := range plumbings {
		if v, err := convertIdentityAliasHistoryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertIdentityAliasUpdateResponseToPorcelain(plumbing *proto.IdentityAliasUpdateResponse) (*IdentityAliasUpdateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &IdentityAliasUpdateResponse{}
	if v, err := convertIdentityAliasToPorcelain(plumbing.IdentityAlias); err != nil {
		return nil, fmt.Errorf("error converting field IdentityAlias: %v", err)
	} else {
		porcelain.IdentityAlias = v
	}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertIdentityAliasUpdateResponseToPlumbing(porcelain *IdentityAliasUpdateResponse) *proto.IdentityAliasUpdateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.IdentityAliasUpdateResponse{}
	plumbing.IdentityAlias = convertIdentityAliasToPlumbing(porcelain.IdentityAlias)
	plumbing.Meta = convertUpdateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedIdentityAliasUpdateResponseToPlumbing(
	porcelains []*IdentityAliasUpdateResponse,
) []*proto.IdentityAliasUpdateResponse {
	var items []*proto.IdentityAliasUpdateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertIdentityAliasUpdateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedIdentityAliasUpdateResponseToPorcelain(plumbings []*proto.IdentityAliasUpdateResponse) (
	[]*IdentityAliasUpdateResponse,
	error,
) {
	var items []*IdentityAliasUpdateResponse
	for _, plumbing := range plumbings {
		if v, err := convertIdentityAliasUpdateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertIdentitySetToPorcelain(plumbing *proto.IdentitySet) (*IdentitySet, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &IdentitySet{}
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	return porcelain, nil
}

func convertIdentitySetToPlumbing(porcelain *IdentitySet) *proto.IdentitySet {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.IdentitySet{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	return plumbing
}
func convertRepeatedIdentitySetToPlumbing(
	porcelains []*IdentitySet,
) []*proto.IdentitySet {
	var items []*proto.IdentitySet
	for _, porcelain := range porcelains {
		items = append(items, convertIdentitySetToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedIdentitySetToPorcelain(plumbings []*proto.IdentitySet) (
	[]*IdentitySet,
	error,
) {
	var items []*IdentitySet
	for _, plumbing := range plumbings {
		if v, err := convertIdentitySetToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertIdentitySetCreateResponseToPorcelain(plumbing *proto.IdentitySetCreateResponse) (*IdentitySetCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &IdentitySetCreateResponse{}
	if v, err := convertIdentitySetToPorcelain(plumbing.IdentitySet); err != nil {
		return nil, fmt.Errorf("error converting field IdentitySet: %v", err)
	} else {
		porcelain.IdentitySet = v
	}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertIdentitySetCreateResponseToPlumbing(porcelain *IdentitySetCreateResponse) *proto.IdentitySetCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.IdentitySetCreateResponse{}
	plumbing.IdentitySet = convertIdentitySetToPlumbing(porcelain.IdentitySet)
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedIdentitySetCreateResponseToPlumbing(
	porcelains []*IdentitySetCreateResponse,
) []*proto.IdentitySetCreateResponse {
	var items []*proto.IdentitySetCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertIdentitySetCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedIdentitySetCreateResponseToPorcelain(plumbings []*proto.IdentitySetCreateResponse) (
	[]*IdentitySetCreateResponse,
	error,
) {
	var items []*IdentitySetCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertIdentitySetCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertIdentitySetDeleteResponseToPorcelain(plumbing *proto.IdentitySetDeleteResponse) (*IdentitySetDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &IdentitySetDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertIdentitySetDeleteResponseToPlumbing(porcelain *IdentitySetDeleteResponse) *proto.IdentitySetDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.IdentitySetDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedIdentitySetDeleteResponseToPlumbing(
	porcelains []*IdentitySetDeleteResponse,
) []*proto.IdentitySetDeleteResponse {
	var items []*proto.IdentitySetDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertIdentitySetDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedIdentitySetDeleteResponseToPorcelain(plumbings []*proto.IdentitySetDeleteResponse) (
	[]*IdentitySetDeleteResponse,
	error,
) {
	var items []*IdentitySetDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertIdentitySetDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertIdentitySetGetResponseToPorcelain(plumbing *proto.IdentitySetGetResponse) (*IdentitySetGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &IdentitySetGetResponse{}
	if v, err := convertIdentitySetToPorcelain(plumbing.IdentitySet); err != nil {
		return nil, fmt.Errorf("error converting field IdentitySet: %v", err)
	} else {
		porcelain.IdentitySet = v
	}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertIdentitySetGetResponseToPlumbing(porcelain *IdentitySetGetResponse) *proto.IdentitySetGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.IdentitySetGetResponse{}
	plumbing.IdentitySet = convertIdentitySetToPlumbing(porcelain.IdentitySet)
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedIdentitySetGetResponseToPlumbing(
	porcelains []*IdentitySetGetResponse,
) []*proto.IdentitySetGetResponse {
	var items []*proto.IdentitySetGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertIdentitySetGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedIdentitySetGetResponseToPorcelain(plumbings []*proto.IdentitySetGetResponse) (
	[]*IdentitySetGetResponse,
	error,
) {
	var items []*IdentitySetGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertIdentitySetGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertIdentitySetHistoryToPorcelain(plumbing *proto.IdentitySetHistory) (*IdentitySetHistory, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &IdentitySetHistory{}
	porcelain.ActivityID = plumbing.ActivityId
	if v, err := convertTimestampToPorcelain(plumbing.DeletedAt); err != nil {
		return nil, fmt.Errorf("error converting field DeletedAt: %v", err)
	} else {
		porcelain.DeletedAt = v
	}
	if v, err := convertIdentitySetToPorcelain(plumbing.IdentitySet); err != nil {
		return nil, fmt.Errorf("error converting field IdentitySet: %v", err)
	} else {
		porcelain.IdentitySet = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	return porcelain, nil
}

func convertIdentitySetHistoryToPlumbing(porcelain *IdentitySetHistory) *proto.IdentitySetHistory {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.IdentitySetHistory{}
	plumbing.ActivityId = (porcelain.ActivityID)
	plumbing.DeletedAt = convertTimestampToPlumbing(porcelain.DeletedAt)
	plumbing.IdentitySet = convertIdentitySetToPlumbing(porcelain.IdentitySet)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	return plumbing
}
func convertRepeatedIdentitySetHistoryToPlumbing(
	porcelains []*IdentitySetHistory,
) []*proto.IdentitySetHistory {
	var items []*proto.IdentitySetHistory
	for _, porcelain := range porcelains {
		items = append(items, convertIdentitySetHistoryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedIdentitySetHistoryToPorcelain(plumbings []*proto.IdentitySetHistory) (
	[]*IdentitySetHistory,
	error,
) {
	var items []*IdentitySetHistory
	for _, plumbing := range plumbings {
		if v, err := convertIdentitySetHistoryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertIdentitySetUpdateResponseToPorcelain(plumbing *proto.IdentitySetUpdateResponse) (*IdentitySetUpdateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &IdentitySetUpdateResponse{}
	if v, err := convertIdentitySetToPorcelain(plumbing.IdentitySet); err != nil {
		return nil, fmt.Errorf("error converting field IdentitySet: %v", err)
	} else {
		porcelain.IdentitySet = v
	}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertIdentitySetUpdateResponseToPlumbing(porcelain *IdentitySetUpdateResponse) *proto.IdentitySetUpdateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.IdentitySetUpdateResponse{}
	plumbing.IdentitySet = convertIdentitySetToPlumbing(porcelain.IdentitySet)
	plumbing.Meta = convertUpdateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedIdentitySetUpdateResponseToPlumbing(
	porcelains []*IdentitySetUpdateResponse,
) []*proto.IdentitySetUpdateResponse {
	var items []*proto.IdentitySetUpdateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertIdentitySetUpdateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedIdentitySetUpdateResponseToPorcelain(plumbings []*proto.IdentitySetUpdateResponse) (
	[]*IdentitySetUpdateResponse,
	error,
) {
	var items []*IdentitySetUpdateResponse
	for _, plumbing := range plumbings {
		if v, err := convertIdentitySetUpdateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertKeyfactorSSHStoreToPorcelain(plumbing *proto.KeyfactorSSHStore) (*KeyfactorSSHStore, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &KeyfactorSSHStore{}
	porcelain.CaFilePath = plumbing.CaFilePath
	porcelain.CertificateFilePath = plumbing.CertificateFilePath
	porcelain.DefaultCertificateAuthorityName = plumbing.DefaultCertificateAuthorityName
	porcelain.DefaultCertificateProfileName = plumbing.DefaultCertificateProfileName
	porcelain.DefaultEndEntityProfileName = plumbing.DefaultEndEntityProfileName
	porcelain.EnrollmentCodeEnvVar = plumbing.EnrollmentCodeEnvVar
	porcelain.EnrollmentUsernameEnvVar = plumbing.EnrollmentUsernameEnvVar
	porcelain.ID = plumbing.Id
	porcelain.KeyFilePath = plumbing.KeyFilePath
	porcelain.Name = plumbing.Name
	porcelain.ServerAddress = plumbing.ServerAddress
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertKeyfactorSSHStoreToPlumbing(porcelain *KeyfactorSSHStore) *proto.KeyfactorSSHStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.KeyfactorSSHStore{}
	plumbing.CaFilePath = (porcelain.CaFilePath)
	plumbing.CertificateFilePath = (porcelain.CertificateFilePath)
	plumbing.DefaultCertificateAuthorityName = (porcelain.DefaultCertificateAuthorityName)
	plumbing.DefaultCertificateProfileName = (porcelain.DefaultCertificateProfileName)
	plumbing.DefaultEndEntityProfileName = (porcelain.DefaultEndEntityProfileName)
	plumbing.EnrollmentCodeEnvVar = (porcelain.EnrollmentCodeEnvVar)
	plumbing.EnrollmentUsernameEnvVar = (porcelain.EnrollmentUsernameEnvVar)
	plumbing.Id = (porcelain.ID)
	plumbing.KeyFilePath = (porcelain.KeyFilePath)
	plumbing.Name = (porcelain.Name)
	plumbing.ServerAddress = (porcelain.ServerAddress)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedKeyfactorSSHStoreToPlumbing(
	porcelains []*KeyfactorSSHStore,
) []*proto.KeyfactorSSHStore {
	var items []*proto.KeyfactorSSHStore
	for _, porcelain := range porcelains {
		items = append(items, convertKeyfactorSSHStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedKeyfactorSSHStoreToPorcelain(plumbings []*proto.KeyfactorSSHStore) (
	[]*KeyfactorSSHStore,
	error,
) {
	var items []*KeyfactorSSHStore
	for _, plumbing := range plumbings {
		if v, err := convertKeyfactorSSHStoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertKeyfactorX509StoreToPorcelain(plumbing *proto.KeyfactorX509Store) (*KeyfactorX509Store, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &KeyfactorX509Store{}
	porcelain.CaFilePath = plumbing.CaFilePath
	porcelain.CertificateFilePath = plumbing.CertificateFilePath
	porcelain.DefaultCertificateAuthorityName = plumbing.DefaultCertificateAuthorityName
	porcelain.DefaultCertificateProfileName = plumbing.DefaultCertificateProfileName
	porcelain.DefaultEndEntityProfileName = plumbing.DefaultEndEntityProfileName
	porcelain.EnrollmentCodeEnvVar = plumbing.EnrollmentCodeEnvVar
	porcelain.EnrollmentUsernameEnvVar = plumbing.EnrollmentUsernameEnvVar
	porcelain.ID = plumbing.Id
	porcelain.KeyFilePath = plumbing.KeyFilePath
	porcelain.Name = plumbing.Name
	porcelain.ServerAddress = plumbing.ServerAddress
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertKeyfactorX509StoreToPlumbing(porcelain *KeyfactorX509Store) *proto.KeyfactorX509Store {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.KeyfactorX509Store{}
	plumbing.CaFilePath = (porcelain.CaFilePath)
	plumbing.CertificateFilePath = (porcelain.CertificateFilePath)
	plumbing.DefaultCertificateAuthorityName = (porcelain.DefaultCertificateAuthorityName)
	plumbing.DefaultCertificateProfileName = (porcelain.DefaultCertificateProfileName)
	plumbing.DefaultEndEntityProfileName = (porcelain.DefaultEndEntityProfileName)
	plumbing.EnrollmentCodeEnvVar = (porcelain.EnrollmentCodeEnvVar)
	plumbing.EnrollmentUsernameEnvVar = (porcelain.EnrollmentUsernameEnvVar)
	plumbing.Id = (porcelain.ID)
	plumbing.KeyFilePath = (porcelain.KeyFilePath)
	plumbing.Name = (porcelain.Name)
	plumbing.ServerAddress = (porcelain.ServerAddress)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedKeyfactorX509StoreToPlumbing(
	porcelains []*KeyfactorX509Store,
) []*proto.KeyfactorX509Store {
	var items []*proto.KeyfactorX509Store
	for _, porcelain := range porcelains {
		items = append(items, convertKeyfactorX509StoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedKeyfactorX509StoreToPorcelain(plumbings []*proto.KeyfactorX509Store) (
	[]*KeyfactorX509Store,
	error,
) {
	var items []*KeyfactorX509Store
	for _, plumbing := range plumbings {
		if v, err := convertKeyfactorX509StoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertKubernetesToPorcelain(plumbing *proto.Kubernetes) (*Kubernetes, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Kubernetes{}
	porcelain.AllowResourceRoleBypass = plumbing.AllowResourceRoleBypass
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.CertificateAuthority = plumbing.CertificateAuthority
	porcelain.ClientCertificate = plumbing.ClientCertificate
	porcelain.ClientKey = plumbing.ClientKey
	porcelain.DiscoveryEnabled = plumbing.DiscoveryEnabled
	porcelain.DiscoveryUsername = plumbing.DiscoveryUsername
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.IdentityAliasHealthcheckUsername = plumbing.IdentityAliasHealthcheckUsername
	porcelain.IdentitySetID = plumbing.IdentitySetId
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertKubernetesToPlumbing(porcelain *Kubernetes) *proto.Kubernetes {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Kubernetes{}
	plumbing.AllowResourceRoleBypass = (porcelain.AllowResourceRoleBypass)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.CertificateAuthority = (porcelain.CertificateAuthority)
	plumbing.ClientCertificate = (porcelain.ClientCertificate)
	plumbing.ClientKey = (porcelain.ClientKey)
	plumbing.DiscoveryEnabled = (porcelain.DiscoveryEnabled)
	plumbing.DiscoveryUsername = (porcelain.DiscoveryUsername)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.IdentityAliasHealthcheckUsername = (porcelain.IdentityAliasHealthcheckUsername)
	plumbing.IdentitySetId = (porcelain.IdentitySetID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedKubernetesToPlumbing(
	porcelains []*Kubernetes,
) []*proto.Kubernetes {
	var items []*proto.Kubernetes
	for _, porcelain := range porcelains {
		items = append(items, convertKubernetesToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedKubernetesToPorcelain(plumbings []*proto.Kubernetes) (
	[]*Kubernetes,
	error,
) {
	var items []*Kubernetes
	for _, plumbing := range plumbings {
		if v, err := convertKubernetesToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertKubernetesBasicAuthToPorcelain(plumbing *proto.KubernetesBasicAuth) (*KubernetesBasicAuth, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &KubernetesBasicAuth{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertKubernetesBasicAuthToPlumbing(porcelain *KubernetesBasicAuth) *proto.KubernetesBasicAuth {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.KubernetesBasicAuth{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedKubernetesBasicAuthToPlumbing(
	porcelains []*KubernetesBasicAuth,
) []*proto.KubernetesBasicAuth {
	var items []*proto.KubernetesBasicAuth
	for _, porcelain := range porcelains {
		items = append(items, convertKubernetesBasicAuthToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedKubernetesBasicAuthToPorcelain(plumbings []*proto.KubernetesBasicAuth) (
	[]*KubernetesBasicAuth,
	error,
) {
	var items []*KubernetesBasicAuth
	for _, plumbing := range plumbings {
		if v, err := convertKubernetesBasicAuthToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertKubernetesServiceAccountToPorcelain(plumbing *proto.KubernetesServiceAccount) (*KubernetesServiceAccount, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &KubernetesServiceAccount{}
	porcelain.AllowResourceRoleBypass = plumbing.AllowResourceRoleBypass
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.DiscoveryEnabled = plumbing.DiscoveryEnabled
	porcelain.DiscoveryUsername = plumbing.DiscoveryUsername
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.IdentityAliasHealthcheckUsername = plumbing.IdentityAliasHealthcheckUsername
	porcelain.IdentitySetID = plumbing.IdentitySetId
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Token = plumbing.Token
	return porcelain, nil
}

func convertKubernetesServiceAccountToPlumbing(porcelain *KubernetesServiceAccount) *proto.KubernetesServiceAccount {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.KubernetesServiceAccount{}
	plumbing.AllowResourceRoleBypass = (porcelain.AllowResourceRoleBypass)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.DiscoveryEnabled = (porcelain.DiscoveryEnabled)
	plumbing.DiscoveryUsername = (porcelain.DiscoveryUsername)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.IdentityAliasHealthcheckUsername = (porcelain.IdentityAliasHealthcheckUsername)
	plumbing.IdentitySetId = (porcelain.IdentitySetID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Token = (porcelain.Token)
	return plumbing
}
func convertRepeatedKubernetesServiceAccountToPlumbing(
	porcelains []*KubernetesServiceAccount,
) []*proto.KubernetesServiceAccount {
	var items []*proto.KubernetesServiceAccount
	for _, porcelain := range porcelains {
		items = append(items, convertKubernetesServiceAccountToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedKubernetesServiceAccountToPorcelain(plumbings []*proto.KubernetesServiceAccount) (
	[]*KubernetesServiceAccount,
	error,
) {
	var items []*KubernetesServiceAccount
	for _, plumbing := range plumbings {
		if v, err := convertKubernetesServiceAccountToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertKubernetesServiceAccountUserImpersonationToPorcelain(plumbing *proto.KubernetesServiceAccountUserImpersonation) (*KubernetesServiceAccountUserImpersonation, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &KubernetesServiceAccountUserImpersonation{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Token = plumbing.Token
	return porcelain, nil
}

func convertKubernetesServiceAccountUserImpersonationToPlumbing(porcelain *KubernetesServiceAccountUserImpersonation) *proto.KubernetesServiceAccountUserImpersonation {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.KubernetesServiceAccountUserImpersonation{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Token = (porcelain.Token)
	return plumbing
}
func convertRepeatedKubernetesServiceAccountUserImpersonationToPlumbing(
	porcelains []*KubernetesServiceAccountUserImpersonation,
) []*proto.KubernetesServiceAccountUserImpersonation {
	var items []*proto.KubernetesServiceAccountUserImpersonation
	for _, porcelain := range porcelains {
		items = append(items, convertKubernetesServiceAccountUserImpersonationToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedKubernetesServiceAccountUserImpersonationToPorcelain(plumbings []*proto.KubernetesServiceAccountUserImpersonation) (
	[]*KubernetesServiceAccountUserImpersonation,
	error,
) {
	var items []*KubernetesServiceAccountUserImpersonation
	for _, plumbing := range plumbings {
		if v, err := convertKubernetesServiceAccountUserImpersonationToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertKubernetesUserImpersonationToPorcelain(plumbing *proto.KubernetesUserImpersonation) (*KubernetesUserImpersonation, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &KubernetesUserImpersonation{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.CertificateAuthority = plumbing.CertificateAuthority
	porcelain.ClientCertificate = plumbing.ClientCertificate
	porcelain.ClientKey = plumbing.ClientKey
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HealthcheckNamespace = plumbing.HealthcheckNamespace
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertKubernetesUserImpersonationToPlumbing(porcelain *KubernetesUserImpersonation) *proto.KubernetesUserImpersonation {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.KubernetesUserImpersonation{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.CertificateAuthority = (porcelain.CertificateAuthority)
	plumbing.ClientCertificate = (porcelain.ClientCertificate)
	plumbing.ClientKey = (porcelain.ClientKey)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HealthcheckNamespace = (porcelain.HealthcheckNamespace)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedKubernetesUserImpersonationToPlumbing(
	porcelains []*KubernetesUserImpersonation,
) []*proto.KubernetesUserImpersonation {
	var items []*proto.KubernetesUserImpersonation
	for _, porcelain := range porcelains {
		items = append(items, convertKubernetesUserImpersonationToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedKubernetesUserImpersonationToPorcelain(plumbings []*proto.KubernetesUserImpersonation) (
	[]*KubernetesUserImpersonation,
	error,
) {
	var items []*KubernetesUserImpersonation
	for _, plumbing := range plumbings {
		if v, err := convertKubernetesUserImpersonationToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertMTLSMysqlToPorcelain(plumbing *proto.MTLSMysql) (*MTLSMysql, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &MTLSMysql{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.CertificateAuthority = plumbing.CertificateAuthority
	porcelain.ClientCertificate = plumbing.ClientCertificate
	porcelain.ClientKey = plumbing.ClientKey
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.RequireNativeAuth = plumbing.RequireNativeAuth
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.ServerName = plumbing.ServerName
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.UseAzureSingleServerUsernames = plumbing.UseAzureSingleServerUsernames
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertMTLSMysqlToPlumbing(porcelain *MTLSMysql) *proto.MTLSMysql {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.MTLSMysql{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.CertificateAuthority = (porcelain.CertificateAuthority)
	plumbing.ClientCertificate = (porcelain.ClientCertificate)
	plumbing.ClientKey = (porcelain.ClientKey)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.RequireNativeAuth = (porcelain.RequireNativeAuth)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.ServerName = (porcelain.ServerName)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.UseAzureSingleServerUsernames = (porcelain.UseAzureSingleServerUsernames)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedMTLSMysqlToPlumbing(
	porcelains []*MTLSMysql,
) []*proto.MTLSMysql {
	var items []*proto.MTLSMysql
	for _, porcelain := range porcelains {
		items = append(items, convertMTLSMysqlToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMTLSMysqlToPorcelain(plumbings []*proto.MTLSMysql) (
	[]*MTLSMysql,
	error,
) {
	var items []*MTLSMysql
	for _, plumbing := range plumbings {
		if v, err := convertMTLSMysqlToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertMTLSPostgresToPorcelain(plumbing *proto.MTLSPostgres) (*MTLSPostgres, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &MTLSPostgres{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.CertificateAuthority = plumbing.CertificateAuthority
	porcelain.ClientCertificate = plumbing.ClientCertificate
	porcelain.ClientKey = plumbing.ClientKey
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.OverrideDatabase = plumbing.OverrideDatabase
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.ServerName = plumbing.ServerName
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertMTLSPostgresToPlumbing(porcelain *MTLSPostgres) *proto.MTLSPostgres {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.MTLSPostgres{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.CertificateAuthority = (porcelain.CertificateAuthority)
	plumbing.ClientCertificate = (porcelain.ClientCertificate)
	plumbing.ClientKey = (porcelain.ClientKey)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.ServerName = (porcelain.ServerName)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedMTLSPostgresToPlumbing(
	porcelains []*MTLSPostgres,
) []*proto.MTLSPostgres {
	var items []*proto.MTLSPostgres
	for _, porcelain := range porcelains {
		items = append(items, convertMTLSPostgresToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMTLSPostgresToPorcelain(plumbings []*proto.MTLSPostgres) (
	[]*MTLSPostgres,
	error,
) {
	var items []*MTLSPostgres
	for _, plumbing := range plumbings {
		if v, err := convertMTLSPostgresToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertMariaToPorcelain(plumbing *proto.Maria) (*Maria, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Maria{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.RequireNativeAuth = plumbing.RequireNativeAuth
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.UseAzureSingleServerUsernames = plumbing.UseAzureSingleServerUsernames
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertMariaToPlumbing(porcelain *Maria) *proto.Maria {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Maria{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.RequireNativeAuth = (porcelain.RequireNativeAuth)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.UseAzureSingleServerUsernames = (porcelain.UseAzureSingleServerUsernames)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedMariaToPlumbing(
	porcelains []*Maria,
) []*proto.Maria {
	var items []*proto.Maria
	for _, porcelain := range porcelains {
		items = append(items, convertMariaToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMariaToPorcelain(plumbings []*proto.Maria) (
	[]*Maria,
	error,
) {
	var items []*Maria
	for _, plumbing := range plumbings {
		if v, err := convertMariaToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertMemcachedToPorcelain(plumbing *proto.Memcached) (*Memcached, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Memcached{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertMemcachedToPlumbing(porcelain *Memcached) *proto.Memcached {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Memcached{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedMemcachedToPlumbing(
	porcelains []*Memcached,
) []*proto.Memcached {
	var items []*proto.Memcached
	for _, porcelain := range porcelains {
		items = append(items, convertMemcachedToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMemcachedToPorcelain(plumbings []*proto.Memcached) (
	[]*Memcached,
	error,
) {
	var items []*Memcached
	for _, plumbing := range plumbings {
		if v, err := convertMemcachedToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertMemsqlToPorcelain(plumbing *proto.Memsql) (*Memsql, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Memsql{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.RequireNativeAuth = plumbing.RequireNativeAuth
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.UseAzureSingleServerUsernames = plumbing.UseAzureSingleServerUsernames
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertMemsqlToPlumbing(porcelain *Memsql) *proto.Memsql {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Memsql{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.RequireNativeAuth = (porcelain.RequireNativeAuth)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.UseAzureSingleServerUsernames = (porcelain.UseAzureSingleServerUsernames)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedMemsqlToPlumbing(
	porcelains []*Memsql,
) []*proto.Memsql {
	var items []*proto.Memsql
	for _, porcelain := range porcelains {
		items = append(items, convertMemsqlToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMemsqlToPorcelain(plumbings []*proto.Memsql) (
	[]*Memsql,
	error,
) {
	var items []*Memsql
	for _, plumbing := range plumbings {
		if v, err := convertMemsqlToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertMongoHostToPorcelain(plumbing *proto.MongoHost) (*MongoHost, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &MongoHost{}
	porcelain.AuthDatabase = plumbing.AuthDatabase
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertMongoHostToPlumbing(porcelain *MongoHost) *proto.MongoHost {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.MongoHost{}
	plumbing.AuthDatabase = (porcelain.AuthDatabase)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedMongoHostToPlumbing(
	porcelains []*MongoHost,
) []*proto.MongoHost {
	var items []*proto.MongoHost
	for _, porcelain := range porcelains {
		items = append(items, convertMongoHostToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMongoHostToPorcelain(plumbings []*proto.MongoHost) (
	[]*MongoHost,
	error,
) {
	var items []*MongoHost
	for _, plumbing := range plumbings {
		if v, err := convertMongoHostToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertMongoLegacyHostToPorcelain(plumbing *proto.MongoLegacyHost) (*MongoLegacyHost, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &MongoLegacyHost{}
	porcelain.AuthDatabase = plumbing.AuthDatabase
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertMongoLegacyHostToPlumbing(porcelain *MongoLegacyHost) *proto.MongoLegacyHost {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.MongoLegacyHost{}
	plumbing.AuthDatabase = (porcelain.AuthDatabase)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedMongoLegacyHostToPlumbing(
	porcelains []*MongoLegacyHost,
) []*proto.MongoLegacyHost {
	var items []*proto.MongoLegacyHost
	for _, porcelain := range porcelains {
		items = append(items, convertMongoLegacyHostToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMongoLegacyHostToPorcelain(plumbings []*proto.MongoLegacyHost) (
	[]*MongoLegacyHost,
	error,
) {
	var items []*MongoLegacyHost
	for _, plumbing := range plumbings {
		if v, err := convertMongoLegacyHostToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertMongoLegacyReplicasetToPorcelain(plumbing *proto.MongoLegacyReplicaset) (*MongoLegacyReplicaset, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &MongoLegacyReplicaset{}
	porcelain.AuthDatabase = plumbing.AuthDatabase
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.ConnectToReplica = plumbing.ConnectToReplica
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.ReplicaSet = plumbing.ReplicaSet
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertMongoLegacyReplicasetToPlumbing(porcelain *MongoLegacyReplicaset) *proto.MongoLegacyReplicaset {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.MongoLegacyReplicaset{}
	plumbing.AuthDatabase = (porcelain.AuthDatabase)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.ConnectToReplica = (porcelain.ConnectToReplica)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.ReplicaSet = (porcelain.ReplicaSet)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedMongoLegacyReplicasetToPlumbing(
	porcelains []*MongoLegacyReplicaset,
) []*proto.MongoLegacyReplicaset {
	var items []*proto.MongoLegacyReplicaset
	for _, porcelain := range porcelains {
		items = append(items, convertMongoLegacyReplicasetToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMongoLegacyReplicasetToPorcelain(plumbings []*proto.MongoLegacyReplicaset) (
	[]*MongoLegacyReplicaset,
	error,
) {
	var items []*MongoLegacyReplicaset
	for _, plumbing := range plumbings {
		if v, err := convertMongoLegacyReplicasetToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertMongoReplicaSetToPorcelain(plumbing *proto.MongoReplicaSet) (*MongoReplicaSet, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &MongoReplicaSet{}
	porcelain.AuthDatabase = plumbing.AuthDatabase
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.ConnectToReplica = plumbing.ConnectToReplica
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.ReplicaSet = plumbing.ReplicaSet
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertMongoReplicaSetToPlumbing(porcelain *MongoReplicaSet) *proto.MongoReplicaSet {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.MongoReplicaSet{}
	plumbing.AuthDatabase = (porcelain.AuthDatabase)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.ConnectToReplica = (porcelain.ConnectToReplica)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.ReplicaSet = (porcelain.ReplicaSet)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedMongoReplicaSetToPlumbing(
	porcelains []*MongoReplicaSet,
) []*proto.MongoReplicaSet {
	var items []*proto.MongoReplicaSet
	for _, porcelain := range porcelains {
		items = append(items, convertMongoReplicaSetToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMongoReplicaSetToPorcelain(plumbings []*proto.MongoReplicaSet) (
	[]*MongoReplicaSet,
	error,
) {
	var items []*MongoReplicaSet
	for _, plumbing := range plumbings {
		if v, err := convertMongoReplicaSetToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertMongoShardedClusterToPorcelain(plumbing *proto.MongoShardedCluster) (*MongoShardedCluster, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &MongoShardedCluster{}
	porcelain.AuthDatabase = plumbing.AuthDatabase
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertMongoShardedClusterToPlumbing(porcelain *MongoShardedCluster) *proto.MongoShardedCluster {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.MongoShardedCluster{}
	plumbing.AuthDatabase = (porcelain.AuthDatabase)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedMongoShardedClusterToPlumbing(
	porcelains []*MongoShardedCluster,
) []*proto.MongoShardedCluster {
	var items []*proto.MongoShardedCluster
	for _, porcelain := range porcelains {
		items = append(items, convertMongoShardedClusterToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMongoShardedClusterToPorcelain(plumbings []*proto.MongoShardedCluster) (
	[]*MongoShardedCluster,
	error,
) {
	var items []*MongoShardedCluster
	for _, plumbing := range plumbings {
		if v, err := convertMongoShardedClusterToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertMysqlToPorcelain(plumbing *proto.Mysql) (*Mysql, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Mysql{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.RequireNativeAuth = plumbing.RequireNativeAuth
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.UseAzureSingleServerUsernames = plumbing.UseAzureSingleServerUsernames
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertMysqlToPlumbing(porcelain *Mysql) *proto.Mysql {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Mysql{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.RequireNativeAuth = (porcelain.RequireNativeAuth)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.UseAzureSingleServerUsernames = (porcelain.UseAzureSingleServerUsernames)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedMysqlToPlumbing(
	porcelains []*Mysql,
) []*proto.Mysql {
	var items []*proto.Mysql
	for _, porcelain := range porcelains {
		items = append(items, convertMysqlToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedMysqlToPorcelain(plumbings []*proto.Mysql) (
	[]*Mysql,
	error,
) {
	var items []*Mysql
	for _, plumbing := range plumbings {
		if v, err := convertMysqlToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertNeptuneToPorcelain(plumbing *proto.Neptune) (*Neptune, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Neptune{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Endpoint = plumbing.Endpoint
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertNeptuneToPlumbing(porcelain *Neptune) *proto.Neptune {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Neptune{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedNeptuneToPlumbing(
	porcelains []*Neptune,
) []*proto.Neptune {
	var items []*proto.Neptune
	for _, porcelain := range porcelains {
		items = append(items, convertNeptuneToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedNeptuneToPorcelain(plumbings []*proto.Neptune) (
	[]*Neptune,
	error,
) {
	var items []*Neptune
	for _, plumbing := range plumbings {
		if v, err := convertNeptuneToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertNeptuneIAMToPorcelain(plumbing *proto.NeptuneIAM) (*NeptuneIAM, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &NeptuneIAM{}
	porcelain.AccessKey = plumbing.AccessKey
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Endpoint = plumbing.Endpoint
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.Region = plumbing.Region
	porcelain.RoleArn = plumbing.RoleArn
	porcelain.RoleExternalID = plumbing.RoleExternalId
	porcelain.SecretAccessKey = plumbing.SecretAccessKey
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertNeptuneIAMToPlumbing(porcelain *NeptuneIAM) *proto.NeptuneIAM {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.NeptuneIAM{}
	plumbing.AccessKey = (porcelain.AccessKey)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Endpoint = (porcelain.Endpoint)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.Region = (porcelain.Region)
	plumbing.RoleArn = (porcelain.RoleArn)
	plumbing.RoleExternalId = (porcelain.RoleExternalID)
	plumbing.SecretAccessKey = (porcelain.SecretAccessKey)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedNeptuneIAMToPlumbing(
	porcelains []*NeptuneIAM,
) []*proto.NeptuneIAM {
	var items []*proto.NeptuneIAM
	for _, porcelain := range porcelains {
		items = append(items, convertNeptuneIAMToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedNeptuneIAMToPorcelain(plumbings []*proto.NeptuneIAM) (
	[]*NeptuneIAM,
	error,
) {
	var items []*NeptuneIAM
	for _, plumbing := range plumbings {
		if v, err := convertNeptuneIAMToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertNodeToPlumbing(porcelain Node) *proto.Node {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Node{}

	switch v := porcelain.(type) {
	case *Gateway:
		plumbing.Node = &proto.Node_Gateway{Gateway: convertGatewayToPlumbing(v)}
	case *ProxyCluster:
		plumbing.Node = &proto.Node_ProxyCluster{ProxyCluster: convertProxyClusterToPlumbing(v)}
	case *Relay:
		plumbing.Node = &proto.Node_Relay{Relay: convertRelayToPlumbing(v)}
	}
	return plumbing
}

func convertNodeToPorcelain(plumbing *proto.Node) (Node, error) {
	if plumbing.GetGateway() != nil {
		return convertGatewayToPorcelain(plumbing.GetGateway())
	}
	if plumbing.GetProxyCluster() != nil {
		return convertProxyClusterToPorcelain(plumbing.GetProxyCluster())
	}
	if plumbing.GetRelay() != nil {
		return convertRelayToPorcelain(plumbing.GetRelay())
	}
	return nil, &UnknownError{Wrapped: fmt.Errorf("unknown polymorphic type, please upgrade your SDK")}
}
func convertRepeatedNodeToPlumbing(
	porcelains []Node,
) []*proto.Node {
	var items []*proto.Node
	for _, porcelain := range porcelains {
		items = append(items, convertNodeToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedNodeToPorcelain(plumbings []*proto.Node) (
	[]Node,
	error,
) {
	var items []Node
	for _, plumbing := range plumbings {
		if v, err := convertNodeToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertNodeCreateResponseToPorcelain(plumbing *proto.NodeCreateResponse) (*NodeCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &NodeCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertNodeToPorcelain(plumbing.Node); err != nil {
		return nil, fmt.Errorf("error converting field Node: %v", err)
	} else {
		porcelain.Node = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	porcelain.Token = plumbing.Token
	return porcelain, nil
}

func convertNodeCreateResponseToPlumbing(porcelain *NodeCreateResponse) *proto.NodeCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.NodeCreateResponse{}
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.Node = convertNodeToPlumbing(porcelain.Node)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.Token = (porcelain.Token)
	return plumbing
}
func convertRepeatedNodeCreateResponseToPlumbing(
	porcelains []*NodeCreateResponse,
) []*proto.NodeCreateResponse {
	var items []*proto.NodeCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertNodeCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedNodeCreateResponseToPorcelain(plumbings []*proto.NodeCreateResponse) (
	[]*NodeCreateResponse,
	error,
) {
	var items []*NodeCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertNodeCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertNodeDeleteResponseToPorcelain(plumbing *proto.NodeDeleteResponse) (*NodeDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &NodeDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertNodeDeleteResponseToPlumbing(porcelain *NodeDeleteResponse) *proto.NodeDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.NodeDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedNodeDeleteResponseToPlumbing(
	porcelains []*NodeDeleteResponse,
) []*proto.NodeDeleteResponse {
	var items []*proto.NodeDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertNodeDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedNodeDeleteResponseToPorcelain(plumbings []*proto.NodeDeleteResponse) (
	[]*NodeDeleteResponse,
	error,
) {
	var items []*NodeDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertNodeDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertNodeGetResponseToPorcelain(plumbing *proto.NodeGetResponse) (*NodeGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &NodeGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertNodeToPorcelain(plumbing.Node); err != nil {
		return nil, fmt.Errorf("error converting field Node: %v", err)
	} else {
		porcelain.Node = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertNodeGetResponseToPlumbing(porcelain *NodeGetResponse) *proto.NodeGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.NodeGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.Node = convertNodeToPlumbing(porcelain.Node)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedNodeGetResponseToPlumbing(
	porcelains []*NodeGetResponse,
) []*proto.NodeGetResponse {
	var items []*proto.NodeGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertNodeGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedNodeGetResponseToPorcelain(plumbings []*proto.NodeGetResponse) (
	[]*NodeGetResponse,
	error,
) {
	var items []*NodeGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertNodeGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertNodeHistoryToPorcelain(plumbing *proto.NodeHistory) (*NodeHistory, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &NodeHistory{}
	porcelain.ActivityID = plumbing.ActivityId
	if v, err := convertTimestampToPorcelain(plumbing.DeletedAt); err != nil {
		return nil, fmt.Errorf("error converting field DeletedAt: %v", err)
	} else {
		porcelain.DeletedAt = v
	}
	if v, err := convertNodeToPorcelain(plumbing.Node); err != nil {
		return nil, fmt.Errorf("error converting field Node: %v", err)
	} else {
		porcelain.Node = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	return porcelain, nil
}

func convertNodeHistoryToPlumbing(porcelain *NodeHistory) *proto.NodeHistory {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.NodeHistory{}
	plumbing.ActivityId = (porcelain.ActivityID)
	plumbing.DeletedAt = convertTimestampToPlumbing(porcelain.DeletedAt)
	plumbing.Node = convertNodeToPlumbing(porcelain.Node)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	return plumbing
}
func convertRepeatedNodeHistoryToPlumbing(
	porcelains []*NodeHistory,
) []*proto.NodeHistory {
	var items []*proto.NodeHistory
	for _, porcelain := range porcelains {
		items = append(items, convertNodeHistoryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedNodeHistoryToPorcelain(plumbings []*proto.NodeHistory) (
	[]*NodeHistory,
	error,
) {
	var items []*NodeHistory
	for _, plumbing := range plumbings {
		if v, err := convertNodeHistoryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertNodeMaintenanceWindowToPorcelain(plumbing *proto.NodeMaintenanceWindow) (*NodeMaintenanceWindow, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &NodeMaintenanceWindow{}
	porcelain.CronSchedule = plumbing.CronSchedule
	porcelain.RequireIdleness = plumbing.RequireIdleness
	return porcelain, nil
}

func convertNodeMaintenanceWindowToPlumbing(porcelain *NodeMaintenanceWindow) *proto.NodeMaintenanceWindow {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.NodeMaintenanceWindow{}
	plumbing.CronSchedule = (porcelain.CronSchedule)
	plumbing.RequireIdleness = (porcelain.RequireIdleness)
	return plumbing
}
func convertRepeatedNodeMaintenanceWindowToPlumbing(
	porcelains []*NodeMaintenanceWindow,
) []*proto.NodeMaintenanceWindow {
	var items []*proto.NodeMaintenanceWindow
	for _, porcelain := range porcelains {
		items = append(items, convertNodeMaintenanceWindowToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedNodeMaintenanceWindowToPorcelain(plumbings []*proto.NodeMaintenanceWindow) (
	[]*NodeMaintenanceWindow,
	error,
) {
	var items []*NodeMaintenanceWindow
	for _, plumbing := range plumbings {
		if v, err := convertNodeMaintenanceWindowToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertNodeUpdateResponseToPorcelain(plumbing *proto.NodeUpdateResponse) (*NodeUpdateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &NodeUpdateResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertNodeToPorcelain(plumbing.Node); err != nil {
		return nil, fmt.Errorf("error converting field Node: %v", err)
	} else {
		porcelain.Node = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertNodeUpdateResponseToPlumbing(porcelain *NodeUpdateResponse) *proto.NodeUpdateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.NodeUpdateResponse{}
	plumbing.Meta = convertUpdateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.Node = convertNodeToPlumbing(porcelain.Node)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedNodeUpdateResponseToPlumbing(
	porcelains []*NodeUpdateResponse,
) []*proto.NodeUpdateResponse {
	var items []*proto.NodeUpdateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertNodeUpdateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedNodeUpdateResponseToPorcelain(plumbings []*proto.NodeUpdateResponse) (
	[]*NodeUpdateResponse,
	error,
) {
	var items []*NodeUpdateResponse
	for _, plumbing := range plumbings {
		if v, err := convertNodeUpdateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertOracleToPorcelain(plumbing *proto.Oracle) (*Oracle, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Oracle{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertOracleToPlumbing(porcelain *Oracle) *proto.Oracle {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Oracle{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedOracleToPlumbing(
	porcelains []*Oracle,
) []*proto.Oracle {
	var items []*proto.Oracle
	for _, porcelain := range porcelains {
		items = append(items, convertOracleToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedOracleToPorcelain(plumbings []*proto.Oracle) (
	[]*Oracle,
	error,
) {
	var items []*Oracle
	for _, plumbing := range plumbings {
		if v, err := convertOracleToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertOrganizationToPorcelain(plumbing *proto.Organization) (*Organization, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Organization{}
	porcelain.AuthProvider = plumbing.AuthProvider
	if v, err := convertTimestampToPorcelain(plumbing.CreatedAt); err != nil {
		return nil, fmt.Errorf("error converting field CreatedAt: %v", err)
	} else {
		porcelain.CreatedAt = v
	}
	porcelain.DeviceTrustEnabled = plumbing.DeviceTrustEnabled
	porcelain.DeviceTrustProvider = plumbing.DeviceTrustProvider
	porcelain.EnforceSingleSession = plumbing.EnforceSingleSession
	if v, err := convertDurationToPorcelain(plumbing.IdleTimeout); err != nil {
		return nil, fmt.Errorf("error converting field IdleTimeout: %v", err)
	} else {
		porcelain.IdleTimeout = v
	}
	porcelain.IdleTimeoutEnabled = plumbing.IdleTimeoutEnabled
	porcelain.Kind = plumbing.Kind
	porcelain.LogLocalEncoder = plumbing.LogLocalEncoder
	porcelain.LogLocalFormat = plumbing.LogLocalFormat
	porcelain.LogLocalStorage = plumbing.LogLocalStorage
	porcelain.LogRemoteEncoder = plumbing.LogRemoteEncoder
	porcelain.LogSocketPath = plumbing.LogSocketPath
	porcelain.LogTCPAddress = plumbing.LogTcpAddress
	porcelain.LoopbackRange = plumbing.LoopbackRange
	porcelain.MFAEnabled = plumbing.MfaEnabled
	porcelain.MFAProvider = plumbing.MfaProvider
	porcelain.Name = plumbing.Name
	porcelain.RequireSecretStore = plumbing.RequireSecretStore
	porcelain.SAMLMetadataURL = plumbing.SamlMetadataUrl
	porcelain.SCIMProvider = plumbing.ScimProvider
	porcelain.SensitiveLabel = plumbing.SensitiveLabel
	if v, err := convertDurationToPorcelain(plumbing.SessionTimeout); err != nil {
		return nil, fmt.Errorf("error converting field SessionTimeout: %v", err)
	} else {
		porcelain.SessionTimeout = v
	}
	porcelain.SessionTimeoutEnabled = plumbing.SessionTimeoutEnabled
	porcelain.SSHCertificateAuthorityPublicKey = plumbing.SshCertificateAuthorityPublicKey
	if v, err := convertTimestampToPorcelain(plumbing.SshCertificateAuthorityUpdatedAt); err != nil {
		return nil, fmt.Errorf("error converting field SshCertificateAuthorityUpdatedAt: %v", err)
	} else {
		porcelain.SSHCertificateAuthorityUpdatedAt = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.UpdatedAt); err != nil {
		return nil, fmt.Errorf("error converting field UpdatedAt: %v", err)
	} else {
		porcelain.UpdatedAt = v
	}
	porcelain.WebsitesSubdomain = plumbing.WebsitesSubdomain
	return porcelain, nil
}

func convertOrganizationToPlumbing(porcelain *Organization) *proto.Organization {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Organization{}
	plumbing.AuthProvider = (porcelain.AuthProvider)
	plumbing.CreatedAt = convertTimestampToPlumbing(porcelain.CreatedAt)
	plumbing.DeviceTrustEnabled = (porcelain.DeviceTrustEnabled)
	plumbing.DeviceTrustProvider = (porcelain.DeviceTrustProvider)
	plumbing.EnforceSingleSession = (porcelain.EnforceSingleSession)
	plumbing.IdleTimeout = convertDurationToPlumbing(porcelain.IdleTimeout)
	plumbing.IdleTimeoutEnabled = (porcelain.IdleTimeoutEnabled)
	plumbing.Kind = (porcelain.Kind)
	plumbing.LogLocalEncoder = (porcelain.LogLocalEncoder)
	plumbing.LogLocalFormat = (porcelain.LogLocalFormat)
	plumbing.LogLocalStorage = (porcelain.LogLocalStorage)
	plumbing.LogRemoteEncoder = (porcelain.LogRemoteEncoder)
	plumbing.LogSocketPath = (porcelain.LogSocketPath)
	plumbing.LogTcpAddress = (porcelain.LogTCPAddress)
	plumbing.LoopbackRange = (porcelain.LoopbackRange)
	plumbing.MfaEnabled = (porcelain.MFAEnabled)
	plumbing.MfaProvider = (porcelain.MFAProvider)
	plumbing.Name = (porcelain.Name)
	plumbing.RequireSecretStore = (porcelain.RequireSecretStore)
	plumbing.SamlMetadataUrl = (porcelain.SAMLMetadataURL)
	plumbing.ScimProvider = (porcelain.SCIMProvider)
	plumbing.SensitiveLabel = (porcelain.SensitiveLabel)
	plumbing.SessionTimeout = convertDurationToPlumbing(porcelain.SessionTimeout)
	plumbing.SessionTimeoutEnabled = (porcelain.SessionTimeoutEnabled)
	plumbing.SshCertificateAuthorityPublicKey = (porcelain.SSHCertificateAuthorityPublicKey)
	plumbing.SshCertificateAuthorityUpdatedAt = convertTimestampToPlumbing(porcelain.SSHCertificateAuthorityUpdatedAt)
	plumbing.UpdatedAt = convertTimestampToPlumbing(porcelain.UpdatedAt)
	plumbing.WebsitesSubdomain = (porcelain.WebsitesSubdomain)
	return plumbing
}
func convertRepeatedOrganizationToPlumbing(
	porcelains []*Organization,
) []*proto.Organization {
	var items []*proto.Organization
	for _, porcelain := range porcelains {
		items = append(items, convertOrganizationToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedOrganizationToPorcelain(plumbings []*proto.Organization) (
	[]*Organization,
	error,
) {
	var items []*Organization
	for _, plumbing := range plumbings {
		if v, err := convertOrganizationToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertOrganizationHistoryRecordToPorcelain(plumbing *proto.OrganizationHistoryRecord) (*OrganizationHistoryRecord, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &OrganizationHistoryRecord{}
	porcelain.ActivityID = plumbing.ActivityId
	if v, err := convertOrganizationToPorcelain(plumbing.Organization); err != nil {
		return nil, fmt.Errorf("error converting field Organization: %v", err)
	} else {
		porcelain.Organization = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	return porcelain, nil
}

func convertOrganizationHistoryRecordToPlumbing(porcelain *OrganizationHistoryRecord) *proto.OrganizationHistoryRecord {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.OrganizationHistoryRecord{}
	plumbing.ActivityId = (porcelain.ActivityID)
	plumbing.Organization = convertOrganizationToPlumbing(porcelain.Organization)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	return plumbing
}
func convertRepeatedOrganizationHistoryRecordToPlumbing(
	porcelains []*OrganizationHistoryRecord,
) []*proto.OrganizationHistoryRecord {
	var items []*proto.OrganizationHistoryRecord
	for _, porcelain := range porcelains {
		items = append(items, convertOrganizationHistoryRecordToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedOrganizationHistoryRecordToPorcelain(plumbings []*proto.OrganizationHistoryRecord) (
	[]*OrganizationHistoryRecord,
	error,
) {
	var items []*OrganizationHistoryRecord
	for _, plumbing := range plumbings {
		if v, err := convertOrganizationHistoryRecordToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPeeringGroupToPorcelain(plumbing *proto.PeeringGroup) (*PeeringGroup, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &PeeringGroup{}
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	return porcelain, nil
}

func convertPeeringGroupToPlumbing(porcelain *PeeringGroup) *proto.PeeringGroup {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.PeeringGroup{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	return plumbing
}
func convertRepeatedPeeringGroupToPlumbing(
	porcelains []*PeeringGroup,
) []*proto.PeeringGroup {
	var items []*proto.PeeringGroup
	for _, porcelain := range porcelains {
		items = append(items, convertPeeringGroupToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPeeringGroupToPorcelain(plumbings []*proto.PeeringGroup) (
	[]*PeeringGroup,
	error,
) {
	var items []*PeeringGroup
	for _, plumbing := range plumbings {
		if v, err := convertPeeringGroupToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPeeringGroupCreateResponseToPorcelain(plumbing *proto.PeeringGroupCreateResponse) (*PeeringGroupCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &PeeringGroupCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertPeeringGroupToPorcelain(plumbing.PeeringGroup); err != nil {
		return nil, fmt.Errorf("error converting field PeeringGroup: %v", err)
	} else {
		porcelain.PeeringGroup = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertPeeringGroupCreateResponseToPlumbing(porcelain *PeeringGroupCreateResponse) *proto.PeeringGroupCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.PeeringGroupCreateResponse{}
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.PeeringGroup = convertPeeringGroupToPlumbing(porcelain.PeeringGroup)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedPeeringGroupCreateResponseToPlumbing(
	porcelains []*PeeringGroupCreateResponse,
) []*proto.PeeringGroupCreateResponse {
	var items []*proto.PeeringGroupCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertPeeringGroupCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPeeringGroupCreateResponseToPorcelain(plumbings []*proto.PeeringGroupCreateResponse) (
	[]*PeeringGroupCreateResponse,
	error,
) {
	var items []*PeeringGroupCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertPeeringGroupCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPeeringGroupDeleteResponseToPorcelain(plumbing *proto.PeeringGroupDeleteResponse) (*PeeringGroupDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &PeeringGroupDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertPeeringGroupDeleteResponseToPlumbing(porcelain *PeeringGroupDeleteResponse) *proto.PeeringGroupDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.PeeringGroupDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedPeeringGroupDeleteResponseToPlumbing(
	porcelains []*PeeringGroupDeleteResponse,
) []*proto.PeeringGroupDeleteResponse {
	var items []*proto.PeeringGroupDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertPeeringGroupDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPeeringGroupDeleteResponseToPorcelain(plumbings []*proto.PeeringGroupDeleteResponse) (
	[]*PeeringGroupDeleteResponse,
	error,
) {
	var items []*PeeringGroupDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertPeeringGroupDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPeeringGroupGetResponseToPorcelain(plumbing *proto.PeeringGroupGetResponse) (*PeeringGroupGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &PeeringGroupGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertPeeringGroupToPorcelain(plumbing.PeeringGroup); err != nil {
		return nil, fmt.Errorf("error converting field PeeringGroup: %v", err)
	} else {
		porcelain.PeeringGroup = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertPeeringGroupGetResponseToPlumbing(porcelain *PeeringGroupGetResponse) *proto.PeeringGroupGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.PeeringGroupGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.PeeringGroup = convertPeeringGroupToPlumbing(porcelain.PeeringGroup)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedPeeringGroupGetResponseToPlumbing(
	porcelains []*PeeringGroupGetResponse,
) []*proto.PeeringGroupGetResponse {
	var items []*proto.PeeringGroupGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertPeeringGroupGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPeeringGroupGetResponseToPorcelain(plumbings []*proto.PeeringGroupGetResponse) (
	[]*PeeringGroupGetResponse,
	error,
) {
	var items []*PeeringGroupGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertPeeringGroupGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPeeringGroupNodeToPorcelain(plumbing *proto.PeeringGroupNode) (*PeeringGroupNode, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &PeeringGroupNode{}
	porcelain.GroupID = plumbing.GroupId
	porcelain.ID = plumbing.Id
	porcelain.NodeID = plumbing.NodeId
	return porcelain, nil
}

func convertPeeringGroupNodeToPlumbing(porcelain *PeeringGroupNode) *proto.PeeringGroupNode {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.PeeringGroupNode{}
	plumbing.GroupId = (porcelain.GroupID)
	plumbing.Id = (porcelain.ID)
	plumbing.NodeId = (porcelain.NodeID)
	return plumbing
}
func convertRepeatedPeeringGroupNodeToPlumbing(
	porcelains []*PeeringGroupNode,
) []*proto.PeeringGroupNode {
	var items []*proto.PeeringGroupNode
	for _, porcelain := range porcelains {
		items = append(items, convertPeeringGroupNodeToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPeeringGroupNodeToPorcelain(plumbings []*proto.PeeringGroupNode) (
	[]*PeeringGroupNode,
	error,
) {
	var items []*PeeringGroupNode
	for _, plumbing := range plumbings {
		if v, err := convertPeeringGroupNodeToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPeeringGroupNodeCreateResponseToPorcelain(plumbing *proto.PeeringGroupNodeCreateResponse) (*PeeringGroupNodeCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &PeeringGroupNodeCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertPeeringGroupNodeToPorcelain(plumbing.PeeringGroupNode); err != nil {
		return nil, fmt.Errorf("error converting field PeeringGroupNode: %v", err)
	} else {
		porcelain.PeeringGroupNode = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertPeeringGroupNodeCreateResponseToPlumbing(porcelain *PeeringGroupNodeCreateResponse) *proto.PeeringGroupNodeCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.PeeringGroupNodeCreateResponse{}
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.PeeringGroupNode = convertPeeringGroupNodeToPlumbing(porcelain.PeeringGroupNode)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedPeeringGroupNodeCreateResponseToPlumbing(
	porcelains []*PeeringGroupNodeCreateResponse,
) []*proto.PeeringGroupNodeCreateResponse {
	var items []*proto.PeeringGroupNodeCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertPeeringGroupNodeCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPeeringGroupNodeCreateResponseToPorcelain(plumbings []*proto.PeeringGroupNodeCreateResponse) (
	[]*PeeringGroupNodeCreateResponse,
	error,
) {
	var items []*PeeringGroupNodeCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertPeeringGroupNodeCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPeeringGroupNodeDeleteResponseToPorcelain(plumbing *proto.PeeringGroupNodeDeleteResponse) (*PeeringGroupNodeDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &PeeringGroupNodeDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertPeeringGroupNodeDeleteResponseToPlumbing(porcelain *PeeringGroupNodeDeleteResponse) *proto.PeeringGroupNodeDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.PeeringGroupNodeDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedPeeringGroupNodeDeleteResponseToPlumbing(
	porcelains []*PeeringGroupNodeDeleteResponse,
) []*proto.PeeringGroupNodeDeleteResponse {
	var items []*proto.PeeringGroupNodeDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertPeeringGroupNodeDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPeeringGroupNodeDeleteResponseToPorcelain(plumbings []*proto.PeeringGroupNodeDeleteResponse) (
	[]*PeeringGroupNodeDeleteResponse,
	error,
) {
	var items []*PeeringGroupNodeDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertPeeringGroupNodeDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPeeringGroupNodeGetResponseToPorcelain(plumbing *proto.PeeringGroupNodeGetResponse) (*PeeringGroupNodeGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &PeeringGroupNodeGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertPeeringGroupNodeToPorcelain(plumbing.PeeringGroupNode); err != nil {
		return nil, fmt.Errorf("error converting field PeeringGroupNode: %v", err)
	} else {
		porcelain.PeeringGroupNode = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertPeeringGroupNodeGetResponseToPlumbing(porcelain *PeeringGroupNodeGetResponse) *proto.PeeringGroupNodeGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.PeeringGroupNodeGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.PeeringGroupNode = convertPeeringGroupNodeToPlumbing(porcelain.PeeringGroupNode)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedPeeringGroupNodeGetResponseToPlumbing(
	porcelains []*PeeringGroupNodeGetResponse,
) []*proto.PeeringGroupNodeGetResponse {
	var items []*proto.PeeringGroupNodeGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertPeeringGroupNodeGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPeeringGroupNodeGetResponseToPorcelain(plumbings []*proto.PeeringGroupNodeGetResponse) (
	[]*PeeringGroupNodeGetResponse,
	error,
) {
	var items []*PeeringGroupNodeGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertPeeringGroupNodeGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPeeringGroupPeerToPorcelain(plumbing *proto.PeeringGroupPeer) (*PeeringGroupPeer, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &PeeringGroupPeer{}
	porcelain.GroupID = plumbing.GroupId
	porcelain.ID = plumbing.Id
	porcelain.PeersWithGroupID = plumbing.PeersWithGroupId
	return porcelain, nil
}

func convertPeeringGroupPeerToPlumbing(porcelain *PeeringGroupPeer) *proto.PeeringGroupPeer {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.PeeringGroupPeer{}
	plumbing.GroupId = (porcelain.GroupID)
	plumbing.Id = (porcelain.ID)
	plumbing.PeersWithGroupId = (porcelain.PeersWithGroupID)
	return plumbing
}
func convertRepeatedPeeringGroupPeerToPlumbing(
	porcelains []*PeeringGroupPeer,
) []*proto.PeeringGroupPeer {
	var items []*proto.PeeringGroupPeer
	for _, porcelain := range porcelains {
		items = append(items, convertPeeringGroupPeerToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPeeringGroupPeerToPorcelain(plumbings []*proto.PeeringGroupPeer) (
	[]*PeeringGroupPeer,
	error,
) {
	var items []*PeeringGroupPeer
	for _, plumbing := range plumbings {
		if v, err := convertPeeringGroupPeerToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPeeringGroupPeerCreateResponseToPorcelain(plumbing *proto.PeeringGroupPeerCreateResponse) (*PeeringGroupPeerCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &PeeringGroupPeerCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertPeeringGroupPeerToPorcelain(plumbing.PeeringGroupPeer); err != nil {
		return nil, fmt.Errorf("error converting field PeeringGroupPeer: %v", err)
	} else {
		porcelain.PeeringGroupPeer = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertPeeringGroupPeerCreateResponseToPlumbing(porcelain *PeeringGroupPeerCreateResponse) *proto.PeeringGroupPeerCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.PeeringGroupPeerCreateResponse{}
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.PeeringGroupPeer = convertPeeringGroupPeerToPlumbing(porcelain.PeeringGroupPeer)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedPeeringGroupPeerCreateResponseToPlumbing(
	porcelains []*PeeringGroupPeerCreateResponse,
) []*proto.PeeringGroupPeerCreateResponse {
	var items []*proto.PeeringGroupPeerCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertPeeringGroupPeerCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPeeringGroupPeerCreateResponseToPorcelain(plumbings []*proto.PeeringGroupPeerCreateResponse) (
	[]*PeeringGroupPeerCreateResponse,
	error,
) {
	var items []*PeeringGroupPeerCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertPeeringGroupPeerCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPeeringGroupPeerDeleteResponseToPorcelain(plumbing *proto.PeeringGroupPeerDeleteResponse) (*PeeringGroupPeerDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &PeeringGroupPeerDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertPeeringGroupPeerDeleteResponseToPlumbing(porcelain *PeeringGroupPeerDeleteResponse) *proto.PeeringGroupPeerDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.PeeringGroupPeerDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedPeeringGroupPeerDeleteResponseToPlumbing(
	porcelains []*PeeringGroupPeerDeleteResponse,
) []*proto.PeeringGroupPeerDeleteResponse {
	var items []*proto.PeeringGroupPeerDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertPeeringGroupPeerDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPeeringGroupPeerDeleteResponseToPorcelain(plumbings []*proto.PeeringGroupPeerDeleteResponse) (
	[]*PeeringGroupPeerDeleteResponse,
	error,
) {
	var items []*PeeringGroupPeerDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertPeeringGroupPeerDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPeeringGroupPeerGetResponseToPorcelain(plumbing *proto.PeeringGroupPeerGetResponse) (*PeeringGroupPeerGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &PeeringGroupPeerGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertPeeringGroupPeerToPorcelain(plumbing.PeeringGroupPeer); err != nil {
		return nil, fmt.Errorf("error converting field PeeringGroupPeer: %v", err)
	} else {
		porcelain.PeeringGroupPeer = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertPeeringGroupPeerGetResponseToPlumbing(porcelain *PeeringGroupPeerGetResponse) *proto.PeeringGroupPeerGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.PeeringGroupPeerGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.PeeringGroupPeer = convertPeeringGroupPeerToPlumbing(porcelain.PeeringGroupPeer)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedPeeringGroupPeerGetResponseToPlumbing(
	porcelains []*PeeringGroupPeerGetResponse,
) []*proto.PeeringGroupPeerGetResponse {
	var items []*proto.PeeringGroupPeerGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertPeeringGroupPeerGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPeeringGroupPeerGetResponseToPorcelain(plumbings []*proto.PeeringGroupPeerGetResponse) (
	[]*PeeringGroupPeerGetResponse,
	error,
) {
	var items []*PeeringGroupPeerGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertPeeringGroupPeerGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPeeringGroupResourceToPorcelain(plumbing *proto.PeeringGroupResource) (*PeeringGroupResource, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &PeeringGroupResource{}
	porcelain.GroupID = plumbing.GroupId
	porcelain.ID = plumbing.Id
	porcelain.ResourceID = plumbing.ResourceId
	return porcelain, nil
}

func convertPeeringGroupResourceToPlumbing(porcelain *PeeringGroupResource) *proto.PeeringGroupResource {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.PeeringGroupResource{}
	plumbing.GroupId = (porcelain.GroupID)
	plumbing.Id = (porcelain.ID)
	plumbing.ResourceId = (porcelain.ResourceID)
	return plumbing
}
func convertRepeatedPeeringGroupResourceToPlumbing(
	porcelains []*PeeringGroupResource,
) []*proto.PeeringGroupResource {
	var items []*proto.PeeringGroupResource
	for _, porcelain := range porcelains {
		items = append(items, convertPeeringGroupResourceToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPeeringGroupResourceToPorcelain(plumbings []*proto.PeeringGroupResource) (
	[]*PeeringGroupResource,
	error,
) {
	var items []*PeeringGroupResource
	for _, plumbing := range plumbings {
		if v, err := convertPeeringGroupResourceToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPeeringGroupResourceCreateResponseToPorcelain(plumbing *proto.PeeringGroupResourceCreateResponse) (*PeeringGroupResourceCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &PeeringGroupResourceCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertPeeringGroupResourceToPorcelain(plumbing.PeeringGroupResource); err != nil {
		return nil, fmt.Errorf("error converting field PeeringGroupResource: %v", err)
	} else {
		porcelain.PeeringGroupResource = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertPeeringGroupResourceCreateResponseToPlumbing(porcelain *PeeringGroupResourceCreateResponse) *proto.PeeringGroupResourceCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.PeeringGroupResourceCreateResponse{}
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.PeeringGroupResource = convertPeeringGroupResourceToPlumbing(porcelain.PeeringGroupResource)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedPeeringGroupResourceCreateResponseToPlumbing(
	porcelains []*PeeringGroupResourceCreateResponse,
) []*proto.PeeringGroupResourceCreateResponse {
	var items []*proto.PeeringGroupResourceCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertPeeringGroupResourceCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPeeringGroupResourceCreateResponseToPorcelain(plumbings []*proto.PeeringGroupResourceCreateResponse) (
	[]*PeeringGroupResourceCreateResponse,
	error,
) {
	var items []*PeeringGroupResourceCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertPeeringGroupResourceCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPeeringGroupResourceDeleteResponseToPorcelain(plumbing *proto.PeeringGroupResourceDeleteResponse) (*PeeringGroupResourceDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &PeeringGroupResourceDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertPeeringGroupResourceDeleteResponseToPlumbing(porcelain *PeeringGroupResourceDeleteResponse) *proto.PeeringGroupResourceDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.PeeringGroupResourceDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedPeeringGroupResourceDeleteResponseToPlumbing(
	porcelains []*PeeringGroupResourceDeleteResponse,
) []*proto.PeeringGroupResourceDeleteResponse {
	var items []*proto.PeeringGroupResourceDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertPeeringGroupResourceDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPeeringGroupResourceDeleteResponseToPorcelain(plumbings []*proto.PeeringGroupResourceDeleteResponse) (
	[]*PeeringGroupResourceDeleteResponse,
	error,
) {
	var items []*PeeringGroupResourceDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertPeeringGroupResourceDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPeeringGroupResourceGetResponseToPorcelain(plumbing *proto.PeeringGroupResourceGetResponse) (*PeeringGroupResourceGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &PeeringGroupResourceGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertPeeringGroupResourceToPorcelain(plumbing.PeeringGroupResource); err != nil {
		return nil, fmt.Errorf("error converting field PeeringGroupResource: %v", err)
	} else {
		porcelain.PeeringGroupResource = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertPeeringGroupResourceGetResponseToPlumbing(porcelain *PeeringGroupResourceGetResponse) *proto.PeeringGroupResourceGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.PeeringGroupResourceGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.PeeringGroupResource = convertPeeringGroupResourceToPlumbing(porcelain.PeeringGroupResource)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedPeeringGroupResourceGetResponseToPlumbing(
	porcelains []*PeeringGroupResourceGetResponse,
) []*proto.PeeringGroupResourceGetResponse {
	var items []*proto.PeeringGroupResourceGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertPeeringGroupResourceGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPeeringGroupResourceGetResponseToPorcelain(plumbings []*proto.PeeringGroupResourceGetResponse) (
	[]*PeeringGroupResourceGetResponse,
	error,
) {
	var items []*PeeringGroupResourceGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertPeeringGroupResourceGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPolicyToPorcelain(plumbing *proto.Policy) (*Policy, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Policy{}
	porcelain.Description = plumbing.Description
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Policy = plumbing.Policy
	return porcelain, nil
}

func convertPolicyToPlumbing(porcelain *Policy) *proto.Policy {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Policy{}
	plumbing.Description = (porcelain.Description)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Policy = (porcelain.Policy)
	return plumbing
}
func convertRepeatedPolicyToPlumbing(
	porcelains []*Policy,
) []*proto.Policy {
	var items []*proto.Policy
	for _, porcelain := range porcelains {
		items = append(items, convertPolicyToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPolicyToPorcelain(plumbings []*proto.Policy) (
	[]*Policy,
	error,
) {
	var items []*Policy
	for _, plumbing := range plumbings {
		if v, err := convertPolicyToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPolicyCreateResponseToPorcelain(plumbing *proto.PolicyCreateResponse) (*PolicyCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &PolicyCreateResponse{}
	if v, err := convertPolicyToPorcelain(plumbing.Policy); err != nil {
		return nil, fmt.Errorf("error converting field Policy: %v", err)
	} else {
		porcelain.Policy = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertPolicyCreateResponseToPlumbing(porcelain *PolicyCreateResponse) *proto.PolicyCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.PolicyCreateResponse{}
	plumbing.Policy = convertPolicyToPlumbing(porcelain.Policy)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedPolicyCreateResponseToPlumbing(
	porcelains []*PolicyCreateResponse,
) []*proto.PolicyCreateResponse {
	var items []*proto.PolicyCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertPolicyCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPolicyCreateResponseToPorcelain(plumbings []*proto.PolicyCreateResponse) (
	[]*PolicyCreateResponse,
	error,
) {
	var items []*PolicyCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertPolicyCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPolicyDeleteResponseToPorcelain(plumbing *proto.PolicyDeleteResponse) (*PolicyDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &PolicyDeleteResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertPolicyDeleteResponseToPlumbing(porcelain *PolicyDeleteResponse) *proto.PolicyDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.PolicyDeleteResponse{}
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedPolicyDeleteResponseToPlumbing(
	porcelains []*PolicyDeleteResponse,
) []*proto.PolicyDeleteResponse {
	var items []*proto.PolicyDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertPolicyDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPolicyDeleteResponseToPorcelain(plumbings []*proto.PolicyDeleteResponse) (
	[]*PolicyDeleteResponse,
	error,
) {
	var items []*PolicyDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertPolicyDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPolicyGetResponseToPorcelain(plumbing *proto.PolicyGetResponse) (*PolicyGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &PolicyGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertPolicyToPorcelain(plumbing.Policy); err != nil {
		return nil, fmt.Errorf("error converting field Policy: %v", err)
	} else {
		porcelain.Policy = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertPolicyGetResponseToPlumbing(porcelain *PolicyGetResponse) *proto.PolicyGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.PolicyGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.Policy = convertPolicyToPlumbing(porcelain.Policy)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedPolicyGetResponseToPlumbing(
	porcelains []*PolicyGetResponse,
) []*proto.PolicyGetResponse {
	var items []*proto.PolicyGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertPolicyGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPolicyGetResponseToPorcelain(plumbings []*proto.PolicyGetResponse) (
	[]*PolicyGetResponse,
	error,
) {
	var items []*PolicyGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertPolicyGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPolicyHistoryToPorcelain(plumbing *proto.PolicyHistory) (*PolicyHistory, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &PolicyHistory{}
	porcelain.ActivityID = plumbing.ActivityId
	if v, err := convertTimestampToPorcelain(plumbing.DeletedAt); err != nil {
		return nil, fmt.Errorf("error converting field DeletedAt: %v", err)
	} else {
		porcelain.DeletedAt = v
	}
	if v, err := convertPolicyToPorcelain(plumbing.Policy); err != nil {
		return nil, fmt.Errorf("error converting field Policy: %v", err)
	} else {
		porcelain.Policy = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	return porcelain, nil
}

func convertPolicyHistoryToPlumbing(porcelain *PolicyHistory) *proto.PolicyHistory {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.PolicyHistory{}
	plumbing.ActivityId = (porcelain.ActivityID)
	plumbing.DeletedAt = convertTimestampToPlumbing(porcelain.DeletedAt)
	plumbing.Policy = convertPolicyToPlumbing(porcelain.Policy)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	return plumbing
}
func convertRepeatedPolicyHistoryToPlumbing(
	porcelains []*PolicyHistory,
) []*proto.PolicyHistory {
	var items []*proto.PolicyHistory
	for _, porcelain := range porcelains {
		items = append(items, convertPolicyHistoryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPolicyHistoryToPorcelain(plumbings []*proto.PolicyHistory) (
	[]*PolicyHistory,
	error,
) {
	var items []*PolicyHistory
	for _, plumbing := range plumbings {
		if v, err := convertPolicyHistoryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPolicyListResponseToPorcelain(plumbing *proto.PolicyListResponse) (*PolicyListResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &PolicyListResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertPolicyListResponseToPlumbing(porcelain *PolicyListResponse) *proto.PolicyListResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.PolicyListResponse{}
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedPolicyListResponseToPlumbing(
	porcelains []*PolicyListResponse,
) []*proto.PolicyListResponse {
	var items []*proto.PolicyListResponse
	for _, porcelain := range porcelains {
		items = append(items, convertPolicyListResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPolicyListResponseToPorcelain(plumbings []*proto.PolicyListResponse) (
	[]*PolicyListResponse,
	error,
) {
	var items []*PolicyListResponse
	for _, plumbing := range plumbings {
		if v, err := convertPolicyListResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPolicyUpdateResponseToPorcelain(plumbing *proto.PolicyUpdateResponse) (*PolicyUpdateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &PolicyUpdateResponse{}
	if v, err := convertPolicyToPorcelain(plumbing.Policy); err != nil {
		return nil, fmt.Errorf("error converting field Policy: %v", err)
	} else {
		porcelain.Policy = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertPolicyUpdateResponseToPlumbing(porcelain *PolicyUpdateResponse) *proto.PolicyUpdateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.PolicyUpdateResponse{}
	plumbing.Policy = convertPolicyToPlumbing(porcelain.Policy)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedPolicyUpdateResponseToPlumbing(
	porcelains []*PolicyUpdateResponse,
) []*proto.PolicyUpdateResponse {
	var items []*proto.PolicyUpdateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertPolicyUpdateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPolicyUpdateResponseToPorcelain(plumbings []*proto.PolicyUpdateResponse) (
	[]*PolicyUpdateResponse,
	error,
) {
	var items []*PolicyUpdateResponse
	for _, plumbing := range plumbings {
		if v, err := convertPolicyUpdateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPostgresToPorcelain(plumbing *proto.Postgres) (*Postgres, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Postgres{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.OverrideDatabase = plumbing.OverrideDatabase
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertPostgresToPlumbing(porcelain *Postgres) *proto.Postgres {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Postgres{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedPostgresToPlumbing(
	porcelains []*Postgres,
) []*proto.Postgres {
	var items []*proto.Postgres
	for _, porcelain := range porcelains {
		items = append(items, convertPostgresToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPostgresToPorcelain(plumbings []*proto.Postgres) (
	[]*Postgres,
	error,
) {
	var items []*Postgres
	for _, plumbing := range plumbings {
		if v, err := convertPostgresToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertPrestoToPorcelain(plumbing *proto.Presto) (*Presto, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Presto{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertPrestoToPlumbing(porcelain *Presto) *proto.Presto {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Presto{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedPrestoToPlumbing(
	porcelains []*Presto,
) []*proto.Presto {
	var items []*proto.Presto
	for _, porcelain := range porcelains {
		items = append(items, convertPrestoToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedPrestoToPorcelain(plumbings []*proto.Presto) (
	[]*Presto,
	error,
) {
	var items []*Presto
	for _, plumbing := range plumbings {
		if v, err := convertPrestoToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertProxyClusterToPorcelain(plumbing *proto.ProxyCluster) (*ProxyCluster, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ProxyCluster{}
	porcelain.Address = plumbing.Address
	porcelain.ID = plumbing.Id
	if v, err := convertRepeatedNodeMaintenanceWindowToPorcelain(plumbing.MaintenanceWindows); err != nil {
		return nil, fmt.Errorf("error converting field MaintenanceWindows: %v", err)
	} else {
		porcelain.MaintenanceWindows = v
	}
	porcelain.Name = plumbing.Name
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertProxyClusterToPlumbing(porcelain *ProxyCluster) *proto.ProxyCluster {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ProxyCluster{}
	plumbing.Address = (porcelain.Address)
	plumbing.Id = (porcelain.ID)
	plumbing.MaintenanceWindows = convertRepeatedNodeMaintenanceWindowToPlumbing(porcelain.MaintenanceWindows)
	plumbing.Name = (porcelain.Name)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedProxyClusterToPlumbing(
	porcelains []*ProxyCluster,
) []*proto.ProxyCluster {
	var items []*proto.ProxyCluster
	for _, porcelain := range porcelains {
		items = append(items, convertProxyClusterToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedProxyClusterToPorcelain(plumbings []*proto.ProxyCluster) (
	[]*ProxyCluster,
	error,
) {
	var items []*ProxyCluster
	for _, plumbing := range plumbings {
		if v, err := convertProxyClusterToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertProxyClusterKeyToPorcelain(plumbing *proto.ProxyClusterKey) (*ProxyClusterKey, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ProxyClusterKey{}
	if v, err := convertTimestampToPorcelain(plumbing.CreatedAt); err != nil {
		return nil, fmt.Errorf("error converting field CreatedAt: %v", err)
	} else {
		porcelain.CreatedAt = v
	}
	porcelain.ID = plumbing.Id
	if v, err := convertTimestampToPorcelain(plumbing.LastUsedAt); err != nil {
		return nil, fmt.Errorf("error converting field LastUsedAt: %v", err)
	} else {
		porcelain.LastUsedAt = v
	}
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	return porcelain, nil
}

func convertProxyClusterKeyToPlumbing(porcelain *ProxyClusterKey) *proto.ProxyClusterKey {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ProxyClusterKey{}
	plumbing.CreatedAt = convertTimestampToPlumbing(porcelain.CreatedAt)
	plumbing.Id = (porcelain.ID)
	plumbing.LastUsedAt = convertTimestampToPlumbing(porcelain.LastUsedAt)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	return plumbing
}
func convertRepeatedProxyClusterKeyToPlumbing(
	porcelains []*ProxyClusterKey,
) []*proto.ProxyClusterKey {
	var items []*proto.ProxyClusterKey
	for _, porcelain := range porcelains {
		items = append(items, convertProxyClusterKeyToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedProxyClusterKeyToPorcelain(plumbings []*proto.ProxyClusterKey) (
	[]*ProxyClusterKey,
	error,
) {
	var items []*ProxyClusterKey
	for _, plumbing := range plumbings {
		if v, err := convertProxyClusterKeyToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertProxyClusterKeyCreateResponseToPorcelain(plumbing *proto.ProxyClusterKeyCreateResponse) (*ProxyClusterKeyCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ProxyClusterKeyCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertProxyClusterKeyToPorcelain(plumbing.ProxyClusterKey); err != nil {
		return nil, fmt.Errorf("error converting field ProxyClusterKey: %v", err)
	} else {
		porcelain.ProxyClusterKey = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	porcelain.SecretKey = plumbing.SecretKey
	return porcelain, nil
}

func convertProxyClusterKeyCreateResponseToPlumbing(porcelain *ProxyClusterKeyCreateResponse) *proto.ProxyClusterKeyCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ProxyClusterKeyCreateResponse{}
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.ProxyClusterKey = convertProxyClusterKeyToPlumbing(porcelain.ProxyClusterKey)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.SecretKey = (porcelain.SecretKey)
	return plumbing
}
func convertRepeatedProxyClusterKeyCreateResponseToPlumbing(
	porcelains []*ProxyClusterKeyCreateResponse,
) []*proto.ProxyClusterKeyCreateResponse {
	var items []*proto.ProxyClusterKeyCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertProxyClusterKeyCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedProxyClusterKeyCreateResponseToPorcelain(plumbings []*proto.ProxyClusterKeyCreateResponse) (
	[]*ProxyClusterKeyCreateResponse,
	error,
) {
	var items []*ProxyClusterKeyCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertProxyClusterKeyCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertProxyClusterKeyDeleteResponseToPorcelain(plumbing *proto.ProxyClusterKeyDeleteResponse) (*ProxyClusterKeyDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ProxyClusterKeyDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertProxyClusterKeyDeleteResponseToPlumbing(porcelain *ProxyClusterKeyDeleteResponse) *proto.ProxyClusterKeyDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ProxyClusterKeyDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedProxyClusterKeyDeleteResponseToPlumbing(
	porcelains []*ProxyClusterKeyDeleteResponse,
) []*proto.ProxyClusterKeyDeleteResponse {
	var items []*proto.ProxyClusterKeyDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertProxyClusterKeyDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedProxyClusterKeyDeleteResponseToPorcelain(plumbings []*proto.ProxyClusterKeyDeleteResponse) (
	[]*ProxyClusterKeyDeleteResponse,
	error,
) {
	var items []*ProxyClusterKeyDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertProxyClusterKeyDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertProxyClusterKeyGetResponseToPorcelain(plumbing *proto.ProxyClusterKeyGetResponse) (*ProxyClusterKeyGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ProxyClusterKeyGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertProxyClusterKeyToPorcelain(plumbing.ProxyClusterKey); err != nil {
		return nil, fmt.Errorf("error converting field ProxyClusterKey: %v", err)
	} else {
		porcelain.ProxyClusterKey = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertProxyClusterKeyGetResponseToPlumbing(porcelain *ProxyClusterKeyGetResponse) *proto.ProxyClusterKeyGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ProxyClusterKeyGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.ProxyClusterKey = convertProxyClusterKeyToPlumbing(porcelain.ProxyClusterKey)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedProxyClusterKeyGetResponseToPlumbing(
	porcelains []*ProxyClusterKeyGetResponse,
) []*proto.ProxyClusterKeyGetResponse {
	var items []*proto.ProxyClusterKeyGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertProxyClusterKeyGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedProxyClusterKeyGetResponseToPorcelain(plumbings []*proto.ProxyClusterKeyGetResponse) (
	[]*ProxyClusterKeyGetResponse,
	error,
) {
	var items []*ProxyClusterKeyGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertProxyClusterKeyGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertQueryToPorcelain(plumbing *proto.Query) (*Query, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Query{}
	porcelain.AccountEmail = plumbing.AccountEmail
	porcelain.AccountFirstName = plumbing.AccountFirstName
	porcelain.AccountID = plumbing.AccountId
	porcelain.AccountLastName = plumbing.AccountLastName
	if v, err := convertTagsToPorcelain(plumbing.AccountTags); err != nil {
		return nil, fmt.Errorf("error converting field AccountTags: %v", err)
	} else {
		porcelain.AccountTags = v
	}
	porcelain.AuthzJSON = plumbing.AuthzJson
	if v, err := convertQueryCaptureToPorcelain(plumbing.Capture); err != nil {
		return nil, fmt.Errorf("error converting field Capture: %v", err)
	} else {
		porcelain.Capture = v
	}
	porcelain.ClientIP = plumbing.ClientIp
	if v, err := convertTimestampToPorcelain(plumbing.CompletedAt); err != nil {
		return nil, fmt.Errorf("error converting field CompletedAt: %v", err)
	} else {
		porcelain.CompletedAt = v
	}
	if v, err := convertDurationToPorcelain(plumbing.Duration); err != nil {
		return nil, fmt.Errorf("error converting field Duration: %v", err)
	} else {
		porcelain.Duration = v
	}
	porcelain.EgressNodeID = plumbing.EgressNodeId
	porcelain.Encrypted = plumbing.Encrypted
	porcelain.ID = plumbing.Id
	porcelain.IdentityAliasUsername = plumbing.IdentityAliasUsername
	porcelain.QueryBody = plumbing.QueryBody
	porcelain.QueryCategory = plumbing.QueryCategory
	porcelain.QueryHash = plumbing.QueryHash
	porcelain.QueryKey = plumbing.QueryKey
	porcelain.RecordCount = plumbing.RecordCount
	porcelain.RemoteIdentityUsername = plumbing.RemoteIdentityUsername
	porcelain.Replayable = plumbing.Replayable
	porcelain.ResourceID = plumbing.ResourceId
	porcelain.ResourceName = plumbing.ResourceName
	if v, err := convertTagsToPorcelain(plumbing.ResourceTags); err != nil {
		return nil, fmt.Errorf("error converting field ResourceTags: %v", err)
	} else {
		porcelain.ResourceTags = v
	}
	porcelain.ResourceType = plumbing.ResourceType
	porcelain.SourceIP = plumbing.SourceIp
	porcelain.Target = plumbing.Target
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	return porcelain, nil
}

func convertQueryToPlumbing(porcelain *Query) *proto.Query {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Query{}
	plumbing.AccountEmail = (porcelain.AccountEmail)
	plumbing.AccountFirstName = (porcelain.AccountFirstName)
	plumbing.AccountId = (porcelain.AccountID)
	plumbing.AccountLastName = (porcelain.AccountLastName)
	plumbing.AccountTags = convertTagsToPlumbing(porcelain.AccountTags)
	plumbing.AuthzJson = (porcelain.AuthzJSON)
	plumbing.Capture = convertQueryCaptureToPlumbing(porcelain.Capture)
	plumbing.ClientIp = (porcelain.ClientIP)
	plumbing.CompletedAt = convertTimestampToPlumbing(porcelain.CompletedAt)
	plumbing.Duration = convertDurationToPlumbing(porcelain.Duration)
	plumbing.EgressNodeId = (porcelain.EgressNodeID)
	plumbing.Encrypted = (porcelain.Encrypted)
	plumbing.Id = (porcelain.ID)
	plumbing.IdentityAliasUsername = (porcelain.IdentityAliasUsername)
	plumbing.QueryBody = (porcelain.QueryBody)
	plumbing.QueryCategory = (porcelain.QueryCategory)
	plumbing.QueryHash = (porcelain.QueryHash)
	plumbing.QueryKey = (porcelain.QueryKey)
	plumbing.RecordCount = (porcelain.RecordCount)
	plumbing.RemoteIdentityUsername = (porcelain.RemoteIdentityUsername)
	plumbing.Replayable = (porcelain.Replayable)
	plumbing.ResourceId = (porcelain.ResourceID)
	plumbing.ResourceName = (porcelain.ResourceName)
	plumbing.ResourceTags = convertTagsToPlumbing(porcelain.ResourceTags)
	plumbing.ResourceType = (porcelain.ResourceType)
	plumbing.SourceIp = (porcelain.SourceIP)
	plumbing.Target = (porcelain.Target)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	return plumbing
}
func convertRepeatedQueryToPlumbing(
	porcelains []*Query,
) []*proto.Query {
	var items []*proto.Query
	for _, porcelain := range porcelains {
		items = append(items, convertQueryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedQueryToPorcelain(plumbings []*proto.Query) (
	[]*Query,
	error,
) {
	var items []*Query
	for _, plumbing := range plumbings {
		if v, err := convertQueryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertQueryCaptureToPorcelain(plumbing *proto.QueryCapture) (*QueryCapture, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &QueryCapture{}
	porcelain.ClientCommand = plumbing.ClientCommand
	porcelain.Command = plumbing.Command
	porcelain.Container = plumbing.Container
	porcelain.Env = plumbing.Env
	porcelain.FileName = plumbing.FileName
	porcelain.FileSize = plumbing.FileSize
	porcelain.Height = plumbing.Height
	porcelain.ImpersonationGroups = plumbing.ImpersonationGroups
	porcelain.ImpersonationUser = plumbing.ImpersonationUser
	porcelain.Pod = plumbing.Pod
	porcelain.PrivilegeGroups = plumbing.PrivilegeGroups
	porcelain.RequestBody = plumbing.RequestBody
	porcelain.RequestMethod = plumbing.RequestMethod
	porcelain.RequestURI = plumbing.RequestUri
	porcelain.Type = plumbing.Type
	porcelain.Width = plumbing.Width
	return porcelain, nil
}

func convertQueryCaptureToPlumbing(porcelain *QueryCapture) *proto.QueryCapture {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.QueryCapture{}
	plumbing.ClientCommand = (porcelain.ClientCommand)
	plumbing.Command = (porcelain.Command)
	plumbing.Container = (porcelain.Container)
	plumbing.Env = (porcelain.Env)
	plumbing.FileName = (porcelain.FileName)
	plumbing.FileSize = (porcelain.FileSize)
	plumbing.Height = (porcelain.Height)
	plumbing.ImpersonationGroups = (porcelain.ImpersonationGroups)
	plumbing.ImpersonationUser = (porcelain.ImpersonationUser)
	plumbing.Pod = (porcelain.Pod)
	plumbing.PrivilegeGroups = (porcelain.PrivilegeGroups)
	plumbing.RequestBody = (porcelain.RequestBody)
	plumbing.RequestMethod = (porcelain.RequestMethod)
	plumbing.RequestUri = (porcelain.RequestURI)
	plumbing.Type = (porcelain.Type)
	plumbing.Width = (porcelain.Width)
	return plumbing
}
func convertRepeatedQueryCaptureToPlumbing(
	porcelains []*QueryCapture,
) []*proto.QueryCapture {
	var items []*proto.QueryCapture
	for _, porcelain := range porcelains {
		items = append(items, convertQueryCaptureToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedQueryCaptureToPorcelain(plumbings []*proto.QueryCapture) (
	[]*QueryCapture,
	error,
) {
	var items []*QueryCapture
	for _, plumbing := range plumbings {
		if v, err := convertQueryCaptureToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRDPToPorcelain(plumbing *proto.RDP) (*RDP, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RDP{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.DowngradeNlaConnections = plumbing.DowngradeNlaConnections
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.LockRequired = plumbing.LockRequired
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertRDPToPlumbing(porcelain *RDP) *proto.RDP {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RDP{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.DowngradeNlaConnections = (porcelain.DowngradeNlaConnections)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.LockRequired = (porcelain.LockRequired)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedRDPToPlumbing(
	porcelains []*RDP,
) []*proto.RDP {
	var items []*proto.RDP
	for _, porcelain := range porcelains {
		items = append(items, convertRDPToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRDPToPorcelain(plumbings []*proto.RDP) (
	[]*RDP,
	error,
) {
	var items []*RDP
	for _, plumbing := range plumbings {
		if v, err := convertRDPToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRDPCertToPorcelain(plumbing *proto.RDPCert) (*RDPCert, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RDPCert{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.IdentityAliasHealthcheckUsername = plumbing.IdentityAliasHealthcheckUsername
	porcelain.IdentitySetID = plumbing.IdentitySetId
	porcelain.LockRequired = plumbing.LockRequired
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertRDPCertToPlumbing(porcelain *RDPCert) *proto.RDPCert {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RDPCert{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.IdentityAliasHealthcheckUsername = (porcelain.IdentityAliasHealthcheckUsername)
	plumbing.IdentitySetId = (porcelain.IdentitySetID)
	plumbing.LockRequired = (porcelain.LockRequired)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedRDPCertToPlumbing(
	porcelains []*RDPCert,
) []*proto.RDPCert {
	var items []*proto.RDPCert
	for _, porcelain := range porcelains {
		items = append(items, convertRDPCertToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRDPCertToPorcelain(plumbings []*proto.RDPCert) (
	[]*RDPCert,
	error,
) {
	var items []*RDPCert
	for _, plumbing := range plumbings {
		if v, err := convertRDPCertToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRDSPostgresIAMToPorcelain(plumbing *proto.RDSPostgresIAM) (*RDSPostgresIAM, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RDSPostgresIAM{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.OverrideDatabase = plumbing.OverrideDatabase
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.Region = plumbing.Region
	porcelain.RoleAssumptionArn = plumbing.RoleAssumptionArn
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertRDSPostgresIAMToPlumbing(porcelain *RDSPostgresIAM) *proto.RDSPostgresIAM {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RDSPostgresIAM{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.Region = (porcelain.Region)
	plumbing.RoleAssumptionArn = (porcelain.RoleAssumptionArn)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedRDSPostgresIAMToPlumbing(
	porcelains []*RDSPostgresIAM,
) []*proto.RDSPostgresIAM {
	var items []*proto.RDSPostgresIAM
	for _, porcelain := range porcelains {
		items = append(items, convertRDSPostgresIAMToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRDSPostgresIAMToPorcelain(plumbings []*proto.RDSPostgresIAM) (
	[]*RDSPostgresIAM,
	error,
) {
	var items []*RDSPostgresIAM
	for _, plumbing := range plumbings {
		if v, err := convertRDSPostgresIAMToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRabbitMQAMQP091ToPorcelain(plumbing *proto.RabbitMQAMQP091) (*RabbitMQAMQP091, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RabbitMQAMQP091{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertRabbitMQAMQP091ToPlumbing(porcelain *RabbitMQAMQP091) *proto.RabbitMQAMQP091 {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RabbitMQAMQP091{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedRabbitMQAMQP091ToPlumbing(
	porcelains []*RabbitMQAMQP091,
) []*proto.RabbitMQAMQP091 {
	var items []*proto.RabbitMQAMQP091
	for _, porcelain := range porcelains {
		items = append(items, convertRabbitMQAMQP091ToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRabbitMQAMQP091ToPorcelain(plumbings []*proto.RabbitMQAMQP091) (
	[]*RabbitMQAMQP091,
	error,
) {
	var items []*RabbitMQAMQP091
	for _, plumbing := range plumbings {
		if v, err := convertRabbitMQAMQP091ToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRateLimitMetadataToPorcelain(plumbing *proto.RateLimitMetadata) (*RateLimitMetadata, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RateLimitMetadata{}
	porcelain.Bucket = plumbing.Bucket
	porcelain.Limit = plumbing.Limit
	porcelain.Remaining = plumbing.Remaining
	if v, err := convertTimestampToPorcelain(plumbing.ResetAt); err != nil {
		return nil, fmt.Errorf("error converting field ResetAt: %v", err)
	} else {
		porcelain.ResetAt = v
	}
	return porcelain, nil
}

func convertRateLimitMetadataToPlumbing(porcelain *RateLimitMetadata) *proto.RateLimitMetadata {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RateLimitMetadata{}
	plumbing.Bucket = (porcelain.Bucket)
	plumbing.Limit = (porcelain.Limit)
	plumbing.Remaining = (porcelain.Remaining)
	plumbing.ResetAt = convertTimestampToPlumbing(porcelain.ResetAt)
	return plumbing
}
func convertRepeatedRateLimitMetadataToPlumbing(
	porcelains []*RateLimitMetadata,
) []*proto.RateLimitMetadata {
	var items []*proto.RateLimitMetadata
	for _, porcelain := range porcelains {
		items = append(items, convertRateLimitMetadataToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRateLimitMetadataToPorcelain(plumbings []*proto.RateLimitMetadata) (
	[]*RateLimitMetadata,
	error,
) {
	var items []*RateLimitMetadata
	for _, plumbing := range plumbings {
		if v, err := convertRateLimitMetadataToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRawTCPToPorcelain(plumbing *proto.RawTCP) (*RawTCP, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RawTCP{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertRawTCPToPlumbing(porcelain *RawTCP) *proto.RawTCP {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RawTCP{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedRawTCPToPlumbing(
	porcelains []*RawTCP,
) []*proto.RawTCP {
	var items []*proto.RawTCP
	for _, porcelain := range porcelains {
		items = append(items, convertRawTCPToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRawTCPToPorcelain(plumbings []*proto.RawTCP) (
	[]*RawTCP,
	error,
) {
	var items []*RawTCP
	for _, plumbing := range plumbings {
		if v, err := convertRawTCPToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRedisToPorcelain(plumbing *proto.Redis) (*Redis, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Redis{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TlsRequired = plumbing.TlsRequired
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertRedisToPlumbing(porcelain *Redis) *proto.Redis {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Redis{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TlsRequired = (porcelain.TlsRequired)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedRedisToPlumbing(
	porcelains []*Redis,
) []*proto.Redis {
	var items []*proto.Redis
	for _, porcelain := range porcelains {
		items = append(items, convertRedisToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRedisToPorcelain(plumbings []*proto.Redis) (
	[]*Redis,
	error,
) {
	var items []*Redis
	for _, plumbing := range plumbings {
		if v, err := convertRedisToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRedshiftToPorcelain(plumbing *proto.Redshift) (*Redshift, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Redshift{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.OverrideDatabase = plumbing.OverrideDatabase
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertRedshiftToPlumbing(porcelain *Redshift) *proto.Redshift {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Redshift{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedRedshiftToPlumbing(
	porcelains []*Redshift,
) []*proto.Redshift {
	var items []*proto.Redshift
	for _, porcelain := range porcelains {
		items = append(items, convertRedshiftToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRedshiftToPorcelain(plumbings []*proto.Redshift) (
	[]*Redshift,
	error,
) {
	var items []*Redshift
	for _, plumbing := range plumbings {
		if v, err := convertRedshiftToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRelayToPorcelain(plumbing *proto.Relay) (*Relay, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Relay{}
	porcelain.Device = plumbing.Device
	porcelain.GatewayFilter = plumbing.GatewayFilter
	porcelain.ID = plumbing.Id
	porcelain.Location = plumbing.Location
	if v, err := convertRepeatedNodeMaintenanceWindowToPorcelain(plumbing.MaintenanceWindows); err != nil {
		return nil, fmt.Errorf("error converting field MaintenanceWindows: %v", err)
	} else {
		porcelain.MaintenanceWindows = v
	}
	porcelain.Name = plumbing.Name
	porcelain.State = plumbing.State
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Version = plumbing.Version
	return porcelain, nil
}

func convertRelayToPlumbing(porcelain *Relay) *proto.Relay {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Relay{}
	plumbing.Device = (porcelain.Device)
	plumbing.GatewayFilter = (porcelain.GatewayFilter)
	plumbing.Id = (porcelain.ID)
	plumbing.Location = (porcelain.Location)
	plumbing.MaintenanceWindows = convertRepeatedNodeMaintenanceWindowToPlumbing(porcelain.MaintenanceWindows)
	plumbing.Name = (porcelain.Name)
	plumbing.State = (porcelain.State)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Version = (porcelain.Version)
	return plumbing
}
func convertRepeatedRelayToPlumbing(
	porcelains []*Relay,
) []*proto.Relay {
	var items []*proto.Relay
	for _, porcelain := range porcelains {
		items = append(items, convertRelayToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRelayToPorcelain(plumbings []*proto.Relay) (
	[]*Relay,
	error,
) {
	var items []*Relay
	for _, plumbing := range plumbings {
		if v, err := convertRelayToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRemoteIdentityToPorcelain(plumbing *proto.RemoteIdentity) (*RemoteIdentity, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RemoteIdentity{}
	porcelain.AccountID = plumbing.AccountId
	porcelain.ID = plumbing.Id
	porcelain.RemoteIdentityGroupID = plumbing.RemoteIdentityGroupId
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertRemoteIdentityToPlumbing(porcelain *RemoteIdentity) *proto.RemoteIdentity {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RemoteIdentity{}
	plumbing.AccountId = (porcelain.AccountID)
	plumbing.Id = (porcelain.ID)
	plumbing.RemoteIdentityGroupId = (porcelain.RemoteIdentityGroupID)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedRemoteIdentityToPlumbing(
	porcelains []*RemoteIdentity,
) []*proto.RemoteIdentity {
	var items []*proto.RemoteIdentity
	for _, porcelain := range porcelains {
		items = append(items, convertRemoteIdentityToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRemoteIdentityToPorcelain(plumbings []*proto.RemoteIdentity) (
	[]*RemoteIdentity,
	error,
) {
	var items []*RemoteIdentity
	for _, plumbing := range plumbings {
		if v, err := convertRemoteIdentityToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRemoteIdentityCreateResponseToPorcelain(plumbing *proto.RemoteIdentityCreateResponse) (*RemoteIdentityCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RemoteIdentityCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertRemoteIdentityToPorcelain(plumbing.RemoteIdentity); err != nil {
		return nil, fmt.Errorf("error converting field RemoteIdentity: %v", err)
	} else {
		porcelain.RemoteIdentity = v
	}
	return porcelain, nil
}

func convertRemoteIdentityCreateResponseToPlumbing(porcelain *RemoteIdentityCreateResponse) *proto.RemoteIdentityCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RemoteIdentityCreateResponse{}
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.RemoteIdentity = convertRemoteIdentityToPlumbing(porcelain.RemoteIdentity)
	return plumbing
}
func convertRepeatedRemoteIdentityCreateResponseToPlumbing(
	porcelains []*RemoteIdentityCreateResponse,
) []*proto.RemoteIdentityCreateResponse {
	var items []*proto.RemoteIdentityCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRemoteIdentityCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRemoteIdentityCreateResponseToPorcelain(plumbings []*proto.RemoteIdentityCreateResponse) (
	[]*RemoteIdentityCreateResponse,
	error,
) {
	var items []*RemoteIdentityCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertRemoteIdentityCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRemoteIdentityDeleteResponseToPorcelain(plumbing *proto.RemoteIdentityDeleteResponse) (*RemoteIdentityDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RemoteIdentityDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertRemoteIdentityDeleteResponseToPlumbing(porcelain *RemoteIdentityDeleteResponse) *proto.RemoteIdentityDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RemoteIdentityDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedRemoteIdentityDeleteResponseToPlumbing(
	porcelains []*RemoteIdentityDeleteResponse,
) []*proto.RemoteIdentityDeleteResponse {
	var items []*proto.RemoteIdentityDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRemoteIdentityDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRemoteIdentityDeleteResponseToPorcelain(plumbings []*proto.RemoteIdentityDeleteResponse) (
	[]*RemoteIdentityDeleteResponse,
	error,
) {
	var items []*RemoteIdentityDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertRemoteIdentityDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRemoteIdentityGetResponseToPorcelain(plumbing *proto.RemoteIdentityGetResponse) (*RemoteIdentityGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RemoteIdentityGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertRemoteIdentityToPorcelain(plumbing.RemoteIdentity); err != nil {
		return nil, fmt.Errorf("error converting field RemoteIdentity: %v", err)
	} else {
		porcelain.RemoteIdentity = v
	}
	return porcelain, nil
}

func convertRemoteIdentityGetResponseToPlumbing(porcelain *RemoteIdentityGetResponse) *proto.RemoteIdentityGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RemoteIdentityGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.RemoteIdentity = convertRemoteIdentityToPlumbing(porcelain.RemoteIdentity)
	return plumbing
}
func convertRepeatedRemoteIdentityGetResponseToPlumbing(
	porcelains []*RemoteIdentityGetResponse,
) []*proto.RemoteIdentityGetResponse {
	var items []*proto.RemoteIdentityGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRemoteIdentityGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRemoteIdentityGetResponseToPorcelain(plumbings []*proto.RemoteIdentityGetResponse) (
	[]*RemoteIdentityGetResponse,
	error,
) {
	var items []*RemoteIdentityGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertRemoteIdentityGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRemoteIdentityGroupToPorcelain(plumbing *proto.RemoteIdentityGroup) (*RemoteIdentityGroup, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RemoteIdentityGroup{}
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	return porcelain, nil
}

func convertRemoteIdentityGroupToPlumbing(porcelain *RemoteIdentityGroup) *proto.RemoteIdentityGroup {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RemoteIdentityGroup{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	return plumbing
}
func convertRepeatedRemoteIdentityGroupToPlumbing(
	porcelains []*RemoteIdentityGroup,
) []*proto.RemoteIdentityGroup {
	var items []*proto.RemoteIdentityGroup
	for _, porcelain := range porcelains {
		items = append(items, convertRemoteIdentityGroupToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRemoteIdentityGroupToPorcelain(plumbings []*proto.RemoteIdentityGroup) (
	[]*RemoteIdentityGroup,
	error,
) {
	var items []*RemoteIdentityGroup
	for _, plumbing := range plumbings {
		if v, err := convertRemoteIdentityGroupToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRemoteIdentityGroupGetResponseToPorcelain(plumbing *proto.RemoteIdentityGroupGetResponse) (*RemoteIdentityGroupGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RemoteIdentityGroupGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertRemoteIdentityGroupToPorcelain(plumbing.RemoteIdentityGroup); err != nil {
		return nil, fmt.Errorf("error converting field RemoteIdentityGroup: %v", err)
	} else {
		porcelain.RemoteIdentityGroup = v
	}
	return porcelain, nil
}

func convertRemoteIdentityGroupGetResponseToPlumbing(porcelain *RemoteIdentityGroupGetResponse) *proto.RemoteIdentityGroupGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RemoteIdentityGroupGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.RemoteIdentityGroup = convertRemoteIdentityGroupToPlumbing(porcelain.RemoteIdentityGroup)
	return plumbing
}
func convertRepeatedRemoteIdentityGroupGetResponseToPlumbing(
	porcelains []*RemoteIdentityGroupGetResponse,
) []*proto.RemoteIdentityGroupGetResponse {
	var items []*proto.RemoteIdentityGroupGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRemoteIdentityGroupGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRemoteIdentityGroupGetResponseToPorcelain(plumbings []*proto.RemoteIdentityGroupGetResponse) (
	[]*RemoteIdentityGroupGetResponse,
	error,
) {
	var items []*RemoteIdentityGroupGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertRemoteIdentityGroupGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRemoteIdentityGroupHistoryToPorcelain(plumbing *proto.RemoteIdentityGroupHistory) (*RemoteIdentityGroupHistory, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RemoteIdentityGroupHistory{}
	porcelain.ActivityID = plumbing.ActivityId
	if v, err := convertTimestampToPorcelain(plumbing.DeletedAt); err != nil {
		return nil, fmt.Errorf("error converting field DeletedAt: %v", err)
	} else {
		porcelain.DeletedAt = v
	}
	if v, err := convertRemoteIdentityGroupToPorcelain(plumbing.RemoteIdentityGroup); err != nil {
		return nil, fmt.Errorf("error converting field RemoteIdentityGroup: %v", err)
	} else {
		porcelain.RemoteIdentityGroup = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	return porcelain, nil
}

func convertRemoteIdentityGroupHistoryToPlumbing(porcelain *RemoteIdentityGroupHistory) *proto.RemoteIdentityGroupHistory {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RemoteIdentityGroupHistory{}
	plumbing.ActivityId = (porcelain.ActivityID)
	plumbing.DeletedAt = convertTimestampToPlumbing(porcelain.DeletedAt)
	plumbing.RemoteIdentityGroup = convertRemoteIdentityGroupToPlumbing(porcelain.RemoteIdentityGroup)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	return plumbing
}
func convertRepeatedRemoteIdentityGroupHistoryToPlumbing(
	porcelains []*RemoteIdentityGroupHistory,
) []*proto.RemoteIdentityGroupHistory {
	var items []*proto.RemoteIdentityGroupHistory
	for _, porcelain := range porcelains {
		items = append(items, convertRemoteIdentityGroupHistoryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRemoteIdentityGroupHistoryToPorcelain(plumbings []*proto.RemoteIdentityGroupHistory) (
	[]*RemoteIdentityGroupHistory,
	error,
) {
	var items []*RemoteIdentityGroupHistory
	for _, plumbing := range plumbings {
		if v, err := convertRemoteIdentityGroupHistoryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRemoteIdentityHistoryToPorcelain(plumbing *proto.RemoteIdentityHistory) (*RemoteIdentityHistory, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RemoteIdentityHistory{}
	porcelain.ActivityID = plumbing.ActivityId
	if v, err := convertTimestampToPorcelain(plumbing.DeletedAt); err != nil {
		return nil, fmt.Errorf("error converting field DeletedAt: %v", err)
	} else {
		porcelain.DeletedAt = v
	}
	if v, err := convertRemoteIdentityToPorcelain(plumbing.RemoteIdentity); err != nil {
		return nil, fmt.Errorf("error converting field RemoteIdentity: %v", err)
	} else {
		porcelain.RemoteIdentity = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	return porcelain, nil
}

func convertRemoteIdentityHistoryToPlumbing(porcelain *RemoteIdentityHistory) *proto.RemoteIdentityHistory {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RemoteIdentityHistory{}
	plumbing.ActivityId = (porcelain.ActivityID)
	plumbing.DeletedAt = convertTimestampToPlumbing(porcelain.DeletedAt)
	plumbing.RemoteIdentity = convertRemoteIdentityToPlumbing(porcelain.RemoteIdentity)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	return plumbing
}
func convertRepeatedRemoteIdentityHistoryToPlumbing(
	porcelains []*RemoteIdentityHistory,
) []*proto.RemoteIdentityHistory {
	var items []*proto.RemoteIdentityHistory
	for _, porcelain := range porcelains {
		items = append(items, convertRemoteIdentityHistoryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRemoteIdentityHistoryToPorcelain(plumbings []*proto.RemoteIdentityHistory) (
	[]*RemoteIdentityHistory,
	error,
) {
	var items []*RemoteIdentityHistory
	for _, plumbing := range plumbings {
		if v, err := convertRemoteIdentityHistoryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRemoteIdentityUpdateResponseToPorcelain(plumbing *proto.RemoteIdentityUpdateResponse) (*RemoteIdentityUpdateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RemoteIdentityUpdateResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertRemoteIdentityToPorcelain(plumbing.RemoteIdentity); err != nil {
		return nil, fmt.Errorf("error converting field RemoteIdentity: %v", err)
	} else {
		porcelain.RemoteIdentity = v
	}
	return porcelain, nil
}

func convertRemoteIdentityUpdateResponseToPlumbing(porcelain *RemoteIdentityUpdateResponse) *proto.RemoteIdentityUpdateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RemoteIdentityUpdateResponse{}
	plumbing.Meta = convertUpdateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.RemoteIdentity = convertRemoteIdentityToPlumbing(porcelain.RemoteIdentity)
	return plumbing
}
func convertRepeatedRemoteIdentityUpdateResponseToPlumbing(
	porcelains []*RemoteIdentityUpdateResponse,
) []*proto.RemoteIdentityUpdateResponse {
	var items []*proto.RemoteIdentityUpdateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRemoteIdentityUpdateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRemoteIdentityUpdateResponseToPorcelain(plumbings []*proto.RemoteIdentityUpdateResponse) (
	[]*RemoteIdentityUpdateResponse,
	error,
) {
	var items []*RemoteIdentityUpdateResponse
	for _, plumbing := range plumbings {
		if v, err := convertRemoteIdentityUpdateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertReplayChunkToPorcelain(plumbing *proto.ReplayChunk) (*ReplayChunk, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ReplayChunk{}
	porcelain.Data = plumbing.Data
	if v, err := convertRepeatedReplayChunkEventToPorcelain(plumbing.Events); err != nil {
		return nil, fmt.Errorf("error converting field Events: %v", err)
	} else {
		porcelain.Events = v
	}
	porcelain.SymmetricKey = plumbing.SymmetricKey
	return porcelain, nil
}

func convertReplayChunkToPlumbing(porcelain *ReplayChunk) *proto.ReplayChunk {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ReplayChunk{}
	plumbing.Data = (porcelain.Data)
	plumbing.Events = convertRepeatedReplayChunkEventToPlumbing(porcelain.Events)
	plumbing.SymmetricKey = (porcelain.SymmetricKey)
	return plumbing
}
func convertRepeatedReplayChunkToPlumbing(
	porcelains []*ReplayChunk,
) []*proto.ReplayChunk {
	var items []*proto.ReplayChunk
	for _, porcelain := range porcelains {
		items = append(items, convertReplayChunkToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedReplayChunkToPorcelain(plumbings []*proto.ReplayChunk) (
	[]*ReplayChunk,
	error,
) {
	var items []*ReplayChunk
	for _, plumbing := range plumbings {
		if v, err := convertReplayChunkToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertReplayChunkEventToPorcelain(plumbing *proto.ReplayChunkEvent) (*ReplayChunkEvent, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ReplayChunkEvent{}
	porcelain.Data = plumbing.Data
	if v, err := convertDurationToPorcelain(plumbing.Duration); err != nil {
		return nil, fmt.Errorf("error converting field Duration: %v", err)
	} else {
		porcelain.Duration = v
	}
	return porcelain, nil
}

func convertReplayChunkEventToPlumbing(porcelain *ReplayChunkEvent) *proto.ReplayChunkEvent {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ReplayChunkEvent{}
	plumbing.Data = (porcelain.Data)
	plumbing.Duration = convertDurationToPlumbing(porcelain.Duration)
	return plumbing
}
func convertRepeatedReplayChunkEventToPlumbing(
	porcelains []*ReplayChunkEvent,
) []*proto.ReplayChunkEvent {
	var items []*proto.ReplayChunkEvent
	for _, porcelain := range porcelains {
		items = append(items, convertReplayChunkEventToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedReplayChunkEventToPorcelain(plumbings []*proto.ReplayChunkEvent) (
	[]*ReplayChunkEvent,
	error,
) {
	var items []*ReplayChunkEvent
	for _, plumbing := range plumbings {
		if v, err := convertReplayChunkEventToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRequestableResourceToPorcelain(plumbing *proto.RequestableResource) (*RequestableResource, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RequestableResource{}
	porcelain.Access = plumbing.Access
	porcelain.Authentication = plumbing.Authentication
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Type = plumbing.Type
	return porcelain, nil
}

func convertRequestableResourceToPlumbing(porcelain *RequestableResource) *proto.RequestableResource {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RequestableResource{}
	plumbing.Access = (porcelain.Access)
	plumbing.Authentication = (porcelain.Authentication)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Type = (porcelain.Type)
	return plumbing
}
func convertRepeatedRequestableResourceToPlumbing(
	porcelains []*RequestableResource,
) []*proto.RequestableResource {
	var items []*proto.RequestableResource
	for _, porcelain := range porcelains {
		items = append(items, convertRequestableResourceToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRequestableResourceToPorcelain(plumbings []*proto.RequestableResource) (
	[]*RequestableResource,
	error,
) {
	var items []*RequestableResource
	for _, plumbing := range plumbings {
		if v, err := convertRequestableResourceToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertResourceToPlumbing(porcelain Resource) *proto.Resource {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Resource{}

	switch v := porcelain.(type) {
	case *AKS:
		plumbing.Resource = &proto.Resource_Aks{Aks: convertAKSToPlumbing(v)}
	case *AKSBasicAuth:
		plumbing.Resource = &proto.Resource_AksBasicAuth{AksBasicAuth: convertAKSBasicAuthToPlumbing(v)}
	case *AKSServiceAccount:
		plumbing.Resource = &proto.Resource_AksServiceAccount{AksServiceAccount: convertAKSServiceAccountToPlumbing(v)}
	case *AKSServiceAccountUserImpersonation:
		plumbing.Resource = &proto.Resource_AksServiceAccountUserImpersonation{AksServiceAccountUserImpersonation: convertAKSServiceAccountUserImpersonationToPlumbing(v)}
	case *AKSUserImpersonation:
		plumbing.Resource = &proto.Resource_AksUserImpersonation{AksUserImpersonation: convertAKSUserImpersonationToPlumbing(v)}
	case *AmazonEKS:
		plumbing.Resource = &proto.Resource_AmazonEks{AmazonEks: convertAmazonEKSToPlumbing(v)}
	case *AmazonEKSInstanceProfile:
		plumbing.Resource = &proto.Resource_AmazonEksInstanceProfile{AmazonEksInstanceProfile: convertAmazonEKSInstanceProfileToPlumbing(v)}
	case *AmazonEKSInstanceProfileUserImpersonation:
		plumbing.Resource = &proto.Resource_AmazonEksInstanceProfileUserImpersonation{AmazonEksInstanceProfileUserImpersonation: convertAmazonEKSInstanceProfileUserImpersonationToPlumbing(v)}
	case *AmazonEKSUserImpersonation:
		plumbing.Resource = &proto.Resource_AmazonEksUserImpersonation{AmazonEksUserImpersonation: convertAmazonEKSUserImpersonationToPlumbing(v)}
	case *AmazonES:
		plumbing.Resource = &proto.Resource_AmazonEs{AmazonEs: convertAmazonESToPlumbing(v)}
	case *AmazonESIAM:
		plumbing.Resource = &proto.Resource_AmazonEsiam{AmazonEsiam: convertAmazonESIAMToPlumbing(v)}
	case *AmazonMQAMQP091:
		plumbing.Resource = &proto.Resource_AmazonMqamqp_091{AmazonMqamqp_091: convertAmazonMQAMQP091ToPlumbing(v)}
	case *Athena:
		plumbing.Resource = &proto.Resource_Athena{Athena: convertAthenaToPlumbing(v)}
	case *AthenaIAM:
		plumbing.Resource = &proto.Resource_AthenaIam{AthenaIam: convertAthenaIAMToPlumbing(v)}
	case *AuroraMysql:
		plumbing.Resource = &proto.Resource_AuroraMysql{AuroraMysql: convertAuroraMysqlToPlumbing(v)}
	case *AuroraMysqlIAM:
		plumbing.Resource = &proto.Resource_AuroraMysqlIam{AuroraMysqlIam: convertAuroraMysqlIAMToPlumbing(v)}
	case *AuroraPostgres:
		plumbing.Resource = &proto.Resource_AuroraPostgres{AuroraPostgres: convertAuroraPostgresToPlumbing(v)}
	case *AuroraPostgresIAM:
		plumbing.Resource = &proto.Resource_AuroraPostgresIam{AuroraPostgresIam: convertAuroraPostgresIAMToPlumbing(v)}
	case *AWS:
		plumbing.Resource = &proto.Resource_Aws{Aws: convertAWSToPlumbing(v)}
	case *AWSConsole:
		plumbing.Resource = &proto.Resource_AwsConsole{AwsConsole: convertAWSConsoleToPlumbing(v)}
	case *AWSConsoleStaticKeyPair:
		plumbing.Resource = &proto.Resource_AwsConsoleStaticKeyPair{AwsConsoleStaticKeyPair: convertAWSConsoleStaticKeyPairToPlumbing(v)}
	case *AWSInstanceProfile:
		plumbing.Resource = &proto.Resource_AwsInstanceProfile{AwsInstanceProfile: convertAWSInstanceProfileToPlumbing(v)}
	case *Azure:
		plumbing.Resource = &proto.Resource_Azure{Azure: convertAzureToPlumbing(v)}
	case *AzureCertificate:
		plumbing.Resource = &proto.Resource_AzureCertificate{AzureCertificate: convertAzureCertificateToPlumbing(v)}
	case *AzureMysql:
		plumbing.Resource = &proto.Resource_AzureMysql{AzureMysql: convertAzureMysqlToPlumbing(v)}
	case *AzurePostgres:
		plumbing.Resource = &proto.Resource_AzurePostgres{AzurePostgres: convertAzurePostgresToPlumbing(v)}
	case *AzurePostgresManagedIdentity:
		plumbing.Resource = &proto.Resource_AzurePostgresManagedIdentity{AzurePostgresManagedIdentity: convertAzurePostgresManagedIdentityToPlumbing(v)}
	case *BigQuery:
		plumbing.Resource = &proto.Resource_BigQuery{BigQuery: convertBigQueryToPlumbing(v)}
	case *Cassandra:
		plumbing.Resource = &proto.Resource_Cassandra{Cassandra: convertCassandraToPlumbing(v)}
	case *Citus:
		plumbing.Resource = &proto.Resource_Citus{Citus: convertCitusToPlumbing(v)}
	case *ClickHouseHTTP:
		plumbing.Resource = &proto.Resource_ClickHouseHttp{ClickHouseHttp: convertClickHouseHTTPToPlumbing(v)}
	case *ClickHouseMySQL:
		plumbing.Resource = &proto.Resource_ClickHouseMySql{ClickHouseMySql: convertClickHouseMySQLToPlumbing(v)}
	case *ClickHouseTCP:
		plumbing.Resource = &proto.Resource_ClickHouseTcp{ClickHouseTcp: convertClickHouseTCPToPlumbing(v)}
	case *Clustrix:
		plumbing.Resource = &proto.Resource_Clustrix{Clustrix: convertClustrixToPlumbing(v)}
	case *Cockroach:
		plumbing.Resource = &proto.Resource_Cockroach{Cockroach: convertCockroachToPlumbing(v)}
	case *CouchbaseDatabase:
		plumbing.Resource = &proto.Resource_CouchbaseDatabase{CouchbaseDatabase: convertCouchbaseDatabaseToPlumbing(v)}
	case *CouchbaseWebUI:
		plumbing.Resource = &proto.Resource_CouchbaseWebUi{CouchbaseWebUi: convertCouchbaseWebUIToPlumbing(v)}
	case *DB2I:
		plumbing.Resource = &proto.Resource_Db_2I{Db_2I: convertDB2IToPlumbing(v)}
	case *DB2LUW:
		plumbing.Resource = &proto.Resource_Db_2Luw{Db_2Luw: convertDB2LUWToPlumbing(v)}
	case *DocumentDBHost:
		plumbing.Resource = &proto.Resource_DocumentDbHost{DocumentDbHost: convertDocumentDBHostToPlumbing(v)}
	case *DocumentDBHostIAM:
		plumbing.Resource = &proto.Resource_DocumentDbHostIam{DocumentDbHostIam: convertDocumentDBHostIAMToPlumbing(v)}
	case *DocumentDBReplicaSet:
		plumbing.Resource = &proto.Resource_DocumentDbReplicaSet{DocumentDbReplicaSet: convertDocumentDBReplicaSetToPlumbing(v)}
	case *Druid:
		plumbing.Resource = &proto.Resource_Druid{Druid: convertDruidToPlumbing(v)}
	case *DynamoDB:
		plumbing.Resource = &proto.Resource_DynamoDb{DynamoDb: convertDynamoDBToPlumbing(v)}
	case *DynamoDBIAM:
		plumbing.Resource = &proto.Resource_DynamoDbiam{DynamoDbiam: convertDynamoDBIAMToPlumbing(v)}
	case *Elastic:
		plumbing.Resource = &proto.Resource_Elastic{Elastic: convertElasticToPlumbing(v)}
	case *ElasticacheRedis:
		plumbing.Resource = &proto.Resource_ElasticacheRedis{ElasticacheRedis: convertElasticacheRedisToPlumbing(v)}
	case *GCP:
		plumbing.Resource = &proto.Resource_Gcp{Gcp: convertGCPToPlumbing(v)}
	case *GCPConsole:
		plumbing.Resource = &proto.Resource_GcpConsole{GcpConsole: convertGCPConsoleToPlumbing(v)}
	case *GCPWIF:
		plumbing.Resource = &proto.Resource_Gcpwif{Gcpwif: convertGCPWIFToPlumbing(v)}
	case *GoogleGKE:
		plumbing.Resource = &proto.Resource_GoogleGke{GoogleGke: convertGoogleGKEToPlumbing(v)}
	case *GoogleGKEUserImpersonation:
		plumbing.Resource = &proto.Resource_GoogleGkeUserImpersonation{GoogleGkeUserImpersonation: convertGoogleGKEUserImpersonationToPlumbing(v)}
	case *Greenplum:
		plumbing.Resource = &proto.Resource_Greenplum{Greenplum: convertGreenplumToPlumbing(v)}
	case *HTTPAuth:
		plumbing.Resource = &proto.Resource_HttpAuth{HttpAuth: convertHTTPAuthToPlumbing(v)}
	case *HTTPBasicAuth:
		plumbing.Resource = &proto.Resource_HttpBasicAuth{HttpBasicAuth: convertHTTPBasicAuthToPlumbing(v)}
	case *HTTPNoAuth:
		plumbing.Resource = &proto.Resource_HttpNoAuth{HttpNoAuth: convertHTTPNoAuthToPlumbing(v)}
	case *Kubernetes:
		plumbing.Resource = &proto.Resource_Kubernetes{Kubernetes: convertKubernetesToPlumbing(v)}
	case *KubernetesBasicAuth:
		plumbing.Resource = &proto.Resource_KubernetesBasicAuth{KubernetesBasicAuth: convertKubernetesBasicAuthToPlumbing(v)}
	case *KubernetesServiceAccount:
		plumbing.Resource = &proto.Resource_KubernetesServiceAccount{KubernetesServiceAccount: convertKubernetesServiceAccountToPlumbing(v)}
	case *KubernetesServiceAccountUserImpersonation:
		plumbing.Resource = &proto.Resource_KubernetesServiceAccountUserImpersonation{KubernetesServiceAccountUserImpersonation: convertKubernetesServiceAccountUserImpersonationToPlumbing(v)}
	case *KubernetesUserImpersonation:
		plumbing.Resource = &proto.Resource_KubernetesUserImpersonation{KubernetesUserImpersonation: convertKubernetesUserImpersonationToPlumbing(v)}
	case *Maria:
		plumbing.Resource = &proto.Resource_Maria{Maria: convertMariaToPlumbing(v)}
	case *Memcached:
		plumbing.Resource = &proto.Resource_Memcached{Memcached: convertMemcachedToPlumbing(v)}
	case *Memsql:
		plumbing.Resource = &proto.Resource_Memsql{Memsql: convertMemsqlToPlumbing(v)}
	case *MongoHost:
		plumbing.Resource = &proto.Resource_MongoHost{MongoHost: convertMongoHostToPlumbing(v)}
	case *MongoLegacyHost:
		plumbing.Resource = &proto.Resource_MongoLegacyHost{MongoLegacyHost: convertMongoLegacyHostToPlumbing(v)}
	case *MongoLegacyReplicaset:
		plumbing.Resource = &proto.Resource_MongoLegacyReplicaset{MongoLegacyReplicaset: convertMongoLegacyReplicasetToPlumbing(v)}
	case *MongoReplicaSet:
		plumbing.Resource = &proto.Resource_MongoReplicaSet{MongoReplicaSet: convertMongoReplicaSetToPlumbing(v)}
	case *MongoShardedCluster:
		plumbing.Resource = &proto.Resource_MongoShardedCluster{MongoShardedCluster: convertMongoShardedClusterToPlumbing(v)}
	case *MTLSMysql:
		plumbing.Resource = &proto.Resource_MtlsMysql{MtlsMysql: convertMTLSMysqlToPlumbing(v)}
	case *MTLSPostgres:
		plumbing.Resource = &proto.Resource_MtlsPostgres{MtlsPostgres: convertMTLSPostgresToPlumbing(v)}
	case *Mysql:
		plumbing.Resource = &proto.Resource_Mysql{Mysql: convertMysqlToPlumbing(v)}
	case *Neptune:
		plumbing.Resource = &proto.Resource_Neptune{Neptune: convertNeptuneToPlumbing(v)}
	case *NeptuneIAM:
		plumbing.Resource = &proto.Resource_NeptuneIam{NeptuneIam: convertNeptuneIAMToPlumbing(v)}
	case *Oracle:
		plumbing.Resource = &proto.Resource_Oracle{Oracle: convertOracleToPlumbing(v)}
	case *Postgres:
		plumbing.Resource = &proto.Resource_Postgres{Postgres: convertPostgresToPlumbing(v)}
	case *Presto:
		plumbing.Resource = &proto.Resource_Presto{Presto: convertPrestoToPlumbing(v)}
	case *RabbitMQAMQP091:
		plumbing.Resource = &proto.Resource_RabbitMqamqp_091{RabbitMqamqp_091: convertRabbitMQAMQP091ToPlumbing(v)}
	case *RawTCP:
		plumbing.Resource = &proto.Resource_RawTcp{RawTcp: convertRawTCPToPlumbing(v)}
	case *RDP:
		plumbing.Resource = &proto.Resource_Rdp{Rdp: convertRDPToPlumbing(v)}
	case *RDPCert:
		plumbing.Resource = &proto.Resource_RdpCert{RdpCert: convertRDPCertToPlumbing(v)}
	case *RDSPostgresIAM:
		plumbing.Resource = &proto.Resource_RdsPostgresIam{RdsPostgresIam: convertRDSPostgresIAMToPlumbing(v)}
	case *Redis:
		plumbing.Resource = &proto.Resource_Redis{Redis: convertRedisToPlumbing(v)}
	case *Redshift:
		plumbing.Resource = &proto.Resource_Redshift{Redshift: convertRedshiftToPlumbing(v)}
	case *SingleStore:
		plumbing.Resource = &proto.Resource_SingleStore{SingleStore: convertSingleStoreToPlumbing(v)}
	case *Snowflake:
		plumbing.Resource = &proto.Resource_Snowflake{Snowflake: convertSnowflakeToPlumbing(v)}
	case *Snowsight:
		plumbing.Resource = &proto.Resource_Snowsight{Snowsight: convertSnowsightToPlumbing(v)}
	case *SQLServer:
		plumbing.Resource = &proto.Resource_SqlServer{SqlServer: convertSQLServerToPlumbing(v)}
	case *SQLServerAzureAD:
		plumbing.Resource = &proto.Resource_SqlServerAzureAd{SqlServerAzureAd: convertSQLServerAzureADToPlumbing(v)}
	case *SQLServerKerberosAD:
		plumbing.Resource = &proto.Resource_SqlServerKerberosAd{SqlServerKerberosAd: convertSQLServerKerberosADToPlumbing(v)}
	case *SSH:
		plumbing.Resource = &proto.Resource_Ssh{Ssh: convertSSHToPlumbing(v)}
	case *SSHCert:
		plumbing.Resource = &proto.Resource_SshCert{SshCert: convertSSHCertToPlumbing(v)}
	case *SSHCustomerKey:
		plumbing.Resource = &proto.Resource_SshCustomerKey{SshCustomerKey: convertSSHCustomerKeyToPlumbing(v)}
	case *SSHPassword:
		plumbing.Resource = &proto.Resource_SshPassword{SshPassword: convertSSHPasswordToPlumbing(v)}
	case *Sybase:
		plumbing.Resource = &proto.Resource_Sybase{Sybase: convertSybaseToPlumbing(v)}
	case *SybaseIQ:
		plumbing.Resource = &proto.Resource_SybaseIq{SybaseIq: convertSybaseIQToPlumbing(v)}
	case *Teradata:
		plumbing.Resource = &proto.Resource_Teradata{Teradata: convertTeradataToPlumbing(v)}
	case *Trino:
		plumbing.Resource = &proto.Resource_Trino{Trino: convertTrinoToPlumbing(v)}
	}
	return plumbing
}

func convertResourceToPorcelain(plumbing *proto.Resource) (Resource, error) {
	if plumbing.GetAks() != nil {
		return convertAKSToPorcelain(plumbing.GetAks())
	}
	if plumbing.GetAksBasicAuth() != nil {
		return convertAKSBasicAuthToPorcelain(plumbing.GetAksBasicAuth())
	}
	if plumbing.GetAksServiceAccount() != nil {
		return convertAKSServiceAccountToPorcelain(plumbing.GetAksServiceAccount())
	}
	if plumbing.GetAksServiceAccountUserImpersonation() != nil {
		return convertAKSServiceAccountUserImpersonationToPorcelain(plumbing.GetAksServiceAccountUserImpersonation())
	}
	if plumbing.GetAksUserImpersonation() != nil {
		return convertAKSUserImpersonationToPorcelain(plumbing.GetAksUserImpersonation())
	}
	if plumbing.GetAmazonEks() != nil {
		return convertAmazonEKSToPorcelain(plumbing.GetAmazonEks())
	}
	if plumbing.GetAmazonEksInstanceProfile() != nil {
		return convertAmazonEKSInstanceProfileToPorcelain(plumbing.GetAmazonEksInstanceProfile())
	}
	if plumbing.GetAmazonEksInstanceProfileUserImpersonation() != nil {
		return convertAmazonEKSInstanceProfileUserImpersonationToPorcelain(plumbing.GetAmazonEksInstanceProfileUserImpersonation())
	}
	if plumbing.GetAmazonEksUserImpersonation() != nil {
		return convertAmazonEKSUserImpersonationToPorcelain(plumbing.GetAmazonEksUserImpersonation())
	}
	if plumbing.GetAmazonEs() != nil {
		return convertAmazonESToPorcelain(plumbing.GetAmazonEs())
	}
	if plumbing.GetAmazonEsiam() != nil {
		return convertAmazonESIAMToPorcelain(plumbing.GetAmazonEsiam())
	}
	if plumbing.GetAmazonMqamqp_091() != nil {
		return convertAmazonMQAMQP091ToPorcelain(plumbing.GetAmazonMqamqp_091())
	}
	if plumbing.GetAthena() != nil {
		return convertAthenaToPorcelain(plumbing.GetAthena())
	}
	if plumbing.GetAthenaIam() != nil {
		return convertAthenaIAMToPorcelain(plumbing.GetAthenaIam())
	}
	if plumbing.GetAuroraMysql() != nil {
		return convertAuroraMysqlToPorcelain(plumbing.GetAuroraMysql())
	}
	if plumbing.GetAuroraMysqlIam() != nil {
		return convertAuroraMysqlIAMToPorcelain(plumbing.GetAuroraMysqlIam())
	}
	if plumbing.GetAuroraPostgres() != nil {
		return convertAuroraPostgresToPorcelain(plumbing.GetAuroraPostgres())
	}
	if plumbing.GetAuroraPostgresIam() != nil {
		return convertAuroraPostgresIAMToPorcelain(plumbing.GetAuroraPostgresIam())
	}
	if plumbing.GetAws() != nil {
		return convertAWSToPorcelain(plumbing.GetAws())
	}
	if plumbing.GetAwsConsole() != nil {
		return convertAWSConsoleToPorcelain(plumbing.GetAwsConsole())
	}
	if plumbing.GetAwsConsoleStaticKeyPair() != nil {
		return convertAWSConsoleStaticKeyPairToPorcelain(plumbing.GetAwsConsoleStaticKeyPair())
	}
	if plumbing.GetAwsInstanceProfile() != nil {
		return convertAWSInstanceProfileToPorcelain(plumbing.GetAwsInstanceProfile())
	}
	if plumbing.GetAzure() != nil {
		return convertAzureToPorcelain(plumbing.GetAzure())
	}
	if plumbing.GetAzureCertificate() != nil {
		return convertAzureCertificateToPorcelain(plumbing.GetAzureCertificate())
	}
	if plumbing.GetAzureMysql() != nil {
		return convertAzureMysqlToPorcelain(plumbing.GetAzureMysql())
	}
	if plumbing.GetAzurePostgres() != nil {
		return convertAzurePostgresToPorcelain(plumbing.GetAzurePostgres())
	}
	if plumbing.GetAzurePostgresManagedIdentity() != nil {
		return convertAzurePostgresManagedIdentityToPorcelain(plumbing.GetAzurePostgresManagedIdentity())
	}
	if plumbing.GetBigQuery() != nil {
		return convertBigQueryToPorcelain(plumbing.GetBigQuery())
	}
	if plumbing.GetCassandra() != nil {
		return convertCassandraToPorcelain(plumbing.GetCassandra())
	}
	if plumbing.GetCitus() != nil {
		return convertCitusToPorcelain(plumbing.GetCitus())
	}
	if plumbing.GetClickHouseHttp() != nil {
		return convertClickHouseHTTPToPorcelain(plumbing.GetClickHouseHttp())
	}
	if plumbing.GetClickHouseMySql() != nil {
		return convertClickHouseMySQLToPorcelain(plumbing.GetClickHouseMySql())
	}
	if plumbing.GetClickHouseTcp() != nil {
		return convertClickHouseTCPToPorcelain(plumbing.GetClickHouseTcp())
	}
	if plumbing.GetClustrix() != nil {
		return convertClustrixToPorcelain(plumbing.GetClustrix())
	}
	if plumbing.GetCockroach() != nil {
		return convertCockroachToPorcelain(plumbing.GetCockroach())
	}
	if plumbing.GetCouchbaseDatabase() != nil {
		return convertCouchbaseDatabaseToPorcelain(plumbing.GetCouchbaseDatabase())
	}
	if plumbing.GetCouchbaseWebUi() != nil {
		return convertCouchbaseWebUIToPorcelain(plumbing.GetCouchbaseWebUi())
	}
	if plumbing.GetDb_2I() != nil {
		return convertDB2IToPorcelain(plumbing.GetDb_2I())
	}
	if plumbing.GetDb_2Luw() != nil {
		return convertDB2LUWToPorcelain(plumbing.GetDb_2Luw())
	}
	if plumbing.GetDocumentDbHost() != nil {
		return convertDocumentDBHostToPorcelain(plumbing.GetDocumentDbHost())
	}
	if plumbing.GetDocumentDbHostIam() != nil {
		return convertDocumentDBHostIAMToPorcelain(plumbing.GetDocumentDbHostIam())
	}
	if plumbing.GetDocumentDbReplicaSet() != nil {
		return convertDocumentDBReplicaSetToPorcelain(plumbing.GetDocumentDbReplicaSet())
	}
	if plumbing.GetDruid() != nil {
		return convertDruidToPorcelain(plumbing.GetDruid())
	}
	if plumbing.GetDynamoDb() != nil {
		return convertDynamoDBToPorcelain(plumbing.GetDynamoDb())
	}
	if plumbing.GetDynamoDbiam() != nil {
		return convertDynamoDBIAMToPorcelain(plumbing.GetDynamoDbiam())
	}
	if plumbing.GetElastic() != nil {
		return convertElasticToPorcelain(plumbing.GetElastic())
	}
	if plumbing.GetElasticacheRedis() != nil {
		return convertElasticacheRedisToPorcelain(plumbing.GetElasticacheRedis())
	}
	if plumbing.GetGcp() != nil {
		return convertGCPToPorcelain(plumbing.GetGcp())
	}
	if plumbing.GetGcpConsole() != nil {
		return convertGCPConsoleToPorcelain(plumbing.GetGcpConsole())
	}
	if plumbing.GetGcpwif() != nil {
		return convertGCPWIFToPorcelain(plumbing.GetGcpwif())
	}
	if plumbing.GetGoogleGke() != nil {
		return convertGoogleGKEToPorcelain(plumbing.GetGoogleGke())
	}
	if plumbing.GetGoogleGkeUserImpersonation() != nil {
		return convertGoogleGKEUserImpersonationToPorcelain(plumbing.GetGoogleGkeUserImpersonation())
	}
	if plumbing.GetGreenplum() != nil {
		return convertGreenplumToPorcelain(plumbing.GetGreenplum())
	}
	if plumbing.GetHttpAuth() != nil {
		return convertHTTPAuthToPorcelain(plumbing.GetHttpAuth())
	}
	if plumbing.GetHttpBasicAuth() != nil {
		return convertHTTPBasicAuthToPorcelain(plumbing.GetHttpBasicAuth())
	}
	if plumbing.GetHttpNoAuth() != nil {
		return convertHTTPNoAuthToPorcelain(plumbing.GetHttpNoAuth())
	}
	if plumbing.GetKubernetes() != nil {
		return convertKubernetesToPorcelain(plumbing.GetKubernetes())
	}
	if plumbing.GetKubernetesBasicAuth() != nil {
		return convertKubernetesBasicAuthToPorcelain(plumbing.GetKubernetesBasicAuth())
	}
	if plumbing.GetKubernetesServiceAccount() != nil {
		return convertKubernetesServiceAccountToPorcelain(plumbing.GetKubernetesServiceAccount())
	}
	if plumbing.GetKubernetesServiceAccountUserImpersonation() != nil {
		return convertKubernetesServiceAccountUserImpersonationToPorcelain(plumbing.GetKubernetesServiceAccountUserImpersonation())
	}
	if plumbing.GetKubernetesUserImpersonation() != nil {
		return convertKubernetesUserImpersonationToPorcelain(plumbing.GetKubernetesUserImpersonation())
	}
	if plumbing.GetMaria() != nil {
		return convertMariaToPorcelain(plumbing.GetMaria())
	}
	if plumbing.GetMemcached() != nil {
		return convertMemcachedToPorcelain(plumbing.GetMemcached())
	}
	if plumbing.GetMemsql() != nil {
		return convertMemsqlToPorcelain(plumbing.GetMemsql())
	}
	if plumbing.GetMongoHost() != nil {
		return convertMongoHostToPorcelain(plumbing.GetMongoHost())
	}
	if plumbing.GetMongoLegacyHost() != nil {
		return convertMongoLegacyHostToPorcelain(plumbing.GetMongoLegacyHost())
	}
	if plumbing.GetMongoLegacyReplicaset() != nil {
		return convertMongoLegacyReplicasetToPorcelain(plumbing.GetMongoLegacyReplicaset())
	}
	if plumbing.GetMongoReplicaSet() != nil {
		return convertMongoReplicaSetToPorcelain(plumbing.GetMongoReplicaSet())
	}
	if plumbing.GetMongoShardedCluster() != nil {
		return convertMongoShardedClusterToPorcelain(plumbing.GetMongoShardedCluster())
	}
	if plumbing.GetMtlsMysql() != nil {
		return convertMTLSMysqlToPorcelain(plumbing.GetMtlsMysql())
	}
	if plumbing.GetMtlsPostgres() != nil {
		return convertMTLSPostgresToPorcelain(plumbing.GetMtlsPostgres())
	}
	if plumbing.GetMysql() != nil {
		return convertMysqlToPorcelain(plumbing.GetMysql())
	}
	if plumbing.GetNeptune() != nil {
		return convertNeptuneToPorcelain(plumbing.GetNeptune())
	}
	if plumbing.GetNeptuneIam() != nil {
		return convertNeptuneIAMToPorcelain(plumbing.GetNeptuneIam())
	}
	if plumbing.GetOracle() != nil {
		return convertOracleToPorcelain(plumbing.GetOracle())
	}
	if plumbing.GetPostgres() != nil {
		return convertPostgresToPorcelain(plumbing.GetPostgres())
	}
	if plumbing.GetPresto() != nil {
		return convertPrestoToPorcelain(plumbing.GetPresto())
	}
	if plumbing.GetRabbitMqamqp_091() != nil {
		return convertRabbitMQAMQP091ToPorcelain(plumbing.GetRabbitMqamqp_091())
	}
	if plumbing.GetRawTcp() != nil {
		return convertRawTCPToPorcelain(plumbing.GetRawTcp())
	}
	if plumbing.GetRdp() != nil {
		return convertRDPToPorcelain(plumbing.GetRdp())
	}
	if plumbing.GetRdpCert() != nil {
		return convertRDPCertToPorcelain(plumbing.GetRdpCert())
	}
	if plumbing.GetRdsPostgresIam() != nil {
		return convertRDSPostgresIAMToPorcelain(plumbing.GetRdsPostgresIam())
	}
	if plumbing.GetRedis() != nil {
		return convertRedisToPorcelain(plumbing.GetRedis())
	}
	if plumbing.GetRedshift() != nil {
		return convertRedshiftToPorcelain(plumbing.GetRedshift())
	}
	if plumbing.GetSingleStore() != nil {
		return convertSingleStoreToPorcelain(plumbing.GetSingleStore())
	}
	if plumbing.GetSnowflake() != nil {
		return convertSnowflakeToPorcelain(plumbing.GetSnowflake())
	}
	if plumbing.GetSnowsight() != nil {
		return convertSnowsightToPorcelain(plumbing.GetSnowsight())
	}
	if plumbing.GetSqlServer() != nil {
		return convertSQLServerToPorcelain(plumbing.GetSqlServer())
	}
	if plumbing.GetSqlServerAzureAd() != nil {
		return convertSQLServerAzureADToPorcelain(plumbing.GetSqlServerAzureAd())
	}
	if plumbing.GetSqlServerKerberosAd() != nil {
		return convertSQLServerKerberosADToPorcelain(plumbing.GetSqlServerKerberosAd())
	}
	if plumbing.GetSsh() != nil {
		return convertSSHToPorcelain(plumbing.GetSsh())
	}
	if plumbing.GetSshCert() != nil {
		return convertSSHCertToPorcelain(plumbing.GetSshCert())
	}
	if plumbing.GetSshCustomerKey() != nil {
		return convertSSHCustomerKeyToPorcelain(plumbing.GetSshCustomerKey())
	}
	if plumbing.GetSshPassword() != nil {
		return convertSSHPasswordToPorcelain(plumbing.GetSshPassword())
	}
	if plumbing.GetSybase() != nil {
		return convertSybaseToPorcelain(plumbing.GetSybase())
	}
	if plumbing.GetSybaseIq() != nil {
		return convertSybaseIQToPorcelain(plumbing.GetSybaseIq())
	}
	if plumbing.GetTeradata() != nil {
		return convertTeradataToPorcelain(plumbing.GetTeradata())
	}
	if plumbing.GetTrino() != nil {
		return convertTrinoToPorcelain(plumbing.GetTrino())
	}
	return nil, &UnknownError{Wrapped: fmt.Errorf("unknown polymorphic type, please upgrade your SDK")}
}
func convertRepeatedResourceToPlumbing(
	porcelains []Resource,
) []*proto.Resource {
	var items []*proto.Resource
	for _, porcelain := range porcelains {
		items = append(items, convertResourceToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedResourceToPorcelain(plumbings []*proto.Resource) (
	[]Resource,
	error,
) {
	var items []Resource
	for _, plumbing := range plumbings {
		if v, err := convertResourceToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertResourceCreateResponseToPorcelain(plumbing *proto.ResourceCreateResponse) (*ResourceCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ResourceCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertResourceToPorcelain(plumbing.Resource); err != nil {
		return nil, fmt.Errorf("error converting field Resource: %v", err)
	} else {
		porcelain.Resource = v
	}
	return porcelain, nil
}

func convertResourceCreateResponseToPlumbing(porcelain *ResourceCreateResponse) *proto.ResourceCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ResourceCreateResponse{}
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.Resource = convertResourceToPlumbing(porcelain.Resource)
	return plumbing
}
func convertRepeatedResourceCreateResponseToPlumbing(
	porcelains []*ResourceCreateResponse,
) []*proto.ResourceCreateResponse {
	var items []*proto.ResourceCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertResourceCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedResourceCreateResponseToPorcelain(plumbings []*proto.ResourceCreateResponse) (
	[]*ResourceCreateResponse,
	error,
) {
	var items []*ResourceCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertResourceCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertResourceDeleteResponseToPorcelain(plumbing *proto.ResourceDeleteResponse) (*ResourceDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ResourceDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertResourceDeleteResponseToPlumbing(porcelain *ResourceDeleteResponse) *proto.ResourceDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ResourceDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedResourceDeleteResponseToPlumbing(
	porcelains []*ResourceDeleteResponse,
) []*proto.ResourceDeleteResponse {
	var items []*proto.ResourceDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertResourceDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedResourceDeleteResponseToPorcelain(plumbings []*proto.ResourceDeleteResponse) (
	[]*ResourceDeleteResponse,
	error,
) {
	var items []*ResourceDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertResourceDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertResourceGetResponseToPorcelain(plumbing *proto.ResourceGetResponse) (*ResourceGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ResourceGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertResourceToPorcelain(plumbing.Resource); err != nil {
		return nil, fmt.Errorf("error converting field Resource: %v", err)
	} else {
		porcelain.Resource = v
	}
	return porcelain, nil
}

func convertResourceGetResponseToPlumbing(porcelain *ResourceGetResponse) *proto.ResourceGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ResourceGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.Resource = convertResourceToPlumbing(porcelain.Resource)
	return plumbing
}
func convertRepeatedResourceGetResponseToPlumbing(
	porcelains []*ResourceGetResponse,
) []*proto.ResourceGetResponse {
	var items []*proto.ResourceGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertResourceGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedResourceGetResponseToPorcelain(plumbings []*proto.ResourceGetResponse) (
	[]*ResourceGetResponse,
	error,
) {
	var items []*ResourceGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertResourceGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertResourceHealthcheckRequestToPorcelain(plumbing *proto.ResourceHealthcheckRequest) (*ResourceHealthcheckRequest, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ResourceHealthcheckRequest{}
	porcelain.ID = plumbing.Id
	return porcelain, nil
}

func convertResourceHealthcheckRequestToPlumbing(porcelain *ResourceHealthcheckRequest) *proto.ResourceHealthcheckRequest {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ResourceHealthcheckRequest{}
	plumbing.Id = (porcelain.ID)
	return plumbing
}
func convertRepeatedResourceHealthcheckRequestToPlumbing(
	porcelains []*ResourceHealthcheckRequest,
) []*proto.ResourceHealthcheckRequest {
	var items []*proto.ResourceHealthcheckRequest
	for _, porcelain := range porcelains {
		items = append(items, convertResourceHealthcheckRequestToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedResourceHealthcheckRequestToPorcelain(plumbings []*proto.ResourceHealthcheckRequest) (
	[]*ResourceHealthcheckRequest,
	error,
) {
	var items []*ResourceHealthcheckRequest
	for _, plumbing := range plumbings {
		if v, err := convertResourceHealthcheckRequestToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertResourceHealthcheckResponseToPorcelain(plumbing *proto.ResourceHealthcheckResponse) (*ResourceHealthcheckResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ResourceHealthcheckResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertResourceHealthcheckResponseToPlumbing(porcelain *ResourceHealthcheckResponse) *proto.ResourceHealthcheckResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ResourceHealthcheckResponse{}
	plumbing.Meta = convertUpdateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedResourceHealthcheckResponseToPlumbing(
	porcelains []*ResourceHealthcheckResponse,
) []*proto.ResourceHealthcheckResponse {
	var items []*proto.ResourceHealthcheckResponse
	for _, porcelain := range porcelains {
		items = append(items, convertResourceHealthcheckResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedResourceHealthcheckResponseToPorcelain(plumbings []*proto.ResourceHealthcheckResponse) (
	[]*ResourceHealthcheckResponse,
	error,
) {
	var items []*ResourceHealthcheckResponse
	for _, plumbing := range plumbings {
		if v, err := convertResourceHealthcheckResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertResourceHistoryToPorcelain(plumbing *proto.ResourceHistory) (*ResourceHistory, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ResourceHistory{}
	porcelain.ActivityID = plumbing.ActivityId
	if v, err := convertTimestampToPorcelain(plumbing.DeletedAt); err != nil {
		return nil, fmt.Errorf("error converting field DeletedAt: %v", err)
	} else {
		porcelain.DeletedAt = v
	}
	if v, err := convertResourceToPorcelain(plumbing.Resource); err != nil {
		return nil, fmt.Errorf("error converting field Resource: %v", err)
	} else {
		porcelain.Resource = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	return porcelain, nil
}

func convertResourceHistoryToPlumbing(porcelain *ResourceHistory) *proto.ResourceHistory {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ResourceHistory{}
	plumbing.ActivityId = (porcelain.ActivityID)
	plumbing.DeletedAt = convertTimestampToPlumbing(porcelain.DeletedAt)
	plumbing.Resource = convertResourceToPlumbing(porcelain.Resource)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	return plumbing
}
func convertRepeatedResourceHistoryToPlumbing(
	porcelains []*ResourceHistory,
) []*proto.ResourceHistory {
	var items []*proto.ResourceHistory
	for _, porcelain := range porcelains {
		items = append(items, convertResourceHistoryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedResourceHistoryToPorcelain(plumbings []*proto.ResourceHistory) (
	[]*ResourceHistory,
	error,
) {
	var items []*ResourceHistory
	for _, plumbing := range plumbings {
		if v, err := convertResourceHistoryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertResourceUpdateResponseToPorcelain(plumbing *proto.ResourceUpdateResponse) (*ResourceUpdateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &ResourceUpdateResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertResourceToPorcelain(plumbing.Resource); err != nil {
		return nil, fmt.Errorf("error converting field Resource: %v", err)
	} else {
		porcelain.Resource = v
	}
	return porcelain, nil
}

func convertResourceUpdateResponseToPlumbing(porcelain *ResourceUpdateResponse) *proto.ResourceUpdateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.ResourceUpdateResponse{}
	plumbing.Meta = convertUpdateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.Resource = convertResourceToPlumbing(porcelain.Resource)
	return plumbing
}
func convertRepeatedResourceUpdateResponseToPlumbing(
	porcelains []*ResourceUpdateResponse,
) []*proto.ResourceUpdateResponse {
	var items []*proto.ResourceUpdateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertResourceUpdateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedResourceUpdateResponseToPorcelain(plumbings []*proto.ResourceUpdateResponse) (
	[]*ResourceUpdateResponse,
	error,
) {
	var items []*ResourceUpdateResponse
	for _, plumbing := range plumbings {
		if v, err := convertResourceUpdateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRoleToPorcelain(plumbing *proto.Role) (*Role, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Role{}
	if v, err := convertAccessRulesToPorcelain(plumbing.AccessRules); err != nil {
		return nil, fmt.Errorf("error converting field AccessRules: %v", err)
	} else {
		porcelain.AccessRules = v
	}
	porcelain.ID = plumbing.Id
	porcelain.ManagedBy = plumbing.ManagedBy
	porcelain.Name = plumbing.Name
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertRoleToPlumbing(porcelain *Role) *proto.Role {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Role{}
	plumbing.AccessRules = convertAccessRulesToPlumbing(porcelain.AccessRules)
	plumbing.Id = (porcelain.ID)
	plumbing.ManagedBy = (porcelain.ManagedBy)
	plumbing.Name = (porcelain.Name)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedRoleToPlumbing(
	porcelains []*Role,
) []*proto.Role {
	var items []*proto.Role
	for _, porcelain := range porcelains {
		items = append(items, convertRoleToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleToPorcelain(plumbings []*proto.Role) (
	[]*Role,
	error,
) {
	var items []*Role
	for _, plumbing := range plumbings {
		if v, err := convertRoleToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRoleCreateResponseToPorcelain(plumbing *proto.RoleCreateResponse) (*RoleCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RoleCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertRoleToPorcelain(plumbing.Role); err != nil {
		return nil, fmt.Errorf("error converting field Role: %v", err)
	} else {
		porcelain.Role = v
	}
	return porcelain, nil
}

func convertRoleCreateResponseToPlumbing(porcelain *RoleCreateResponse) *proto.RoleCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleCreateResponse{}
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.Role = convertRoleToPlumbing(porcelain.Role)
	return plumbing
}
func convertRepeatedRoleCreateResponseToPlumbing(
	porcelains []*RoleCreateResponse,
) []*proto.RoleCreateResponse {
	var items []*proto.RoleCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRoleCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleCreateResponseToPorcelain(plumbings []*proto.RoleCreateResponse) (
	[]*RoleCreateResponse,
	error,
) {
	var items []*RoleCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertRoleCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRoleDeleteResponseToPorcelain(plumbing *proto.RoleDeleteResponse) (*RoleDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RoleDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertRoleDeleteResponseToPlumbing(porcelain *RoleDeleteResponse) *proto.RoleDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedRoleDeleteResponseToPlumbing(
	porcelains []*RoleDeleteResponse,
) []*proto.RoleDeleteResponse {
	var items []*proto.RoleDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRoleDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleDeleteResponseToPorcelain(plumbings []*proto.RoleDeleteResponse) (
	[]*RoleDeleteResponse,
	error,
) {
	var items []*RoleDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertRoleDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRoleGetResponseToPorcelain(plumbing *proto.RoleGetResponse) (*RoleGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RoleGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertRoleToPorcelain(plumbing.Role); err != nil {
		return nil, fmt.Errorf("error converting field Role: %v", err)
	} else {
		porcelain.Role = v
	}
	return porcelain, nil
}

func convertRoleGetResponseToPlumbing(porcelain *RoleGetResponse) *proto.RoleGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.Role = convertRoleToPlumbing(porcelain.Role)
	return plumbing
}
func convertRepeatedRoleGetResponseToPlumbing(
	porcelains []*RoleGetResponse,
) []*proto.RoleGetResponse {
	var items []*proto.RoleGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRoleGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleGetResponseToPorcelain(plumbings []*proto.RoleGetResponse) (
	[]*RoleGetResponse,
	error,
) {
	var items []*RoleGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertRoleGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRoleHistoryToPorcelain(plumbing *proto.RoleHistory) (*RoleHistory, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RoleHistory{}
	porcelain.ActivityID = plumbing.ActivityId
	if v, err := convertTimestampToPorcelain(plumbing.DeletedAt); err != nil {
		return nil, fmt.Errorf("error converting field DeletedAt: %v", err)
	} else {
		porcelain.DeletedAt = v
	}
	if v, err := convertRoleToPorcelain(plumbing.Role); err != nil {
		return nil, fmt.Errorf("error converting field Role: %v", err)
	} else {
		porcelain.Role = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	return porcelain, nil
}

func convertRoleHistoryToPlumbing(porcelain *RoleHistory) *proto.RoleHistory {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleHistory{}
	plumbing.ActivityId = (porcelain.ActivityID)
	plumbing.DeletedAt = convertTimestampToPlumbing(porcelain.DeletedAt)
	plumbing.Role = convertRoleToPlumbing(porcelain.Role)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	return plumbing
}
func convertRepeatedRoleHistoryToPlumbing(
	porcelains []*RoleHistory,
) []*proto.RoleHistory {
	var items []*proto.RoleHistory
	for _, porcelain := range porcelains {
		items = append(items, convertRoleHistoryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleHistoryToPorcelain(plumbings []*proto.RoleHistory) (
	[]*RoleHistory,
	error,
) {
	var items []*RoleHistory
	for _, plumbing := range plumbings {
		if v, err := convertRoleHistoryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRoleResourceToPorcelain(plumbing *proto.RoleResource) (*RoleResource, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RoleResource{}
	if v, err := convertTimestampToPorcelain(plumbing.GrantedAt); err != nil {
		return nil, fmt.Errorf("error converting field GrantedAt: %v", err)
	} else {
		porcelain.GrantedAt = v
	}
	porcelain.ResourceID = plumbing.ResourceId
	porcelain.RoleID = plumbing.RoleId
	return porcelain, nil
}

func convertRoleResourceToPlumbing(porcelain *RoleResource) *proto.RoleResource {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleResource{}
	plumbing.GrantedAt = convertTimestampToPlumbing(porcelain.GrantedAt)
	plumbing.ResourceId = (porcelain.ResourceID)
	plumbing.RoleId = (porcelain.RoleID)
	return plumbing
}
func convertRepeatedRoleResourceToPlumbing(
	porcelains []*RoleResource,
) []*proto.RoleResource {
	var items []*proto.RoleResource
	for _, porcelain := range porcelains {
		items = append(items, convertRoleResourceToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleResourceToPorcelain(plumbings []*proto.RoleResource) (
	[]*RoleResource,
	error,
) {
	var items []*RoleResource
	for _, plumbing := range plumbings {
		if v, err := convertRoleResourceToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRoleResourceHistoryToPorcelain(plumbing *proto.RoleResourceHistory) (*RoleResourceHistory, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RoleResourceHistory{}
	porcelain.ActivityID = plumbing.ActivityId
	if v, err := convertTimestampToPorcelain(plumbing.DeletedAt); err != nil {
		return nil, fmt.Errorf("error converting field DeletedAt: %v", err)
	} else {
		porcelain.DeletedAt = v
	}
	if v, err := convertRoleResourceToPorcelain(plumbing.RoleResource); err != nil {
		return nil, fmt.Errorf("error converting field RoleResource: %v", err)
	} else {
		porcelain.RoleResource = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	return porcelain, nil
}

func convertRoleResourceHistoryToPlumbing(porcelain *RoleResourceHistory) *proto.RoleResourceHistory {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleResourceHistory{}
	plumbing.ActivityId = (porcelain.ActivityID)
	plumbing.DeletedAt = convertTimestampToPlumbing(porcelain.DeletedAt)
	plumbing.RoleResource = convertRoleResourceToPlumbing(porcelain.RoleResource)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	return plumbing
}
func convertRepeatedRoleResourceHistoryToPlumbing(
	porcelains []*RoleResourceHistory,
) []*proto.RoleResourceHistory {
	var items []*proto.RoleResourceHistory
	for _, porcelain := range porcelains {
		items = append(items, convertRoleResourceHistoryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleResourceHistoryToPorcelain(plumbings []*proto.RoleResourceHistory) (
	[]*RoleResourceHistory,
	error,
) {
	var items []*RoleResourceHistory
	for _, plumbing := range plumbings {
		if v, err := convertRoleResourceHistoryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertRoleUpdateResponseToPorcelain(plumbing *proto.RoleUpdateResponse) (*RoleUpdateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &RoleUpdateResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertRoleToPorcelain(plumbing.Role); err != nil {
		return nil, fmt.Errorf("error converting field Role: %v", err)
	} else {
		porcelain.Role = v
	}
	return porcelain, nil
}

func convertRoleUpdateResponseToPlumbing(porcelain *RoleUpdateResponse) *proto.RoleUpdateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.RoleUpdateResponse{}
	plumbing.Meta = convertUpdateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.Role = convertRoleToPlumbing(porcelain.Role)
	return plumbing
}
func convertRepeatedRoleUpdateResponseToPlumbing(
	porcelains []*RoleUpdateResponse,
) []*proto.RoleUpdateResponse {
	var items []*proto.RoleUpdateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertRoleUpdateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedRoleUpdateResponseToPorcelain(plumbings []*proto.RoleUpdateResponse) (
	[]*RoleUpdateResponse,
	error,
) {
	var items []*RoleUpdateResponse
	for _, plumbing := range plumbings {
		if v, err := convertRoleUpdateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSQLServerToPorcelain(plumbing *proto.SQLServer) (*SQLServer, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SQLServer{}
	porcelain.AllowDeprecatedEncryption = plumbing.AllowDeprecatedEncryption
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.OverrideDatabase = plumbing.OverrideDatabase
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.Schema = plumbing.Schema
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertSQLServerToPlumbing(porcelain *SQLServer) *proto.SQLServer {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SQLServer{}
	plumbing.AllowDeprecatedEncryption = (porcelain.AllowDeprecatedEncryption)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.Schema = (porcelain.Schema)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedSQLServerToPlumbing(
	porcelains []*SQLServer,
) []*proto.SQLServer {
	var items []*proto.SQLServer
	for _, porcelain := range porcelains {
		items = append(items, convertSQLServerToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSQLServerToPorcelain(plumbings []*proto.SQLServer) (
	[]*SQLServer,
	error,
) {
	var items []*SQLServer
	for _, plumbing := range plumbings {
		if v, err := convertSQLServerToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSQLServerAzureADToPorcelain(plumbing *proto.SQLServerAzureAD) (*SQLServerAzureAD, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SQLServerAzureAD{}
	porcelain.AllowDeprecatedEncryption = plumbing.AllowDeprecatedEncryption
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.ClientID = plumbing.ClientId
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.OverrideDatabase = plumbing.OverrideDatabase
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.Schema = plumbing.Schema
	porcelain.Secret = plumbing.Secret
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.TenantID = plumbing.TenantId
	return porcelain, nil
}

func convertSQLServerAzureADToPlumbing(porcelain *SQLServerAzureAD) *proto.SQLServerAzureAD {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SQLServerAzureAD{}
	plumbing.AllowDeprecatedEncryption = (porcelain.AllowDeprecatedEncryption)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.ClientId = (porcelain.ClientID)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.Schema = (porcelain.Schema)
	plumbing.Secret = (porcelain.Secret)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.TenantId = (porcelain.TenantID)
	return plumbing
}
func convertRepeatedSQLServerAzureADToPlumbing(
	porcelains []*SQLServerAzureAD,
) []*proto.SQLServerAzureAD {
	var items []*proto.SQLServerAzureAD
	for _, porcelain := range porcelains {
		items = append(items, convertSQLServerAzureADToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSQLServerAzureADToPorcelain(plumbings []*proto.SQLServerAzureAD) (
	[]*SQLServerAzureAD,
	error,
) {
	var items []*SQLServerAzureAD
	for _, plumbing := range plumbings {
		if v, err := convertSQLServerAzureADToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSQLServerKerberosADToPorcelain(plumbing *proto.SQLServerKerberosAD) (*SQLServerKerberosAD, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SQLServerKerberosAD{}
	porcelain.AllowDeprecatedEncryption = plumbing.AllowDeprecatedEncryption
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Keytab = plumbing.Keytab
	porcelain.KrbConfig = plumbing.KrbConfig
	porcelain.Name = plumbing.Name
	porcelain.OverrideDatabase = plumbing.OverrideDatabase
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.Realm = plumbing.Realm
	porcelain.Schema = plumbing.Schema
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.ServerSpn = plumbing.ServerSpn
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertSQLServerKerberosADToPlumbing(porcelain *SQLServerKerberosAD) *proto.SQLServerKerberosAD {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SQLServerKerberosAD{}
	plumbing.AllowDeprecatedEncryption = (porcelain.AllowDeprecatedEncryption)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Keytab = (porcelain.Keytab)
	plumbing.KrbConfig = (porcelain.KrbConfig)
	plumbing.Name = (porcelain.Name)
	plumbing.OverrideDatabase = (porcelain.OverrideDatabase)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.Realm = (porcelain.Realm)
	plumbing.Schema = (porcelain.Schema)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.ServerSpn = (porcelain.ServerSpn)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedSQLServerKerberosADToPlumbing(
	porcelains []*SQLServerKerberosAD,
) []*proto.SQLServerKerberosAD {
	var items []*proto.SQLServerKerberosAD
	for _, porcelain := range porcelains {
		items = append(items, convertSQLServerKerberosADToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSQLServerKerberosADToPorcelain(plumbings []*proto.SQLServerKerberosAD) (
	[]*SQLServerKerberosAD,
	error,
) {
	var items []*SQLServerKerberosAD
	for _, plumbing := range plumbings {
		if v, err := convertSQLServerKerberosADToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSSHToPorcelain(plumbing *proto.SSH) (*SSH, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SSH{}
	porcelain.AllowDeprecatedKeyExchanges = plumbing.AllowDeprecatedKeyExchanges
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.KeyType = plumbing.KeyType
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.PortForwarding = plumbing.PortForwarding
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.PublicKey = plumbing.PublicKey
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertSSHToPlumbing(porcelain *SSH) *proto.SSH {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SSH{}
	plumbing.AllowDeprecatedKeyExchanges = (porcelain.AllowDeprecatedKeyExchanges)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.KeyType = (porcelain.KeyType)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.PortForwarding = (porcelain.PortForwarding)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.PublicKey = (porcelain.PublicKey)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedSSHToPlumbing(
	porcelains []*SSH,
) []*proto.SSH {
	var items []*proto.SSH
	for _, porcelain := range porcelains {
		items = append(items, convertSSHToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSSHToPorcelain(plumbings []*proto.SSH) (
	[]*SSH,
	error,
) {
	var items []*SSH
	for _, plumbing := range plumbings {
		if v, err := convertSSHToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSSHCertToPorcelain(plumbing *proto.SSHCert) (*SSHCert, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SSHCert{}
	porcelain.AllowDeprecatedKeyExchanges = plumbing.AllowDeprecatedKeyExchanges
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.IdentityAliasHealthcheckUsername = plumbing.IdentityAliasHealthcheckUsername
	porcelain.IdentitySetID = plumbing.IdentitySetId
	porcelain.KeyType = plumbing.KeyType
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.PortForwarding = plumbing.PortForwarding
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertSSHCertToPlumbing(porcelain *SSHCert) *proto.SSHCert {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SSHCert{}
	plumbing.AllowDeprecatedKeyExchanges = (porcelain.AllowDeprecatedKeyExchanges)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.IdentityAliasHealthcheckUsername = (porcelain.IdentityAliasHealthcheckUsername)
	plumbing.IdentitySetId = (porcelain.IdentitySetID)
	plumbing.KeyType = (porcelain.KeyType)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.PortForwarding = (porcelain.PortForwarding)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedSSHCertToPlumbing(
	porcelains []*SSHCert,
) []*proto.SSHCert {
	var items []*proto.SSHCert
	for _, porcelain := range porcelains {
		items = append(items, convertSSHCertToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSSHCertToPorcelain(plumbings []*proto.SSHCert) (
	[]*SSHCert,
	error,
) {
	var items []*SSHCert
	for _, plumbing := range plumbings {
		if v, err := convertSSHCertToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSSHCustomerKeyToPorcelain(plumbing *proto.SSHCustomerKey) (*SSHCustomerKey, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SSHCustomerKey{}
	porcelain.AllowDeprecatedKeyExchanges = plumbing.AllowDeprecatedKeyExchanges
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Port = plumbing.Port
	porcelain.PortForwarding = plumbing.PortForwarding
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.PrivateKey = plumbing.PrivateKey
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertSSHCustomerKeyToPlumbing(porcelain *SSHCustomerKey) *proto.SSHCustomerKey {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SSHCustomerKey{}
	plumbing.AllowDeprecatedKeyExchanges = (porcelain.AllowDeprecatedKeyExchanges)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Port = (porcelain.Port)
	plumbing.PortForwarding = (porcelain.PortForwarding)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.PrivateKey = (porcelain.PrivateKey)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedSSHCustomerKeyToPlumbing(
	porcelains []*SSHCustomerKey,
) []*proto.SSHCustomerKey {
	var items []*proto.SSHCustomerKey
	for _, porcelain := range porcelains {
		items = append(items, convertSSHCustomerKeyToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSSHCustomerKeyToPorcelain(plumbings []*proto.SSHCustomerKey) (
	[]*SSHCustomerKey,
	error,
) {
	var items []*SSHCustomerKey
	for _, plumbing := range plumbings {
		if v, err := convertSSHCustomerKeyToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSSHPasswordToPorcelain(plumbing *proto.SSHPassword) (*SSHPassword, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SSHPassword{}
	porcelain.AllowDeprecatedKeyExchanges = plumbing.AllowDeprecatedKeyExchanges
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortForwarding = plumbing.PortForwarding
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertSSHPasswordToPlumbing(porcelain *SSHPassword) *proto.SSHPassword {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SSHPassword{}
	plumbing.AllowDeprecatedKeyExchanges = (porcelain.AllowDeprecatedKeyExchanges)
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortForwarding = (porcelain.PortForwarding)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedSSHPasswordToPlumbing(
	porcelains []*SSHPassword,
) []*proto.SSHPassword {
	var items []*proto.SSHPassword
	for _, porcelain := range porcelains {
		items = append(items, convertSSHPasswordToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSSHPasswordToPorcelain(plumbings []*proto.SSHPassword) (
	[]*SSHPassword,
	error,
) {
	var items []*SSHPassword
	for _, plumbing := range plumbings {
		if v, err := convertSSHPasswordToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSecretStoreToPlumbing(porcelain SecretStore) *proto.SecretStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SecretStore{}

	switch v := porcelain.(type) {
	case *ActiveDirectoryStore:
		plumbing.SecretStore = &proto.SecretStore_ActiveDirectory{ActiveDirectory: convertActiveDirectoryStoreToPlumbing(v)}
	case *AWSStore:
		plumbing.SecretStore = &proto.SecretStore_Aws{Aws: convertAWSStoreToPlumbing(v)}
	case *AWSCertX509Store:
		plumbing.SecretStore = &proto.SecretStore_AwsCertX_509{AwsCertX_509: convertAWSCertX509StoreToPlumbing(v)}
	case *AzureStore:
		plumbing.SecretStore = &proto.SecretStore_Azure{Azure: convertAzureStoreToPlumbing(v)}
	case *CyberarkConjurStore:
		plumbing.SecretStore = &proto.SecretStore_CyberarkConjur{CyberarkConjur: convertCyberarkConjurStoreToPlumbing(v)}
	case *CyberarkPAMStore:
		plumbing.SecretStore = &proto.SecretStore_CyberarkPam{CyberarkPam: convertCyberarkPAMStoreToPlumbing(v)}
	case *CyberarkPAMExperimentalStore:
		plumbing.SecretStore = &proto.SecretStore_CyberarkPamExperimental{CyberarkPamExperimental: convertCyberarkPAMExperimentalStoreToPlumbing(v)}
	case *DelineaStore:
		plumbing.SecretStore = &proto.SecretStore_Delinea{Delinea: convertDelineaStoreToPlumbing(v)}
	case *GCPStore:
		plumbing.SecretStore = &proto.SecretStore_Gcp{Gcp: convertGCPStoreToPlumbing(v)}
	case *GCPCertX509Store:
		plumbing.SecretStore = &proto.SecretStore_GcpCertX_509{GcpCertX_509: convertGCPCertX509StoreToPlumbing(v)}
	case *KeyfactorSSHStore:
		plumbing.SecretStore = &proto.SecretStore_KeyfactorSsh{KeyfactorSsh: convertKeyfactorSSHStoreToPlumbing(v)}
	case *KeyfactorX509Store:
		plumbing.SecretStore = &proto.SecretStore_KeyfactorX_509{KeyfactorX_509: convertKeyfactorX509StoreToPlumbing(v)}
	case *VaultAppRoleStore:
		plumbing.SecretStore = &proto.SecretStore_VaultAppRole{VaultAppRole: convertVaultAppRoleStoreToPlumbing(v)}
	case *VaultAppRoleCertSSHStore:
		plumbing.SecretStore = &proto.SecretStore_VaultAppRoleCertSsh{VaultAppRoleCertSsh: convertVaultAppRoleCertSSHStoreToPlumbing(v)}
	case *VaultAppRoleCertX509Store:
		plumbing.SecretStore = &proto.SecretStore_VaultAppRoleCertX_509{VaultAppRoleCertX_509: convertVaultAppRoleCertX509StoreToPlumbing(v)}
	case *VaultAWSEC2Store:
		plumbing.SecretStore = &proto.SecretStore_VaultAwsec_2{VaultAwsec_2: convertVaultAWSEC2StoreToPlumbing(v)}
	case *VaultAWSIAMStore:
		plumbing.SecretStore = &proto.SecretStore_VaultAwsiam{VaultAwsiam: convertVaultAWSIAMStoreToPlumbing(v)}
	case *VaultTLSStore:
		plumbing.SecretStore = &proto.SecretStore_VaultTls{VaultTls: convertVaultTLSStoreToPlumbing(v)}
	case *VaultTLSCertSSHStore:
		plumbing.SecretStore = &proto.SecretStore_VaultTlsCertSsh{VaultTlsCertSsh: convertVaultTLSCertSSHStoreToPlumbing(v)}
	case *VaultTLSCertX509Store:
		plumbing.SecretStore = &proto.SecretStore_VaultTlsCertX_509{VaultTlsCertX_509: convertVaultTLSCertX509StoreToPlumbing(v)}
	case *VaultTokenStore:
		plumbing.SecretStore = &proto.SecretStore_VaultToken{VaultToken: convertVaultTokenStoreToPlumbing(v)}
	case *VaultTokenCertSSHStore:
		plumbing.SecretStore = &proto.SecretStore_VaultTokenCertSsh{VaultTokenCertSsh: convertVaultTokenCertSSHStoreToPlumbing(v)}
	case *VaultTokenCertX509Store:
		plumbing.SecretStore = &proto.SecretStore_VaultTokenCertX_509{VaultTokenCertX_509: convertVaultTokenCertX509StoreToPlumbing(v)}
	}
	return plumbing
}

func convertSecretStoreToPorcelain(plumbing *proto.SecretStore) (SecretStore, error) {
	if plumbing.GetActiveDirectory() != nil {
		return convertActiveDirectoryStoreToPorcelain(plumbing.GetActiveDirectory())
	}
	if plumbing.GetAws() != nil {
		return convertAWSStoreToPorcelain(plumbing.GetAws())
	}
	if plumbing.GetAwsCertX_509() != nil {
		return convertAWSCertX509StoreToPorcelain(plumbing.GetAwsCertX_509())
	}
	if plumbing.GetAzure() != nil {
		return convertAzureStoreToPorcelain(plumbing.GetAzure())
	}
	if plumbing.GetCyberarkConjur() != nil {
		return convertCyberarkConjurStoreToPorcelain(plumbing.GetCyberarkConjur())
	}
	if plumbing.GetCyberarkPam() != nil {
		return convertCyberarkPAMStoreToPorcelain(plumbing.GetCyberarkPam())
	}
	if plumbing.GetCyberarkPamExperimental() != nil {
		return convertCyberarkPAMExperimentalStoreToPorcelain(plumbing.GetCyberarkPamExperimental())
	}
	if plumbing.GetDelinea() != nil {
		return convertDelineaStoreToPorcelain(plumbing.GetDelinea())
	}
	if plumbing.GetGcp() != nil {
		return convertGCPStoreToPorcelain(plumbing.GetGcp())
	}
	if plumbing.GetGcpCertX_509() != nil {
		return convertGCPCertX509StoreToPorcelain(plumbing.GetGcpCertX_509())
	}
	if plumbing.GetKeyfactorSsh() != nil {
		return convertKeyfactorSSHStoreToPorcelain(plumbing.GetKeyfactorSsh())
	}
	if plumbing.GetKeyfactorX_509() != nil {
		return convertKeyfactorX509StoreToPorcelain(plumbing.GetKeyfactorX_509())
	}
	if plumbing.GetVaultAppRole() != nil {
		return convertVaultAppRoleStoreToPorcelain(plumbing.GetVaultAppRole())
	}
	if plumbing.GetVaultAppRoleCertSsh() != nil {
		return convertVaultAppRoleCertSSHStoreToPorcelain(plumbing.GetVaultAppRoleCertSsh())
	}
	if plumbing.GetVaultAppRoleCertX_509() != nil {
		return convertVaultAppRoleCertX509StoreToPorcelain(plumbing.GetVaultAppRoleCertX_509())
	}
	if plumbing.GetVaultAwsec_2() != nil {
		return convertVaultAWSEC2StoreToPorcelain(plumbing.GetVaultAwsec_2())
	}
	if plumbing.GetVaultAwsiam() != nil {
		return convertVaultAWSIAMStoreToPorcelain(plumbing.GetVaultAwsiam())
	}
	if plumbing.GetVaultTls() != nil {
		return convertVaultTLSStoreToPorcelain(plumbing.GetVaultTls())
	}
	if plumbing.GetVaultTlsCertSsh() != nil {
		return convertVaultTLSCertSSHStoreToPorcelain(plumbing.GetVaultTlsCertSsh())
	}
	if plumbing.GetVaultTlsCertX_509() != nil {
		return convertVaultTLSCertX509StoreToPorcelain(plumbing.GetVaultTlsCertX_509())
	}
	if plumbing.GetVaultToken() != nil {
		return convertVaultTokenStoreToPorcelain(plumbing.GetVaultToken())
	}
	if plumbing.GetVaultTokenCertSsh() != nil {
		return convertVaultTokenCertSSHStoreToPorcelain(plumbing.GetVaultTokenCertSsh())
	}
	if plumbing.GetVaultTokenCertX_509() != nil {
		return convertVaultTokenCertX509StoreToPorcelain(plumbing.GetVaultTokenCertX_509())
	}
	return nil, &UnknownError{Wrapped: fmt.Errorf("unknown polymorphic type, please upgrade your SDK")}
}
func convertRepeatedSecretStoreToPlumbing(
	porcelains []SecretStore,
) []*proto.SecretStore {
	var items []*proto.SecretStore
	for _, porcelain := range porcelains {
		items = append(items, convertSecretStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSecretStoreToPorcelain(plumbings []*proto.SecretStore) (
	[]SecretStore,
	error,
) {
	var items []SecretStore
	for _, plumbing := range plumbings {
		if v, err := convertSecretStoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSecretStoreCreateResponseToPorcelain(plumbing *proto.SecretStoreCreateResponse) (*SecretStoreCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SecretStoreCreateResponse{}
	if v, err := convertCreateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertSecretStoreToPorcelain(plumbing.SecretStore); err != nil {
		return nil, fmt.Errorf("error converting field SecretStore: %v", err)
	} else {
		porcelain.SecretStore = v
	}
	return porcelain, nil
}

func convertSecretStoreCreateResponseToPlumbing(porcelain *SecretStoreCreateResponse) *proto.SecretStoreCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SecretStoreCreateResponse{}
	plumbing.Meta = convertCreateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.SecretStore = convertSecretStoreToPlumbing(porcelain.SecretStore)
	return plumbing
}
func convertRepeatedSecretStoreCreateResponseToPlumbing(
	porcelains []*SecretStoreCreateResponse,
) []*proto.SecretStoreCreateResponse {
	var items []*proto.SecretStoreCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertSecretStoreCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSecretStoreCreateResponseToPorcelain(plumbings []*proto.SecretStoreCreateResponse) (
	[]*SecretStoreCreateResponse,
	error,
) {
	var items []*SecretStoreCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertSecretStoreCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSecretStoreDeleteResponseToPorcelain(plumbing *proto.SecretStoreDeleteResponse) (*SecretStoreDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SecretStoreDeleteResponse{}
	if v, err := convertDeleteResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertSecretStoreDeleteResponseToPlumbing(porcelain *SecretStoreDeleteResponse) *proto.SecretStoreDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SecretStoreDeleteResponse{}
	plumbing.Meta = convertDeleteResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedSecretStoreDeleteResponseToPlumbing(
	porcelains []*SecretStoreDeleteResponse,
) []*proto.SecretStoreDeleteResponse {
	var items []*proto.SecretStoreDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertSecretStoreDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSecretStoreDeleteResponseToPorcelain(plumbings []*proto.SecretStoreDeleteResponse) (
	[]*SecretStoreDeleteResponse,
	error,
) {
	var items []*SecretStoreDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertSecretStoreDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSecretStoreGetResponseToPorcelain(plumbing *proto.SecretStoreGetResponse) (*SecretStoreGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SecretStoreGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertSecretStoreToPorcelain(plumbing.SecretStore); err != nil {
		return nil, fmt.Errorf("error converting field SecretStore: %v", err)
	} else {
		porcelain.SecretStore = v
	}
	return porcelain, nil
}

func convertSecretStoreGetResponseToPlumbing(porcelain *SecretStoreGetResponse) *proto.SecretStoreGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SecretStoreGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.SecretStore = convertSecretStoreToPlumbing(porcelain.SecretStore)
	return plumbing
}
func convertRepeatedSecretStoreGetResponseToPlumbing(
	porcelains []*SecretStoreGetResponse,
) []*proto.SecretStoreGetResponse {
	var items []*proto.SecretStoreGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertSecretStoreGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSecretStoreGetResponseToPorcelain(plumbings []*proto.SecretStoreGetResponse) (
	[]*SecretStoreGetResponse,
	error,
) {
	var items []*SecretStoreGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertSecretStoreGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSecretStoreHealthToPorcelain(plumbing *proto.SecretStoreHealth) (*SecretStoreHealth, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SecretStoreHealth{}
	if v, err := convertTimestampToPorcelain(plumbing.ChangedAt); err != nil {
		return nil, fmt.Errorf("error converting field ChangedAt: %v", err)
	} else {
		porcelain.ChangedAt = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.CheckedAt); err != nil {
		return nil, fmt.Errorf("error converting field CheckedAt: %v", err)
	} else {
		porcelain.CheckedAt = v
	}
	porcelain.Error = plumbing.Error
	porcelain.Flags = plumbing.Flags
	porcelain.NodeID = plumbing.NodeId
	porcelain.Reachability = plumbing.Reachability
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Status = plumbing.Status
	return porcelain, nil
}

func convertSecretStoreHealthToPlumbing(porcelain *SecretStoreHealth) *proto.SecretStoreHealth {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SecretStoreHealth{}
	plumbing.ChangedAt = convertTimestampToPlumbing(porcelain.ChangedAt)
	plumbing.CheckedAt = convertTimestampToPlumbing(porcelain.CheckedAt)
	plumbing.Error = (porcelain.Error)
	plumbing.Flags = (porcelain.Flags)
	plumbing.NodeId = (porcelain.NodeID)
	plumbing.Reachability = (porcelain.Reachability)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Status = (porcelain.Status)
	return plumbing
}
func convertRepeatedSecretStoreHealthToPlumbing(
	porcelains []*SecretStoreHealth,
) []*proto.SecretStoreHealth {
	var items []*proto.SecretStoreHealth
	for _, porcelain := range porcelains {
		items = append(items, convertSecretStoreHealthToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSecretStoreHealthToPorcelain(plumbings []*proto.SecretStoreHealth) (
	[]*SecretStoreHealth,
	error,
) {
	var items []*SecretStoreHealth
	for _, plumbing := range plumbings {
		if v, err := convertSecretStoreHealthToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSecretStoreHealthListResponseToPorcelain(plumbing *proto.SecretStoreHealthListResponse) (*SecretStoreHealthListResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SecretStoreHealthListResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertSecretStoreHealthListResponseToPlumbing(porcelain *SecretStoreHealthListResponse) *proto.SecretStoreHealthListResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SecretStoreHealthListResponse{}
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedSecretStoreHealthListResponseToPlumbing(
	porcelains []*SecretStoreHealthListResponse,
) []*proto.SecretStoreHealthListResponse {
	var items []*proto.SecretStoreHealthListResponse
	for _, porcelain := range porcelains {
		items = append(items, convertSecretStoreHealthListResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSecretStoreHealthListResponseToPorcelain(plumbings []*proto.SecretStoreHealthListResponse) (
	[]*SecretStoreHealthListResponse,
	error,
) {
	var items []*SecretStoreHealthListResponse
	for _, plumbing := range plumbings {
		if v, err := convertSecretStoreHealthListResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSecretStoreHealthcheckResponseToPorcelain(plumbing *proto.SecretStoreHealthcheckResponse) (*SecretStoreHealthcheckResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SecretStoreHealthcheckResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertSecretStoreHealthcheckResponseToPlumbing(porcelain *SecretStoreHealthcheckResponse) *proto.SecretStoreHealthcheckResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SecretStoreHealthcheckResponse{}
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedSecretStoreHealthcheckResponseToPlumbing(
	porcelains []*SecretStoreHealthcheckResponse,
) []*proto.SecretStoreHealthcheckResponse {
	var items []*proto.SecretStoreHealthcheckResponse
	for _, porcelain := range porcelains {
		items = append(items, convertSecretStoreHealthcheckResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSecretStoreHealthcheckResponseToPorcelain(plumbings []*proto.SecretStoreHealthcheckResponse) (
	[]*SecretStoreHealthcheckResponse,
	error,
) {
	var items []*SecretStoreHealthcheckResponse
	for _, plumbing := range plumbings {
		if v, err := convertSecretStoreHealthcheckResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSecretStoreHistoryToPorcelain(plumbing *proto.SecretStoreHistory) (*SecretStoreHistory, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SecretStoreHistory{}
	porcelain.ActivityID = plumbing.ActivityId
	if v, err := convertTimestampToPorcelain(plumbing.DeletedAt); err != nil {
		return nil, fmt.Errorf("error converting field DeletedAt: %v", err)
	} else {
		porcelain.DeletedAt = v
	}
	if v, err := convertSecretStoreToPorcelain(plumbing.SecretStore); err != nil {
		return nil, fmt.Errorf("error converting field SecretStore: %v", err)
	} else {
		porcelain.SecretStore = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	return porcelain, nil
}

func convertSecretStoreHistoryToPlumbing(porcelain *SecretStoreHistory) *proto.SecretStoreHistory {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SecretStoreHistory{}
	plumbing.ActivityId = (porcelain.ActivityID)
	plumbing.DeletedAt = convertTimestampToPlumbing(porcelain.DeletedAt)
	plumbing.SecretStore = convertSecretStoreToPlumbing(porcelain.SecretStore)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	return plumbing
}
func convertRepeatedSecretStoreHistoryToPlumbing(
	porcelains []*SecretStoreHistory,
) []*proto.SecretStoreHistory {
	var items []*proto.SecretStoreHistory
	for _, porcelain := range porcelains {
		items = append(items, convertSecretStoreHistoryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSecretStoreHistoryToPorcelain(plumbings []*proto.SecretStoreHistory) (
	[]*SecretStoreHistory,
	error,
) {
	var items []*SecretStoreHistory
	for _, plumbing := range plumbings {
		if v, err := convertSecretStoreHistoryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSecretStoreUpdateResponseToPorcelain(plumbing *proto.SecretStoreUpdateResponse) (*SecretStoreUpdateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SecretStoreUpdateResponse{}
	if v, err := convertUpdateResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertSecretStoreToPorcelain(plumbing.SecretStore); err != nil {
		return nil, fmt.Errorf("error converting field SecretStore: %v", err)
	} else {
		porcelain.SecretStore = v
	}
	return porcelain, nil
}

func convertSecretStoreUpdateResponseToPlumbing(porcelain *SecretStoreUpdateResponse) *proto.SecretStoreUpdateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SecretStoreUpdateResponse{}
	plumbing.Meta = convertUpdateResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.SecretStore = convertSecretStoreToPlumbing(porcelain.SecretStore)
	return plumbing
}
func convertRepeatedSecretStoreUpdateResponseToPlumbing(
	porcelains []*SecretStoreUpdateResponse,
) []*proto.SecretStoreUpdateResponse {
	var items []*proto.SecretStoreUpdateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertSecretStoreUpdateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSecretStoreUpdateResponseToPorcelain(plumbings []*proto.SecretStoreUpdateResponse) (
	[]*SecretStoreUpdateResponse,
	error,
) {
	var items []*SecretStoreUpdateResponse
	for _, plumbing := range plumbings {
		if v, err := convertSecretStoreUpdateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertServiceToPorcelain(plumbing *proto.Service) (*Service, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Service{}
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Suspended = plumbing.Suspended
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertServiceToPlumbing(porcelain *Service) *proto.Service {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Service{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Suspended = (porcelain.Suspended)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedServiceToPlumbing(
	porcelains []*Service,
) []*proto.Service {
	var items []*proto.Service
	for _, porcelain := range porcelains {
		items = append(items, convertServiceToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedServiceToPorcelain(plumbings []*proto.Service) (
	[]*Service,
	error,
) {
	var items []*Service
	for _, plumbing := range plumbings {
		if v, err := convertServiceToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSingleStoreToPorcelain(plumbing *proto.SingleStore) (*SingleStore, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SingleStore{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.RequireNativeAuth = plumbing.RequireNativeAuth
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.UseAzureSingleServerUsernames = plumbing.UseAzureSingleServerUsernames
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertSingleStoreToPlumbing(porcelain *SingleStore) *proto.SingleStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SingleStore{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.RequireNativeAuth = (porcelain.RequireNativeAuth)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.UseAzureSingleServerUsernames = (porcelain.UseAzureSingleServerUsernames)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedSingleStoreToPlumbing(
	porcelains []*SingleStore,
) []*proto.SingleStore {
	var items []*proto.SingleStore
	for _, porcelain := range porcelains {
		items = append(items, convertSingleStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSingleStoreToPorcelain(plumbings []*proto.SingleStore) (
	[]*SingleStore,
	error,
) {
	var items []*SingleStore
	for _, plumbing := range plumbings {
		if v, err := convertSingleStoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSnowflakeToPorcelain(plumbing *proto.Snowflake) (*Snowflake, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Snowflake{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.Schema = plumbing.Schema
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertSnowflakeToPlumbing(porcelain *Snowflake) *proto.Snowflake {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Snowflake{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.Schema = (porcelain.Schema)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedSnowflakeToPlumbing(
	porcelains []*Snowflake,
) []*proto.Snowflake {
	var items []*proto.Snowflake
	for _, porcelain := range porcelains {
		items = append(items, convertSnowflakeToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSnowflakeToPorcelain(plumbings []*proto.Snowflake) (
	[]*Snowflake,
	error,
) {
	var items []*Snowflake
	for _, plumbing := range plumbings {
		if v, err := convertSnowflakeToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSnowsightToPorcelain(plumbing *proto.Snowsight) (*Snowsight, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Snowsight{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.HealthcheckUsername = plumbing.HealthcheckUsername
	porcelain.Healthy = plumbing.Healthy
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SamlMetadata = plumbing.SamlMetadata
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertSnowsightToPlumbing(porcelain *Snowsight) *proto.Snowsight {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Snowsight{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.HealthcheckUsername = (porcelain.HealthcheckUsername)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SamlMetadata = (porcelain.SamlMetadata)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedSnowsightToPlumbing(
	porcelains []*Snowsight,
) []*proto.Snowsight {
	var items []*proto.Snowsight
	for _, porcelain := range porcelains {
		items = append(items, convertSnowsightToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSnowsightToPorcelain(plumbings []*proto.Snowsight) (
	[]*Snowsight,
	error,
) {
	var items []*Snowsight
	for _, plumbing := range plumbings {
		if v, err := convertSnowsightToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSybaseToPorcelain(plumbing *proto.Sybase) (*Sybase, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Sybase{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertSybaseToPlumbing(porcelain *Sybase) *proto.Sybase {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Sybase{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedSybaseToPlumbing(
	porcelains []*Sybase,
) []*proto.Sybase {
	var items []*proto.Sybase
	for _, porcelain := range porcelains {
		items = append(items, convertSybaseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSybaseToPorcelain(plumbings []*proto.Sybase) (
	[]*Sybase,
	error,
) {
	var items []*Sybase
	for _, plumbing := range plumbings {
		if v, err := convertSybaseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertSybaseIQToPorcelain(plumbing *proto.SybaseIQ) (*SybaseIQ, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &SybaseIQ{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertSybaseIQToPlumbing(porcelain *SybaseIQ) *proto.SybaseIQ {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.SybaseIQ{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedSybaseIQToPlumbing(
	porcelains []*SybaseIQ,
) []*proto.SybaseIQ {
	var items []*proto.SybaseIQ
	for _, porcelain := range porcelains {
		items = append(items, convertSybaseIQToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedSybaseIQToPorcelain(plumbings []*proto.SybaseIQ) (
	[]*SybaseIQ,
	error,
) {
	var items []*SybaseIQ
	for _, plumbing := range plumbings {
		if v, err := convertSybaseIQToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertTagToPorcelain(plumbing *proto.Tag) (*Tag, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Tag{}
	porcelain.Name = plumbing.Name
	porcelain.Value = plumbing.Value
	return porcelain, nil
}

func convertTagToPlumbing(porcelain *Tag) *proto.Tag {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Tag{}
	plumbing.Name = (porcelain.Name)
	plumbing.Value = (porcelain.Value)
	return plumbing
}
func convertRepeatedTagToPlumbing(
	porcelains []*Tag,
) []*proto.Tag {
	var items []*proto.Tag
	for _, porcelain := range porcelains {
		items = append(items, convertTagToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedTagToPorcelain(plumbings []*proto.Tag) (
	[]*Tag,
	error,
) {
	var items []*Tag
	for _, plumbing := range plumbings {
		if v, err := convertTagToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertTeradataToPorcelain(plumbing *proto.Teradata) (*Teradata, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Teradata{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertTeradataToPlumbing(porcelain *Teradata) *proto.Teradata {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Teradata{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedTeradataToPlumbing(
	porcelains []*Teradata,
) []*proto.Teradata {
	var items []*proto.Teradata
	for _, porcelain := range porcelains {
		items = append(items, convertTeradataToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedTeradataToPorcelain(plumbings []*proto.Teradata) (
	[]*Teradata,
	error,
) {
	var items []*Teradata
	for _, plumbing := range plumbings {
		if v, err := convertTeradataToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertTokenToPorcelain(plumbing *proto.Token) (*Token, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Token{}
	porcelain.AccountType = plumbing.AccountType
	if v, err := convertTimestampToPorcelain(plumbing.Deadline); err != nil {
		return nil, fmt.Errorf("error converting field Deadline: %v", err)
	} else {
		porcelain.Deadline = v
	}
	if v, err := convertDurationToPorcelain(plumbing.Duration); err != nil {
		return nil, fmt.Errorf("error converting field Duration: %v", err)
	} else {
		porcelain.Duration = v
	}
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Permissions = plumbing.Permissions
	if v, err := convertTimestampToPorcelain(plumbing.Rekeyed); err != nil {
		return nil, fmt.Errorf("error converting field Rekeyed: %v", err)
	} else {
		porcelain.Rekeyed = v
	}
	porcelain.Suspended = plumbing.Suspended
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertTokenToPlumbing(porcelain *Token) *proto.Token {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Token{}
	plumbing.AccountType = (porcelain.AccountType)
	plumbing.Deadline = convertTimestampToPlumbing(porcelain.Deadline)
	plumbing.Duration = convertDurationToPlumbing(porcelain.Duration)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Permissions = (porcelain.Permissions)
	plumbing.Rekeyed = convertTimestampToPlumbing(porcelain.Rekeyed)
	plumbing.Suspended = (porcelain.Suspended)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedTokenToPlumbing(
	porcelains []*Token,
) []*proto.Token {
	var items []*proto.Token
	for _, porcelain := range porcelains {
		items = append(items, convertTokenToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedTokenToPorcelain(plumbings []*proto.Token) (
	[]*Token,
	error,
) {
	var items []*Token
	for _, plumbing := range plumbings {
		if v, err := convertTokenToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertTrinoToPorcelain(plumbing *proto.Trino) (*Trino, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Trino{}
	porcelain.BindInterface = plumbing.BindInterface
	porcelain.Database = plumbing.Database
	porcelain.EgressFilter = plumbing.EgressFilter
	porcelain.Healthy = plumbing.Healthy
	porcelain.Hostname = plumbing.Hostname
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Password = plumbing.Password
	porcelain.Port = plumbing.Port
	porcelain.PortOverride = plumbing.PortOverride
	porcelain.ProxyClusterID = plumbing.ProxyClusterId
	porcelain.SecretStoreID = plumbing.SecretStoreId
	porcelain.Subdomain = plumbing.Subdomain
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	porcelain.Username = plumbing.Username
	return porcelain, nil
}

func convertTrinoToPlumbing(porcelain *Trino) *proto.Trino {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Trino{}
	plumbing.BindInterface = (porcelain.BindInterface)
	plumbing.Database = (porcelain.Database)
	plumbing.EgressFilter = (porcelain.EgressFilter)
	plumbing.Healthy = (porcelain.Healthy)
	plumbing.Hostname = (porcelain.Hostname)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Password = (porcelain.Password)
	plumbing.Port = (porcelain.Port)
	plumbing.PortOverride = (porcelain.PortOverride)
	plumbing.ProxyClusterId = (porcelain.ProxyClusterID)
	plumbing.SecretStoreId = (porcelain.SecretStoreID)
	plumbing.Subdomain = (porcelain.Subdomain)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	plumbing.Username = (porcelain.Username)
	return plumbing
}
func convertRepeatedTrinoToPlumbing(
	porcelains []*Trino,
) []*proto.Trino {
	var items []*proto.Trino
	for _, porcelain := range porcelains {
		items = append(items, convertTrinoToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedTrinoToPorcelain(plumbings []*proto.Trino) (
	[]*Trino,
	error,
) {
	var items []*Trino
	for _, plumbing := range plumbings {
		if v, err := convertTrinoToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertUpdateResponseMetadataToPorcelain(plumbing *proto.UpdateResponseMetadata) (*UpdateResponseMetadata, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &UpdateResponseMetadata{}
	return porcelain, nil
}

func convertUpdateResponseMetadataToPlumbing(porcelain *UpdateResponseMetadata) *proto.UpdateResponseMetadata {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.UpdateResponseMetadata{}
	return plumbing
}
func convertRepeatedUpdateResponseMetadataToPlumbing(
	porcelains []*UpdateResponseMetadata,
) []*proto.UpdateResponseMetadata {
	var items []*proto.UpdateResponseMetadata
	for _, porcelain := range porcelains {
		items = append(items, convertUpdateResponseMetadataToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedUpdateResponseMetadataToPorcelain(plumbings []*proto.UpdateResponseMetadata) (
	[]*UpdateResponseMetadata,
	error,
) {
	var items []*UpdateResponseMetadata
	for _, plumbing := range plumbings {
		if v, err := convertUpdateResponseMetadataToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertUserToPorcelain(plumbing *proto.User) (*User, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &User{}
	porcelain.Email = plumbing.Email
	porcelain.ExternalID = plumbing.ExternalId
	porcelain.FirstName = plumbing.FirstName
	porcelain.ID = plumbing.Id
	porcelain.LastName = plumbing.LastName
	porcelain.ManagedBy = plumbing.ManagedBy
	porcelain.Password = plumbing.Password
	porcelain.PermissionLevel = plumbing.PermissionLevelRW
	porcelain.Suspended = plumbing.SuspendedRO
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertUserToPlumbing(porcelain *User) *proto.User {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.User{}
	plumbing.Email = (porcelain.Email)
	plumbing.ExternalId = (porcelain.ExternalID)
	plumbing.FirstName = (porcelain.FirstName)
	plumbing.Id = (porcelain.ID)
	plumbing.LastName = (porcelain.LastName)
	plumbing.ManagedBy = (porcelain.ManagedBy)
	plumbing.Password = (porcelain.Password)
	plumbing.PermissionLevelRW = (porcelain.PermissionLevel)
	plumbing.SuspendedRO = (porcelain.Suspended)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedUserToPlumbing(
	porcelains []*User,
) []*proto.User {
	var items []*proto.User
	for _, porcelain := range porcelains {
		items = append(items, convertUserToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedUserToPorcelain(plumbings []*proto.User) (
	[]*User,
	error,
) {
	var items []*User
	for _, plumbing := range plumbings {
		if v, err := convertUserToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertVaultAWSEC2StoreToPorcelain(plumbing *proto.VaultAWSEC2Store) (*VaultAWSEC2Store, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &VaultAWSEC2Store{}
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Namespace = plumbing.Namespace
	porcelain.ServerAddress = plumbing.ServerAddress
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertVaultAWSEC2StoreToPlumbing(porcelain *VaultAWSEC2Store) *proto.VaultAWSEC2Store {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.VaultAWSEC2Store{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Namespace = (porcelain.Namespace)
	plumbing.ServerAddress = (porcelain.ServerAddress)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedVaultAWSEC2StoreToPlumbing(
	porcelains []*VaultAWSEC2Store,
) []*proto.VaultAWSEC2Store {
	var items []*proto.VaultAWSEC2Store
	for _, porcelain := range porcelains {
		items = append(items, convertVaultAWSEC2StoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedVaultAWSEC2StoreToPorcelain(plumbings []*proto.VaultAWSEC2Store) (
	[]*VaultAWSEC2Store,
	error,
) {
	var items []*VaultAWSEC2Store
	for _, plumbing := range plumbings {
		if v, err := convertVaultAWSEC2StoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertVaultAWSIAMStoreToPorcelain(plumbing *proto.VaultAWSIAMStore) (*VaultAWSIAMStore, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &VaultAWSIAMStore{}
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Namespace = plumbing.Namespace
	porcelain.ServerAddress = plumbing.ServerAddress
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertVaultAWSIAMStoreToPlumbing(porcelain *VaultAWSIAMStore) *proto.VaultAWSIAMStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.VaultAWSIAMStore{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Namespace = (porcelain.Namespace)
	plumbing.ServerAddress = (porcelain.ServerAddress)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedVaultAWSIAMStoreToPlumbing(
	porcelains []*VaultAWSIAMStore,
) []*proto.VaultAWSIAMStore {
	var items []*proto.VaultAWSIAMStore
	for _, porcelain := range porcelains {
		items = append(items, convertVaultAWSIAMStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedVaultAWSIAMStoreToPorcelain(plumbings []*proto.VaultAWSIAMStore) (
	[]*VaultAWSIAMStore,
	error,
) {
	var items []*VaultAWSIAMStore
	for _, plumbing := range plumbings {
		if v, err := convertVaultAWSIAMStoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertVaultAppRoleCertSSHStoreToPorcelain(plumbing *proto.VaultAppRoleCertSSHStore) (*VaultAppRoleCertSSHStore, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &VaultAppRoleCertSSHStore{}
	porcelain.ID = plumbing.Id
	porcelain.IssuedCertTTLMinutes = plumbing.IssuedCertTTLMinutes
	porcelain.Name = plumbing.Name
	porcelain.Namespace = plumbing.Namespace
	porcelain.ServerAddress = plumbing.ServerAddress
	porcelain.SigningRole = plumbing.SigningRole
	porcelain.SshMountPoint = plumbing.SshMountPoint
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertVaultAppRoleCertSSHStoreToPlumbing(porcelain *VaultAppRoleCertSSHStore) *proto.VaultAppRoleCertSSHStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.VaultAppRoleCertSSHStore{}
	plumbing.Id = (porcelain.ID)
	plumbing.IssuedCertTTLMinutes = (porcelain.IssuedCertTTLMinutes)
	plumbing.Name = (porcelain.Name)
	plumbing.Namespace = (porcelain.Namespace)
	plumbing.ServerAddress = (porcelain.ServerAddress)
	plumbing.SigningRole = (porcelain.SigningRole)
	plumbing.SshMountPoint = (porcelain.SshMountPoint)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedVaultAppRoleCertSSHStoreToPlumbing(
	porcelains []*VaultAppRoleCertSSHStore,
) []*proto.VaultAppRoleCertSSHStore {
	var items []*proto.VaultAppRoleCertSSHStore
	for _, porcelain := range porcelains {
		items = append(items, convertVaultAppRoleCertSSHStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedVaultAppRoleCertSSHStoreToPorcelain(plumbings []*proto.VaultAppRoleCertSSHStore) (
	[]*VaultAppRoleCertSSHStore,
	error,
) {
	var items []*VaultAppRoleCertSSHStore
	for _, plumbing := range plumbings {
		if v, err := convertVaultAppRoleCertSSHStoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertVaultAppRoleCertX509StoreToPorcelain(plumbing *proto.VaultAppRoleCertX509Store) (*VaultAppRoleCertX509Store, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &VaultAppRoleCertX509Store{}
	porcelain.ID = plumbing.Id
	porcelain.IssuedCertTTLMinutes = plumbing.IssuedCertTTLMinutes
	porcelain.Name = plumbing.Name
	porcelain.Namespace = plumbing.Namespace
	porcelain.PkiMountPoint = plumbing.PkiMountPoint
	porcelain.ServerAddress = plumbing.ServerAddress
	porcelain.SigningRole = plumbing.SigningRole
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertVaultAppRoleCertX509StoreToPlumbing(porcelain *VaultAppRoleCertX509Store) *proto.VaultAppRoleCertX509Store {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.VaultAppRoleCertX509Store{}
	plumbing.Id = (porcelain.ID)
	plumbing.IssuedCertTTLMinutes = (porcelain.IssuedCertTTLMinutes)
	plumbing.Name = (porcelain.Name)
	plumbing.Namespace = (porcelain.Namespace)
	plumbing.PkiMountPoint = (porcelain.PkiMountPoint)
	plumbing.ServerAddress = (porcelain.ServerAddress)
	plumbing.SigningRole = (porcelain.SigningRole)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedVaultAppRoleCertX509StoreToPlumbing(
	porcelains []*VaultAppRoleCertX509Store,
) []*proto.VaultAppRoleCertX509Store {
	var items []*proto.VaultAppRoleCertX509Store
	for _, porcelain := range porcelains {
		items = append(items, convertVaultAppRoleCertX509StoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedVaultAppRoleCertX509StoreToPorcelain(plumbings []*proto.VaultAppRoleCertX509Store) (
	[]*VaultAppRoleCertX509Store,
	error,
) {
	var items []*VaultAppRoleCertX509Store
	for _, plumbing := range plumbings {
		if v, err := convertVaultAppRoleCertX509StoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertVaultAppRoleStoreToPorcelain(plumbing *proto.VaultAppRoleStore) (*VaultAppRoleStore, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &VaultAppRoleStore{}
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Namespace = plumbing.Namespace
	porcelain.ServerAddress = plumbing.ServerAddress
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertVaultAppRoleStoreToPlumbing(porcelain *VaultAppRoleStore) *proto.VaultAppRoleStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.VaultAppRoleStore{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Namespace = (porcelain.Namespace)
	plumbing.ServerAddress = (porcelain.ServerAddress)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedVaultAppRoleStoreToPlumbing(
	porcelains []*VaultAppRoleStore,
) []*proto.VaultAppRoleStore {
	var items []*proto.VaultAppRoleStore
	for _, porcelain := range porcelains {
		items = append(items, convertVaultAppRoleStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedVaultAppRoleStoreToPorcelain(plumbings []*proto.VaultAppRoleStore) (
	[]*VaultAppRoleStore,
	error,
) {
	var items []*VaultAppRoleStore
	for _, plumbing := range plumbings {
		if v, err := convertVaultAppRoleStoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertVaultTLSCertSSHStoreToPorcelain(plumbing *proto.VaultTLSCertSSHStore) (*VaultTLSCertSSHStore, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &VaultTLSCertSSHStore{}
	porcelain.CACertPath = plumbing.CACertPath
	porcelain.ClientCertPath = plumbing.ClientCertPath
	porcelain.ClientKeyPath = plumbing.ClientKeyPath
	porcelain.ID = plumbing.Id
	porcelain.IssuedCertTTLMinutes = plumbing.IssuedCertTTLMinutes
	porcelain.Name = plumbing.Name
	porcelain.Namespace = plumbing.Namespace
	porcelain.ServerAddress = plumbing.ServerAddress
	porcelain.SigningRole = plumbing.SigningRole
	porcelain.SshMountPoint = plumbing.SshMountPoint
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertVaultTLSCertSSHStoreToPlumbing(porcelain *VaultTLSCertSSHStore) *proto.VaultTLSCertSSHStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.VaultTLSCertSSHStore{}
	plumbing.CACertPath = (porcelain.CACertPath)
	plumbing.ClientCertPath = (porcelain.ClientCertPath)
	plumbing.ClientKeyPath = (porcelain.ClientKeyPath)
	plumbing.Id = (porcelain.ID)
	plumbing.IssuedCertTTLMinutes = (porcelain.IssuedCertTTLMinutes)
	plumbing.Name = (porcelain.Name)
	plumbing.Namespace = (porcelain.Namespace)
	plumbing.ServerAddress = (porcelain.ServerAddress)
	plumbing.SigningRole = (porcelain.SigningRole)
	plumbing.SshMountPoint = (porcelain.SshMountPoint)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedVaultTLSCertSSHStoreToPlumbing(
	porcelains []*VaultTLSCertSSHStore,
) []*proto.VaultTLSCertSSHStore {
	var items []*proto.VaultTLSCertSSHStore
	for _, porcelain := range porcelains {
		items = append(items, convertVaultTLSCertSSHStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedVaultTLSCertSSHStoreToPorcelain(plumbings []*proto.VaultTLSCertSSHStore) (
	[]*VaultTLSCertSSHStore,
	error,
) {
	var items []*VaultTLSCertSSHStore
	for _, plumbing := range plumbings {
		if v, err := convertVaultTLSCertSSHStoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertVaultTLSCertX509StoreToPorcelain(plumbing *proto.VaultTLSCertX509Store) (*VaultTLSCertX509Store, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &VaultTLSCertX509Store{}
	porcelain.CACertPath = plumbing.CACertPath
	porcelain.ClientCertPath = plumbing.ClientCertPath
	porcelain.ClientKeyPath = plumbing.ClientKeyPath
	porcelain.ID = plumbing.Id
	porcelain.IssuedCertTTLMinutes = plumbing.IssuedCertTTLMinutes
	porcelain.Name = plumbing.Name
	porcelain.Namespace = plumbing.Namespace
	porcelain.PkiMountPoint = plumbing.PkiMountPoint
	porcelain.ServerAddress = plumbing.ServerAddress
	porcelain.SigningRole = plumbing.SigningRole
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertVaultTLSCertX509StoreToPlumbing(porcelain *VaultTLSCertX509Store) *proto.VaultTLSCertX509Store {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.VaultTLSCertX509Store{}
	plumbing.CACertPath = (porcelain.CACertPath)
	plumbing.ClientCertPath = (porcelain.ClientCertPath)
	plumbing.ClientKeyPath = (porcelain.ClientKeyPath)
	plumbing.Id = (porcelain.ID)
	plumbing.IssuedCertTTLMinutes = (porcelain.IssuedCertTTLMinutes)
	plumbing.Name = (porcelain.Name)
	plumbing.Namespace = (porcelain.Namespace)
	plumbing.PkiMountPoint = (porcelain.PkiMountPoint)
	plumbing.ServerAddress = (porcelain.ServerAddress)
	plumbing.SigningRole = (porcelain.SigningRole)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedVaultTLSCertX509StoreToPlumbing(
	porcelains []*VaultTLSCertX509Store,
) []*proto.VaultTLSCertX509Store {
	var items []*proto.VaultTLSCertX509Store
	for _, porcelain := range porcelains {
		items = append(items, convertVaultTLSCertX509StoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedVaultTLSCertX509StoreToPorcelain(plumbings []*proto.VaultTLSCertX509Store) (
	[]*VaultTLSCertX509Store,
	error,
) {
	var items []*VaultTLSCertX509Store
	for _, plumbing := range plumbings {
		if v, err := convertVaultTLSCertX509StoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertVaultTLSStoreToPorcelain(plumbing *proto.VaultTLSStore) (*VaultTLSStore, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &VaultTLSStore{}
	porcelain.CACertPath = plumbing.CACertPath
	porcelain.ClientCertPath = plumbing.ClientCertPath
	porcelain.ClientKeyPath = plumbing.ClientKeyPath
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Namespace = plumbing.Namespace
	porcelain.ServerAddress = plumbing.ServerAddress
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertVaultTLSStoreToPlumbing(porcelain *VaultTLSStore) *proto.VaultTLSStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.VaultTLSStore{}
	plumbing.CACertPath = (porcelain.CACertPath)
	plumbing.ClientCertPath = (porcelain.ClientCertPath)
	plumbing.ClientKeyPath = (porcelain.ClientKeyPath)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Namespace = (porcelain.Namespace)
	plumbing.ServerAddress = (porcelain.ServerAddress)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedVaultTLSStoreToPlumbing(
	porcelains []*VaultTLSStore,
) []*proto.VaultTLSStore {
	var items []*proto.VaultTLSStore
	for _, porcelain := range porcelains {
		items = append(items, convertVaultTLSStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedVaultTLSStoreToPorcelain(plumbings []*proto.VaultTLSStore) (
	[]*VaultTLSStore,
	error,
) {
	var items []*VaultTLSStore
	for _, plumbing := range plumbings {
		if v, err := convertVaultTLSStoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertVaultTokenCertSSHStoreToPorcelain(plumbing *proto.VaultTokenCertSSHStore) (*VaultTokenCertSSHStore, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &VaultTokenCertSSHStore{}
	porcelain.ID = plumbing.Id
	porcelain.IssuedCertTTLMinutes = plumbing.IssuedCertTTLMinutes
	porcelain.Name = plumbing.Name
	porcelain.Namespace = plumbing.Namespace
	porcelain.ServerAddress = plumbing.ServerAddress
	porcelain.SigningRole = plumbing.SigningRole
	porcelain.SshMountPoint = plumbing.SshMountPoint
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertVaultTokenCertSSHStoreToPlumbing(porcelain *VaultTokenCertSSHStore) *proto.VaultTokenCertSSHStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.VaultTokenCertSSHStore{}
	plumbing.Id = (porcelain.ID)
	plumbing.IssuedCertTTLMinutes = (porcelain.IssuedCertTTLMinutes)
	plumbing.Name = (porcelain.Name)
	plumbing.Namespace = (porcelain.Namespace)
	plumbing.ServerAddress = (porcelain.ServerAddress)
	plumbing.SigningRole = (porcelain.SigningRole)
	plumbing.SshMountPoint = (porcelain.SshMountPoint)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedVaultTokenCertSSHStoreToPlumbing(
	porcelains []*VaultTokenCertSSHStore,
) []*proto.VaultTokenCertSSHStore {
	var items []*proto.VaultTokenCertSSHStore
	for _, porcelain := range porcelains {
		items = append(items, convertVaultTokenCertSSHStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedVaultTokenCertSSHStoreToPorcelain(plumbings []*proto.VaultTokenCertSSHStore) (
	[]*VaultTokenCertSSHStore,
	error,
) {
	var items []*VaultTokenCertSSHStore
	for _, plumbing := range plumbings {
		if v, err := convertVaultTokenCertSSHStoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertVaultTokenCertX509StoreToPorcelain(plumbing *proto.VaultTokenCertX509Store) (*VaultTokenCertX509Store, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &VaultTokenCertX509Store{}
	porcelain.ID = plumbing.Id
	porcelain.IssuedCertTTLMinutes = plumbing.IssuedCertTTLMinutes
	porcelain.Name = plumbing.Name
	porcelain.Namespace = plumbing.Namespace
	porcelain.PkiMountPoint = plumbing.PkiMountPoint
	porcelain.ServerAddress = plumbing.ServerAddress
	porcelain.SigningRole = plumbing.SigningRole
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertVaultTokenCertX509StoreToPlumbing(porcelain *VaultTokenCertX509Store) *proto.VaultTokenCertX509Store {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.VaultTokenCertX509Store{}
	plumbing.Id = (porcelain.ID)
	plumbing.IssuedCertTTLMinutes = (porcelain.IssuedCertTTLMinutes)
	plumbing.Name = (porcelain.Name)
	plumbing.Namespace = (porcelain.Namespace)
	plumbing.PkiMountPoint = (porcelain.PkiMountPoint)
	plumbing.ServerAddress = (porcelain.ServerAddress)
	plumbing.SigningRole = (porcelain.SigningRole)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedVaultTokenCertX509StoreToPlumbing(
	porcelains []*VaultTokenCertX509Store,
) []*proto.VaultTokenCertX509Store {
	var items []*proto.VaultTokenCertX509Store
	for _, porcelain := range porcelains {
		items = append(items, convertVaultTokenCertX509StoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedVaultTokenCertX509StoreToPorcelain(plumbings []*proto.VaultTokenCertX509Store) (
	[]*VaultTokenCertX509Store,
	error,
) {
	var items []*VaultTokenCertX509Store
	for _, plumbing := range plumbings {
		if v, err := convertVaultTokenCertX509StoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertVaultTokenStoreToPorcelain(plumbing *proto.VaultTokenStore) (*VaultTokenStore, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &VaultTokenStore{}
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Namespace = plumbing.Namespace
	porcelain.ServerAddress = plumbing.ServerAddress
	if v, err := convertTagsToPorcelain(plumbing.Tags); err != nil {
		return nil, fmt.Errorf("error converting field Tags: %v", err)
	} else {
		porcelain.Tags = v
	}
	return porcelain, nil
}

func convertVaultTokenStoreToPlumbing(porcelain *VaultTokenStore) *proto.VaultTokenStore {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.VaultTokenStore{}
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Namespace = (porcelain.Namespace)
	plumbing.ServerAddress = (porcelain.ServerAddress)
	plumbing.Tags = convertTagsToPlumbing(porcelain.Tags)
	return plumbing
}
func convertRepeatedVaultTokenStoreToPlumbing(
	porcelains []*VaultTokenStore,
) []*proto.VaultTokenStore {
	var items []*proto.VaultTokenStore
	for _, porcelain := range porcelains {
		items = append(items, convertVaultTokenStoreToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedVaultTokenStoreToPorcelain(plumbings []*proto.VaultTokenStore) (
	[]*VaultTokenStore,
	error,
) {
	var items []*VaultTokenStore
	for _, plumbing := range plumbings {
		if v, err := convertVaultTokenStoreToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowToPorcelain(plumbing *proto.Workflow) (*Workflow, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &Workflow{}
	if v, err := convertDurationToPorcelain(plumbing.AccessRequestFixedDuration); err != nil {
		return nil, fmt.Errorf("error converting field AccessRequestFixedDuration: %v", err)
	} else {
		porcelain.AccessRequestFixedDuration = v
	}
	if v, err := convertDurationToPorcelain(plumbing.AccessRequestMaxDuration); err != nil {
		return nil, fmt.Errorf("error converting field AccessRequestMaxDuration: %v", err)
	} else {
		porcelain.AccessRequestMaxDuration = v
	}
	if v, err := convertAccessRulesToPorcelain(plumbing.AccessRules); err != nil {
		return nil, fmt.Errorf("error converting field AccessRules: %v", err)
	} else {
		porcelain.AccessRules = v
	}
	porcelain.ApprovalFlowID = plumbing.ApprovalFlowId
	porcelain.AutoGrant = plumbing.AutoGrant
	porcelain.Description = plumbing.Description
	porcelain.Enabled = plumbing.Enabled
	porcelain.ID = plumbing.Id
	porcelain.Name = plumbing.Name
	porcelain.Weight = plumbing.Weight
	return porcelain, nil
}

func convertWorkflowToPlumbing(porcelain *Workflow) *proto.Workflow {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.Workflow{}
	plumbing.AccessRequestFixedDuration = convertDurationToPlumbing(porcelain.AccessRequestFixedDuration)
	plumbing.AccessRequestMaxDuration = convertDurationToPlumbing(porcelain.AccessRequestMaxDuration)
	plumbing.AccessRules = convertAccessRulesToPlumbing(porcelain.AccessRules)
	plumbing.ApprovalFlowId = (porcelain.ApprovalFlowID)
	plumbing.AutoGrant = (porcelain.AutoGrant)
	plumbing.Description = (porcelain.Description)
	plumbing.Enabled = (porcelain.Enabled)
	plumbing.Id = (porcelain.ID)
	plumbing.Name = (porcelain.Name)
	plumbing.Weight = (porcelain.Weight)
	return plumbing
}
func convertRepeatedWorkflowToPlumbing(
	porcelains []*Workflow,
) []*proto.Workflow {
	var items []*proto.Workflow
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowToPorcelain(plumbings []*proto.Workflow) (
	[]*Workflow,
	error,
) {
	var items []*Workflow
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowApproverToPorcelain(plumbing *proto.WorkflowApprover) (*WorkflowApprover, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowApprover{}
	porcelain.AccountID = plumbing.AccountId
	porcelain.ID = plumbing.Id
	porcelain.RoleID = plumbing.RoleId
	porcelain.WorkflowID = plumbing.WorkflowId
	return porcelain, nil
}

func convertWorkflowApproverToPlumbing(porcelain *WorkflowApprover) *proto.WorkflowApprover {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowApprover{}
	plumbing.AccountId = (porcelain.AccountID)
	plumbing.Id = (porcelain.ID)
	plumbing.RoleId = (porcelain.RoleID)
	plumbing.WorkflowId = (porcelain.WorkflowID)
	return plumbing
}
func convertRepeatedWorkflowApproverToPlumbing(
	porcelains []*WorkflowApprover,
) []*proto.WorkflowApprover {
	var items []*proto.WorkflowApprover
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowApproverToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowApproverToPorcelain(plumbings []*proto.WorkflowApprover) (
	[]*WorkflowApprover,
	error,
) {
	var items []*WorkflowApprover
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowApproverToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowApproverGetResponseToPorcelain(plumbing *proto.WorkflowApproverGetResponse) (*WorkflowApproverGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowApproverGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertWorkflowApproverToPorcelain(plumbing.WorkflowApprover); err != nil {
		return nil, fmt.Errorf("error converting field WorkflowApprover: %v", err)
	} else {
		porcelain.WorkflowApprover = v
	}
	return porcelain, nil
}

func convertWorkflowApproverGetResponseToPlumbing(porcelain *WorkflowApproverGetResponse) *proto.WorkflowApproverGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowApproverGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.WorkflowApprover = convertWorkflowApproverToPlumbing(porcelain.WorkflowApprover)
	return plumbing
}
func convertRepeatedWorkflowApproverGetResponseToPlumbing(
	porcelains []*WorkflowApproverGetResponse,
) []*proto.WorkflowApproverGetResponse {
	var items []*proto.WorkflowApproverGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowApproverGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowApproverGetResponseToPorcelain(plumbings []*proto.WorkflowApproverGetResponse) (
	[]*WorkflowApproverGetResponse,
	error,
) {
	var items []*WorkflowApproverGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowApproverGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowApproverHistoryToPorcelain(plumbing *proto.WorkflowApproverHistory) (*WorkflowApproverHistory, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowApproverHistory{}
	porcelain.ActivityID = plumbing.ActivityId
	if v, err := convertTimestampToPorcelain(plumbing.DeletedAt); err != nil {
		return nil, fmt.Errorf("error converting field DeletedAt: %v", err)
	} else {
		porcelain.DeletedAt = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	if v, err := convertWorkflowApproverToPorcelain(plumbing.WorkflowApprover); err != nil {
		return nil, fmt.Errorf("error converting field WorkflowApprover: %v", err)
	} else {
		porcelain.WorkflowApprover = v
	}
	return porcelain, nil
}

func convertWorkflowApproverHistoryToPlumbing(porcelain *WorkflowApproverHistory) *proto.WorkflowApproverHistory {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowApproverHistory{}
	plumbing.ActivityId = (porcelain.ActivityID)
	plumbing.DeletedAt = convertTimestampToPlumbing(porcelain.DeletedAt)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	plumbing.WorkflowApprover = convertWorkflowApproverToPlumbing(porcelain.WorkflowApprover)
	return plumbing
}
func convertRepeatedWorkflowApproverHistoryToPlumbing(
	porcelains []*WorkflowApproverHistory,
) []*proto.WorkflowApproverHistory {
	var items []*proto.WorkflowApproverHistory
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowApproverHistoryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowApproverHistoryToPorcelain(plumbings []*proto.WorkflowApproverHistory) (
	[]*WorkflowApproverHistory,
	error,
) {
	var items []*WorkflowApproverHistory
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowApproverHistoryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowApproversCreateRequestToPorcelain(plumbing *proto.WorkflowApproversCreateRequest) (*WorkflowApproversCreateRequest, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowApproversCreateRequest{}
	if v, err := convertWorkflowApproverToPorcelain(plumbing.WorkflowApprover); err != nil {
		return nil, fmt.Errorf("error converting field WorkflowApprover: %v", err)
	} else {
		porcelain.WorkflowApprover = v
	}
	return porcelain, nil
}

func convertWorkflowApproversCreateRequestToPlumbing(porcelain *WorkflowApproversCreateRequest) *proto.WorkflowApproversCreateRequest {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowApproversCreateRequest{}
	plumbing.WorkflowApprover = convertWorkflowApproverToPlumbing(porcelain.WorkflowApprover)
	return plumbing
}
func convertRepeatedWorkflowApproversCreateRequestToPlumbing(
	porcelains []*WorkflowApproversCreateRequest,
) []*proto.WorkflowApproversCreateRequest {
	var items []*proto.WorkflowApproversCreateRequest
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowApproversCreateRequestToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowApproversCreateRequestToPorcelain(plumbings []*proto.WorkflowApproversCreateRequest) (
	[]*WorkflowApproversCreateRequest,
	error,
) {
	var items []*WorkflowApproversCreateRequest
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowApproversCreateRequestToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowApproversCreateResponseToPorcelain(plumbing *proto.WorkflowApproversCreateResponse) (*WorkflowApproversCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowApproversCreateResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertWorkflowApproverToPorcelain(plumbing.WorkflowApprover); err != nil {
		return nil, fmt.Errorf("error converting field WorkflowApprover: %v", err)
	} else {
		porcelain.WorkflowApprover = v
	}
	return porcelain, nil
}

func convertWorkflowApproversCreateResponseToPlumbing(porcelain *WorkflowApproversCreateResponse) *proto.WorkflowApproversCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowApproversCreateResponse{}
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.WorkflowApprover = convertWorkflowApproverToPlumbing(porcelain.WorkflowApprover)
	return plumbing
}
func convertRepeatedWorkflowApproversCreateResponseToPlumbing(
	porcelains []*WorkflowApproversCreateResponse,
) []*proto.WorkflowApproversCreateResponse {
	var items []*proto.WorkflowApproversCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowApproversCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowApproversCreateResponseToPorcelain(plumbings []*proto.WorkflowApproversCreateResponse) (
	[]*WorkflowApproversCreateResponse,
	error,
) {
	var items []*WorkflowApproversCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowApproversCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowApproversDeleteRequestToPorcelain(plumbing *proto.WorkflowApproversDeleteRequest) (*WorkflowApproversDeleteRequest, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowApproversDeleteRequest{}
	porcelain.ID = plumbing.Id
	return porcelain, nil
}

func convertWorkflowApproversDeleteRequestToPlumbing(porcelain *WorkflowApproversDeleteRequest) *proto.WorkflowApproversDeleteRequest {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowApproversDeleteRequest{}
	plumbing.Id = (porcelain.ID)
	return plumbing
}
func convertRepeatedWorkflowApproversDeleteRequestToPlumbing(
	porcelains []*WorkflowApproversDeleteRequest,
) []*proto.WorkflowApproversDeleteRequest {
	var items []*proto.WorkflowApproversDeleteRequest
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowApproversDeleteRequestToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowApproversDeleteRequestToPorcelain(plumbings []*proto.WorkflowApproversDeleteRequest) (
	[]*WorkflowApproversDeleteRequest,
	error,
) {
	var items []*WorkflowApproversDeleteRequest
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowApproversDeleteRequestToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowApproversDeleteResponseToPorcelain(plumbing *proto.WorkflowApproversDeleteResponse) (*WorkflowApproversDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowApproversDeleteResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertWorkflowApproversDeleteResponseToPlumbing(porcelain *WorkflowApproversDeleteResponse) *proto.WorkflowApproversDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowApproversDeleteResponse{}
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedWorkflowApproversDeleteResponseToPlumbing(
	porcelains []*WorkflowApproversDeleteResponse,
) []*proto.WorkflowApproversDeleteResponse {
	var items []*proto.WorkflowApproversDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowApproversDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowApproversDeleteResponseToPorcelain(plumbings []*proto.WorkflowApproversDeleteResponse) (
	[]*WorkflowApproversDeleteResponse,
	error,
) {
	var items []*WorkflowApproversDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowApproversDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowApproversListRequestToPorcelain(plumbing *proto.WorkflowApproversListRequest) (*WorkflowApproversListRequest, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowApproversListRequest{}
	porcelain.Filter = plumbing.Filter
	return porcelain, nil
}

func convertWorkflowApproversListRequestToPlumbing(porcelain *WorkflowApproversListRequest) *proto.WorkflowApproversListRequest {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowApproversListRequest{}
	plumbing.Filter = (porcelain.Filter)
	return plumbing
}
func convertRepeatedWorkflowApproversListRequestToPlumbing(
	porcelains []*WorkflowApproversListRequest,
) []*proto.WorkflowApproversListRequest {
	var items []*proto.WorkflowApproversListRequest
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowApproversListRequestToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowApproversListRequestToPorcelain(plumbings []*proto.WorkflowApproversListRequest) (
	[]*WorkflowApproversListRequest,
	error,
) {
	var items []*WorkflowApproversListRequest
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowApproversListRequestToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowApproversListResponseToPorcelain(plumbing *proto.WorkflowApproversListResponse) (*WorkflowApproversListResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowApproversListResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertWorkflowApproversListResponseToPlumbing(porcelain *WorkflowApproversListResponse) *proto.WorkflowApproversListResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowApproversListResponse{}
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedWorkflowApproversListResponseToPlumbing(
	porcelains []*WorkflowApproversListResponse,
) []*proto.WorkflowApproversListResponse {
	var items []*proto.WorkflowApproversListResponse
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowApproversListResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowApproversListResponseToPorcelain(plumbings []*proto.WorkflowApproversListResponse) (
	[]*WorkflowApproversListResponse,
	error,
) {
	var items []*WorkflowApproversListResponse
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowApproversListResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowAssignmentToPorcelain(plumbing *proto.WorkflowAssignment) (*WorkflowAssignment, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowAssignment{}
	porcelain.ResourceID = plumbing.ResourceId
	porcelain.WorkflowID = plumbing.WorkflowId
	return porcelain, nil
}

func convertWorkflowAssignmentToPlumbing(porcelain *WorkflowAssignment) *proto.WorkflowAssignment {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowAssignment{}
	plumbing.ResourceId = (porcelain.ResourceID)
	plumbing.WorkflowId = (porcelain.WorkflowID)
	return plumbing
}
func convertRepeatedWorkflowAssignmentToPlumbing(
	porcelains []*WorkflowAssignment,
) []*proto.WorkflowAssignment {
	var items []*proto.WorkflowAssignment
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowAssignmentToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowAssignmentToPorcelain(plumbings []*proto.WorkflowAssignment) (
	[]*WorkflowAssignment,
	error,
) {
	var items []*WorkflowAssignment
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowAssignmentToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowAssignmentHistoryToPorcelain(plumbing *proto.WorkflowAssignmentHistory) (*WorkflowAssignmentHistory, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowAssignmentHistory{}
	porcelain.ActivityID = plumbing.ActivityId
	if v, err := convertTimestampToPorcelain(plumbing.DeletedAt); err != nil {
		return nil, fmt.Errorf("error converting field DeletedAt: %v", err)
	} else {
		porcelain.DeletedAt = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	if v, err := convertWorkflowAssignmentToPorcelain(plumbing.WorkflowAssignment); err != nil {
		return nil, fmt.Errorf("error converting field WorkflowAssignment: %v", err)
	} else {
		porcelain.WorkflowAssignment = v
	}
	return porcelain, nil
}

func convertWorkflowAssignmentHistoryToPlumbing(porcelain *WorkflowAssignmentHistory) *proto.WorkflowAssignmentHistory {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowAssignmentHistory{}
	plumbing.ActivityId = (porcelain.ActivityID)
	plumbing.DeletedAt = convertTimestampToPlumbing(porcelain.DeletedAt)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	plumbing.WorkflowAssignment = convertWorkflowAssignmentToPlumbing(porcelain.WorkflowAssignment)
	return plumbing
}
func convertRepeatedWorkflowAssignmentHistoryToPlumbing(
	porcelains []*WorkflowAssignmentHistory,
) []*proto.WorkflowAssignmentHistory {
	var items []*proto.WorkflowAssignmentHistory
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowAssignmentHistoryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowAssignmentHistoryToPorcelain(plumbings []*proto.WorkflowAssignmentHistory) (
	[]*WorkflowAssignmentHistory,
	error,
) {
	var items []*WorkflowAssignmentHistory
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowAssignmentHistoryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowAssignmentsListRequestToPorcelain(plumbing *proto.WorkflowAssignmentsListRequest) (*WorkflowAssignmentsListRequest, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowAssignmentsListRequest{}
	porcelain.Filter = plumbing.Filter
	return porcelain, nil
}

func convertWorkflowAssignmentsListRequestToPlumbing(porcelain *WorkflowAssignmentsListRequest) *proto.WorkflowAssignmentsListRequest {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowAssignmentsListRequest{}
	plumbing.Filter = (porcelain.Filter)
	return plumbing
}
func convertRepeatedWorkflowAssignmentsListRequestToPlumbing(
	porcelains []*WorkflowAssignmentsListRequest,
) []*proto.WorkflowAssignmentsListRequest {
	var items []*proto.WorkflowAssignmentsListRequest
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowAssignmentsListRequestToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowAssignmentsListRequestToPorcelain(plumbings []*proto.WorkflowAssignmentsListRequest) (
	[]*WorkflowAssignmentsListRequest,
	error,
) {
	var items []*WorkflowAssignmentsListRequest
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowAssignmentsListRequestToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowAssignmentsListResponseToPorcelain(plumbing *proto.WorkflowAssignmentsListResponse) (*WorkflowAssignmentsListResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowAssignmentsListResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertWorkflowAssignmentsListResponseToPlumbing(porcelain *WorkflowAssignmentsListResponse) *proto.WorkflowAssignmentsListResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowAssignmentsListResponse{}
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedWorkflowAssignmentsListResponseToPlumbing(
	porcelains []*WorkflowAssignmentsListResponse,
) []*proto.WorkflowAssignmentsListResponse {
	var items []*proto.WorkflowAssignmentsListResponse
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowAssignmentsListResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowAssignmentsListResponseToPorcelain(plumbings []*proto.WorkflowAssignmentsListResponse) (
	[]*WorkflowAssignmentsListResponse,
	error,
) {
	var items []*WorkflowAssignmentsListResponse
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowAssignmentsListResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowCreateResponseToPorcelain(plumbing *proto.WorkflowCreateResponse) (*WorkflowCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowCreateResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertWorkflowToPorcelain(plumbing.Workflow); err != nil {
		return nil, fmt.Errorf("error converting field Workflow: %v", err)
	} else {
		porcelain.Workflow = v
	}
	return porcelain, nil
}

func convertWorkflowCreateResponseToPlumbing(porcelain *WorkflowCreateResponse) *proto.WorkflowCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowCreateResponse{}
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.Workflow = convertWorkflowToPlumbing(porcelain.Workflow)
	return plumbing
}
func convertRepeatedWorkflowCreateResponseToPlumbing(
	porcelains []*WorkflowCreateResponse,
) []*proto.WorkflowCreateResponse {
	var items []*proto.WorkflowCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowCreateResponseToPorcelain(plumbings []*proto.WorkflowCreateResponse) (
	[]*WorkflowCreateResponse,
	error,
) {
	var items []*WorkflowCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowDeleteResponseToPorcelain(plumbing *proto.WorkflowDeleteResponse) (*WorkflowDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowDeleteResponse{}
	porcelain.ID = plumbing.Id
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertWorkflowDeleteResponseToPlumbing(porcelain *WorkflowDeleteResponse) *proto.WorkflowDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowDeleteResponse{}
	plumbing.Id = (porcelain.ID)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedWorkflowDeleteResponseToPlumbing(
	porcelains []*WorkflowDeleteResponse,
) []*proto.WorkflowDeleteResponse {
	var items []*proto.WorkflowDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowDeleteResponseToPorcelain(plumbings []*proto.WorkflowDeleteResponse) (
	[]*WorkflowDeleteResponse,
	error,
) {
	var items []*WorkflowDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowGetResponseToPorcelain(plumbing *proto.WorkflowGetResponse) (*WorkflowGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertWorkflowToPorcelain(plumbing.Workflow); err != nil {
		return nil, fmt.Errorf("error converting field Workflow: %v", err)
	} else {
		porcelain.Workflow = v
	}
	return porcelain, nil
}

func convertWorkflowGetResponseToPlumbing(porcelain *WorkflowGetResponse) *proto.WorkflowGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.Workflow = convertWorkflowToPlumbing(porcelain.Workflow)
	return plumbing
}
func convertRepeatedWorkflowGetResponseToPlumbing(
	porcelains []*WorkflowGetResponse,
) []*proto.WorkflowGetResponse {
	var items []*proto.WorkflowGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowGetResponseToPorcelain(plumbings []*proto.WorkflowGetResponse) (
	[]*WorkflowGetResponse,
	error,
) {
	var items []*WorkflowGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowHistoryToPorcelain(plumbing *proto.WorkflowHistory) (*WorkflowHistory, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowHistory{}
	porcelain.ActivityID = plumbing.ActivityId
	if v, err := convertTimestampToPorcelain(plumbing.DeletedAt); err != nil {
		return nil, fmt.Errorf("error converting field DeletedAt: %v", err)
	} else {
		porcelain.DeletedAt = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	if v, err := convertWorkflowToPorcelain(plumbing.Workflow); err != nil {
		return nil, fmt.Errorf("error converting field Workflow: %v", err)
	} else {
		porcelain.Workflow = v
	}
	return porcelain, nil
}

func convertWorkflowHistoryToPlumbing(porcelain *WorkflowHistory) *proto.WorkflowHistory {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowHistory{}
	plumbing.ActivityId = (porcelain.ActivityID)
	plumbing.DeletedAt = convertTimestampToPlumbing(porcelain.DeletedAt)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	plumbing.Workflow = convertWorkflowToPlumbing(porcelain.Workflow)
	return plumbing
}
func convertRepeatedWorkflowHistoryToPlumbing(
	porcelains []*WorkflowHistory,
) []*proto.WorkflowHistory {
	var items []*proto.WorkflowHistory
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowHistoryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowHistoryToPorcelain(plumbings []*proto.WorkflowHistory) (
	[]*WorkflowHistory,
	error,
) {
	var items []*WorkflowHistory
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowHistoryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowListResponseToPorcelain(plumbing *proto.WorkflowListResponse) (*WorkflowListResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowListResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertWorkflowListResponseToPlumbing(porcelain *WorkflowListResponse) *proto.WorkflowListResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowListResponse{}
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedWorkflowListResponseToPlumbing(
	porcelains []*WorkflowListResponse,
) []*proto.WorkflowListResponse {
	var items []*proto.WorkflowListResponse
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowListResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowListResponseToPorcelain(plumbings []*proto.WorkflowListResponse) (
	[]*WorkflowListResponse,
	error,
) {
	var items []*WorkflowListResponse
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowListResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowRoleToPorcelain(plumbing *proto.WorkflowRole) (*WorkflowRole, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowRole{}
	porcelain.ID = plumbing.Id
	porcelain.RoleID = plumbing.RoleId
	porcelain.WorkflowID = plumbing.WorkflowId
	return porcelain, nil
}

func convertWorkflowRoleToPlumbing(porcelain *WorkflowRole) *proto.WorkflowRole {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowRole{}
	plumbing.Id = (porcelain.ID)
	plumbing.RoleId = (porcelain.RoleID)
	plumbing.WorkflowId = (porcelain.WorkflowID)
	return plumbing
}
func convertRepeatedWorkflowRoleToPlumbing(
	porcelains []*WorkflowRole,
) []*proto.WorkflowRole {
	var items []*proto.WorkflowRole
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowRoleToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowRoleToPorcelain(plumbings []*proto.WorkflowRole) (
	[]*WorkflowRole,
	error,
) {
	var items []*WorkflowRole
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowRoleToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowRoleGetResponseToPorcelain(plumbing *proto.WorkflowRoleGetResponse) (*WorkflowRoleGetResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowRoleGetResponse{}
	if v, err := convertGetResponseMetadataToPorcelain(plumbing.Meta); err != nil {
		return nil, fmt.Errorf("error converting field Meta: %v", err)
	} else {
		porcelain.Meta = v
	}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertWorkflowRoleToPorcelain(plumbing.WorkflowRole); err != nil {
		return nil, fmt.Errorf("error converting field WorkflowRole: %v", err)
	} else {
		porcelain.WorkflowRole = v
	}
	return porcelain, nil
}

func convertWorkflowRoleGetResponseToPlumbing(porcelain *WorkflowRoleGetResponse) *proto.WorkflowRoleGetResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowRoleGetResponse{}
	plumbing.Meta = convertGetResponseMetadataToPlumbing(porcelain.Meta)
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.WorkflowRole = convertWorkflowRoleToPlumbing(porcelain.WorkflowRole)
	return plumbing
}
func convertRepeatedWorkflowRoleGetResponseToPlumbing(
	porcelains []*WorkflowRoleGetResponse,
) []*proto.WorkflowRoleGetResponse {
	var items []*proto.WorkflowRoleGetResponse
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowRoleGetResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowRoleGetResponseToPorcelain(plumbings []*proto.WorkflowRoleGetResponse) (
	[]*WorkflowRoleGetResponse,
	error,
) {
	var items []*WorkflowRoleGetResponse
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowRoleGetResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowRoleHistoryToPorcelain(plumbing *proto.WorkflowRoleHistory) (*WorkflowRoleHistory, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowRoleHistory{}
	porcelain.ActivityID = plumbing.ActivityId
	if v, err := convertTimestampToPorcelain(plumbing.DeletedAt); err != nil {
		return nil, fmt.Errorf("error converting field DeletedAt: %v", err)
	} else {
		porcelain.DeletedAt = v
	}
	if v, err := convertTimestampToPorcelain(plumbing.Timestamp); err != nil {
		return nil, fmt.Errorf("error converting field Timestamp: %v", err)
	} else {
		porcelain.Timestamp = v
	}
	if v, err := convertWorkflowRoleToPorcelain(plumbing.WorkflowRole); err != nil {
		return nil, fmt.Errorf("error converting field WorkflowRole: %v", err)
	} else {
		porcelain.WorkflowRole = v
	}
	return porcelain, nil
}

func convertWorkflowRoleHistoryToPlumbing(porcelain *WorkflowRoleHistory) *proto.WorkflowRoleHistory {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowRoleHistory{}
	plumbing.ActivityId = (porcelain.ActivityID)
	plumbing.DeletedAt = convertTimestampToPlumbing(porcelain.DeletedAt)
	plumbing.Timestamp = convertTimestampToPlumbing(porcelain.Timestamp)
	plumbing.WorkflowRole = convertWorkflowRoleToPlumbing(porcelain.WorkflowRole)
	return plumbing
}
func convertRepeatedWorkflowRoleHistoryToPlumbing(
	porcelains []*WorkflowRoleHistory,
) []*proto.WorkflowRoleHistory {
	var items []*proto.WorkflowRoleHistory
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowRoleHistoryToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowRoleHistoryToPorcelain(plumbings []*proto.WorkflowRoleHistory) (
	[]*WorkflowRoleHistory,
	error,
) {
	var items []*WorkflowRoleHistory
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowRoleHistoryToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowRolesCreateRequestToPorcelain(plumbing *proto.WorkflowRolesCreateRequest) (*WorkflowRolesCreateRequest, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowRolesCreateRequest{}
	if v, err := convertWorkflowRoleToPorcelain(plumbing.WorkflowRole); err != nil {
		return nil, fmt.Errorf("error converting field WorkflowRole: %v", err)
	} else {
		porcelain.WorkflowRole = v
	}
	return porcelain, nil
}

func convertWorkflowRolesCreateRequestToPlumbing(porcelain *WorkflowRolesCreateRequest) *proto.WorkflowRolesCreateRequest {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowRolesCreateRequest{}
	plumbing.WorkflowRole = convertWorkflowRoleToPlumbing(porcelain.WorkflowRole)
	return plumbing
}
func convertRepeatedWorkflowRolesCreateRequestToPlumbing(
	porcelains []*WorkflowRolesCreateRequest,
) []*proto.WorkflowRolesCreateRequest {
	var items []*proto.WorkflowRolesCreateRequest
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowRolesCreateRequestToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowRolesCreateRequestToPorcelain(plumbings []*proto.WorkflowRolesCreateRequest) (
	[]*WorkflowRolesCreateRequest,
	error,
) {
	var items []*WorkflowRolesCreateRequest
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowRolesCreateRequestToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowRolesCreateResponseToPorcelain(plumbing *proto.WorkflowRolesCreateResponse) (*WorkflowRolesCreateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowRolesCreateResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertWorkflowRoleToPorcelain(plumbing.WorkflowRole); err != nil {
		return nil, fmt.Errorf("error converting field WorkflowRole: %v", err)
	} else {
		porcelain.WorkflowRole = v
	}
	return porcelain, nil
}

func convertWorkflowRolesCreateResponseToPlumbing(porcelain *WorkflowRolesCreateResponse) *proto.WorkflowRolesCreateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowRolesCreateResponse{}
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.WorkflowRole = convertWorkflowRoleToPlumbing(porcelain.WorkflowRole)
	return plumbing
}
func convertRepeatedWorkflowRolesCreateResponseToPlumbing(
	porcelains []*WorkflowRolesCreateResponse,
) []*proto.WorkflowRolesCreateResponse {
	var items []*proto.WorkflowRolesCreateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowRolesCreateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowRolesCreateResponseToPorcelain(plumbings []*proto.WorkflowRolesCreateResponse) (
	[]*WorkflowRolesCreateResponse,
	error,
) {
	var items []*WorkflowRolesCreateResponse
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowRolesCreateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowRolesDeleteRequestToPorcelain(plumbing *proto.WorkflowRolesDeleteRequest) (*WorkflowRolesDeleteRequest, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowRolesDeleteRequest{}
	porcelain.ID = plumbing.Id
	return porcelain, nil
}

func convertWorkflowRolesDeleteRequestToPlumbing(porcelain *WorkflowRolesDeleteRequest) *proto.WorkflowRolesDeleteRequest {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowRolesDeleteRequest{}
	plumbing.Id = (porcelain.ID)
	return plumbing
}
func convertRepeatedWorkflowRolesDeleteRequestToPlumbing(
	porcelains []*WorkflowRolesDeleteRequest,
) []*proto.WorkflowRolesDeleteRequest {
	var items []*proto.WorkflowRolesDeleteRequest
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowRolesDeleteRequestToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowRolesDeleteRequestToPorcelain(plumbings []*proto.WorkflowRolesDeleteRequest) (
	[]*WorkflowRolesDeleteRequest,
	error,
) {
	var items []*WorkflowRolesDeleteRequest
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowRolesDeleteRequestToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowRolesDeleteResponseToPorcelain(plumbing *proto.WorkflowRolesDeleteResponse) (*WorkflowRolesDeleteResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowRolesDeleteResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertWorkflowRolesDeleteResponseToPlumbing(porcelain *WorkflowRolesDeleteResponse) *proto.WorkflowRolesDeleteResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowRolesDeleteResponse{}
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedWorkflowRolesDeleteResponseToPlumbing(
	porcelains []*WorkflowRolesDeleteResponse,
) []*proto.WorkflowRolesDeleteResponse {
	var items []*proto.WorkflowRolesDeleteResponse
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowRolesDeleteResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowRolesDeleteResponseToPorcelain(plumbings []*proto.WorkflowRolesDeleteResponse) (
	[]*WorkflowRolesDeleteResponse,
	error,
) {
	var items []*WorkflowRolesDeleteResponse
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowRolesDeleteResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowRolesListRequestToPorcelain(plumbing *proto.WorkflowRolesListRequest) (*WorkflowRolesListRequest, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowRolesListRequest{}
	porcelain.Filter = plumbing.Filter
	return porcelain, nil
}

func convertWorkflowRolesListRequestToPlumbing(porcelain *WorkflowRolesListRequest) *proto.WorkflowRolesListRequest {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowRolesListRequest{}
	plumbing.Filter = (porcelain.Filter)
	return plumbing
}
func convertRepeatedWorkflowRolesListRequestToPlumbing(
	porcelains []*WorkflowRolesListRequest,
) []*proto.WorkflowRolesListRequest {
	var items []*proto.WorkflowRolesListRequest
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowRolesListRequestToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowRolesListRequestToPorcelain(plumbings []*proto.WorkflowRolesListRequest) (
	[]*WorkflowRolesListRequest,
	error,
) {
	var items []*WorkflowRolesListRequest
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowRolesListRequestToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowRolesListResponseToPorcelain(plumbing *proto.WorkflowRolesListResponse) (*WorkflowRolesListResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowRolesListResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	return porcelain, nil
}

func convertWorkflowRolesListResponseToPlumbing(porcelain *WorkflowRolesListResponse) *proto.WorkflowRolesListResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowRolesListResponse{}
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	return plumbing
}
func convertRepeatedWorkflowRolesListResponseToPlumbing(
	porcelains []*WorkflowRolesListResponse,
) []*proto.WorkflowRolesListResponse {
	var items []*proto.WorkflowRolesListResponse
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowRolesListResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowRolesListResponseToPorcelain(plumbings []*proto.WorkflowRolesListResponse) (
	[]*WorkflowRolesListResponse,
	error,
) {
	var items []*WorkflowRolesListResponse
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowRolesListResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}
func convertWorkflowUpdateResponseToPorcelain(plumbing *proto.WorkflowUpdateResponse) (*WorkflowUpdateResponse, error) {
	if plumbing == nil {
		return nil, nil
	}
	porcelain := &WorkflowUpdateResponse{}
	if v, err := convertRateLimitMetadataToPorcelain(plumbing.RateLimit); err != nil {
		return nil, fmt.Errorf("error converting field RateLimit: %v", err)
	} else {
		porcelain.RateLimit = v
	}
	if v, err := convertWorkflowToPorcelain(plumbing.Workflow); err != nil {
		return nil, fmt.Errorf("error converting field Workflow: %v", err)
	} else {
		porcelain.Workflow = v
	}
	return porcelain, nil
}

func convertWorkflowUpdateResponseToPlumbing(porcelain *WorkflowUpdateResponse) *proto.WorkflowUpdateResponse {
	if porcelain == nil {
		return nil
	}
	plumbing := &proto.WorkflowUpdateResponse{}
	plumbing.RateLimit = convertRateLimitMetadataToPlumbing(porcelain.RateLimit)
	plumbing.Workflow = convertWorkflowToPlumbing(porcelain.Workflow)
	return plumbing
}
func convertRepeatedWorkflowUpdateResponseToPlumbing(
	porcelains []*WorkflowUpdateResponse,
) []*proto.WorkflowUpdateResponse {
	var items []*proto.WorkflowUpdateResponse
	for _, porcelain := range porcelains {
		items = append(items, convertWorkflowUpdateResponseToPlumbing(porcelain))
	}
	return items
}

func convertRepeatedWorkflowUpdateResponseToPorcelain(plumbings []*proto.WorkflowUpdateResponse) (
	[]*WorkflowUpdateResponse,
	error,
) {
	var items []*WorkflowUpdateResponse
	for _, plumbing := range plumbings {
		if v, err := convertWorkflowUpdateResponseToPorcelain(plumbing); err != nil {
			return nil, err
		} else {
			items = append(items, v)
		}
	}
	return items, nil
}

type rpcError struct {
	wrapped error
	code    int
}

func (e *rpcError) Error() string {
	return e.wrapped.Error()
}

func (e *rpcError) Unwrap() error {
	return e.wrapped
}

func (e *rpcError) Code() int {
	return e.code
}

func convertErrorToPorcelain(err error) error {
	if s, ok := status.FromError(err); ok {
		switch s.Code() {
		case codes.Canceled:
			return &ContextCanceledError{Wrapped: err}
		case codes.DeadlineExceeded:
			return &DeadlineExceededError{Wrapped: err}
		case codes.AlreadyExists:
			return &AlreadyExistsError{Message: s.Message()}
		case codes.NotFound:
			return &NotFoundError{Message: s.Message()}
		case codes.InvalidArgument:
			return &BadRequestError{Message: s.Message()}
		case codes.Unauthenticated:
			return &AuthenticationError{Message: s.Message()}
		case codes.PermissionDenied:
			return &PermissionError{Message: s.Message()}
		case codes.Internal:
			return &InternalError{Message: s.Message()}
		case codes.ResourceExhausted:
			for _, d := range s.Details() {
				if d, ok := d.(*proto.RateLimitMetadata); ok {
					rateLimit, _ := convertRateLimitMetadataToPorcelain(d)
					return &RateLimitError{Message: s.Message(), RateLimit: rateLimit}
				}
			}
		}
		return &rpcError{wrapped: err, code: int(s.Code())}
	}
	return &UnknownError{Wrapped: err}
}

type accessRequestIteratorImplFetchFunc func() (
	[]*AccessRequest,
	bool, error)
type accessRequestIteratorImpl struct {
	buffer      []*AccessRequest
	index       int
	hasNextPage bool
	err         error
	fetch       accessRequestIteratorImplFetchFunc
}

func newAccessRequestIteratorImpl(f accessRequestIteratorImplFetchFunc) *accessRequestIteratorImpl {
	return &accessRequestIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (a *accessRequestIteratorImpl) Next() bool {
	if a.index < len(a.buffer)-1 {
		a.index++
		return true
	}

	// reached end of buffer
	if !a.hasNextPage {
		return false
	}

	a.index = 0
	a.buffer, a.hasNextPage, a.err = a.fetch()
	return len(a.buffer) > 0
}

func (a *accessRequestIteratorImpl) Value() *AccessRequest {
	if a.index >= len(a.buffer) {
		return nil
	}
	return a.buffer[a.index]
}

func (a *accessRequestIteratorImpl) Err() error {
	return a.err
}

type accessRequestEventHistoryIteratorImplFetchFunc func() (
	[]*AccessRequestEventHistory,
	bool, error)
type accessRequestEventHistoryIteratorImpl struct {
	buffer      []*AccessRequestEventHistory
	index       int
	hasNextPage bool
	err         error
	fetch       accessRequestEventHistoryIteratorImplFetchFunc
}

func newAccessRequestEventHistoryIteratorImpl(f accessRequestEventHistoryIteratorImplFetchFunc) *accessRequestEventHistoryIteratorImpl {
	return &accessRequestEventHistoryIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (a *accessRequestEventHistoryIteratorImpl) Next() bool {
	if a.index < len(a.buffer)-1 {
		a.index++
		return true
	}

	// reached end of buffer
	if !a.hasNextPage {
		return false
	}

	a.index = 0
	a.buffer, a.hasNextPage, a.err = a.fetch()
	return len(a.buffer) > 0
}

func (a *accessRequestEventHistoryIteratorImpl) Value() *AccessRequestEventHistory {
	if a.index >= len(a.buffer) {
		return nil
	}
	return a.buffer[a.index]
}

func (a *accessRequestEventHistoryIteratorImpl) Err() error {
	return a.err
}

type accessRequestHistoryIteratorImplFetchFunc func() (
	[]*AccessRequestHistory,
	bool, error)
type accessRequestHistoryIteratorImpl struct {
	buffer      []*AccessRequestHistory
	index       int
	hasNextPage bool
	err         error
	fetch       accessRequestHistoryIteratorImplFetchFunc
}

func newAccessRequestHistoryIteratorImpl(f accessRequestHistoryIteratorImplFetchFunc) *accessRequestHistoryIteratorImpl {
	return &accessRequestHistoryIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (a *accessRequestHistoryIteratorImpl) Next() bool {
	if a.index < len(a.buffer)-1 {
		a.index++
		return true
	}

	// reached end of buffer
	if !a.hasNextPage {
		return false
	}

	a.index = 0
	a.buffer, a.hasNextPage, a.err = a.fetch()
	return len(a.buffer) > 0
}

func (a *accessRequestHistoryIteratorImpl) Value() *AccessRequestHistory {
	if a.index >= len(a.buffer) {
		return nil
	}
	return a.buffer[a.index]
}

func (a *accessRequestHistoryIteratorImpl) Err() error {
	return a.err
}

type accountAttachmentIteratorImplFetchFunc func() (
	[]*AccountAttachment,
	bool, error)
type accountAttachmentIteratorImpl struct {
	buffer      []*AccountAttachment
	index       int
	hasNextPage bool
	err         error
	fetch       accountAttachmentIteratorImplFetchFunc
}

func newAccountAttachmentIteratorImpl(f accountAttachmentIteratorImplFetchFunc) *accountAttachmentIteratorImpl {
	return &accountAttachmentIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (a *accountAttachmentIteratorImpl) Next() bool {
	if a.index < len(a.buffer)-1 {
		a.index++
		return true
	}

	// reached end of buffer
	if !a.hasNextPage {
		return false
	}

	a.index = 0
	a.buffer, a.hasNextPage, a.err = a.fetch()
	return len(a.buffer) > 0
}

func (a *accountAttachmentIteratorImpl) Value() *AccountAttachment {
	if a.index >= len(a.buffer) {
		return nil
	}
	return a.buffer[a.index]
}

func (a *accountAttachmentIteratorImpl) Err() error {
	return a.err
}

type accountAttachmentHistoryIteratorImplFetchFunc func() (
	[]*AccountAttachmentHistory,
	bool, error)
type accountAttachmentHistoryIteratorImpl struct {
	buffer      []*AccountAttachmentHistory
	index       int
	hasNextPage bool
	err         error
	fetch       accountAttachmentHistoryIteratorImplFetchFunc
}

func newAccountAttachmentHistoryIteratorImpl(f accountAttachmentHistoryIteratorImplFetchFunc) *accountAttachmentHistoryIteratorImpl {
	return &accountAttachmentHistoryIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (a *accountAttachmentHistoryIteratorImpl) Next() bool {
	if a.index < len(a.buffer)-1 {
		a.index++
		return true
	}

	// reached end of buffer
	if !a.hasNextPage {
		return false
	}

	a.index = 0
	a.buffer, a.hasNextPage, a.err = a.fetch()
	return len(a.buffer) > 0
}

func (a *accountAttachmentHistoryIteratorImpl) Value() *AccountAttachmentHistory {
	if a.index >= len(a.buffer) {
		return nil
	}
	return a.buffer[a.index]
}

func (a *accountAttachmentHistoryIteratorImpl) Err() error {
	return a.err
}

type accountGrantIteratorImplFetchFunc func() (
	[]*AccountGrant,
	bool, error)
type accountGrantIteratorImpl struct {
	buffer      []*AccountGrant
	index       int
	hasNextPage bool
	err         error
	fetch       accountGrantIteratorImplFetchFunc
}

func newAccountGrantIteratorImpl(f accountGrantIteratorImplFetchFunc) *accountGrantIteratorImpl {
	return &accountGrantIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (a *accountGrantIteratorImpl) Next() bool {
	if a.index < len(a.buffer)-1 {
		a.index++
		return true
	}

	// reached end of buffer
	if !a.hasNextPage {
		return false
	}

	a.index = 0
	a.buffer, a.hasNextPage, a.err = a.fetch()
	return len(a.buffer) > 0
}

func (a *accountGrantIteratorImpl) Value() *AccountGrant {
	if a.index >= len(a.buffer) {
		return nil
	}
	return a.buffer[a.index]
}

func (a *accountGrantIteratorImpl) Err() error {
	return a.err
}

type accountGrantHistoryIteratorImplFetchFunc func() (
	[]*AccountGrantHistory,
	bool, error)
type accountGrantHistoryIteratorImpl struct {
	buffer      []*AccountGrantHistory
	index       int
	hasNextPage bool
	err         error
	fetch       accountGrantHistoryIteratorImplFetchFunc
}

func newAccountGrantHistoryIteratorImpl(f accountGrantHistoryIteratorImplFetchFunc) *accountGrantHistoryIteratorImpl {
	return &accountGrantHistoryIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (a *accountGrantHistoryIteratorImpl) Next() bool {
	if a.index < len(a.buffer)-1 {
		a.index++
		return true
	}

	// reached end of buffer
	if !a.hasNextPage {
		return false
	}

	a.index = 0
	a.buffer, a.hasNextPage, a.err = a.fetch()
	return len(a.buffer) > 0
}

func (a *accountGrantHistoryIteratorImpl) Value() *AccountGrantHistory {
	if a.index >= len(a.buffer) {
		return nil
	}
	return a.buffer[a.index]
}

func (a *accountGrantHistoryIteratorImpl) Err() error {
	return a.err
}

type accountPermissionIteratorImplFetchFunc func() (
	[]*AccountPermission,
	bool, error)
type accountPermissionIteratorImpl struct {
	buffer      []*AccountPermission
	index       int
	hasNextPage bool
	err         error
	fetch       accountPermissionIteratorImplFetchFunc
}

func newAccountPermissionIteratorImpl(f accountPermissionIteratorImplFetchFunc) *accountPermissionIteratorImpl {
	return &accountPermissionIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (a *accountPermissionIteratorImpl) Next() bool {
	if a.index < len(a.buffer)-1 {
		a.index++
		return true
	}

	// reached end of buffer
	if !a.hasNextPage {
		return false
	}

	a.index = 0
	a.buffer, a.hasNextPage, a.err = a.fetch()
	return len(a.buffer) > 0
}

func (a *accountPermissionIteratorImpl) Value() *AccountPermission {
	if a.index >= len(a.buffer) {
		return nil
	}
	return a.buffer[a.index]
}

func (a *accountPermissionIteratorImpl) Err() error {
	return a.err
}

type accountResourceIteratorImplFetchFunc func() (
	[]*AccountResource,
	bool, error)
type accountResourceIteratorImpl struct {
	buffer      []*AccountResource
	index       int
	hasNextPage bool
	err         error
	fetch       accountResourceIteratorImplFetchFunc
}

func newAccountResourceIteratorImpl(f accountResourceIteratorImplFetchFunc) *accountResourceIteratorImpl {
	return &accountResourceIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (a *accountResourceIteratorImpl) Next() bool {
	if a.index < len(a.buffer)-1 {
		a.index++
		return true
	}

	// reached end of buffer
	if !a.hasNextPage {
		return false
	}

	a.index = 0
	a.buffer, a.hasNextPage, a.err = a.fetch()
	return len(a.buffer) > 0
}

func (a *accountResourceIteratorImpl) Value() *AccountResource {
	if a.index >= len(a.buffer) {
		return nil
	}
	return a.buffer[a.index]
}

func (a *accountResourceIteratorImpl) Err() error {
	return a.err
}

type accountResourceHistoryIteratorImplFetchFunc func() (
	[]*AccountResourceHistory,
	bool, error)
type accountResourceHistoryIteratorImpl struct {
	buffer      []*AccountResourceHistory
	index       int
	hasNextPage bool
	err         error
	fetch       accountResourceHistoryIteratorImplFetchFunc
}

func newAccountResourceHistoryIteratorImpl(f accountResourceHistoryIteratorImplFetchFunc) *accountResourceHistoryIteratorImpl {
	return &accountResourceHistoryIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (a *accountResourceHistoryIteratorImpl) Next() bool {
	if a.index < len(a.buffer)-1 {
		a.index++
		return true
	}

	// reached end of buffer
	if !a.hasNextPage {
		return false
	}

	a.index = 0
	a.buffer, a.hasNextPage, a.err = a.fetch()
	return len(a.buffer) > 0
}

func (a *accountResourceHistoryIteratorImpl) Value() *AccountResourceHistory {
	if a.index >= len(a.buffer) {
		return nil
	}
	return a.buffer[a.index]
}

func (a *accountResourceHistoryIteratorImpl) Err() error {
	return a.err
}

type accountIteratorImplFetchFunc func() (
	[]Account,
	bool, error)
type accountIteratorImpl struct {
	buffer      []Account
	index       int
	hasNextPage bool
	err         error
	fetch       accountIteratorImplFetchFunc
}

func newAccountIteratorImpl(f accountIteratorImplFetchFunc) *accountIteratorImpl {
	return &accountIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (a *accountIteratorImpl) Next() bool {
	if a.index < len(a.buffer)-1 {
		a.index++
		return true
	}

	// reached end of buffer
	if !a.hasNextPage {
		return false
	}

	a.index = 0
	a.buffer, a.hasNextPage, a.err = a.fetch()
	return len(a.buffer) > 0
}

func (a *accountIteratorImpl) Value() Account {
	if a.index >= len(a.buffer) {
		return nil
	}
	return a.buffer[a.index]
}

func (a *accountIteratorImpl) Err() error {
	return a.err
}

type accountHistoryIteratorImplFetchFunc func() (
	[]*AccountHistory,
	bool, error)
type accountHistoryIteratorImpl struct {
	buffer      []*AccountHistory
	index       int
	hasNextPage bool
	err         error
	fetch       accountHistoryIteratorImplFetchFunc
}

func newAccountHistoryIteratorImpl(f accountHistoryIteratorImplFetchFunc) *accountHistoryIteratorImpl {
	return &accountHistoryIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (a *accountHistoryIteratorImpl) Next() bool {
	if a.index < len(a.buffer)-1 {
		a.index++
		return true
	}

	// reached end of buffer
	if !a.hasNextPage {
		return false
	}

	a.index = 0
	a.buffer, a.hasNextPage, a.err = a.fetch()
	return len(a.buffer) > 0
}

func (a *accountHistoryIteratorImpl) Value() *AccountHistory {
	if a.index >= len(a.buffer) {
		return nil
	}
	return a.buffer[a.index]
}

func (a *accountHistoryIteratorImpl) Err() error {
	return a.err
}

type activityIteratorImplFetchFunc func() (
	[]*Activity,
	bool, error)
type activityIteratorImpl struct {
	buffer      []*Activity
	index       int
	hasNextPage bool
	err         error
	fetch       activityIteratorImplFetchFunc
}

func newActivityIteratorImpl(f activityIteratorImplFetchFunc) *activityIteratorImpl {
	return &activityIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (a *activityIteratorImpl) Next() bool {
	if a.index < len(a.buffer)-1 {
		a.index++
		return true
	}

	// reached end of buffer
	if !a.hasNextPage {
		return false
	}

	a.index = 0
	a.buffer, a.hasNextPage, a.err = a.fetch()
	return len(a.buffer) > 0
}

func (a *activityIteratorImpl) Value() *Activity {
	if a.index >= len(a.buffer) {
		return nil
	}
	return a.buffer[a.index]
}

func (a *activityIteratorImpl) Err() error {
	return a.err
}

type approvalWorkflowApproverIteratorImplFetchFunc func() (
	[]*ApprovalWorkflowApprover,
	bool, error)
type approvalWorkflowApproverIteratorImpl struct {
	buffer      []*ApprovalWorkflowApprover
	index       int
	hasNextPage bool
	err         error
	fetch       approvalWorkflowApproverIteratorImplFetchFunc
}

func newApprovalWorkflowApproverIteratorImpl(f approvalWorkflowApproverIteratorImplFetchFunc) *approvalWorkflowApproverIteratorImpl {
	return &approvalWorkflowApproverIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (a *approvalWorkflowApproverIteratorImpl) Next() bool {
	if a.index < len(a.buffer)-1 {
		a.index++
		return true
	}

	// reached end of buffer
	if !a.hasNextPage {
		return false
	}

	a.index = 0
	a.buffer, a.hasNextPage, a.err = a.fetch()
	return len(a.buffer) > 0
}

func (a *approvalWorkflowApproverIteratorImpl) Value() *ApprovalWorkflowApprover {
	if a.index >= len(a.buffer) {
		return nil
	}
	return a.buffer[a.index]
}

func (a *approvalWorkflowApproverIteratorImpl) Err() error {
	return a.err
}

type approvalWorkflowApproverHistoryIteratorImplFetchFunc func() (
	[]*ApprovalWorkflowApproverHistory,
	bool, error)
type approvalWorkflowApproverHistoryIteratorImpl struct {
	buffer      []*ApprovalWorkflowApproverHistory
	index       int
	hasNextPage bool
	err         error
	fetch       approvalWorkflowApproverHistoryIteratorImplFetchFunc
}

func newApprovalWorkflowApproverHistoryIteratorImpl(f approvalWorkflowApproverHistoryIteratorImplFetchFunc) *approvalWorkflowApproverHistoryIteratorImpl {
	return &approvalWorkflowApproverHistoryIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (a *approvalWorkflowApproverHistoryIteratorImpl) Next() bool {
	if a.index < len(a.buffer)-1 {
		a.index++
		return true
	}

	// reached end of buffer
	if !a.hasNextPage {
		return false
	}

	a.index = 0
	a.buffer, a.hasNextPage, a.err = a.fetch()
	return len(a.buffer) > 0
}

func (a *approvalWorkflowApproverHistoryIteratorImpl) Value() *ApprovalWorkflowApproverHistory {
	if a.index >= len(a.buffer) {
		return nil
	}
	return a.buffer[a.index]
}

func (a *approvalWorkflowApproverHistoryIteratorImpl) Err() error {
	return a.err
}

type approvalWorkflowStepIteratorImplFetchFunc func() (
	[]*ApprovalWorkflowStep,
	bool, error)
type approvalWorkflowStepIteratorImpl struct {
	buffer      []*ApprovalWorkflowStep
	index       int
	hasNextPage bool
	err         error
	fetch       approvalWorkflowStepIteratorImplFetchFunc
}

func newApprovalWorkflowStepIteratorImpl(f approvalWorkflowStepIteratorImplFetchFunc) *approvalWorkflowStepIteratorImpl {
	return &approvalWorkflowStepIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (a *approvalWorkflowStepIteratorImpl) Next() bool {
	if a.index < len(a.buffer)-1 {
		a.index++
		return true
	}

	// reached end of buffer
	if !a.hasNextPage {
		return false
	}

	a.index = 0
	a.buffer, a.hasNextPage, a.err = a.fetch()
	return len(a.buffer) > 0
}

func (a *approvalWorkflowStepIteratorImpl) Value() *ApprovalWorkflowStep {
	if a.index >= len(a.buffer) {
		return nil
	}
	return a.buffer[a.index]
}

func (a *approvalWorkflowStepIteratorImpl) Err() error {
	return a.err
}

type approvalWorkflowStepHistoryIteratorImplFetchFunc func() (
	[]*ApprovalWorkflowStepHistory,
	bool, error)
type approvalWorkflowStepHistoryIteratorImpl struct {
	buffer      []*ApprovalWorkflowStepHistory
	index       int
	hasNextPage bool
	err         error
	fetch       approvalWorkflowStepHistoryIteratorImplFetchFunc
}

func newApprovalWorkflowStepHistoryIteratorImpl(f approvalWorkflowStepHistoryIteratorImplFetchFunc) *approvalWorkflowStepHistoryIteratorImpl {
	return &approvalWorkflowStepHistoryIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (a *approvalWorkflowStepHistoryIteratorImpl) Next() bool {
	if a.index < len(a.buffer)-1 {
		a.index++
		return true
	}

	// reached end of buffer
	if !a.hasNextPage {
		return false
	}

	a.index = 0
	a.buffer, a.hasNextPage, a.err = a.fetch()
	return len(a.buffer) > 0
}

func (a *approvalWorkflowStepHistoryIteratorImpl) Value() *ApprovalWorkflowStepHistory {
	if a.index >= len(a.buffer) {
		return nil
	}
	return a.buffer[a.index]
}

func (a *approvalWorkflowStepHistoryIteratorImpl) Err() error {
	return a.err
}

type approvalWorkflowIteratorImplFetchFunc func() (
	[]*ApprovalWorkflow,
	bool, error)
type approvalWorkflowIteratorImpl struct {
	buffer      []*ApprovalWorkflow
	index       int
	hasNextPage bool
	err         error
	fetch       approvalWorkflowIteratorImplFetchFunc
}

func newApprovalWorkflowIteratorImpl(f approvalWorkflowIteratorImplFetchFunc) *approvalWorkflowIteratorImpl {
	return &approvalWorkflowIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (a *approvalWorkflowIteratorImpl) Next() bool {
	if a.index < len(a.buffer)-1 {
		a.index++
		return true
	}

	// reached end of buffer
	if !a.hasNextPage {
		return false
	}

	a.index = 0
	a.buffer, a.hasNextPage, a.err = a.fetch()
	return len(a.buffer) > 0
}

func (a *approvalWorkflowIteratorImpl) Value() *ApprovalWorkflow {
	if a.index >= len(a.buffer) {
		return nil
	}
	return a.buffer[a.index]
}

func (a *approvalWorkflowIteratorImpl) Err() error {
	return a.err
}

type approvalWorkflowHistoryIteratorImplFetchFunc func() (
	[]*ApprovalWorkflowHistory,
	bool, error)
type approvalWorkflowHistoryIteratorImpl struct {
	buffer      []*ApprovalWorkflowHistory
	index       int
	hasNextPage bool
	err         error
	fetch       approvalWorkflowHistoryIteratorImplFetchFunc
}

func newApprovalWorkflowHistoryIteratorImpl(f approvalWorkflowHistoryIteratorImplFetchFunc) *approvalWorkflowHistoryIteratorImpl {
	return &approvalWorkflowHistoryIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (a *approvalWorkflowHistoryIteratorImpl) Next() bool {
	if a.index < len(a.buffer)-1 {
		a.index++
		return true
	}

	// reached end of buffer
	if !a.hasNextPage {
		return false
	}

	a.index = 0
	a.buffer, a.hasNextPage, a.err = a.fetch()
	return len(a.buffer) > 0
}

func (a *approvalWorkflowHistoryIteratorImpl) Value() *ApprovalWorkflowHistory {
	if a.index >= len(a.buffer) {
		return nil
	}
	return a.buffer[a.index]
}

func (a *approvalWorkflowHistoryIteratorImpl) Err() error {
	return a.err
}

type healthcheckIteratorImplFetchFunc func() (
	[]*Healthcheck,
	bool, error)
type healthcheckIteratorImpl struct {
	buffer      []*Healthcheck
	index       int
	hasNextPage bool
	err         error
	fetch       healthcheckIteratorImplFetchFunc
}

func newHealthcheckIteratorImpl(f healthcheckIteratorImplFetchFunc) *healthcheckIteratorImpl {
	return &healthcheckIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (h *healthcheckIteratorImpl) Next() bool {
	if h.index < len(h.buffer)-1 {
		h.index++
		return true
	}

	// reached end of buffer
	if !h.hasNextPage {
		return false
	}

	h.index = 0
	h.buffer, h.hasNextPage, h.err = h.fetch()
	return len(h.buffer) > 0
}

func (h *healthcheckIteratorImpl) Value() *Healthcheck {
	if h.index >= len(h.buffer) {
		return nil
	}
	return h.buffer[h.index]
}

func (h *healthcheckIteratorImpl) Err() error {
	return h.err
}

type identityAliasIteratorImplFetchFunc func() (
	[]*IdentityAlias,
	bool, error)
type identityAliasIteratorImpl struct {
	buffer      []*IdentityAlias
	index       int
	hasNextPage bool
	err         error
	fetch       identityAliasIteratorImplFetchFunc
}

func newIdentityAliasIteratorImpl(f identityAliasIteratorImplFetchFunc) *identityAliasIteratorImpl {
	return &identityAliasIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (i *identityAliasIteratorImpl) Next() bool {
	if i.index < len(i.buffer)-1 {
		i.index++
		return true
	}

	// reached end of buffer
	if !i.hasNextPage {
		return false
	}

	i.index = 0
	i.buffer, i.hasNextPage, i.err = i.fetch()
	return len(i.buffer) > 0
}

func (i *identityAliasIteratorImpl) Value() *IdentityAlias {
	if i.index >= len(i.buffer) {
		return nil
	}
	return i.buffer[i.index]
}

func (i *identityAliasIteratorImpl) Err() error {
	return i.err
}

type identityAliasHistoryIteratorImplFetchFunc func() (
	[]*IdentityAliasHistory,
	bool, error)
type identityAliasHistoryIteratorImpl struct {
	buffer      []*IdentityAliasHistory
	index       int
	hasNextPage bool
	err         error
	fetch       identityAliasHistoryIteratorImplFetchFunc
}

func newIdentityAliasHistoryIteratorImpl(f identityAliasHistoryIteratorImplFetchFunc) *identityAliasHistoryIteratorImpl {
	return &identityAliasHistoryIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (i *identityAliasHistoryIteratorImpl) Next() bool {
	if i.index < len(i.buffer)-1 {
		i.index++
		return true
	}

	// reached end of buffer
	if !i.hasNextPage {
		return false
	}

	i.index = 0
	i.buffer, i.hasNextPage, i.err = i.fetch()
	return len(i.buffer) > 0
}

func (i *identityAliasHistoryIteratorImpl) Value() *IdentityAliasHistory {
	if i.index >= len(i.buffer) {
		return nil
	}
	return i.buffer[i.index]
}

func (i *identityAliasHistoryIteratorImpl) Err() error {
	return i.err
}

type identitySetIteratorImplFetchFunc func() (
	[]*IdentitySet,
	bool, error)
type identitySetIteratorImpl struct {
	buffer      []*IdentitySet
	index       int
	hasNextPage bool
	err         error
	fetch       identitySetIteratorImplFetchFunc
}

func newIdentitySetIteratorImpl(f identitySetIteratorImplFetchFunc) *identitySetIteratorImpl {
	return &identitySetIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (i *identitySetIteratorImpl) Next() bool {
	if i.index < len(i.buffer)-1 {
		i.index++
		return true
	}

	// reached end of buffer
	if !i.hasNextPage {
		return false
	}

	i.index = 0
	i.buffer, i.hasNextPage, i.err = i.fetch()
	return len(i.buffer) > 0
}

func (i *identitySetIteratorImpl) Value() *IdentitySet {
	if i.index >= len(i.buffer) {
		return nil
	}
	return i.buffer[i.index]
}

func (i *identitySetIteratorImpl) Err() error {
	return i.err
}

type identitySetHistoryIteratorImplFetchFunc func() (
	[]*IdentitySetHistory,
	bool, error)
type identitySetHistoryIteratorImpl struct {
	buffer      []*IdentitySetHistory
	index       int
	hasNextPage bool
	err         error
	fetch       identitySetHistoryIteratorImplFetchFunc
}

func newIdentitySetHistoryIteratorImpl(f identitySetHistoryIteratorImplFetchFunc) *identitySetHistoryIteratorImpl {
	return &identitySetHistoryIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (i *identitySetHistoryIteratorImpl) Next() bool {
	if i.index < len(i.buffer)-1 {
		i.index++
		return true
	}

	// reached end of buffer
	if !i.hasNextPage {
		return false
	}

	i.index = 0
	i.buffer, i.hasNextPage, i.err = i.fetch()
	return len(i.buffer) > 0
}

func (i *identitySetHistoryIteratorImpl) Value() *IdentitySetHistory {
	if i.index >= len(i.buffer) {
		return nil
	}
	return i.buffer[i.index]
}

func (i *identitySetHistoryIteratorImpl) Err() error {
	return i.err
}

type nodeIteratorImplFetchFunc func() (
	[]Node,
	bool, error)
type nodeIteratorImpl struct {
	buffer      []Node
	index       int
	hasNextPage bool
	err         error
	fetch       nodeIteratorImplFetchFunc
}

func newNodeIteratorImpl(f nodeIteratorImplFetchFunc) *nodeIteratorImpl {
	return &nodeIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (n *nodeIteratorImpl) Next() bool {
	if n.index < len(n.buffer)-1 {
		n.index++
		return true
	}

	// reached end of buffer
	if !n.hasNextPage {
		return false
	}

	n.index = 0
	n.buffer, n.hasNextPage, n.err = n.fetch()
	return len(n.buffer) > 0
}

func (n *nodeIteratorImpl) Value() Node {
	if n.index >= len(n.buffer) {
		return nil
	}
	return n.buffer[n.index]
}

func (n *nodeIteratorImpl) Err() error {
	return n.err
}

type nodeHistoryIteratorImplFetchFunc func() (
	[]*NodeHistory,
	bool, error)
type nodeHistoryIteratorImpl struct {
	buffer      []*NodeHistory
	index       int
	hasNextPage bool
	err         error
	fetch       nodeHistoryIteratorImplFetchFunc
}

func newNodeHistoryIteratorImpl(f nodeHistoryIteratorImplFetchFunc) *nodeHistoryIteratorImpl {
	return &nodeHistoryIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (n *nodeHistoryIteratorImpl) Next() bool {
	if n.index < len(n.buffer)-1 {
		n.index++
		return true
	}

	// reached end of buffer
	if !n.hasNextPage {
		return false
	}

	n.index = 0
	n.buffer, n.hasNextPage, n.err = n.fetch()
	return len(n.buffer) > 0
}

func (n *nodeHistoryIteratorImpl) Value() *NodeHistory {
	if n.index >= len(n.buffer) {
		return nil
	}
	return n.buffer[n.index]
}

func (n *nodeHistoryIteratorImpl) Err() error {
	return n.err
}

type organizationHistoryRecordIteratorImplFetchFunc func() (
	[]*OrganizationHistoryRecord,
	bool, error)
type organizationHistoryRecordIteratorImpl struct {
	buffer      []*OrganizationHistoryRecord
	index       int
	hasNextPage bool
	err         error
	fetch       organizationHistoryRecordIteratorImplFetchFunc
}

func newOrganizationHistoryRecordIteratorImpl(f organizationHistoryRecordIteratorImplFetchFunc) *organizationHistoryRecordIteratorImpl {
	return &organizationHistoryRecordIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (o *organizationHistoryRecordIteratorImpl) Next() bool {
	if o.index < len(o.buffer)-1 {
		o.index++
		return true
	}

	// reached end of buffer
	if !o.hasNextPage {
		return false
	}

	o.index = 0
	o.buffer, o.hasNextPage, o.err = o.fetch()
	return len(o.buffer) > 0
}

func (o *organizationHistoryRecordIteratorImpl) Value() *OrganizationHistoryRecord {
	if o.index >= len(o.buffer) {
		return nil
	}
	return o.buffer[o.index]
}

func (o *organizationHistoryRecordIteratorImpl) Err() error {
	return o.err
}

type peeringGroupNodeIteratorImplFetchFunc func() (
	[]*PeeringGroupNode,
	bool, error)
type peeringGroupNodeIteratorImpl struct {
	buffer      []*PeeringGroupNode
	index       int
	hasNextPage bool
	err         error
	fetch       peeringGroupNodeIteratorImplFetchFunc
}

func newPeeringGroupNodeIteratorImpl(f peeringGroupNodeIteratorImplFetchFunc) *peeringGroupNodeIteratorImpl {
	return &peeringGroupNodeIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (p *peeringGroupNodeIteratorImpl) Next() bool {
	if p.index < len(p.buffer)-1 {
		p.index++
		return true
	}

	// reached end of buffer
	if !p.hasNextPage {
		return false
	}

	p.index = 0
	p.buffer, p.hasNextPage, p.err = p.fetch()
	return len(p.buffer) > 0
}

func (p *peeringGroupNodeIteratorImpl) Value() *PeeringGroupNode {
	if p.index >= len(p.buffer) {
		return nil
	}
	return p.buffer[p.index]
}

func (p *peeringGroupNodeIteratorImpl) Err() error {
	return p.err
}

type peeringGroupPeerIteratorImplFetchFunc func() (
	[]*PeeringGroupPeer,
	bool, error)
type peeringGroupPeerIteratorImpl struct {
	buffer      []*PeeringGroupPeer
	index       int
	hasNextPage bool
	err         error
	fetch       peeringGroupPeerIteratorImplFetchFunc
}

func newPeeringGroupPeerIteratorImpl(f peeringGroupPeerIteratorImplFetchFunc) *peeringGroupPeerIteratorImpl {
	return &peeringGroupPeerIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (p *peeringGroupPeerIteratorImpl) Next() bool {
	if p.index < len(p.buffer)-1 {
		p.index++
		return true
	}

	// reached end of buffer
	if !p.hasNextPage {
		return false
	}

	p.index = 0
	p.buffer, p.hasNextPage, p.err = p.fetch()
	return len(p.buffer) > 0
}

func (p *peeringGroupPeerIteratorImpl) Value() *PeeringGroupPeer {
	if p.index >= len(p.buffer) {
		return nil
	}
	return p.buffer[p.index]
}

func (p *peeringGroupPeerIteratorImpl) Err() error {
	return p.err
}

type peeringGroupResourceIteratorImplFetchFunc func() (
	[]*PeeringGroupResource,
	bool, error)
type peeringGroupResourceIteratorImpl struct {
	buffer      []*PeeringGroupResource
	index       int
	hasNextPage bool
	err         error
	fetch       peeringGroupResourceIteratorImplFetchFunc
}

func newPeeringGroupResourceIteratorImpl(f peeringGroupResourceIteratorImplFetchFunc) *peeringGroupResourceIteratorImpl {
	return &peeringGroupResourceIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (p *peeringGroupResourceIteratorImpl) Next() bool {
	if p.index < len(p.buffer)-1 {
		p.index++
		return true
	}

	// reached end of buffer
	if !p.hasNextPage {
		return false
	}

	p.index = 0
	p.buffer, p.hasNextPage, p.err = p.fetch()
	return len(p.buffer) > 0
}

func (p *peeringGroupResourceIteratorImpl) Value() *PeeringGroupResource {
	if p.index >= len(p.buffer) {
		return nil
	}
	return p.buffer[p.index]
}

func (p *peeringGroupResourceIteratorImpl) Err() error {
	return p.err
}

type peeringGroupIteratorImplFetchFunc func() (
	[]*PeeringGroup,
	bool, error)
type peeringGroupIteratorImpl struct {
	buffer      []*PeeringGroup
	index       int
	hasNextPage bool
	err         error
	fetch       peeringGroupIteratorImplFetchFunc
}

func newPeeringGroupIteratorImpl(f peeringGroupIteratorImplFetchFunc) *peeringGroupIteratorImpl {
	return &peeringGroupIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (p *peeringGroupIteratorImpl) Next() bool {
	if p.index < len(p.buffer)-1 {
		p.index++
		return true
	}

	// reached end of buffer
	if !p.hasNextPage {
		return false
	}

	p.index = 0
	p.buffer, p.hasNextPage, p.err = p.fetch()
	return len(p.buffer) > 0
}

func (p *peeringGroupIteratorImpl) Value() *PeeringGroup {
	if p.index >= len(p.buffer) {
		return nil
	}
	return p.buffer[p.index]
}

func (p *peeringGroupIteratorImpl) Err() error {
	return p.err
}

type policyIteratorImplFetchFunc func() (
	[]*Policy,
	bool, error)
type policyIteratorImpl struct {
	buffer      []*Policy
	index       int
	hasNextPage bool
	err         error
	fetch       policyIteratorImplFetchFunc
}

func newPolicyIteratorImpl(f policyIteratorImplFetchFunc) *policyIteratorImpl {
	return &policyIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (p *policyIteratorImpl) Next() bool {
	if p.index < len(p.buffer)-1 {
		p.index++
		return true
	}

	// reached end of buffer
	if !p.hasNextPage {
		return false
	}

	p.index = 0
	p.buffer, p.hasNextPage, p.err = p.fetch()
	return len(p.buffer) > 0
}

func (p *policyIteratorImpl) Value() *Policy {
	if p.index >= len(p.buffer) {
		return nil
	}
	return p.buffer[p.index]
}

func (p *policyIteratorImpl) Err() error {
	return p.err
}

type policyHistoryIteratorImplFetchFunc func() (
	[]*PolicyHistory,
	bool, error)
type policyHistoryIteratorImpl struct {
	buffer      []*PolicyHistory
	index       int
	hasNextPage bool
	err         error
	fetch       policyHistoryIteratorImplFetchFunc
}

func newPolicyHistoryIteratorImpl(f policyHistoryIteratorImplFetchFunc) *policyHistoryIteratorImpl {
	return &policyHistoryIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (p *policyHistoryIteratorImpl) Next() bool {
	if p.index < len(p.buffer)-1 {
		p.index++
		return true
	}

	// reached end of buffer
	if !p.hasNextPage {
		return false
	}

	p.index = 0
	p.buffer, p.hasNextPage, p.err = p.fetch()
	return len(p.buffer) > 0
}

func (p *policyHistoryIteratorImpl) Value() *PolicyHistory {
	if p.index >= len(p.buffer) {
		return nil
	}
	return p.buffer[p.index]
}

func (p *policyHistoryIteratorImpl) Err() error {
	return p.err
}

type proxyClusterKeyIteratorImplFetchFunc func() (
	[]*ProxyClusterKey,
	bool, error)
type proxyClusterKeyIteratorImpl struct {
	buffer      []*ProxyClusterKey
	index       int
	hasNextPage bool
	err         error
	fetch       proxyClusterKeyIteratorImplFetchFunc
}

func newProxyClusterKeyIteratorImpl(f proxyClusterKeyIteratorImplFetchFunc) *proxyClusterKeyIteratorImpl {
	return &proxyClusterKeyIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (p *proxyClusterKeyIteratorImpl) Next() bool {
	if p.index < len(p.buffer)-1 {
		p.index++
		return true
	}

	// reached end of buffer
	if !p.hasNextPage {
		return false
	}

	p.index = 0
	p.buffer, p.hasNextPage, p.err = p.fetch()
	return len(p.buffer) > 0
}

func (p *proxyClusterKeyIteratorImpl) Value() *ProxyClusterKey {
	if p.index >= len(p.buffer) {
		return nil
	}
	return p.buffer[p.index]
}

func (p *proxyClusterKeyIteratorImpl) Err() error {
	return p.err
}

type queryIteratorImplFetchFunc func() (
	[]*Query,
	bool, error)
type queryIteratorImpl struct {
	buffer      []*Query
	index       int
	hasNextPage bool
	err         error
	fetch       queryIteratorImplFetchFunc
}

func newQueryIteratorImpl(f queryIteratorImplFetchFunc) *queryIteratorImpl {
	return &queryIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (q *queryIteratorImpl) Next() bool {
	if q.index < len(q.buffer)-1 {
		q.index++
		return true
	}

	// reached end of buffer
	if !q.hasNextPage {
		return false
	}

	q.index = 0
	q.buffer, q.hasNextPage, q.err = q.fetch()
	return len(q.buffer) > 0
}

func (q *queryIteratorImpl) Value() *Query {
	if q.index >= len(q.buffer) {
		return nil
	}
	return q.buffer[q.index]
}

func (q *queryIteratorImpl) Err() error {
	return q.err
}

type remoteIdentityIteratorImplFetchFunc func() (
	[]*RemoteIdentity,
	bool, error)
type remoteIdentityIteratorImpl struct {
	buffer      []*RemoteIdentity
	index       int
	hasNextPage bool
	err         error
	fetch       remoteIdentityIteratorImplFetchFunc
}

func newRemoteIdentityIteratorImpl(f remoteIdentityIteratorImplFetchFunc) *remoteIdentityIteratorImpl {
	return &remoteIdentityIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (r *remoteIdentityIteratorImpl) Next() bool {
	if r.index < len(r.buffer)-1 {
		r.index++
		return true
	}

	// reached end of buffer
	if !r.hasNextPage {
		return false
	}

	r.index = 0
	r.buffer, r.hasNextPage, r.err = r.fetch()
	return len(r.buffer) > 0
}

func (r *remoteIdentityIteratorImpl) Value() *RemoteIdentity {
	if r.index >= len(r.buffer) {
		return nil
	}
	return r.buffer[r.index]
}

func (r *remoteIdentityIteratorImpl) Err() error {
	return r.err
}

type remoteIdentityHistoryIteratorImplFetchFunc func() (
	[]*RemoteIdentityHistory,
	bool, error)
type remoteIdentityHistoryIteratorImpl struct {
	buffer      []*RemoteIdentityHistory
	index       int
	hasNextPage bool
	err         error
	fetch       remoteIdentityHistoryIteratorImplFetchFunc
}

func newRemoteIdentityHistoryIteratorImpl(f remoteIdentityHistoryIteratorImplFetchFunc) *remoteIdentityHistoryIteratorImpl {
	return &remoteIdentityHistoryIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (r *remoteIdentityHistoryIteratorImpl) Next() bool {
	if r.index < len(r.buffer)-1 {
		r.index++
		return true
	}

	// reached end of buffer
	if !r.hasNextPage {
		return false
	}

	r.index = 0
	r.buffer, r.hasNextPage, r.err = r.fetch()
	return len(r.buffer) > 0
}

func (r *remoteIdentityHistoryIteratorImpl) Value() *RemoteIdentityHistory {
	if r.index >= len(r.buffer) {
		return nil
	}
	return r.buffer[r.index]
}

func (r *remoteIdentityHistoryIteratorImpl) Err() error {
	return r.err
}

type remoteIdentityGroupIteratorImplFetchFunc func() (
	[]*RemoteIdentityGroup,
	bool, error)
type remoteIdentityGroupIteratorImpl struct {
	buffer      []*RemoteIdentityGroup
	index       int
	hasNextPage bool
	err         error
	fetch       remoteIdentityGroupIteratorImplFetchFunc
}

func newRemoteIdentityGroupIteratorImpl(f remoteIdentityGroupIteratorImplFetchFunc) *remoteIdentityGroupIteratorImpl {
	return &remoteIdentityGroupIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (r *remoteIdentityGroupIteratorImpl) Next() bool {
	if r.index < len(r.buffer)-1 {
		r.index++
		return true
	}

	// reached end of buffer
	if !r.hasNextPage {
		return false
	}

	r.index = 0
	r.buffer, r.hasNextPage, r.err = r.fetch()
	return len(r.buffer) > 0
}

func (r *remoteIdentityGroupIteratorImpl) Value() *RemoteIdentityGroup {
	if r.index >= len(r.buffer) {
		return nil
	}
	return r.buffer[r.index]
}

func (r *remoteIdentityGroupIteratorImpl) Err() error {
	return r.err
}

type remoteIdentityGroupHistoryIteratorImplFetchFunc func() (
	[]*RemoteIdentityGroupHistory,
	bool, error)
type remoteIdentityGroupHistoryIteratorImpl struct {
	buffer      []*RemoteIdentityGroupHistory
	index       int
	hasNextPage bool
	err         error
	fetch       remoteIdentityGroupHistoryIteratorImplFetchFunc
}

func newRemoteIdentityGroupHistoryIteratorImpl(f remoteIdentityGroupHistoryIteratorImplFetchFunc) *remoteIdentityGroupHistoryIteratorImpl {
	return &remoteIdentityGroupHistoryIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (r *remoteIdentityGroupHistoryIteratorImpl) Next() bool {
	if r.index < len(r.buffer)-1 {
		r.index++
		return true
	}

	// reached end of buffer
	if !r.hasNextPage {
		return false
	}

	r.index = 0
	r.buffer, r.hasNextPage, r.err = r.fetch()
	return len(r.buffer) > 0
}

func (r *remoteIdentityGroupHistoryIteratorImpl) Value() *RemoteIdentityGroupHistory {
	if r.index >= len(r.buffer) {
		return nil
	}
	return r.buffer[r.index]
}

func (r *remoteIdentityGroupHistoryIteratorImpl) Err() error {
	return r.err
}

type replayChunkIteratorImplFetchFunc func() (
	[]*ReplayChunk,
	bool, error)
type replayChunkIteratorImpl struct {
	buffer      []*ReplayChunk
	index       int
	hasNextPage bool
	err         error
	fetch       replayChunkIteratorImplFetchFunc
}

func newReplayChunkIteratorImpl(f replayChunkIteratorImplFetchFunc) *replayChunkIteratorImpl {
	return &replayChunkIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (r *replayChunkIteratorImpl) Next() bool {
	if r.index < len(r.buffer)-1 {
		r.index++
		return true
	}

	// reached end of buffer
	if !r.hasNextPage {
		return false
	}

	r.index = 0
	r.buffer, r.hasNextPage, r.err = r.fetch()
	return len(r.buffer) > 0
}

func (r *replayChunkIteratorImpl) Value() *ReplayChunk {
	if r.index >= len(r.buffer) {
		return nil
	}
	return r.buffer[r.index]
}

func (r *replayChunkIteratorImpl) Err() error {
	return r.err
}

type tagIteratorImplFetchFunc func() (
	[]*Tag,
	bool, error)
type tagIteratorImpl struct {
	buffer      []*Tag
	index       int
	hasNextPage bool
	err         error
	fetch       tagIteratorImplFetchFunc
}

func newTagIteratorImpl(f tagIteratorImplFetchFunc) *tagIteratorImpl {
	return &tagIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (t *tagIteratorImpl) Next() bool {
	if t.index < len(t.buffer)-1 {
		t.index++
		return true
	}

	// reached end of buffer
	if !t.hasNextPage {
		return false
	}

	t.index = 0
	t.buffer, t.hasNextPage, t.err = t.fetch()
	return len(t.buffer) > 0
}

func (t *tagIteratorImpl) Value() *Tag {
	if t.index >= len(t.buffer) {
		return nil
	}
	return t.buffer[t.index]
}

func (t *tagIteratorImpl) Err() error {
	return t.err
}

type resourceIteratorImplFetchFunc func() (
	[]Resource,
	bool, error)
type resourceIteratorImpl struct {
	buffer      []Resource
	index       int
	hasNextPage bool
	err         error
	fetch       resourceIteratorImplFetchFunc
}

func newResourceIteratorImpl(f resourceIteratorImplFetchFunc) *resourceIteratorImpl {
	return &resourceIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (r *resourceIteratorImpl) Next() bool {
	if r.index < len(r.buffer)-1 {
		r.index++
		return true
	}

	// reached end of buffer
	if !r.hasNextPage {
		return false
	}

	r.index = 0
	r.buffer, r.hasNextPage, r.err = r.fetch()
	return len(r.buffer) > 0
}

func (r *resourceIteratorImpl) Value() Resource {
	if r.index >= len(r.buffer) {
		return nil
	}
	return r.buffer[r.index]
}

func (r *resourceIteratorImpl) Err() error {
	return r.err
}

type resourceHistoryIteratorImplFetchFunc func() (
	[]*ResourceHistory,
	bool, error)
type resourceHistoryIteratorImpl struct {
	buffer      []*ResourceHistory
	index       int
	hasNextPage bool
	err         error
	fetch       resourceHistoryIteratorImplFetchFunc
}

func newResourceHistoryIteratorImpl(f resourceHistoryIteratorImplFetchFunc) *resourceHistoryIteratorImpl {
	return &resourceHistoryIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (r *resourceHistoryIteratorImpl) Next() bool {
	if r.index < len(r.buffer)-1 {
		r.index++
		return true
	}

	// reached end of buffer
	if !r.hasNextPage {
		return false
	}

	r.index = 0
	r.buffer, r.hasNextPage, r.err = r.fetch()
	return len(r.buffer) > 0
}

func (r *resourceHistoryIteratorImpl) Value() *ResourceHistory {
	if r.index >= len(r.buffer) {
		return nil
	}
	return r.buffer[r.index]
}

func (r *resourceHistoryIteratorImpl) Err() error {
	return r.err
}

type roleResourceIteratorImplFetchFunc func() (
	[]*RoleResource,
	bool, error)
type roleResourceIteratorImpl struct {
	buffer      []*RoleResource
	index       int
	hasNextPage bool
	err         error
	fetch       roleResourceIteratorImplFetchFunc
}

func newRoleResourceIteratorImpl(f roleResourceIteratorImplFetchFunc) *roleResourceIteratorImpl {
	return &roleResourceIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (r *roleResourceIteratorImpl) Next() bool {
	if r.index < len(r.buffer)-1 {
		r.index++
		return true
	}

	// reached end of buffer
	if !r.hasNextPage {
		return false
	}

	r.index = 0
	r.buffer, r.hasNextPage, r.err = r.fetch()
	return len(r.buffer) > 0
}

func (r *roleResourceIteratorImpl) Value() *RoleResource {
	if r.index >= len(r.buffer) {
		return nil
	}
	return r.buffer[r.index]
}

func (r *roleResourceIteratorImpl) Err() error {
	return r.err
}

type roleResourceHistoryIteratorImplFetchFunc func() (
	[]*RoleResourceHistory,
	bool, error)
type roleResourceHistoryIteratorImpl struct {
	buffer      []*RoleResourceHistory
	index       int
	hasNextPage bool
	err         error
	fetch       roleResourceHistoryIteratorImplFetchFunc
}

func newRoleResourceHistoryIteratorImpl(f roleResourceHistoryIteratorImplFetchFunc) *roleResourceHistoryIteratorImpl {
	return &roleResourceHistoryIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (r *roleResourceHistoryIteratorImpl) Next() bool {
	if r.index < len(r.buffer)-1 {
		r.index++
		return true
	}

	// reached end of buffer
	if !r.hasNextPage {
		return false
	}

	r.index = 0
	r.buffer, r.hasNextPage, r.err = r.fetch()
	return len(r.buffer) > 0
}

func (r *roleResourceHistoryIteratorImpl) Value() *RoleResourceHistory {
	if r.index >= len(r.buffer) {
		return nil
	}
	return r.buffer[r.index]
}

func (r *roleResourceHistoryIteratorImpl) Err() error {
	return r.err
}

type roleIteratorImplFetchFunc func() (
	[]*Role,
	bool, error)
type roleIteratorImpl struct {
	buffer      []*Role
	index       int
	hasNextPage bool
	err         error
	fetch       roleIteratorImplFetchFunc
}

func newRoleIteratorImpl(f roleIteratorImplFetchFunc) *roleIteratorImpl {
	return &roleIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (r *roleIteratorImpl) Next() bool {
	if r.index < len(r.buffer)-1 {
		r.index++
		return true
	}

	// reached end of buffer
	if !r.hasNextPage {
		return false
	}

	r.index = 0
	r.buffer, r.hasNextPage, r.err = r.fetch()
	return len(r.buffer) > 0
}

func (r *roleIteratorImpl) Value() *Role {
	if r.index >= len(r.buffer) {
		return nil
	}
	return r.buffer[r.index]
}

func (r *roleIteratorImpl) Err() error {
	return r.err
}

type roleHistoryIteratorImplFetchFunc func() (
	[]*RoleHistory,
	bool, error)
type roleHistoryIteratorImpl struct {
	buffer      []*RoleHistory
	index       int
	hasNextPage bool
	err         error
	fetch       roleHistoryIteratorImplFetchFunc
}

func newRoleHistoryIteratorImpl(f roleHistoryIteratorImplFetchFunc) *roleHistoryIteratorImpl {
	return &roleHistoryIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (r *roleHistoryIteratorImpl) Next() bool {
	if r.index < len(r.buffer)-1 {
		r.index++
		return true
	}

	// reached end of buffer
	if !r.hasNextPage {
		return false
	}

	r.index = 0
	r.buffer, r.hasNextPage, r.err = r.fetch()
	return len(r.buffer) > 0
}

func (r *roleHistoryIteratorImpl) Value() *RoleHistory {
	if r.index >= len(r.buffer) {
		return nil
	}
	return r.buffer[r.index]
}

func (r *roleHistoryIteratorImpl) Err() error {
	return r.err
}

type secretStoreIteratorImplFetchFunc func() (
	[]SecretStore,
	bool, error)
type secretStoreIteratorImpl struct {
	buffer      []SecretStore
	index       int
	hasNextPage bool
	err         error
	fetch       secretStoreIteratorImplFetchFunc
}

func newSecretStoreIteratorImpl(f secretStoreIteratorImplFetchFunc) *secretStoreIteratorImpl {
	return &secretStoreIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (s *secretStoreIteratorImpl) Next() bool {
	if s.index < len(s.buffer)-1 {
		s.index++
		return true
	}

	// reached end of buffer
	if !s.hasNextPage {
		return false
	}

	s.index = 0
	s.buffer, s.hasNextPage, s.err = s.fetch()
	return len(s.buffer) > 0
}

func (s *secretStoreIteratorImpl) Value() SecretStore {
	if s.index >= len(s.buffer) {
		return nil
	}
	return s.buffer[s.index]
}

func (s *secretStoreIteratorImpl) Err() error {
	return s.err
}

type secretStoreHealthIteratorImplFetchFunc func() (
	[]*SecretStoreHealth,
	bool, error)
type secretStoreHealthIteratorImpl struct {
	buffer      []*SecretStoreHealth
	index       int
	hasNextPage bool
	err         error
	fetch       secretStoreHealthIteratorImplFetchFunc
}

func newSecretStoreHealthIteratorImpl(f secretStoreHealthIteratorImplFetchFunc) *secretStoreHealthIteratorImpl {
	return &secretStoreHealthIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (s *secretStoreHealthIteratorImpl) Next() bool {
	if s.index < len(s.buffer)-1 {
		s.index++
		return true
	}

	// reached end of buffer
	if !s.hasNextPage {
		return false
	}

	s.index = 0
	s.buffer, s.hasNextPage, s.err = s.fetch()
	return len(s.buffer) > 0
}

func (s *secretStoreHealthIteratorImpl) Value() *SecretStoreHealth {
	if s.index >= len(s.buffer) {
		return nil
	}
	return s.buffer[s.index]
}

func (s *secretStoreHealthIteratorImpl) Err() error {
	return s.err
}

type secretStoreHistoryIteratorImplFetchFunc func() (
	[]*SecretStoreHistory,
	bool, error)
type secretStoreHistoryIteratorImpl struct {
	buffer      []*SecretStoreHistory
	index       int
	hasNextPage bool
	err         error
	fetch       secretStoreHistoryIteratorImplFetchFunc
}

func newSecretStoreHistoryIteratorImpl(f secretStoreHistoryIteratorImplFetchFunc) *secretStoreHistoryIteratorImpl {
	return &secretStoreHistoryIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (s *secretStoreHistoryIteratorImpl) Next() bool {
	if s.index < len(s.buffer)-1 {
		s.index++
		return true
	}

	// reached end of buffer
	if !s.hasNextPage {
		return false
	}

	s.index = 0
	s.buffer, s.hasNextPage, s.err = s.fetch()
	return len(s.buffer) > 0
}

func (s *secretStoreHistoryIteratorImpl) Value() *SecretStoreHistory {
	if s.index >= len(s.buffer) {
		return nil
	}
	return s.buffer[s.index]
}

func (s *secretStoreHistoryIteratorImpl) Err() error {
	return s.err
}

type workflowApproverIteratorImplFetchFunc func() (
	[]*WorkflowApprover,
	bool, error)
type workflowApproverIteratorImpl struct {
	buffer      []*WorkflowApprover
	index       int
	hasNextPage bool
	err         error
	fetch       workflowApproverIteratorImplFetchFunc
}

func newWorkflowApproverIteratorImpl(f workflowApproverIteratorImplFetchFunc) *workflowApproverIteratorImpl {
	return &workflowApproverIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (w *workflowApproverIteratorImpl) Next() bool {
	if w.index < len(w.buffer)-1 {
		w.index++
		return true
	}

	// reached end of buffer
	if !w.hasNextPage {
		return false
	}

	w.index = 0
	w.buffer, w.hasNextPage, w.err = w.fetch()
	return len(w.buffer) > 0
}

func (w *workflowApproverIteratorImpl) Value() *WorkflowApprover {
	if w.index >= len(w.buffer) {
		return nil
	}
	return w.buffer[w.index]
}

func (w *workflowApproverIteratorImpl) Err() error {
	return w.err
}

type workflowApproverHistoryIteratorImplFetchFunc func() (
	[]*WorkflowApproverHistory,
	bool, error)
type workflowApproverHistoryIteratorImpl struct {
	buffer      []*WorkflowApproverHistory
	index       int
	hasNextPage bool
	err         error
	fetch       workflowApproverHistoryIteratorImplFetchFunc
}

func newWorkflowApproverHistoryIteratorImpl(f workflowApproverHistoryIteratorImplFetchFunc) *workflowApproverHistoryIteratorImpl {
	return &workflowApproverHistoryIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (w *workflowApproverHistoryIteratorImpl) Next() bool {
	if w.index < len(w.buffer)-1 {
		w.index++
		return true
	}

	// reached end of buffer
	if !w.hasNextPage {
		return false
	}

	w.index = 0
	w.buffer, w.hasNextPage, w.err = w.fetch()
	return len(w.buffer) > 0
}

func (w *workflowApproverHistoryIteratorImpl) Value() *WorkflowApproverHistory {
	if w.index >= len(w.buffer) {
		return nil
	}
	return w.buffer[w.index]
}

func (w *workflowApproverHistoryIteratorImpl) Err() error {
	return w.err
}

type workflowAssignmentIteratorImplFetchFunc func() (
	[]*WorkflowAssignment,
	bool, error)
type workflowAssignmentIteratorImpl struct {
	buffer      []*WorkflowAssignment
	index       int
	hasNextPage bool
	err         error
	fetch       workflowAssignmentIteratorImplFetchFunc
}

func newWorkflowAssignmentIteratorImpl(f workflowAssignmentIteratorImplFetchFunc) *workflowAssignmentIteratorImpl {
	return &workflowAssignmentIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (w *workflowAssignmentIteratorImpl) Next() bool {
	if w.index < len(w.buffer)-1 {
		w.index++
		return true
	}

	// reached end of buffer
	if !w.hasNextPage {
		return false
	}

	w.index = 0
	w.buffer, w.hasNextPage, w.err = w.fetch()
	return len(w.buffer) > 0
}

func (w *workflowAssignmentIteratorImpl) Value() *WorkflowAssignment {
	if w.index >= len(w.buffer) {
		return nil
	}
	return w.buffer[w.index]
}

func (w *workflowAssignmentIteratorImpl) Err() error {
	return w.err
}

type workflowAssignmentHistoryIteratorImplFetchFunc func() (
	[]*WorkflowAssignmentHistory,
	bool, error)
type workflowAssignmentHistoryIteratorImpl struct {
	buffer      []*WorkflowAssignmentHistory
	index       int
	hasNextPage bool
	err         error
	fetch       workflowAssignmentHistoryIteratorImplFetchFunc
}

func newWorkflowAssignmentHistoryIteratorImpl(f workflowAssignmentHistoryIteratorImplFetchFunc) *workflowAssignmentHistoryIteratorImpl {
	return &workflowAssignmentHistoryIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (w *workflowAssignmentHistoryIteratorImpl) Next() bool {
	if w.index < len(w.buffer)-1 {
		w.index++
		return true
	}

	// reached end of buffer
	if !w.hasNextPage {
		return false
	}

	w.index = 0
	w.buffer, w.hasNextPage, w.err = w.fetch()
	return len(w.buffer) > 0
}

func (w *workflowAssignmentHistoryIteratorImpl) Value() *WorkflowAssignmentHistory {
	if w.index >= len(w.buffer) {
		return nil
	}
	return w.buffer[w.index]
}

func (w *workflowAssignmentHistoryIteratorImpl) Err() error {
	return w.err
}

type workflowRoleIteratorImplFetchFunc func() (
	[]*WorkflowRole,
	bool, error)
type workflowRoleIteratorImpl struct {
	buffer      []*WorkflowRole
	index       int
	hasNextPage bool
	err         error
	fetch       workflowRoleIteratorImplFetchFunc
}

func newWorkflowRoleIteratorImpl(f workflowRoleIteratorImplFetchFunc) *workflowRoleIteratorImpl {
	return &workflowRoleIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (w *workflowRoleIteratorImpl) Next() bool {
	if w.index < len(w.buffer)-1 {
		w.index++
		return true
	}

	// reached end of buffer
	if !w.hasNextPage {
		return false
	}

	w.index = 0
	w.buffer, w.hasNextPage, w.err = w.fetch()
	return len(w.buffer) > 0
}

func (w *workflowRoleIteratorImpl) Value() *WorkflowRole {
	if w.index >= len(w.buffer) {
		return nil
	}
	return w.buffer[w.index]
}

func (w *workflowRoleIteratorImpl) Err() error {
	return w.err
}

type workflowRoleHistoryIteratorImplFetchFunc func() (
	[]*WorkflowRoleHistory,
	bool, error)
type workflowRoleHistoryIteratorImpl struct {
	buffer      []*WorkflowRoleHistory
	index       int
	hasNextPage bool
	err         error
	fetch       workflowRoleHistoryIteratorImplFetchFunc
}

func newWorkflowRoleHistoryIteratorImpl(f workflowRoleHistoryIteratorImplFetchFunc) *workflowRoleHistoryIteratorImpl {
	return &workflowRoleHistoryIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (w *workflowRoleHistoryIteratorImpl) Next() bool {
	if w.index < len(w.buffer)-1 {
		w.index++
		return true
	}

	// reached end of buffer
	if !w.hasNextPage {
		return false
	}

	w.index = 0
	w.buffer, w.hasNextPage, w.err = w.fetch()
	return len(w.buffer) > 0
}

func (w *workflowRoleHistoryIteratorImpl) Value() *WorkflowRoleHistory {
	if w.index >= len(w.buffer) {
		return nil
	}
	return w.buffer[w.index]
}

func (w *workflowRoleHistoryIteratorImpl) Err() error {
	return w.err
}

type workflowIteratorImplFetchFunc func() (
	[]*Workflow,
	bool, error)
type workflowIteratorImpl struct {
	buffer      []*Workflow
	index       int
	hasNextPage bool
	err         error
	fetch       workflowIteratorImplFetchFunc
}

func newWorkflowIteratorImpl(f workflowIteratorImplFetchFunc) *workflowIteratorImpl {
	return &workflowIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (w *workflowIteratorImpl) Next() bool {
	if w.index < len(w.buffer)-1 {
		w.index++
		return true
	}

	// reached end of buffer
	if !w.hasNextPage {
		return false
	}

	w.index = 0
	w.buffer, w.hasNextPage, w.err = w.fetch()
	return len(w.buffer) > 0
}

func (w *workflowIteratorImpl) Value() *Workflow {
	if w.index >= len(w.buffer) {
		return nil
	}
	return w.buffer[w.index]
}

func (w *workflowIteratorImpl) Err() error {
	return w.err
}

type workflowHistoryIteratorImplFetchFunc func() (
	[]*WorkflowHistory,
	bool, error)
type workflowHistoryIteratorImpl struct {
	buffer      []*WorkflowHistory
	index       int
	hasNextPage bool
	err         error
	fetch       workflowHistoryIteratorImplFetchFunc
}

func newWorkflowHistoryIteratorImpl(f workflowHistoryIteratorImplFetchFunc) *workflowHistoryIteratorImpl {
	return &workflowHistoryIteratorImpl{
		hasNextPage: true,
		fetch:       f,
	}
}

func (w *workflowHistoryIteratorImpl) Next() bool {
	if w.index < len(w.buffer)-1 {
		w.index++
		return true
	}

	// reached end of buffer
	if !w.hasNextPage {
		return false
	}

	w.index = 0
	w.buffer, w.hasNextPage, w.err = w.fetch()
	return len(w.buffer) > 0
}

func (w *workflowHistoryIteratorImpl) Value() *WorkflowHistory {
	if w.index >= len(w.buffer) {
		return nil
	}
	return w.buffer[w.index]
}

func (w *workflowHistoryIteratorImpl) Err() error {
	return w.err
}
