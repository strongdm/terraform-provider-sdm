// Code generated by protogen. DO NOT EDIT.

package sdm

import (
	"context"
	"fmt"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	sdm "github.com/strongdm/terraform-provider-sdm/sdm/internal/sdk"
)

func dataSourceSecretStore() *schema.Resource {
	return &schema.Resource{
		ReadContext: wrapCrudOperation(dataSourceSecretStoreList),
		Schema: map[string]*schema.Schema{
			"ids": {
				Type:     schema.TypeList,
				Computed: true,
				Elem:     &schema.Schema{Type: schema.TypeString},
			},
			"type": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"id": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"name": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"tags": {
				Type:     schema.TypeMap,
				Optional: true,
			},
			"secret_stores": {
				Type:     schema.TypeList,
				Computed: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"active_directory_store": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the SecretStore.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the SecretStore.",
									},
									"server_address": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Hostname of server that is hosting NDES (Network Device Enrollment Services). Often this is the same host as Active Directory Certificate Services",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"aws": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the SecretStore.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the SecretStore.",
									},
									"region": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The AWS region to target e.g. us-east-1",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"aws_cert_x509": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"ca_arn": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The ARN of the CA in AWS Private CA",
									},
									"certificate_template_arn": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The ARN of the AWS certificate template for requested certificates. Must allow SAN, key usage, and ext key usage passthrough from CSR",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the SecretStore.",
									},
									"issued_cert_ttl_minutes": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The lifetime of certificates issued by this CA represented in minutes.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the SecretStore.",
									},
									"region": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The AWS region to target e.g. us-east-1",
									},
									"signing_algo": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The specified signing algorithm family (RSA or ECDSA) must match the algorithm family of the CA's secret key. e.g. SHA256WITHRSA",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"azure_store": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the SecretStore.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the SecretStore.",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"vault_uri": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The URI of the key vault to target e.g. https://myvault.vault.azure.net",
									},
								},
							},
						},
						"cyberark_conjur": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"app_url": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The URL of the Cyberark instance",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the SecretStore.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the SecretStore.",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"cyberark_pam": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"app_url": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The URL of the Cyberark instance",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the SecretStore.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the SecretStore.",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"cyberark_pam_experimental": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"app_url": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The URL of the Cyberark instance",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the SecretStore.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the SecretStore.",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"delinea_store": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the SecretStore.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the SecretStore.",
									},
									"server_url": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The URL of the Delinea instance",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"tenant_name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The tenant name to target",
									},
								},
							},
						},
						"gcp_store": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the SecretStore.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the SecretStore.",
									},
									"project_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The GCP project ID to target.",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"gcp_cert_x_509_store": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"ca_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The ID of the target CA",
									},
									"ca_pool_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The ID of the target CA pool",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the SecretStore.",
									},
									"issued_cert_ttl_minutes": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The lifetime of certificates issued by this CA represented in minutes.",
									},
									"location": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The Region for the CA in GCP format e.g. us-west1",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the SecretStore.",
									},
									"project_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The GCP project ID to target.",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"keyfactor_ssh_store": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"ca_file_path": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.",
									},
									"certificate_file_path": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.",
									},
									"default_certificate_authority_name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Name of EJBCA certificate authority that will enroll CSR.",
									},
									"default_certificate_profile_name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Certificate profile name that EJBCA will enroll the CSR with.",
									},
									"default_end_entity_profile_name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "End entity profile that EJBCA will enroll the CSR with.",
									},
									"enrollment_code_env_var": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "code used by EJBCA during enrollment. May be left blank if no code is required.",
									},
									"enrollment_username_env_var": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the SecretStore.",
									},
									"key_file_path": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the SecretStore.",
									},
									"server_address": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "the host of the Key Factor CA",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"keyfactor_x_509_store": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"ca_file_path": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.",
									},
									"certificate_file_path": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.",
									},
									"default_certificate_authority_name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Name of EJBCA certificate authority that will enroll CSR.",
									},
									"default_certificate_profile_name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Certificate profile name that EJBCA will enroll the CSR with.",
									},
									"default_end_entity_profile_name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "End entity profile that EJBCA will enroll the CSR with.",
									},
									"enrollment_code_env_var": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "code used by EJBCA during enrollment. May be left blank if no code is required.",
									},
									"enrollment_username_env_var": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the SecretStore.",
									},
									"key_file_path": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the SecretStore.",
									},
									"server_address": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "the host of the Key Factor CA",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"vault_approle": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the SecretStore.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the SecretStore.",
									},
									"namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The namespace to make requests within",
									},
									"server_address": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The URL of the Vault to target",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"vault_approle_cert_ssh": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the SecretStore.",
									},
									"issued_cert_ttl_minutes": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The lifetime of certificates issued by this CA represented in minutes.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the SecretStore.",
									},
									"namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The namespace to make requests within",
									},
									"server_address": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The URL of the Vault to target",
									},
									"signing_role": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The signing role to be used for signing certificates",
									},
									"ssh_mount_point": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The mount point of the SSH engine configured with the desired CA",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"vault_approle_cert_x509": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the SecretStore.",
									},
									"issued_cert_ttl_minutes": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The lifetime of certificates issued by this CA in minutes. Recommended value is 5.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the SecretStore.",
									},
									"namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The namespace to make requests within",
									},
									"pki_mount_point": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The mount point of the PKI engine configured with the desired CA",
									},
									"server_address": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The URL of the Vault to target",
									},
									"signing_role": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The signing role to be used for signing certificates",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"vault_aws_ec2": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the SecretStore.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the SecretStore.",
									},
									"namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The namespace to make requests within",
									},
									"server_address": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The URL of the Vault to target",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"vault_aws_iam": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the SecretStore.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the SecretStore.",
									},
									"namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The namespace to make requests within",
									},
									"server_address": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The URL of the Vault to target",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"vault_tls": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"ca_cert_path": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A path to a CA file accessible by a Node",
									},
									"client_cert_path": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A path to a client certificate file accessible by a Node",
									},
									"client_key_path": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A path to a client key file accessible by a Node",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the SecretStore.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the SecretStore.",
									},
									"namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The namespace to make requests within",
									},
									"server_address": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The URL of the Vault to target",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"vault_tls_cert_ssh": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"ca_cert_path": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A path to a CA file accessible by a Node",
									},
									"client_cert_path": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A path to a client certificate file accessible by a Node",
									},
									"client_key_path": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A path to a client key file accessible by a Node",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the SecretStore.",
									},
									"issued_cert_ttl_minutes": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The lifetime of certificates issued by this CA represented in minutes.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the SecretStore.",
									},
									"namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The namespace to make requests within",
									},
									"server_address": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The URL of the Vault to target",
									},
									"signing_role": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The signing role to be used for signing certificates",
									},
									"ssh_mount_point": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The mount point of the SSH engine configured with the desired CA",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"vault_tls_cert_x509": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"ca_cert_path": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A path to a CA file accessible by a Node",
									},
									"client_cert_path": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A path to a client certificate file accessible by a Node",
									},
									"client_key_path": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A path to a client key file accessible by a Node",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the SecretStore.",
									},
									"issued_cert_ttl_minutes": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The lifetime of certificates issued by this CA represented in minutes.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the SecretStore.",
									},
									"namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The namespace to make requests within",
									},
									"pki_mount_point": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The mount point of the PKI engine configured with the desired CA",
									},
									"server_address": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The URL of the Vault to target",
									},
									"signing_role": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The signing role to be used for signing certificates",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"vault_token": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the SecretStore.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the SecretStore.",
									},
									"namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The namespace to make requests within",
									},
									"server_address": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The URL of the Vault to target",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"vault_token_cert_ssh": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the SecretStore.",
									},
									"issued_cert_ttl_minutes": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The lifetime of certificates issued by this CA in minutes. Recommended value is 5.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the SecretStore.",
									},
									"namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The namespace to make requests within",
									},
									"server_address": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The URL of the Vault to target",
									},
									"signing_role": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The signing role to be used for signing certificates",
									},
									"ssh_mount_point": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The mount point of the SSH engine configured with the desired CA",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"vault_token_cert_x509": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the SecretStore.",
									},
									"issued_cert_ttl_minutes": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The lifetime of certificates issued by this CA represented in minutes.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the SecretStore.",
									},
									"namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The namespace to make requests within",
									},
									"pki_mount_point": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The mount point of the PKI engine configured with the desired CA",
									},
									"server_address": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The URL of the Vault to target",
									},
									"signing_role": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The signing role to be used for signing certificates",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
					},
				},
			},
		},
		Timeouts: &schema.ResourceTimeout{
			Default: schema.DefaultTimeout(60 * time.Second),
		},
	}
}

func convertSecretStoreFilterToPlumbing(d *schema.ResourceData) (string, []interface{}) {
	filter := ""
	args := []interface{}{}
	if v, ok := d.GetOkExists("type"); ok {
		filter += "type:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("id"); ok {
		filter += "id:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("name"); ok {
		filter += "name:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("tags"); ok {
		tags := convertTagsToPlumbing(v)
		for kk, vv := range tags {
			filter += "tag:?=?"
			args = append(args, kk, vv)
		}
	}
	return filter, args
}

func dataSourceSecretStoreList(ctx context.Context, d *schema.ResourceData, cc *sdm.Client) error {
	filter, args := convertSecretStoreFilterToPlumbing(d)
	resp, err := cc.SecretStores().List(ctx, filter, args...)
	if err != nil {
		return fmt.Errorf("cannot list SecretStores %s: %w", d.Id(), err)
	}
	ids := []string{}
	type entity = map[string]interface{}
	output := make([]map[string][]entity, 1)
	output[0] = map[string][]entity{
		"active_directory_store": {},
	}
	for resp.Next() {
		ids = append(ids, resp.Value().GetID())
		switch v := resp.Value().(type) {
		case *sdm.ActiveDirectoryStore:
			output[0]["active_directory_store"] = append(output[0]["active_directory_store"], entity{
				"id":             (v.ID),
				"name":           (v.Name),
				"server_address": (v.ServerAddress),
				"tags":           convertTagsToPorcelain(v.Tags),
			})
		case *sdm.AWSStore:
			output[0]["aws"] = append(output[0]["aws"], entity{
				"id":     (v.ID),
				"name":   (v.Name),
				"region": (v.Region),
				"tags":   convertTagsToPorcelain(v.Tags),
			})
		case *sdm.AWSCertX509Store:
			output[0]["aws_cert_x509"] = append(output[0]["aws_cert_x509"], entity{
				"ca_arn":                   (v.CaArn),
				"certificate_template_arn": (v.CertificateTemplateArn),
				"id":                       (v.ID),
				"issued_cert_ttl_minutes":  (v.IssuedCertTTLMinutes),
				"name":                     (v.Name),
				"region":                   (v.Region),
				"signing_algo":             (v.SigningAlgo),
				"tags":                     convertTagsToPorcelain(v.Tags),
			})
		case *sdm.AzureStore:
			output[0]["azure_store"] = append(output[0]["azure_store"], entity{
				"id":        (v.ID),
				"name":      (v.Name),
				"tags":      convertTagsToPorcelain(v.Tags),
				"vault_uri": (v.VaultUri),
			})
		case *sdm.CyberarkConjurStore:
			output[0]["cyberark_conjur"] = append(output[0]["cyberark_conjur"], entity{
				"app_url": (v.AppURL),
				"id":      (v.ID),
				"name":    (v.Name),
				"tags":    convertTagsToPorcelain(v.Tags),
			})
		case *sdm.CyberarkPAMStore:
			output[0]["cyberark_pam"] = append(output[0]["cyberark_pam"], entity{
				"app_url": (v.AppURL),
				"id":      (v.ID),
				"name":    (v.Name),
				"tags":    convertTagsToPorcelain(v.Tags),
			})
		case *sdm.CyberarkPAMExperimentalStore:
			output[0]["cyberark_pam_experimental"] = append(output[0]["cyberark_pam_experimental"], entity{
				"app_url": (v.AppURL),
				"id":      (v.ID),
				"name":    (v.Name),
				"tags":    convertTagsToPorcelain(v.Tags),
			})
		case *sdm.DelineaStore:
			output[0]["delinea_store"] = append(output[0]["delinea_store"], entity{
				"id":          (v.ID),
				"name":        (v.Name),
				"server_url":  (v.ServerUrl),
				"tags":        convertTagsToPorcelain(v.Tags),
				"tenant_name": (v.TenantName),
			})
		case *sdm.GCPStore:
			output[0]["gcp_store"] = append(output[0]["gcp_store"], entity{
				"id":         (v.ID),
				"name":       (v.Name),
				"project_id": (v.ProjectID),
				"tags":       convertTagsToPorcelain(v.Tags),
			})
		case *sdm.GCPCertX509Store:
			output[0]["gcp_cert_x_509_store"] = append(output[0]["gcp_cert_x_509_store"], entity{
				"ca_id":                   (v.CaID),
				"ca_pool_id":              (v.CaPoolID),
				"id":                      (v.ID),
				"issued_cert_ttl_minutes": (v.IssuedCertTTLMinutes),
				"location":                (v.Location),
				"name":                    (v.Name),
				"project_id":              (v.ProjectID),
				"tags":                    convertTagsToPorcelain(v.Tags),
			})
		case *sdm.KeyfactorSSHStore:
			output[0]["keyfactor_ssh_store"] = append(output[0]["keyfactor_ssh_store"], entity{
				"ca_file_path":                       (v.CaFilePath),
				"certificate_file_path":              (v.CertificateFilePath),
				"default_certificate_authority_name": (v.DefaultCertificateAuthorityName),
				"default_certificate_profile_name":   (v.DefaultCertificateProfileName),
				"default_end_entity_profile_name":    (v.DefaultEndEntityProfileName),
				"enrollment_code_env_var":            (v.EnrollmentCodeEnvVar),
				"enrollment_username_env_var":        (v.EnrollmentUsernameEnvVar),
				"id":                                 (v.ID),
				"key_file_path":                      (v.KeyFilePath),
				"name":                               (v.Name),
				"server_address":                     (v.ServerAddress),
				"tags":                               convertTagsToPorcelain(v.Tags),
			})
		case *sdm.KeyfactorX509Store:
			output[0]["keyfactor_x_509_store"] = append(output[0]["keyfactor_x_509_store"], entity{
				"ca_file_path":                       (v.CaFilePath),
				"certificate_file_path":              (v.CertificateFilePath),
				"default_certificate_authority_name": (v.DefaultCertificateAuthorityName),
				"default_certificate_profile_name":   (v.DefaultCertificateProfileName),
				"default_end_entity_profile_name":    (v.DefaultEndEntityProfileName),
				"enrollment_code_env_var":            (v.EnrollmentCodeEnvVar),
				"enrollment_username_env_var":        (v.EnrollmentUsernameEnvVar),
				"id":                                 (v.ID),
				"key_file_path":                      (v.KeyFilePath),
				"name":                               (v.Name),
				"server_address":                     (v.ServerAddress),
				"tags":                               convertTagsToPorcelain(v.Tags),
			})
		case *sdm.VaultAppRoleStore:
			output[0]["vault_approle"] = append(output[0]["vault_approle"], entity{
				"id":             (v.ID),
				"name":           (v.Name),
				"namespace":      (v.Namespace),
				"server_address": (v.ServerAddress),
				"tags":           convertTagsToPorcelain(v.Tags),
			})
		case *sdm.VaultAppRoleCertSSHStore:
			output[0]["vault_approle_cert_ssh"] = append(output[0]["vault_approle_cert_ssh"], entity{
				"id":                      (v.ID),
				"issued_cert_ttl_minutes": (v.IssuedCertTTLMinutes),
				"name":                    (v.Name),
				"namespace":               (v.Namespace),
				"server_address":          (v.ServerAddress),
				"signing_role":            (v.SigningRole),
				"ssh_mount_point":         (v.SshMountPoint),
				"tags":                    convertTagsToPorcelain(v.Tags),
			})
		case *sdm.VaultAppRoleCertX509Store:
			output[0]["vault_approle_cert_x509"] = append(output[0]["vault_approle_cert_x509"], entity{
				"id":                      (v.ID),
				"issued_cert_ttl_minutes": (v.IssuedCertTTLMinutes),
				"name":                    (v.Name),
				"namespace":               (v.Namespace),
				"pki_mount_point":         (v.PkiMountPoint),
				"server_address":          (v.ServerAddress),
				"signing_role":            (v.SigningRole),
				"tags":                    convertTagsToPorcelain(v.Tags),
			})
		case *sdm.VaultAWSEC2Store:
			output[0]["vault_aws_ec2"] = append(output[0]["vault_aws_ec2"], entity{
				"id":             (v.ID),
				"name":           (v.Name),
				"namespace":      (v.Namespace),
				"server_address": (v.ServerAddress),
				"tags":           convertTagsToPorcelain(v.Tags),
			})
		case *sdm.VaultAWSIAMStore:
			output[0]["vault_aws_iam"] = append(output[0]["vault_aws_iam"], entity{
				"id":             (v.ID),
				"name":           (v.Name),
				"namespace":      (v.Namespace),
				"server_address": (v.ServerAddress),
				"tags":           convertTagsToPorcelain(v.Tags),
			})
		case *sdm.VaultTLSStore:
			output[0]["vault_tls"] = append(output[0]["vault_tls"], entity{
				"ca_cert_path":     (v.CACertPath),
				"client_cert_path": (v.ClientCertPath),
				"client_key_path":  (v.ClientKeyPath),
				"id":               (v.ID),
				"name":             (v.Name),
				"namespace":        (v.Namespace),
				"server_address":   (v.ServerAddress),
				"tags":             convertTagsToPorcelain(v.Tags),
			})
		case *sdm.VaultTLSCertSSHStore:
			output[0]["vault_tls_cert_ssh"] = append(output[0]["vault_tls_cert_ssh"], entity{
				"ca_cert_path":            (v.CACertPath),
				"client_cert_path":        (v.ClientCertPath),
				"client_key_path":         (v.ClientKeyPath),
				"id":                      (v.ID),
				"issued_cert_ttl_minutes": (v.IssuedCertTTLMinutes),
				"name":                    (v.Name),
				"namespace":               (v.Namespace),
				"server_address":          (v.ServerAddress),
				"signing_role":            (v.SigningRole),
				"ssh_mount_point":         (v.SshMountPoint),
				"tags":                    convertTagsToPorcelain(v.Tags),
			})
		case *sdm.VaultTLSCertX509Store:
			output[0]["vault_tls_cert_x509"] = append(output[0]["vault_tls_cert_x509"], entity{
				"ca_cert_path":            (v.CACertPath),
				"client_cert_path":        (v.ClientCertPath),
				"client_key_path":         (v.ClientKeyPath),
				"id":                      (v.ID),
				"issued_cert_ttl_minutes": (v.IssuedCertTTLMinutes),
				"name":                    (v.Name),
				"namespace":               (v.Namespace),
				"pki_mount_point":         (v.PkiMountPoint),
				"server_address":          (v.ServerAddress),
				"signing_role":            (v.SigningRole),
				"tags":                    convertTagsToPorcelain(v.Tags),
			})
		case *sdm.VaultTokenStore:
			output[0]["vault_token"] = append(output[0]["vault_token"], entity{
				"id":             (v.ID),
				"name":           (v.Name),
				"namespace":      (v.Namespace),
				"server_address": (v.ServerAddress),
				"tags":           convertTagsToPorcelain(v.Tags),
			})
		case *sdm.VaultTokenCertSSHStore:
			output[0]["vault_token_cert_ssh"] = append(output[0]["vault_token_cert_ssh"], entity{
				"id":                      (v.ID),
				"issued_cert_ttl_minutes": (v.IssuedCertTTLMinutes),
				"name":                    (v.Name),
				"namespace":               (v.Namespace),
				"server_address":          (v.ServerAddress),
				"signing_role":            (v.SigningRole),
				"ssh_mount_point":         (v.SshMountPoint),
				"tags":                    convertTagsToPorcelain(v.Tags),
			})
		case *sdm.VaultTokenCertX509Store:
			output[0]["vault_token_cert_x509"] = append(output[0]["vault_token_cert_x509"], entity{
				"id":                      (v.ID),
				"issued_cert_ttl_minutes": (v.IssuedCertTTLMinutes),
				"name":                    (v.Name),
				"namespace":               (v.Namespace),
				"pki_mount_point":         (v.PkiMountPoint),
				"server_address":          (v.ServerAddress),
				"signing_role":            (v.SigningRole),
				"tags":                    convertTagsToPorcelain(v.Tags),
			})
		}
	}
	if resp.Err() != nil {
		return fmt.Errorf("failure during list: %w", resp.Err())
	}

	err = d.Set("ids", ids)
	if err != nil {
		return fmt.Errorf("cannot set ids: %w", err)
	}
	err = d.Set("secret_stores", output)
	if err != nil {
		return fmt.Errorf("cannot set output: %w", err)
	}
	d.SetId("SecretStore" + filter + fmt.Sprint(args...))
	return nil
}
