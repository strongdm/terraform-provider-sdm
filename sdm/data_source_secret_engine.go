// Code generated by protogen. DO NOT EDIT.

package sdm

import (
	"context"
	"fmt"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	sdm "github.com/strongdm/terraform-provider-sdm/sdm/internal/sdk"
)

func dataSourceSecretEngine() *schema.Resource {
	return &schema.Resource{
		ReadContext: wrapCrudOperation(dataSourceSecretEngineList),
		Schema: map[string]*schema.Schema{
			"ids": {
				Type:     schema.TypeList,
				Computed: true,
				Elem:     &schema.Schema{Type: schema.TypeString},
			},
			"type": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"binddn": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"bindpass": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"certificate": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"connection_timeout": {
				Type:     schema.TypeInt,
				Optional: true,
			},
			"do_not_validate_timestamps": {
				Type:     schema.TypeBool,
				Optional: true,
			},
			"hostname": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"id": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"insecure_tls": {
				Type:     schema.TypeBool,
				Optional: true,
			},
			"key_rotation_interval_days": {
				Type:     schema.TypeInt,
				Optional: true,
			},
			"name": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"password": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"port": {
				Type:     schema.TypeInt,
				Optional: true,
			},
			"request_timeout": {
				Type:     schema.TypeInt,
				Optional: true,
			},
			"secret_store_id": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"secret_store_root_path": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"start_tls": {
				Type:     schema.TypeBool,
				Optional: true,
			},
			"tags": {
				Type:     schema.TypeMap,
				Optional: true,
				Elem:     tagsElemType,
			},
			"upndomain": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"url": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"userdn": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"username": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"secret_engines": {
				Type:     schema.TypeList,
				Computed: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"active_directory": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"after_read_ttl": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The default time-to-live duration of the password after it's read. Once the ttl has passed, a password will be rotated.",
									},
									"binddn": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Distinguished name of object to bind when performing user and group search. Example: cn=vault,ou=Users,dc=example,dc=com",
									},
									"bindpass": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Password to use along with binddn when performing user search.",
									},
									"certificate": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "CA certificate to use when verifying LDAP server certificate, must be x509 PEM encoded.",
									},
									"connection_timeout": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Timeout, in seconds, when attempting to connect to the LDAP server before trying the next URL in the configuration.",
									},
									"do_not_validate_timestamps": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set to true this will prevent password change timestamp validation in Active Directory when validating credentials",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Secret Engine.",
									},
									"insecure_tls": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If true, skips LDAP server SSL certificate verification - insecure, use with caution!",
									},
									"key_rotation_interval_days": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "An interval of public/private key rotation for secret engine in days",
									},
									"max_backoff_duration": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The maximum retry duration in case of automatic failure. On failed ttl rotation attempt it will be retried in an increasing intervals until it reaches max_backoff_duration",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Secret Engine.",
									},
									"public_key": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Public key linked with a secret engine",
									},
									"request_timeout": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Timeout, in seconds, for the connection when making requests against the server before returning back an error.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Backing secret store identifier",
									},
									"secret_store_root_path": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Backing Secret Store root path where managed secrets are going to be stored",
									},
									"start_tls": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If true, issues a StartTLS command after establishing an unencrypted connection.",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"ttl": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The default password time-to-live duration. Once the ttl has passed, a password will be rotated the next time it's requested.",
									},
									"upndomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The domain (userPrincipalDomain) used to construct a UPN string for authentication.",
									},
									"url": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The LDAP server to connect to.",
									},
									"userdn": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Base DN under which to perform user search. Example: ou=Users,dc=example,dc=com",
									},
								},
							},
						},
						"key_value": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Secret Engine.",
									},
									"key_rotation_interval_days": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "An interval of public/private key rotation for secret engine in days",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Secret Engine.",
									},
									"public_key": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Public key linked with a secret engine",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Backing secret store identifier",
									},
									"secret_store_root_path": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Backing Secret Store root path where managed secrets are going to be stored",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"postgres_secret_engine": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Hostname is the hostname or IP address of the Postgres server.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Secret Engine.",
									},
									"key_rotation_interval_days": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "An interval of public/private key rotation for secret engine in days",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Secret Engine.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Password is the password to connect to the Postgres server.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Port is the port number of the Postgres server.",
									},
									"public_key": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Public key linked with a secret engine",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Backing secret store identifier",
									},
									"secret_store_root_path": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Backing Secret Store root path where managed secrets are going to be stored",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Username is the username to connect to the Postgres server.",
									},
								},
							},
						},
					},
				},
			},
		},
		Timeouts: &schema.ResourceTimeout{
			Default: schema.DefaultTimeout(60 * time.Second),
		},
	}
}

func init() {
	dataSourcesMap["sdm_secret_engine"] = dataSourceSecretEngine
}

func convertSecretEngineFilterToPlumbing(d *schema.ResourceData) (string, []interface{}) {
	filter := ""
	args := []interface{}{}
	if v, ok := d.GetOkExists("type"); ok {
		filter += "type:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("after_read_ttl"); ok {
		filter += "afterreadttl:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("binddn"); ok {
		filter += "binddn:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("bindpass"); ok {
		filter += "bindpass:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("certificate"); ok {
		filter += "certificate:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("connection_timeout"); ok {
		filter += "connectiontimeout:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("do_not_validate_timestamps"); ok {
		filter += "donotvalidatetimestamps:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("hostname"); ok {
		filter += "hostname:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("id"); ok {
		filter += "id:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("insecure_tls"); ok {
		filter += "insecuretls:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("key_rotation_interval_days"); ok {
		filter += "keyrotationintervaldays:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("max_backoff_duration"); ok {
		filter += "maxbackoffduration:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("name"); ok {
		filter += "name:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("password"); ok {
		filter += "password:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("policy"); ok {
		filter += "policy:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("port"); ok {
		filter += "port:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("public_key"); ok {
		filter += "publickey:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("request_timeout"); ok {
		filter += "requesttimeout:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("secret_store_id"); ok {
		filter += "secretstoreid:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("secret_store_root_path"); ok {
		filter += "secretstorerootpath:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("start_tls"); ok {
		filter += "starttls:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("tags"); ok {
		tags := convertTagsToPlumbing(v)
		for kk, vv := range tags {
			filter += "tag:?=? "
			args = append(args, kk, vv)
		}
	}
	if v, ok := d.GetOkExists("ttl"); ok {
		filter += "ttl:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("upndomain"); ok {
		filter += "upndomain:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("url"); ok {
		filter += "url:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("userdn"); ok {
		filter += "userdn:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("username"); ok {
		filter += "username:? "
		args = append(args, v)
	}
	return filter, args
}

func dataSourceSecretEngineList(ctx context.Context, d *schema.ResourceData, cc *sdm.Client) error {
	filter, args := convertSecretEngineFilterToPlumbing(d)
	resp, err := cc.SecretEngines().List(ctx, filter, args...)
	if err != nil {
		return fmt.Errorf("cannot list SecretEngines %s: %w", d.Id(), err)
	}
	ids := []string{}
	type entity = map[string]interface{}
	output := make([]map[string][]entity, 1)
	output[0] = map[string][]entity{
		"active_directory": {},
	}
	for resp.Next() {
		ids = append(ids, resp.Value().GetID())
		switch v := resp.Value().(type) {
		case *sdm.ActiveDirectoryEngine:
			output[0]["active_directory"] = append(output[0]["active_directory"], entity{
				"after_read_ttl":             convertDurationToPorcelain(v.AfterReadTtl),
				"binddn":                     (v.Binddn),
				"bindpass":                   (v.Bindpass),
				"certificate":                (v.Certificate),
				"connection_timeout":         (v.ConnectionTimeout),
				"do_not_validate_timestamps": (v.DoNotValidateTimestamps),
				"id":                         (v.ID),
				"insecure_tls":               (v.InsecureTls),
				"key_rotation_interval_days": (v.KeyRotationIntervalDays),
				"max_backoff_duration":       convertDurationToPorcelain(v.MaxBackoffDuration),
				"name":                       (v.Name),
				"public_key":                 convertBytesToPorcelain(v.PublicKey),
				"request_timeout":            (v.RequestTimeout),
				"secret_store_id":            (v.SecretStoreID),
				"secret_store_root_path":     (v.SecretStoreRootPath),
				"start_tls":                  (v.StartTls),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"ttl":                        convertDurationToPorcelain(v.Ttl),
				"upndomain":                  (v.Upndomain),
				"url":                        (v.Url),
				"userdn":                     (v.Userdn),
			})
		case *sdm.KeyValueEngine:
			output[0]["key_value"] = append(output[0]["key_value"], entity{
				"id":                         (v.ID),
				"key_rotation_interval_days": (v.KeyRotationIntervalDays),
				"name":                       (v.Name),
				"public_key":                 convertBytesToPorcelain(v.PublicKey),
				"secret_store_id":            (v.SecretStoreID),
				"secret_store_root_path":     (v.SecretStoreRootPath),
				"tags":                       convertTagsToPorcelain(v.Tags),
			})
		case *sdm.PostgresEngine:
			output[0]["postgres_secret_engine"] = append(output[0]["postgres_secret_engine"], entity{
				"hostname":                   (v.Hostname),
				"id":                         (v.ID),
				"key_rotation_interval_days": (v.KeyRotationIntervalDays),
				"name":                       (v.Name),
				"password":                   (v.Password),
				"port":                       (v.Port),
				"public_key":                 convertBytesToPorcelain(v.PublicKey),
				"secret_store_id":            (v.SecretStoreID),
				"secret_store_root_path":     (v.SecretStoreRootPath),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   (v.Username),
			})
		}
	}
	if resp.Err() != nil {
		return fmt.Errorf("failure during list: %w", resp.Err())
	}

	err = d.Set("ids", ids)
	if err != nil {
		return fmt.Errorf("cannot set ids: %w", err)
	}
	err = d.Set("secret_engines", output)
	if err != nil {
		return fmt.Errorf("cannot set output: %w", err)
	}
	d.SetId("SecretEngine" + filter + fmt.Sprint(args...))
	return nil
}
