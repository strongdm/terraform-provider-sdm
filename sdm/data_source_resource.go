// Code generated by protogen. DO NOT EDIT.

package sdm

import (
	"context"
	"fmt"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	sdm "github.com/strongdm/terraform-provider-sdm/sdm/internal/sdk"
)

func dataSourceResource() *schema.Resource {
	return &schema.Resource{
		ReadContext: wrapCrudOperation(dataSourceResourceList),
		Schema: map[string]*schema.Schema{
			"ids": {
				Type:     schema.TypeList,
				Computed: true,
				Elem:     &schema.Schema{Type: schema.TypeString},
			},
			"type": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"hostname": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"id": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"name": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"port": {
				Type:     schema.TypeInt,
				Optional: true,
			},
			"tags": {
				Type:     schema.TypeMap,
				Optional: true,
			},
			"username": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"resources": {
				Type:     schema.TypeList,
				Computed: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"aks": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"certificate_authority": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The CA to authenticate TLS connections with.",
									},
									"client_certificate": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The certificate to authenticate TLS connections with.",
									},
									"client_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The key to authenticate TLS connections with.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"healthcheck_namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"remote_identity_group_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The ID of the remote identity group to use for remote identity connections.",
									},
									"remote_identity_healthcheck_username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to use for healthchecks, when clients otherwise connect with their own remote identity username.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"aks_basic_auth": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"healthcheck_namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"aks_service_account": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"healthcheck_namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"remote_identity_group_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The ID of the remote identity group to use for remote identity connections.",
									},
									"remote_identity_healthcheck_username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to use for healthchecks, when clients otherwise connect with their own remote identity username.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"token": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The API token to authenticate with.",
									},
								},
							},
						},
						"aks_service_account_user_impersonation": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"healthcheck_namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"token": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The API token to authenticate with.",
									},
								},
							},
						},
						"aks_user_impersonation": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"certificate_authority": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The CA to authenticate TLS connections with.",
									},
									"client_certificate": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The certificate to authenticate TLS connections with.",
									},
									"client_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The key to authenticate TLS connections with.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"healthcheck_namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"amazon_eks": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"access_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The Access Key ID to use to authenticate.",
									},
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"certificate_authority": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The CA to authenticate TLS connections with.",
									},
									"cluster_name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The name of the cluster to connect to.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"endpoint": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The endpoint to dial.",
									},
									"healthcheck_namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"region": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The AWS region to connect to e.g. us-east-1.",
									},
									"remote_identity_group_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The ID of the remote identity group to use for remote identity connections.",
									},
									"remote_identity_healthcheck_username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to use for healthchecks, when clients otherwise connect with their own remote identity username.",
									},
									"role_arn": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The role to assume after logging in.",
									},
									"role_external_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
									},
									"secret_access_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The Secret Access Key to use to authenticate.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"amazon_eks_instance_profile": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"certificate_authority": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The CA to authenticate TLS connections with.",
									},
									"cluster_name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The name of the cluster to connect to.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"endpoint": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The endpoint to dial.",
									},
									"healthcheck_namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"region": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The AWS region to connect to e.g. us-east-1.",
									},
									"remote_identity_group_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The ID of the remote identity group to use for remote identity connections.",
									},
									"remote_identity_healthcheck_username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to use for healthchecks, when clients otherwise connect with their own remote identity username.",
									},
									"role_arn": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The role to assume after logging in.",
									},
									"role_external_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"amazon_eks_instance_profile_user_impersonation": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"certificate_authority": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The CA to authenticate TLS connections with.",
									},
									"cluster_name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The name of the cluster to connect to.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"endpoint": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The endpoint to dial.",
									},
									"healthcheck_namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"region": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The AWS region to connect to e.g. us-east-1.",
									},
									"remote_identity_group_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The ID of the remote identity group to use for remote identity connections.",
									},
									"remote_identity_healthcheck_username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to use for healthchecks, when clients otherwise connect with their own remote identity username.",
									},
									"role_arn": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The role to assume after logging in.",
									},
									"role_external_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"amazon_eks_user_impersonation": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"access_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The Access Key ID to use to authenticate.",
									},
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"certificate_authority": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The CA to authenticate TLS connections with.",
									},
									"cluster_name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The name of the cluster to connect to.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"endpoint": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The endpoint to dial.",
									},
									"healthcheck_namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"region": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The AWS region to connect to e.g. us-east-1.",
									},
									"role_arn": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The role to assume after logging in.",
									},
									"role_external_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
									},
									"secret_access_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The Secret Access Key to use to authenticate.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"amazon_es": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"access_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The Access Key ID to use to authenticate.",
									},
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"endpoint": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The endpoint to dial e.g. search-?.region.es.amazonaws.com\"",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"region": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The AWS region to connect to e.g. us-east-1.",
									},
									"role_arn": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The role to assume after logging in.",
									},
									"role_external_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
									},
									"secret_access_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The Secret Access Key to use to authenticate.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"amazonmq_amqp_091": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"tls_required": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, TLS must be used to connect to this resource.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"athena": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"access_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The Access Key ID to use to authenticate.",
									},
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"output": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The AWS S3 output location.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"region": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The AWS region to connect to e.g. us-east-1.",
									},
									"role_arn": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The role to assume after logging in.",
									},
									"role_external_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
									},
									"secret_access_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The Secret Access Key to use to authenticate.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"aurora_mysql": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The database for healthchecks. Does not affect client requests",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"require_native_auth": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"use_azure_single_server_usernames": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If true, appends the hostname to the username when hitting a database.azure.com address",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"aurora_postgres": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"override_database": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"aws": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"access_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The Access Key ID to use to authenticate.",
									},
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"healthcheck_region": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The AWS region healthcheck requests should attempt to connect to.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"role_arn": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The role to assume after logging in.",
									},
									"role_external_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
									},
									"secret_access_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The Secret Access Key to use to authenticate.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"aws_console": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"enable_env_variables": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If true, prefer environment variables to authenticate connection even if EC2 roles are configured.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"region": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The AWS region to connect to.",
									},
									"remote_identity_group_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The ID of the remote identity group to use for remote identity connections.",
									},
									"remote_identity_healthcheck_username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to use for healthchecks, when clients otherwise connect with their own remote identity username.",
									},
									"role_arn": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The role to assume after logging in.",
									},
									"role_external_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"session_expiry": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The length of time in seconds AWS console sessions will live before needing to reauthenticate.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"aws_console_static_key_pair": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"access_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The Access Key ID to authenticate with.",
									},
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"region": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The AWS region to connect to.",
									},
									"remote_identity_group_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The ID of the remote identity group to use for remote identity connections.",
									},
									"remote_identity_healthcheck_username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to use for healthchecks, when clients otherwise connect with their own remote identity username.",
									},
									"role_arn": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The role to assume after logging in.",
									},
									"role_external_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
									},
									"secret_access_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The Secret Access Key to authenticate with.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"session_expiry": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The length of time in seconds AWS console sessions will live before needing to reauthenticate.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"azure": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"app_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The application ID to authenticate with.",
									},
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"tenant_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The tenant ID to authenticate to.",
									},
								},
							},
						},
						"azure_certificate": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"app_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The application ID to authenticate with.",
									},
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"client_certificate": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The service Principal certificate file, both private and public key included.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"tenant_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The tenant ID to authenticate to.",
									},
								},
							},
						},
						"azure_mysql": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The database for healthchecks. Does not affect client requests.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"require_native_auth": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"use_azure_single_server_usernames": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If true, appends the hostname to the username when hitting a database.azure.com address",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"azure_postgres": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"override_database": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with. For Azure Postgres, this also will include the hostname of the target server for Azure Single Server compatibility. For Flexible servers, use the normal Postgres type.",
									},
								},
							},
						},
						"azure_postgres_managed_identity": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"override_database": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"use_azure_single_server_usernames": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If true, appends the hostname to the username when hitting a database.azure.com address",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"big_query": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"endpoint": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The endpoint to dial.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"private_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The JSON Private key to authenticate with.",
									},
									"project": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The project to connect to.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"cassandra": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"tls_required": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, TLS must be used to connect to this resource.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"citus": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"override_database": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"clustrix": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The database for healthchecks. Does not affect client requests.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"require_native_auth": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"use_azure_single_server_usernames": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If true, appends the hostname to the username when hitting a database.azure.com address",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"cockroach": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"override_database": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"db_2_i": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"tls_required": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, TLS must be used to connect to this resource.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"db_2_luw": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"document_db_host": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"auth_database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The authentication database to use.",
									},
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"document_db_replica_set": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"auth_database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The authentication database to use.",
									},
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"connect_to_replica": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Set to connect to a replica instead of the primary node.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Hostname must contain the hostname/port pairs of all instances in the replica set separated by commas.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"replica_set": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The name of the mongo replicaset.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"druid": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"dynamo_db": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"access_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The Access Key ID to use to authenticate.",
									},
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"endpoint": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The endpoint to dial e.g. dynamodb.region.amazonaws.com",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"region": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The region to authenticate requests against e.g. us-east-1",
									},
									"role_arn": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The role to assume after logging in.",
									},
									"role_external_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
									},
									"secret_access_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The Secret Access Key to use to authenticate.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"elastic": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"tls_required": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, TLS must be used to connect to this resource.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"elasticache_redis": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"tls_required": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, TLS must be used to connect to this resource.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"gcp": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"keyfile": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The service account keyfile to authenticate with.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"scopes": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Space separated scopes that this login should assume into when authenticating.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"google_gke": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"certificate_authority": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The CA to authenticate TLS connections with.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"endpoint": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The endpoint to dial.",
									},
									"healthcheck_namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"remote_identity_group_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The ID of the remote identity group to use for remote identity connections.",
									},
									"remote_identity_healthcheck_username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to use for healthchecks, when clients otherwise connect with their own remote identity username.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"service_account_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The service account key to authenticate with.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"google_gke_user_impersonation": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"certificate_authority": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The CA to authenticate TLS connections with.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"endpoint": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The endpoint to dial.",
									},
									"healthcheck_namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"service_account_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The service account key to authenticate with.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"greenplum": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"override_database": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"http_auth": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"auth_header": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The content to set as the authorization header.",
									},
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"default_path": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Automatically redirect to this path upon connecting.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"headers_blacklist": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Header names (e.g. Authorization), to omit from logs.",
									},
									"healthcheck_path": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "This path will be used to check the health of your site.",
									},
									"host_override": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host header will be overwritten with this field if provided.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"url": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The base address of your website without the path.",
									},
								},
							},
						},
						"http_basic_auth": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"default_path": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Automatically redirect to this path upon connecting.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"headers_blacklist": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Header names (e.g. Authorization), to omit from logs.",
									},
									"healthcheck_path": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "This path will be used to check the health of your site.",
									},
									"host_override": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host header will be overwritten with this field if provided.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"url": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The base address of your website without the path.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"http_no_auth": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"default_path": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Automatically redirect to this path upon connecting.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"headers_blacklist": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Header names (e.g. Authorization), to omit from logs.",
									},
									"healthcheck_path": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "This path will be used to check the health of your site.",
									},
									"host_override": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host header will be overwritten with this field if provided.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"url": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The base address of your website without the path.",
									},
								},
							},
						},
						"kubernetes": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"certificate_authority": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The CA to authenticate TLS connections with.",
									},
									"client_certificate": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The certificate to authenticate TLS connections with.",
									},
									"client_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The key to authenticate TLS connections with.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"healthcheck_namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"remote_identity_group_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The ID of the remote identity group to use for remote identity connections.",
									},
									"remote_identity_healthcheck_username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to use for healthchecks, when clients otherwise connect with their own remote identity username.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"kubernetes_basic_auth": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"healthcheck_namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"kubernetes_service_account": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"healthcheck_namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"remote_identity_group_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The ID of the remote identity group to use for remote identity connections.",
									},
									"remote_identity_healthcheck_username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to use for healthchecks, when clients otherwise connect with their own remote identity username.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"token": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The API token to authenticate with.",
									},
								},
							},
						},
						"kubernetes_service_account_user_impersonation": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"healthcheck_namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"token": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The API token to authenticate with.",
									},
								},
							},
						},
						"kubernetes_user_impersonation": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"certificate_authority": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The CA to authenticate TLS connections with.",
									},
									"client_certificate": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The certificate to authenticate TLS connections with.",
									},
									"client_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The key to authenticate TLS connections with.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"healthcheck_namespace": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"maria": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The database for healthchecks. Does not affect client requests.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"require_native_auth": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"use_azure_single_server_usernames": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If true, appends the hostname to the username when hitting a database.azure.com address",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"memcached": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"memsql": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The database for healthchecks. Does not affect client requests.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"require_native_auth": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"use_azure_single_server_usernames": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If true, appends the hostname to the username when hitting a database.azure.com address",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"mongo_host": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"auth_database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The authentication database to use.",
									},
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"tls_required": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, TLS must be used to connect to this resource.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"mongo_legacy_host": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"auth_database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The authentication database to use.",
									},
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"replica_set": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The name of the mongo replicaset.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"tls_required": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, TLS must be used to connect to this resource.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"mongo_legacy_replicaset": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"auth_database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The authentication database to use.",
									},
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"connect_to_replica": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Set to connect to a replica instead of the primary node.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"replica_set": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The name of the mongo replicaset.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"tls_required": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, TLS must be used to connect to this resource.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"mongo_replica_set": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"auth_database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The authentication database to use.",
									},
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"connect_to_replica": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Set to connect to a replica instead of the primary node.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"replica_set": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The name of the mongo replicaset.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"tls_required": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, TLS must be used to connect to this resource.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"mongo_sharded_cluster": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"auth_database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The authentication database to use.",
									},
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"tls_required": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, TLS must be used to connect to this resource.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"mtls_mysql": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"certificate_authority": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The CA to authenticate TLS connections with.",
									},
									"client_certificate": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The certificate to authenticate TLS connections with.",
									},
									"client_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The key to authenticate TLS connections with.",
									},
									"database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The database for healthchecks. Does not affect client requests.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"require_native_auth": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"server_name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Server name for TLS verification (unverified by StrongDM if empty)",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"use_azure_single_server_usernames": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If true, appends the hostname to the username when hitting a database.azure.com address",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"mtls_postgres": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"certificate_authority": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The CA to authenticate TLS connections with.",
									},
									"client_certificate": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The certificate to authenticate TLS connections with.",
									},
									"client_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The key to authenticate TLS connections with.",
									},
									"database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"override_database": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"server_name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Server name for TLS verification (unverified by StrongDM if empty)",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"mysql": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The database for healthchecks. Does not affect client requests.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"require_native_auth": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"use_azure_single_server_usernames": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If true, appends the hostname to the username when hitting a database.azure.com address",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"neptune": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"endpoint": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"neptune_iam": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"access_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The Access Key ID to use to authenticate.",
									},
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"endpoint": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"region": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The AWS region to connect to.",
									},
									"role_arn": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The role to assume after logging in.",
									},
									"role_external_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.",
									},
									"secret_access_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The Secret Access Key to use to authenticate.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"oracle": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"tls_required": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, TLS must be used to connect to this resource.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"postgres": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"override_database": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"presto": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"tls_required": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, TLS must be used to connect to this resource.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"rabbitmq_amqp_091": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"tls_required": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, TLS must be used to connect to this resource.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"raw_tcp": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"rdp": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"downgrade_nla_connections": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "When set, network level authentication will not be used. May resolve unexpected authentication errors to older servers. When set, healthchecks cannot detect if a provided username / password pair is correct.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"lock_required": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"redis": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"tls_required": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, TLS must be used to connect to this resource.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"redshift": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"override_database": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"single_store": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The database for healthchecks. Does not affect client requests.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"require_native_auth": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"use_azure_single_server_usernames": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If true, appends the hostname to the username when hitting a database.azure.com address",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"snowflake": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"schema": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The schema to provide on authentication.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"snowsight": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"healthcheck_username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The StrongDM user email to use for healthchecks.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"saml_metadata": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The Metadata for your snowflake IDP integration",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"sql_server": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"allow_deprecated_encryption": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.",
									},
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The database for healthchecks, and used for clients if Override Default Database is true.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"override_database": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"schema": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The Schema to use to direct initial requests.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"sql_server_azure_ad": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"allow_deprecated_encryption": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.",
									},
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"client_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The Azure AD application (client) ID with which to authenticate.",
									},
									"database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The database for healthchecks, and used for clients if Override Default Database is true.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"override_database": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"schema": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The Schema to use to direct initial requests.",
									},
									"secret": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The Azure AD client secret (application password) with which to authenticate.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"tenant_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The Azure AD directory (tenant) ID with which to authenticate.",
									},
								},
							},
						},
						"sql_server_kerberos_ad": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"allow_deprecated_encryption": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.",
									},
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The database for healthchecks, and used for clients if Override Default Database is true.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"keytab": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The keytab file in base64 format containing an entry with the principal name (username@realm) and key version number with which to authenticate.",
									},
									"krb_config": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The Kerberos 5 configuration file (krb5.conf) specifying the Active Directory server (KDC) for the configured realm.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"override_database": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"realm": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The Active Directory domain (realm) to which the configured username belongs.",
									},
									"schema": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The Schema to use to direct initial requests.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"server_spn": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The Service Principal Name of the Microsoft SQL Server instance in Active Directory.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"ssh": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"allow_deprecated_key_exchanges": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.",
									},
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"key_type": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The key type to use e.g. rsa-2048 or ed25519",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_forwarding": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Whether port forwarding is allowed through this server.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"public_key": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "The public key to append to a server's authorized keys. This will be generated after resource creation.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"ssh_cert": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"allow_deprecated_key_exchanges": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.",
									},
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"key_type": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The key type to use e.g. rsa-2048 or ed25519",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_forwarding": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Whether port forwarding is allowed through this server.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"remote_identity_group_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The ID of the remote identity group to use for remote identity connections.",
									},
									"remote_identity_healthcheck_username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to use for healthchecks, when clients otherwise connect with their own remote identity username.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"ssh_customer_key": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"allow_deprecated_key_exchanges": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.",
									},
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_forwarding": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Whether port forwarding is allowed through this server.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"private_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The private key used to authenticate with the server.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"sybase": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"sybase_iq": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"teradata": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
						"trino": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_interface": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.",
									},
									"database": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.",
									},
									"egress_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "A filter applied to the routing logic to pin datasource to nodes.",
									},
									"hostname": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The host to dial to initiate a connection from the egress node to this resource.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Resource.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Resource.",
									},
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Sensitive:   true,
										Description: "The password to authenticate with.",
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The port to dial to initiate a connection from the egress node to this resource.",
									},
									"port_override": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The local port used by clients to connect to this resource.",
									},
									"secret_store_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "ID of the secret store containing credentials for this resource, if any.",
									},
									"subdomain": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The username to authenticate with.",
									},
								},
							},
						},
					},
				},
			},
		},
		Timeouts: &schema.ResourceTimeout{
			Default: schema.DefaultTimeout(60 * time.Second),
		},
	}
}

func convertResourceFilterToPlumbing(d *schema.ResourceData) (string, []interface{}) {
	filter := ""
	args := []interface{}{}
	if v, ok := d.GetOkExists("type"); ok {
		filter += "type:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("hostname"); ok {
		filter += "hostname:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("id"); ok {
		filter += "id:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("name"); ok {
		filter += "name:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("port"); ok {
		filter += "port:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("tags"); ok {
		tags := convertTagsToPlumbing(v)
		for kk, vv := range tags {
			filter += "tag:?=?"
			args = append(args, kk, vv)
		}
	}
	if v, ok := d.GetOkExists("username"); ok {
		filter += "username:? "
		args = append(args, v)
	}
	return filter, args
}

func dataSourceResourceList(ctx context.Context, d *schema.ResourceData, cc *sdm.Client) error {
	filter, args := convertResourceFilterToPlumbing(d)
	resp, err := cc.Resources().List(ctx, filter, args...)
	if err != nil {
		return fmt.Errorf("cannot list Resources %s: %w", d.Id(), err)
	}
	ids := []string{}
	type entity = map[string]interface{}
	output := make([]map[string][]entity, 1)
	output[0] = map[string][]entity{
		"aks": {},
	}
	for resp.Next() {
		ids = append(ids, resp.Value().GetID())
		switch v := resp.Value().(type) {
		case *sdm.AKS:
			output[0]["aks"] = append(output[0]["aks"], entity{
				"bind_interface":                       (v.BindInterface),
				"certificate_authority":                (v.CertificateAuthority),
				"client_certificate":                   (v.ClientCertificate),
				"client_key":                           (v.ClientKey),
				"egress_filter":                        (v.EgressFilter),
				"healthcheck_namespace":                (v.HealthcheckNamespace),
				"hostname":                             (v.Hostname),
				"id":                                   (v.ID),
				"name":                                 (v.Name),
				"port":                                 (v.Port),
				"port_override":                        (v.PortOverride),
				"remote_identity_group_id":             (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username": (v.RemoteIdentityHealthcheckUsername),
				"secret_store_id":                      (v.SecretStoreID),
				"subdomain":                            (v.Subdomain),
				"tags":                                 convertTagsToPorcelain(v.Tags),
			})
		case *sdm.AKSBasicAuth:
			output[0]["aks_basic_auth"] = append(output[0]["aks_basic_auth"], entity{
				"bind_interface":        (v.BindInterface),
				"egress_filter":         (v.EgressFilter),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"hostname":              (v.Hostname),
				"id":                    (v.ID),
				"name":                  (v.Name),
				"password":              (v.Password),
				"port":                  (v.Port),
				"port_override":         (v.PortOverride),
				"secret_store_id":       (v.SecretStoreID),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
				"username":              (v.Username),
			})
		case *sdm.AKSServiceAccount:
			output[0]["aks_service_account"] = append(output[0]["aks_service_account"], entity{
				"bind_interface":                       (v.BindInterface),
				"egress_filter":                        (v.EgressFilter),
				"healthcheck_namespace":                (v.HealthcheckNamespace),
				"hostname":                             (v.Hostname),
				"id":                                   (v.ID),
				"name":                                 (v.Name),
				"port":                                 (v.Port),
				"port_override":                        (v.PortOverride),
				"remote_identity_group_id":             (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username": (v.RemoteIdentityHealthcheckUsername),
				"secret_store_id":                      (v.SecretStoreID),
				"subdomain":                            (v.Subdomain),
				"tags":                                 convertTagsToPorcelain(v.Tags),
				"token":                                (v.Token),
			})
		case *sdm.AKSServiceAccountUserImpersonation:
			output[0]["aks_service_account_user_impersonation"] = append(output[0]["aks_service_account_user_impersonation"], entity{
				"bind_interface":        (v.BindInterface),
				"egress_filter":         (v.EgressFilter),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"hostname":              (v.Hostname),
				"id":                    (v.ID),
				"name":                  (v.Name),
				"port":                  (v.Port),
				"port_override":         (v.PortOverride),
				"secret_store_id":       (v.SecretStoreID),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
				"token":                 (v.Token),
			})
		case *sdm.AKSUserImpersonation:
			output[0]["aks_user_impersonation"] = append(output[0]["aks_user_impersonation"], entity{
				"bind_interface":        (v.BindInterface),
				"certificate_authority": (v.CertificateAuthority),
				"client_certificate":    (v.ClientCertificate),
				"client_key":            (v.ClientKey),
				"egress_filter":         (v.EgressFilter),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"hostname":              (v.Hostname),
				"id":                    (v.ID),
				"name":                  (v.Name),
				"port":                  (v.Port),
				"port_override":         (v.PortOverride),
				"secret_store_id":       (v.SecretStoreID),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
			})
		case *sdm.AmazonEKS:
			output[0]["amazon_eks"] = append(output[0]["amazon_eks"], entity{
				"access_key":                           (v.AccessKey),
				"bind_interface":                       (v.BindInterface),
				"certificate_authority":                (v.CertificateAuthority),
				"cluster_name":                         (v.ClusterName),
				"egress_filter":                        (v.EgressFilter),
				"endpoint":                             (v.Endpoint),
				"healthcheck_namespace":                (v.HealthcheckNamespace),
				"id":                                   (v.ID),
				"name":                                 (v.Name),
				"port_override":                        (v.PortOverride),
				"region":                               (v.Region),
				"remote_identity_group_id":             (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username": (v.RemoteIdentityHealthcheckUsername),
				"role_arn":                             (v.RoleArn),
				"role_external_id":                     (v.RoleExternalID),
				"secret_access_key":                    (v.SecretAccessKey),
				"secret_store_id":                      (v.SecretStoreID),
				"subdomain":                            (v.Subdomain),
				"tags":                                 convertTagsToPorcelain(v.Tags),
			})
		case *sdm.AmazonEKSInstanceProfile:
			output[0]["amazon_eks_instance_profile"] = append(output[0]["amazon_eks_instance_profile"], entity{
				"bind_interface":                       (v.BindInterface),
				"certificate_authority":                (v.CertificateAuthority),
				"cluster_name":                         (v.ClusterName),
				"egress_filter":                        (v.EgressFilter),
				"endpoint":                             (v.Endpoint),
				"healthcheck_namespace":                (v.HealthcheckNamespace),
				"id":                                   (v.ID),
				"name":                                 (v.Name),
				"port_override":                        (v.PortOverride),
				"region":                               (v.Region),
				"remote_identity_group_id":             (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username": (v.RemoteIdentityHealthcheckUsername),
				"role_arn":                             (v.RoleArn),
				"role_external_id":                     (v.RoleExternalID),
				"secret_store_id":                      (v.SecretStoreID),
				"subdomain":                            (v.Subdomain),
				"tags":                                 convertTagsToPorcelain(v.Tags),
			})
		case *sdm.AmazonEKSInstanceProfileUserImpersonation:
			output[0]["amazon_eks_instance_profile_user_impersonation"] = append(output[0]["amazon_eks_instance_profile_user_impersonation"], entity{
				"bind_interface":                       (v.BindInterface),
				"certificate_authority":                (v.CertificateAuthority),
				"cluster_name":                         (v.ClusterName),
				"egress_filter":                        (v.EgressFilter),
				"endpoint":                             (v.Endpoint),
				"healthcheck_namespace":                (v.HealthcheckNamespace),
				"id":                                   (v.ID),
				"name":                                 (v.Name),
				"port_override":                        (v.PortOverride),
				"region":                               (v.Region),
				"remote_identity_group_id":             (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username": (v.RemoteIdentityHealthcheckUsername),
				"role_arn":                             (v.RoleArn),
				"role_external_id":                     (v.RoleExternalID),
				"secret_store_id":                      (v.SecretStoreID),
				"subdomain":                            (v.Subdomain),
				"tags":                                 convertTagsToPorcelain(v.Tags),
			})
		case *sdm.AmazonEKSUserImpersonation:
			output[0]["amazon_eks_user_impersonation"] = append(output[0]["amazon_eks_user_impersonation"], entity{
				"access_key":            (v.AccessKey),
				"bind_interface":        (v.BindInterface),
				"certificate_authority": (v.CertificateAuthority),
				"cluster_name":          (v.ClusterName),
				"egress_filter":         (v.EgressFilter),
				"endpoint":              (v.Endpoint),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"id":                    (v.ID),
				"name":                  (v.Name),
				"port_override":         (v.PortOverride),
				"region":                (v.Region),
				"role_arn":              (v.RoleArn),
				"role_external_id":      (v.RoleExternalID),
				"secret_access_key":     (v.SecretAccessKey),
				"secret_store_id":       (v.SecretStoreID),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
			})
		case *sdm.AmazonES:
			output[0]["amazon_es"] = append(output[0]["amazon_es"], entity{
				"access_key":        (v.AccessKey),
				"bind_interface":    (v.BindInterface),
				"egress_filter":     (v.EgressFilter),
				"endpoint":          (v.Endpoint),
				"id":                (v.ID),
				"name":              (v.Name),
				"port_override":     (v.PortOverride),
				"region":            (v.Region),
				"role_arn":          (v.RoleArn),
				"role_external_id":  (v.RoleExternalID),
				"secret_access_key": (v.SecretAccessKey),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
			})
		case *sdm.AmazonMQAMQP091:
			output[0]["amazonmq_amqp_091"] = append(output[0]["amazonmq_amqp_091"], entity{
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"id":              (v.ID),
				"name":            (v.Name),
				"password":        (v.Password),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
				"tls_required":    (v.TlsRequired),
				"username":        (v.Username),
			})
		case *sdm.Athena:
			output[0]["athena"] = append(output[0]["athena"], entity{
				"access_key":        (v.AccessKey),
				"bind_interface":    (v.BindInterface),
				"egress_filter":     (v.EgressFilter),
				"id":                (v.ID),
				"name":              (v.Name),
				"output":            (v.Output),
				"port_override":     (v.PortOverride),
				"region":            (v.Region),
				"role_arn":          (v.RoleArn),
				"role_external_id":  (v.RoleExternalID),
				"secret_access_key": (v.SecretAccessKey),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
			})
		case *sdm.AuroraMysql:
			output[0]["aurora_mysql"] = append(output[0]["aurora_mysql"], entity{
				"bind_interface":                    (v.BindInterface),
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"id":                                (v.ID),
				"name":                              (v.Name),
				"password":                          (v.Password),
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"require_native_auth":               (v.RequireNativeAuth),
				"secret_store_id":                   (v.SecretStoreID),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          (v.Username),
			})
		case *sdm.AuroraPostgres:
			output[0]["aurora_postgres"] = append(output[0]["aurora_postgres"], entity{
				"bind_interface":    (v.BindInterface),
				"database":          (v.Database),
				"egress_filter":     (v.EgressFilter),
				"hostname":          (v.Hostname),
				"id":                (v.ID),
				"name":              (v.Name),
				"override_database": (v.OverrideDatabase),
				"password":          (v.Password),
				"port":              (v.Port),
				"port_override":     (v.PortOverride),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"username":          (v.Username),
			})
		case *sdm.AWS:
			output[0]["aws"] = append(output[0]["aws"], entity{
				"access_key":         (v.AccessKey),
				"bind_interface":     (v.BindInterface),
				"egress_filter":      (v.EgressFilter),
				"healthcheck_region": (v.HealthcheckRegion),
				"id":                 (v.ID),
				"name":               (v.Name),
				"port_override":      (v.PortOverride),
				"role_arn":           (v.RoleArn),
				"role_external_id":   (v.RoleExternalID),
				"secret_access_key":  (v.SecretAccessKey),
				"secret_store_id":    (v.SecretStoreID),
				"subdomain":          (v.Subdomain),
				"tags":               convertTagsToPorcelain(v.Tags),
			})
		case *sdm.AWSConsole:
			output[0]["aws_console"] = append(output[0]["aws_console"], entity{
				"bind_interface":                       (v.BindInterface),
				"egress_filter":                        (v.EgressFilter),
				"enable_env_variables":                 (v.EnableEnvVariables),
				"id":                                   (v.ID),
				"name":                                 (v.Name),
				"port_override":                        (v.PortOverride),
				"region":                               (v.Region),
				"remote_identity_group_id":             (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username": (v.RemoteIdentityHealthcheckUsername),
				"role_arn":                             (v.RoleArn),
				"role_external_id":                     (v.RoleExternalID),
				"secret_store_id":                      (v.SecretStoreID),
				"session_expiry":                       (v.SessionExpiry),
				"subdomain":                            (v.Subdomain),
				"tags":                                 convertTagsToPorcelain(v.Tags),
			})
		case *sdm.AWSConsoleStaticKeyPair:
			output[0]["aws_console_static_key_pair"] = append(output[0]["aws_console_static_key_pair"], entity{
				"access_key":                           (v.AccessKey),
				"bind_interface":                       (v.BindInterface),
				"egress_filter":                        (v.EgressFilter),
				"id":                                   (v.ID),
				"name":                                 (v.Name),
				"port_override":                        (v.PortOverride),
				"region":                               (v.Region),
				"remote_identity_group_id":             (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username": (v.RemoteIdentityHealthcheckUsername),
				"role_arn":                             (v.RoleArn),
				"role_external_id":                     (v.RoleExternalID),
				"secret_access_key":                    (v.SecretAccessKey),
				"secret_store_id":                      (v.SecretStoreID),
				"session_expiry":                       (v.SessionExpiry),
				"subdomain":                            (v.Subdomain),
				"tags":                                 convertTagsToPorcelain(v.Tags),
			})
		case *sdm.Azure:
			output[0]["azure"] = append(output[0]["azure"], entity{
				"app_id":          (v.AppID),
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"id":              (v.ID),
				"name":            (v.Name),
				"password":        (v.Password),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
				"tenant_id":       (v.TenantID),
			})
		case *sdm.AzureCertificate:
			output[0]["azure_certificate"] = append(output[0]["azure_certificate"], entity{
				"app_id":             (v.AppID),
				"bind_interface":     (v.BindInterface),
				"client_certificate": (v.ClientCertificate),
				"egress_filter":      (v.EgressFilter),
				"id":                 (v.ID),
				"name":               (v.Name),
				"port_override":      (v.PortOverride),
				"secret_store_id":    (v.SecretStoreID),
				"subdomain":          (v.Subdomain),
				"tags":               convertTagsToPorcelain(v.Tags),
				"tenant_id":          (v.TenantID),
			})
		case *sdm.AzureMysql:
			output[0]["azure_mysql"] = append(output[0]["azure_mysql"], entity{
				"bind_interface":                    (v.BindInterface),
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"id":                                (v.ID),
				"name":                              (v.Name),
				"password":                          (v.Password),
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"require_native_auth":               (v.RequireNativeAuth),
				"secret_store_id":                   (v.SecretStoreID),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          (v.Username),
			})
		case *sdm.AzurePostgres:
			output[0]["azure_postgres"] = append(output[0]["azure_postgres"], entity{
				"bind_interface":    (v.BindInterface),
				"database":          (v.Database),
				"egress_filter":     (v.EgressFilter),
				"hostname":          (v.Hostname),
				"id":                (v.ID),
				"name":              (v.Name),
				"override_database": (v.OverrideDatabase),
				"password":          (v.Password),
				"port":              (v.Port),
				"port_override":     (v.PortOverride),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"username":          (v.Username),
			})
		case *sdm.AzurePostgresManagedIdentity:
			output[0]["azure_postgres_managed_identity"] = append(output[0]["azure_postgres_managed_identity"], entity{
				"bind_interface":                    (v.BindInterface),
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"id":                                (v.ID),
				"name":                              (v.Name),
				"override_database":                 (v.OverrideDatabase),
				"password":                          (v.Password),
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"secret_store_id":                   (v.SecretStoreID),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          (v.Username),
			})
		case *sdm.BigQuery:
			output[0]["big_query"] = append(output[0]["big_query"], entity{
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"endpoint":        (v.Endpoint),
				"id":              (v.ID),
				"name":            (v.Name),
				"port_override":   (v.PortOverride),
				"private_key":     (v.PrivateKey),
				"project":         (v.Project),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
				"username":        (v.Username),
			})
		case *sdm.Cassandra:
			output[0]["cassandra"] = append(output[0]["cassandra"], entity{
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"id":              (v.ID),
				"name":            (v.Name),
				"password":        (v.Password),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
				"tls_required":    (v.TlsRequired),
				"username":        (v.Username),
			})
		case *sdm.Citus:
			output[0]["citus"] = append(output[0]["citus"], entity{
				"bind_interface":    (v.BindInterface),
				"database":          (v.Database),
				"egress_filter":     (v.EgressFilter),
				"hostname":          (v.Hostname),
				"id":                (v.ID),
				"name":              (v.Name),
				"override_database": (v.OverrideDatabase),
				"password":          (v.Password),
				"port":              (v.Port),
				"port_override":     (v.PortOverride),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"username":          (v.Username),
			})
		case *sdm.Clustrix:
			output[0]["clustrix"] = append(output[0]["clustrix"], entity{
				"bind_interface":                    (v.BindInterface),
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"id":                                (v.ID),
				"name":                              (v.Name),
				"password":                          (v.Password),
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"require_native_auth":               (v.RequireNativeAuth),
				"secret_store_id":                   (v.SecretStoreID),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          (v.Username),
			})
		case *sdm.Cockroach:
			output[0]["cockroach"] = append(output[0]["cockroach"], entity{
				"bind_interface":    (v.BindInterface),
				"database":          (v.Database),
				"egress_filter":     (v.EgressFilter),
				"hostname":          (v.Hostname),
				"id":                (v.ID),
				"name":              (v.Name),
				"override_database": (v.OverrideDatabase),
				"password":          (v.Password),
				"port":              (v.Port),
				"port_override":     (v.PortOverride),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"username":          (v.Username),
			})
		case *sdm.DB2I:
			output[0]["db_2_i"] = append(output[0]["db_2_i"], entity{
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"id":              (v.ID),
				"name":            (v.Name),
				"password":        (v.Password),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
				"tls_required":    (v.TlsRequired),
				"username":        (v.Username),
			})
		case *sdm.DB2LUW:
			output[0]["db_2_luw"] = append(output[0]["db_2_luw"], entity{
				"bind_interface":  (v.BindInterface),
				"database":        (v.Database),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"id":              (v.ID),
				"name":            (v.Name),
				"password":        (v.Password),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
				"username":        (v.Username),
			})
		case *sdm.DocumentDBHost:
			output[0]["document_db_host"] = append(output[0]["document_db_host"], entity{
				"auth_database":   (v.AuthDatabase),
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"id":              (v.ID),
				"name":            (v.Name),
				"password":        (v.Password),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
				"username":        (v.Username),
			})
		case *sdm.DocumentDBReplicaSet:
			output[0]["document_db_replica_set"] = append(output[0]["document_db_replica_set"], entity{
				"auth_database":      (v.AuthDatabase),
				"bind_interface":     (v.BindInterface),
				"connect_to_replica": (v.ConnectToReplica),
				"egress_filter":      (v.EgressFilter),
				"hostname":           (v.Hostname),
				"id":                 (v.ID),
				"name":               (v.Name),
				"password":           (v.Password),
				"port_override":      (v.PortOverride),
				"replica_set":        (v.ReplicaSet),
				"secret_store_id":    (v.SecretStoreID),
				"subdomain":          (v.Subdomain),
				"tags":               convertTagsToPorcelain(v.Tags),
				"username":           (v.Username),
			})
		case *sdm.Druid:
			output[0]["druid"] = append(output[0]["druid"], entity{
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"id":              (v.ID),
				"name":            (v.Name),
				"password":        (v.Password),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
				"username":        (v.Username),
			})
		case *sdm.DynamoDB:
			output[0]["dynamo_db"] = append(output[0]["dynamo_db"], entity{
				"access_key":        (v.AccessKey),
				"bind_interface":    (v.BindInterface),
				"egress_filter":     (v.EgressFilter),
				"endpoint":          (v.Endpoint),
				"id":                (v.ID),
				"name":              (v.Name),
				"port_override":     (v.PortOverride),
				"region":            (v.Region),
				"role_arn":          (v.RoleArn),
				"role_external_id":  (v.RoleExternalID),
				"secret_access_key": (v.SecretAccessKey),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
			})
		case *sdm.Elastic:
			output[0]["elastic"] = append(output[0]["elastic"], entity{
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"id":              (v.ID),
				"name":            (v.Name),
				"password":        (v.Password),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
				"tls_required":    (v.TlsRequired),
				"username":        (v.Username),
			})
		case *sdm.ElasticacheRedis:
			output[0]["elasticache_redis"] = append(output[0]["elasticache_redis"], entity{
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"id":              (v.ID),
				"name":            (v.Name),
				"password":        (v.Password),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
				"tls_required":    (v.TlsRequired),
				"username":        (v.Username),
			})
		case *sdm.GCP:
			output[0]["gcp"] = append(output[0]["gcp"], entity{
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"id":              (v.ID),
				"keyfile":         (v.Keyfile),
				"name":            (v.Name),
				"port_override":   (v.PortOverride),
				"scopes":          (v.Scopes),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
			})
		case *sdm.GoogleGKE:
			output[0]["google_gke"] = append(output[0]["google_gke"], entity{
				"bind_interface":                       (v.BindInterface),
				"certificate_authority":                (v.CertificateAuthority),
				"egress_filter":                        (v.EgressFilter),
				"endpoint":                             (v.Endpoint),
				"healthcheck_namespace":                (v.HealthcheckNamespace),
				"id":                                   (v.ID),
				"name":                                 (v.Name),
				"port_override":                        (v.PortOverride),
				"remote_identity_group_id":             (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username": (v.RemoteIdentityHealthcheckUsername),
				"secret_store_id":                      (v.SecretStoreID),
				"service_account_key":                  (v.ServiceAccountKey),
				"subdomain":                            (v.Subdomain),
				"tags":                                 convertTagsToPorcelain(v.Tags),
			})
		case *sdm.GoogleGKEUserImpersonation:
			output[0]["google_gke_user_impersonation"] = append(output[0]["google_gke_user_impersonation"], entity{
				"bind_interface":        (v.BindInterface),
				"certificate_authority": (v.CertificateAuthority),
				"egress_filter":         (v.EgressFilter),
				"endpoint":              (v.Endpoint),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"id":                    (v.ID),
				"name":                  (v.Name),
				"port_override":         (v.PortOverride),
				"secret_store_id":       (v.SecretStoreID),
				"service_account_key":   (v.ServiceAccountKey),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
			})
		case *sdm.Greenplum:
			output[0]["greenplum"] = append(output[0]["greenplum"], entity{
				"bind_interface":    (v.BindInterface),
				"database":          (v.Database),
				"egress_filter":     (v.EgressFilter),
				"hostname":          (v.Hostname),
				"id":                (v.ID),
				"name":              (v.Name),
				"override_database": (v.OverrideDatabase),
				"password":          (v.Password),
				"port":              (v.Port),
				"port_override":     (v.PortOverride),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"username":          (v.Username),
			})
		case *sdm.HTTPAuth:
			output[0]["http_auth"] = append(output[0]["http_auth"], entity{
				"auth_header":       (v.AuthHeader),
				"bind_interface":    (v.BindInterface),
				"default_path":      (v.DefaultPath),
				"egress_filter":     (v.EgressFilter),
				"headers_blacklist": (v.HeadersBlacklist),
				"healthcheck_path":  (v.HealthcheckPath),
				"host_override":     (v.HostOverride),
				"id":                (v.ID),
				"name":              (v.Name),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"url":               (v.Url),
			})
		case *sdm.HTTPBasicAuth:
			output[0]["http_basic_auth"] = append(output[0]["http_basic_auth"], entity{
				"bind_interface":    (v.BindInterface),
				"default_path":      (v.DefaultPath),
				"egress_filter":     (v.EgressFilter),
				"headers_blacklist": (v.HeadersBlacklist),
				"healthcheck_path":  (v.HealthcheckPath),
				"host_override":     (v.HostOverride),
				"id":                (v.ID),
				"name":              (v.Name),
				"password":          (v.Password),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"url":               (v.Url),
				"username":          (v.Username),
			})
		case *sdm.HTTPNoAuth:
			output[0]["http_no_auth"] = append(output[0]["http_no_auth"], entity{
				"bind_interface":    (v.BindInterface),
				"default_path":      (v.DefaultPath),
				"egress_filter":     (v.EgressFilter),
				"headers_blacklist": (v.HeadersBlacklist),
				"healthcheck_path":  (v.HealthcheckPath),
				"host_override":     (v.HostOverride),
				"id":                (v.ID),
				"name":              (v.Name),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"url":               (v.Url),
			})
		case *sdm.Kubernetes:
			output[0]["kubernetes"] = append(output[0]["kubernetes"], entity{
				"bind_interface":                       (v.BindInterface),
				"certificate_authority":                (v.CertificateAuthority),
				"client_certificate":                   (v.ClientCertificate),
				"client_key":                           (v.ClientKey),
				"egress_filter":                        (v.EgressFilter),
				"healthcheck_namespace":                (v.HealthcheckNamespace),
				"hostname":                             (v.Hostname),
				"id":                                   (v.ID),
				"name":                                 (v.Name),
				"port":                                 (v.Port),
				"port_override":                        (v.PortOverride),
				"remote_identity_group_id":             (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username": (v.RemoteIdentityHealthcheckUsername),
				"secret_store_id":                      (v.SecretStoreID),
				"subdomain":                            (v.Subdomain),
				"tags":                                 convertTagsToPorcelain(v.Tags),
			})
		case *sdm.KubernetesBasicAuth:
			output[0]["kubernetes_basic_auth"] = append(output[0]["kubernetes_basic_auth"], entity{
				"bind_interface":        (v.BindInterface),
				"egress_filter":         (v.EgressFilter),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"hostname":              (v.Hostname),
				"id":                    (v.ID),
				"name":                  (v.Name),
				"password":              (v.Password),
				"port":                  (v.Port),
				"port_override":         (v.PortOverride),
				"secret_store_id":       (v.SecretStoreID),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
				"username":              (v.Username),
			})
		case *sdm.KubernetesServiceAccount:
			output[0]["kubernetes_service_account"] = append(output[0]["kubernetes_service_account"], entity{
				"bind_interface":                       (v.BindInterface),
				"egress_filter":                        (v.EgressFilter),
				"healthcheck_namespace":                (v.HealthcheckNamespace),
				"hostname":                             (v.Hostname),
				"id":                                   (v.ID),
				"name":                                 (v.Name),
				"port":                                 (v.Port),
				"port_override":                        (v.PortOverride),
				"remote_identity_group_id":             (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username": (v.RemoteIdentityHealthcheckUsername),
				"secret_store_id":                      (v.SecretStoreID),
				"subdomain":                            (v.Subdomain),
				"tags":                                 convertTagsToPorcelain(v.Tags),
				"token":                                (v.Token),
			})
		case *sdm.KubernetesServiceAccountUserImpersonation:
			output[0]["kubernetes_service_account_user_impersonation"] = append(output[0]["kubernetes_service_account_user_impersonation"], entity{
				"bind_interface":        (v.BindInterface),
				"egress_filter":         (v.EgressFilter),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"hostname":              (v.Hostname),
				"id":                    (v.ID),
				"name":                  (v.Name),
				"port":                  (v.Port),
				"port_override":         (v.PortOverride),
				"secret_store_id":       (v.SecretStoreID),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
				"token":                 (v.Token),
			})
		case *sdm.KubernetesUserImpersonation:
			output[0]["kubernetes_user_impersonation"] = append(output[0]["kubernetes_user_impersonation"], entity{
				"bind_interface":        (v.BindInterface),
				"certificate_authority": (v.CertificateAuthority),
				"client_certificate":    (v.ClientCertificate),
				"client_key":            (v.ClientKey),
				"egress_filter":         (v.EgressFilter),
				"healthcheck_namespace": (v.HealthcheckNamespace),
				"hostname":              (v.Hostname),
				"id":                    (v.ID),
				"name":                  (v.Name),
				"port":                  (v.Port),
				"port_override":         (v.PortOverride),
				"secret_store_id":       (v.SecretStoreID),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
			})
		case *sdm.Maria:
			output[0]["maria"] = append(output[0]["maria"], entity{
				"bind_interface":                    (v.BindInterface),
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"id":                                (v.ID),
				"name":                              (v.Name),
				"password":                          (v.Password),
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"require_native_auth":               (v.RequireNativeAuth),
				"secret_store_id":                   (v.SecretStoreID),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          (v.Username),
			})
		case *sdm.Memcached:
			output[0]["memcached"] = append(output[0]["memcached"], entity{
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"id":              (v.ID),
				"name":            (v.Name),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
			})
		case *sdm.Memsql:
			output[0]["memsql"] = append(output[0]["memsql"], entity{
				"bind_interface":                    (v.BindInterface),
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"id":                                (v.ID),
				"name":                              (v.Name),
				"password":                          (v.Password),
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"require_native_auth":               (v.RequireNativeAuth),
				"secret_store_id":                   (v.SecretStoreID),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          (v.Username),
			})
		case *sdm.MongoHost:
			output[0]["mongo_host"] = append(output[0]["mongo_host"], entity{
				"auth_database":   (v.AuthDatabase),
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"id":              (v.ID),
				"name":            (v.Name),
				"password":        (v.Password),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
				"tls_required":    (v.TlsRequired),
				"username":        (v.Username),
			})
		case *sdm.MongoLegacyHost:
			output[0]["mongo_legacy_host"] = append(output[0]["mongo_legacy_host"], entity{
				"auth_database":   (v.AuthDatabase),
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"id":              (v.ID),
				"name":            (v.Name),
				"password":        (v.Password),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"replica_set":     (v.ReplicaSet),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
				"tls_required":    (v.TlsRequired),
				"username":        (v.Username),
			})
		case *sdm.MongoLegacyReplicaset:
			output[0]["mongo_legacy_replicaset"] = append(output[0]["mongo_legacy_replicaset"], entity{
				"auth_database":      (v.AuthDatabase),
				"bind_interface":     (v.BindInterface),
				"connect_to_replica": (v.ConnectToReplica),
				"egress_filter":      (v.EgressFilter),
				"hostname":           (v.Hostname),
				"id":                 (v.ID),
				"name":               (v.Name),
				"password":           (v.Password),
				"port":               (v.Port),
				"port_override":      (v.PortOverride),
				"replica_set":        (v.ReplicaSet),
				"secret_store_id":    (v.SecretStoreID),
				"subdomain":          (v.Subdomain),
				"tags":               convertTagsToPorcelain(v.Tags),
				"tls_required":       (v.TlsRequired),
				"username":           (v.Username),
			})
		case *sdm.MongoReplicaSet:
			output[0]["mongo_replica_set"] = append(output[0]["mongo_replica_set"], entity{
				"auth_database":      (v.AuthDatabase),
				"bind_interface":     (v.BindInterface),
				"connect_to_replica": (v.ConnectToReplica),
				"egress_filter":      (v.EgressFilter),
				"hostname":           (v.Hostname),
				"id":                 (v.ID),
				"name":               (v.Name),
				"password":           (v.Password),
				"port":               (v.Port),
				"port_override":      (v.PortOverride),
				"replica_set":        (v.ReplicaSet),
				"secret_store_id":    (v.SecretStoreID),
				"subdomain":          (v.Subdomain),
				"tags":               convertTagsToPorcelain(v.Tags),
				"tls_required":       (v.TlsRequired),
				"username":           (v.Username),
			})
		case *sdm.MongoShardedCluster:
			output[0]["mongo_sharded_cluster"] = append(output[0]["mongo_sharded_cluster"], entity{
				"auth_database":   (v.AuthDatabase),
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"id":              (v.ID),
				"name":            (v.Name),
				"password":        (v.Password),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
				"tls_required":    (v.TlsRequired),
				"username":        (v.Username),
			})
		case *sdm.MTLSMysql:
			output[0]["mtls_mysql"] = append(output[0]["mtls_mysql"], entity{
				"bind_interface":                    (v.BindInterface),
				"certificate_authority":             (v.CertificateAuthority),
				"client_certificate":                (v.ClientCertificate),
				"client_key":                        (v.ClientKey),
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"id":                                (v.ID),
				"name":                              (v.Name),
				"password":                          (v.Password),
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"require_native_auth":               (v.RequireNativeAuth),
				"secret_store_id":                   (v.SecretStoreID),
				"server_name":                       (v.ServerName),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          (v.Username),
			})
		case *sdm.MTLSPostgres:
			output[0]["mtls_postgres"] = append(output[0]["mtls_postgres"], entity{
				"bind_interface":        (v.BindInterface),
				"certificate_authority": (v.CertificateAuthority),
				"client_certificate":    (v.ClientCertificate),
				"client_key":            (v.ClientKey),
				"database":              (v.Database),
				"egress_filter":         (v.EgressFilter),
				"hostname":              (v.Hostname),
				"id":                    (v.ID),
				"name":                  (v.Name),
				"override_database":     (v.OverrideDatabase),
				"password":              (v.Password),
				"port":                  (v.Port),
				"port_override":         (v.PortOverride),
				"secret_store_id":       (v.SecretStoreID),
				"server_name":           (v.ServerName),
				"subdomain":             (v.Subdomain),
				"tags":                  convertTagsToPorcelain(v.Tags),
				"username":              (v.Username),
			})
		case *sdm.Mysql:
			output[0]["mysql"] = append(output[0]["mysql"], entity{
				"bind_interface":                    (v.BindInterface),
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"id":                                (v.ID),
				"name":                              (v.Name),
				"password":                          (v.Password),
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"require_native_auth":               (v.RequireNativeAuth),
				"secret_store_id":                   (v.SecretStoreID),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          (v.Username),
			})
		case *sdm.Neptune:
			output[0]["neptune"] = append(output[0]["neptune"], entity{
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"endpoint":        (v.Endpoint),
				"id":              (v.ID),
				"name":            (v.Name),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
			})
		case *sdm.NeptuneIAM:
			output[0]["neptune_iam"] = append(output[0]["neptune_iam"], entity{
				"access_key":        (v.AccessKey),
				"bind_interface":    (v.BindInterface),
				"egress_filter":     (v.EgressFilter),
				"endpoint":          (v.Endpoint),
				"id":                (v.ID),
				"name":              (v.Name),
				"port":              (v.Port),
				"port_override":     (v.PortOverride),
				"region":            (v.Region),
				"role_arn":          (v.RoleArn),
				"role_external_id":  (v.RoleExternalID),
				"secret_access_key": (v.SecretAccessKey),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
			})
		case *sdm.Oracle:
			output[0]["oracle"] = append(output[0]["oracle"], entity{
				"bind_interface":  (v.BindInterface),
				"database":        (v.Database),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"id":              (v.ID),
				"name":            (v.Name),
				"password":        (v.Password),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
				"tls_required":    (v.TlsRequired),
				"username":        (v.Username),
			})
		case *sdm.Postgres:
			output[0]["postgres"] = append(output[0]["postgres"], entity{
				"bind_interface":    (v.BindInterface),
				"database":          (v.Database),
				"egress_filter":     (v.EgressFilter),
				"hostname":          (v.Hostname),
				"id":                (v.ID),
				"name":              (v.Name),
				"override_database": (v.OverrideDatabase),
				"password":          (v.Password),
				"port":              (v.Port),
				"port_override":     (v.PortOverride),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"username":          (v.Username),
			})
		case *sdm.Presto:
			output[0]["presto"] = append(output[0]["presto"], entity{
				"bind_interface":  (v.BindInterface),
				"database":        (v.Database),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"id":              (v.ID),
				"name":            (v.Name),
				"password":        (v.Password),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
				"tls_required":    (v.TlsRequired),
				"username":        (v.Username),
			})
		case *sdm.RabbitMQAMQP091:
			output[0]["rabbitmq_amqp_091"] = append(output[0]["rabbitmq_amqp_091"], entity{
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"id":              (v.ID),
				"name":            (v.Name),
				"password":        (v.Password),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
				"tls_required":    (v.TlsRequired),
				"username":        (v.Username),
			})
		case *sdm.RawTCP:
			output[0]["raw_tcp"] = append(output[0]["raw_tcp"], entity{
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"id":              (v.ID),
				"name":            (v.Name),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
			})
		case *sdm.RDP:
			output[0]["rdp"] = append(output[0]["rdp"], entity{
				"bind_interface":            (v.BindInterface),
				"downgrade_nla_connections": (v.DowngradeNlaConnections),
				"egress_filter":             (v.EgressFilter),
				"hostname":                  (v.Hostname),
				"id":                        (v.ID),
				"lock_required":             (v.LockRequired),
				"name":                      (v.Name),
				"password":                  (v.Password),
				"port":                      (v.Port),
				"port_override":             (v.PortOverride),
				"secret_store_id":           (v.SecretStoreID),
				"subdomain":                 (v.Subdomain),
				"tags":                      convertTagsToPorcelain(v.Tags),
				"username":                  (v.Username),
			})
		case *sdm.Redis:
			output[0]["redis"] = append(output[0]["redis"], entity{
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"id":              (v.ID),
				"name":            (v.Name),
				"password":        (v.Password),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
				"tls_required":    (v.TlsRequired),
				"username":        (v.Username),
			})
		case *sdm.Redshift:
			output[0]["redshift"] = append(output[0]["redshift"], entity{
				"bind_interface":    (v.BindInterface),
				"database":          (v.Database),
				"egress_filter":     (v.EgressFilter),
				"hostname":          (v.Hostname),
				"id":                (v.ID),
				"name":              (v.Name),
				"override_database": (v.OverrideDatabase),
				"password":          (v.Password),
				"port":              (v.Port),
				"port_override":     (v.PortOverride),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"username":          (v.Username),
			})
		case *sdm.SingleStore:
			output[0]["single_store"] = append(output[0]["single_store"], entity{
				"bind_interface":                    (v.BindInterface),
				"database":                          (v.Database),
				"egress_filter":                     (v.EgressFilter),
				"hostname":                          (v.Hostname),
				"id":                                (v.ID),
				"name":                              (v.Name),
				"password":                          (v.Password),
				"port":                              (v.Port),
				"port_override":                     (v.PortOverride),
				"require_native_auth":               (v.RequireNativeAuth),
				"secret_store_id":                   (v.SecretStoreID),
				"subdomain":                         (v.Subdomain),
				"tags":                              convertTagsToPorcelain(v.Tags),
				"use_azure_single_server_usernames": (v.UseAzureSingleServerUsernames),
				"username":                          (v.Username),
			})
		case *sdm.Snowflake:
			output[0]["snowflake"] = append(output[0]["snowflake"], entity{
				"bind_interface":  (v.BindInterface),
				"database":        (v.Database),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"id":              (v.ID),
				"name":            (v.Name),
				"password":        (v.Password),
				"port_override":   (v.PortOverride),
				"schema":          (v.Schema),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
				"username":        (v.Username),
			})
		case *sdm.Snowsight:
			output[0]["snowsight"] = append(output[0]["snowsight"], entity{
				"bind_interface":       (v.BindInterface),
				"egress_filter":        (v.EgressFilter),
				"healthcheck_username": (v.HealthcheckUsername),
				"id":                   (v.ID),
				"name":                 (v.Name),
				"port_override":        (v.PortOverride),
				"saml_metadata":        (v.SamlMetadata),
				"secret_store_id":      (v.SecretStoreID),
				"subdomain":            (v.Subdomain),
				"tags":                 convertTagsToPorcelain(v.Tags),
			})
		case *sdm.SQLServer:
			output[0]["sql_server"] = append(output[0]["sql_server"], entity{
				"allow_deprecated_encryption": (v.AllowDeprecatedEncryption),
				"bind_interface":              (v.BindInterface),
				"database":                    (v.Database),
				"egress_filter":               (v.EgressFilter),
				"hostname":                    (v.Hostname),
				"id":                          (v.ID),
				"name":                        (v.Name),
				"override_database":           (v.OverrideDatabase),
				"password":                    (v.Password),
				"port":                        (v.Port),
				"port_override":               (v.PortOverride),
				"schema":                      (v.Schema),
				"secret_store_id":             (v.SecretStoreID),
				"subdomain":                   (v.Subdomain),
				"tags":                        convertTagsToPorcelain(v.Tags),
				"username":                    (v.Username),
			})
		case *sdm.SQLServerAzureAD:
			output[0]["sql_server_azure_ad"] = append(output[0]["sql_server_azure_ad"], entity{
				"allow_deprecated_encryption": (v.AllowDeprecatedEncryption),
				"bind_interface":              (v.BindInterface),
				"client_id":                   (v.ClientID),
				"database":                    (v.Database),
				"egress_filter":               (v.EgressFilter),
				"hostname":                    (v.Hostname),
				"id":                          (v.ID),
				"name":                        (v.Name),
				"override_database":           (v.OverrideDatabase),
				"port":                        (v.Port),
				"port_override":               (v.PortOverride),
				"schema":                      (v.Schema),
				"secret":                      (v.Secret),
				"secret_store_id":             (v.SecretStoreID),
				"subdomain":                   (v.Subdomain),
				"tags":                        convertTagsToPorcelain(v.Tags),
				"tenant_id":                   (v.TenantID),
			})
		case *sdm.SQLServerKerberosAD:
			output[0]["sql_server_kerberos_ad"] = append(output[0]["sql_server_kerberos_ad"], entity{
				"allow_deprecated_encryption": (v.AllowDeprecatedEncryption),
				"bind_interface":              (v.BindInterface),
				"database":                    (v.Database),
				"egress_filter":               (v.EgressFilter),
				"hostname":                    (v.Hostname),
				"id":                          (v.ID),
				"keytab":                      (v.Keytab),
				"krb_config":                  (v.KrbConfig),
				"name":                        (v.Name),
				"override_database":           (v.OverrideDatabase),
				"port":                        (v.Port),
				"port_override":               (v.PortOverride),
				"realm":                       (v.Realm),
				"schema":                      (v.Schema),
				"secret_store_id":             (v.SecretStoreID),
				"server_spn":                  (v.ServerSpn),
				"subdomain":                   (v.Subdomain),
				"tags":                        convertTagsToPorcelain(v.Tags),
				"username":                    (v.Username),
			})
		case *sdm.SSH:
			output[0]["ssh"] = append(output[0]["ssh"], entity{
				"allow_deprecated_key_exchanges": (v.AllowDeprecatedKeyExchanges),
				"bind_interface":                 (v.BindInterface),
				"egress_filter":                  (v.EgressFilter),
				"hostname":                       (v.Hostname),
				"id":                             (v.ID),
				"key_type":                       (v.KeyType),
				"name":                           (v.Name),
				"port":                           (v.Port),
				"port_forwarding":                (v.PortForwarding),
				"port_override":                  (v.PortOverride),
				"public_key":                     (v.PublicKey),
				"secret_store_id":                (v.SecretStoreID),
				"subdomain":                      (v.Subdomain),
				"tags":                           convertTagsToPorcelain(v.Tags),
				"username":                       (v.Username),
			})
		case *sdm.SSHCert:
			output[0]["ssh_cert"] = append(output[0]["ssh_cert"], entity{
				"allow_deprecated_key_exchanges":       (v.AllowDeprecatedKeyExchanges),
				"bind_interface":                       (v.BindInterface),
				"egress_filter":                        (v.EgressFilter),
				"hostname":                             (v.Hostname),
				"id":                                   (v.ID),
				"key_type":                             (v.KeyType),
				"name":                                 (v.Name),
				"port":                                 (v.Port),
				"port_forwarding":                      (v.PortForwarding),
				"port_override":                        (v.PortOverride),
				"remote_identity_group_id":             (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username": (v.RemoteIdentityHealthcheckUsername),
				"secret_store_id":                      (v.SecretStoreID),
				"subdomain":                            (v.Subdomain),
				"tags":                                 convertTagsToPorcelain(v.Tags),
				"username":                             (v.Username),
			})
		case *sdm.SSHCustomerKey:
			output[0]["ssh_customer_key"] = append(output[0]["ssh_customer_key"], entity{
				"allow_deprecated_key_exchanges": (v.AllowDeprecatedKeyExchanges),
				"bind_interface":                 (v.BindInterface),
				"egress_filter":                  (v.EgressFilter),
				"hostname":                       (v.Hostname),
				"id":                             (v.ID),
				"name":                           (v.Name),
				"port":                           (v.Port),
				"port_forwarding":                (v.PortForwarding),
				"port_override":                  (v.PortOverride),
				"private_key":                    (v.PrivateKey),
				"secret_store_id":                (v.SecretStoreID),
				"subdomain":                      (v.Subdomain),
				"tags":                           convertTagsToPorcelain(v.Tags),
				"username":                       (v.Username),
			})
		case *sdm.Sybase:
			output[0]["sybase"] = append(output[0]["sybase"], entity{
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"id":              (v.ID),
				"name":            (v.Name),
				"password":        (v.Password),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
				"username":        (v.Username),
			})
		case *sdm.SybaseIQ:
			output[0]["sybase_iq"] = append(output[0]["sybase_iq"], entity{
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"id":              (v.ID),
				"name":            (v.Name),
				"password":        (v.Password),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
				"username":        (v.Username),
			})
		case *sdm.Teradata:
			output[0]["teradata"] = append(output[0]["teradata"], entity{
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"id":              (v.ID),
				"name":            (v.Name),
				"password":        (v.Password),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
				"username":        (v.Username),
			})
		case *sdm.Trino:
			output[0]["trino"] = append(output[0]["trino"], entity{
				"bind_interface":  (v.BindInterface),
				"database":        (v.Database),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"id":              (v.ID),
				"name":            (v.Name),
				"password":        (v.Password),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
				"username":        (v.Username),
			})
		}
	}
	if resp.Err() != nil {
		return fmt.Errorf("failure during list: %w", resp.Err())
	}

	err = d.Set("ids", ids)
	if err != nil {
		return fmt.Errorf("cannot set ids: %w", err)
	}
	err = d.Set("resources", output)
	if err != nil {
		return fmt.Errorf("cannot set output: %w", err)
	}
	d.SetId("Resource" + filter + fmt.Sprint(args...))
	return nil
}
