// Code generated by protogen. DO NOT EDIT.

package sdm

import (
	"context"
	"fmt"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	sdm "github.com/strongdm/terraform-provider-sdm/sdm/internal/sdk"
)

func dataSourceNode() *schema.Resource {
	return &schema.Resource{
		ReadContext: wrapCrudOperation(dataSourceNodeList),
		Schema: map[string]*schema.Schema{
			"ids": {
				Type:     schema.TypeList,
				Computed: true,
				Elem:     &schema.Schema{Type: schema.TypeString},
			},
			"type": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"bind_address": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"id": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"listen_address": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"name": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"tags": {
				Type:     schema.TypeMap,
				Optional: true,
				Elem:     tagsElemType,
			},
			"nodes": {
				Type:     schema.TypeList,
				Computed: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"gateway": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "Gateway represents a StrongDM CLI installation running in gateway mode.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bind_address": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The hostname/port tuple which the gateway daemon will bind to. If not provided on create, set to \"0.0.0.0:listen_address_port\".",
									},
									"device": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Device is a read only device name uploaded by the gateway process when it comes online.",
									},
									"gateway_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Gateway.",
									},
									"listen_address": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The public hostname/port tuple at which the gateway will be accessible to clients.",
									},
									"location": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Location is a read only network location uploaded by the gateway process when it comes online.",
									},
									"maintenance_window": {
										Type:        schema.TypeList,
										Elem:        nodeMaintenanceWindowElemType,
										Optional:    true,
										Description: "Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Gateway. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"version": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Version is a read only sdm binary version uploaded by the gateway process when it comes online.",
									},
								},
							},
						},
						"proxy_cluster": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "ProxyCluster represents a cluster of StrongDM proxies.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"address": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The public hostname/port tuple at which the proxy cluster will be accessible to clients.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Proxy Cluster.",
									},
									"maintenance_window": {
										Type:        schema.TypeList,
										Elem:        nodeMaintenanceWindowElemType,
										Optional:    true,
										Description: "Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the proxy cluster. Names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
								},
							},
						},
						"relay": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "Relay represents a StrongDM CLI installation running in relay mode.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"device": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Device is a read only device name uploaded by the gateway process when it comes online.",
									},
									"gateway_filter": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.",
									},
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique identifier of the Relay.",
									},
									"location": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Location is a read only network location uploaded by the gateway process when it comes online.",
									},
									"maintenance_window": {
										Type:        schema.TypeList,
										Elem:        nodeMaintenanceWindowElemType,
										Optional:    true,
										Description: "Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.",
									},
									"tags": {
										Type:        schema.TypeMap,
										Elem:        tagsElemType,
										Optional:    true,
										Description: "Tags is a map of key, value pairs.",
									},
									"version": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Version is a read only sdm binary version uploaded by the gateway process when it comes online.",
									},
								},
							},
						},
					},
				},
			},
		},
		Timeouts: &schema.ResourceTimeout{
			Default: schema.DefaultTimeout(60 * time.Second),
		},
	}
}

func convertNodeFilterToPlumbing(d *schema.ResourceData) (string, []interface{}) {
	filter := ""
	args := []interface{}{}
	if v, ok := d.GetOkExists("type"); ok {
		filter += "type:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("bind_address"); ok {
		filter += "bindaddress:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("id"); ok {
		filter += "id:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("listen_address"); ok {
		filter += "listenaddress:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("name"); ok {
		filter += "name:? "
		args = append(args, v)
	}
	if v, ok := d.GetOkExists("tags"); ok {
		tags := convertTagsToPlumbing(v)
		for kk, vv := range tags {
			filter += "tag:?=? "
			args = append(args, kk, vv)
		}
	}
	return filter, args
}

func dataSourceNodeList(ctx context.Context, d *schema.ResourceData, cc *sdm.Client) error {
	filter, args := convertNodeFilterToPlumbing(d)
	resp, err := cc.Nodes().List(ctx, filter, args...)
	if err != nil {
		return fmt.Errorf("cannot list Nodes %s: %w", d.Id(), err)
	}
	ids := []string{}
	type entity = map[string]interface{}
	output := make([]map[string][]entity, 1)
	output[0] = map[string][]entity{
		"gateway": {},
	}
	for resp.Next() {
		ids = append(ids, resp.Value().GetID())
		switch v := resp.Value().(type) {
		case *sdm.Gateway:
			output[0]["gateway"] = append(output[0]["gateway"], entity{
				"bind_address":       (v.BindAddress),
				"device":             (v.Device),
				"gateway_filter":     (v.GatewayFilter),
				"id":                 (v.ID),
				"listen_address":     (v.ListenAddress),
				"location":           (v.Location),
				"maintenance_window": convertRepeatedNodeMaintenanceWindowToPorcelain(v.MaintenanceWindows),
				"name":               (v.Name),
				"tags":               convertTagsToPorcelain(v.Tags),
				"version":            (v.Version),
			})
		case *sdm.ProxyCluster:
			output[0]["proxy_cluster"] = append(output[0]["proxy_cluster"], entity{
				"address":            (v.Address),
				"id":                 (v.ID),
				"maintenance_window": convertRepeatedNodeMaintenanceWindowToPorcelain(v.MaintenanceWindows),
				"name":               (v.Name),
				"tags":               convertTagsToPorcelain(v.Tags),
			})
		case *sdm.Relay:
			output[0]["relay"] = append(output[0]["relay"], entity{
				"device":             (v.Device),
				"gateway_filter":     (v.GatewayFilter),
				"id":                 (v.ID),
				"location":           (v.Location),
				"maintenance_window": convertRepeatedNodeMaintenanceWindowToPorcelain(v.MaintenanceWindows),
				"name":               (v.Name),
				"tags":               convertTagsToPorcelain(v.Tags),
				"version":            (v.Version),
			})
		}
	}
	if resp.Err() != nil {
		return fmt.Errorf("failure during list: %w", resp.Err())
	}

	err = d.Set("ids", ids)
	if err != nil {
		return fmt.Errorf("cannot set ids: %w", err)
	}
	err = d.Set("nodes", output)
	if err != nil {
		return fmt.Errorf("cannot set output: %w", err)
	}
	d.SetId("Node" + filter + fmt.Sprint(args...))
	return nil
}
